//****************************************************************************************************
//* *
//* Copyright (C) Microsoft. All rights reserved. *
//* *
//****************************************************************************************************
/// VUEPLOT.JS - a charting library from the Microsoft Research Vibe team.
//****************************************************************************************************

"use strict"        // apply max error checking

// preserve any namespaces we might overwrite.
var _vuePlotNamespacePreserver_ = { vp: window.vp};

if (!vp)
{
    vp = {};
}

if (!vp.utils)
{
    vp.utils = {};
}

vp.strict = false;      // set this to "true" for more error checking
vp.onError = null;

vp.utils.getErrorInfo = function ()
{
    var error = null;

    try
    {
        var x = window.thisNameDoesNotExist;
    }
    catch (ex)
    {
        error = ex;
    }

    return error;
}

//---- private ----
vp.utils.argToStr = function(arg)
{
    var str = arg;

    if (vp.utils.isString(arg))
    {
        str = "\"" + arg + "\"";
    }

    return str;
}

//---- private ----
vp.utils.checkArgCompat = function (funcName, argIndex, arg, type)
{
    if (type)
    {
        if (type == "bool")
        {
            if ((arg != 0) && (arg != 1) && (arg != true) && (arg != false))
            {
                vp.utils.error("Function '" + funcName + "', argument[" + argIndex + "] must be of type '" + type + "' (arg passed: " + vp.utils.argToStr(arg) + ")");
            }
        }
    }
}

vp.utils.argCheck = function (args, funcName, minArgs, maxArgs, argTypes)
{
    if (vp.strict)
    {
        var len = args.length;
        var lineNum = vp.utils.getErrorInfo();

        if (len < minArgs)
        {
            vp.utils.error("Function '" + funcName + "' requires at least " + minArgs + " (received=" + len + ")", lineNum);
        }
        else if (len > maxArgs)
        {
            vp.utils.error("Function '" + funcName + "' can only accept up to " + maxArgs + " (received=" + len + ")", lineNum);
        }

        for (var i = 0; i < len; i++)
        {
            vp.utils.checkArgCompat(funcName, i, args[i], argTypes[i]);
        }
    }

}

///-----------------------------------------------------------------------------------------------------------------
// arrayHelpers.ts.  Copyright (c) 2013 Microsoft Corporation.
//     - part of SandLib library.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
///<reference path="../scripts/allfiles.ts" />
//---- note: these are "this" functions - assumes "this" is the array pointer ----
var vp;
(function (vp) {
    /// signature:  arraySelect(func)
    ///     summary: creates a new array by calling the specified function with each element of the array
    ///     paramType(func): function
    ///     snippet: var aray = [3, 5, 2, 1];
    ///     snippet: var newAray = arraySelect(aray, function(n) { return 10*n; });  // newAray will be: [30, 50, 20, 10]
    ///     returns: the new array
    function arraySelect(selectFunc) {
        if (!vp.utils.isFunction(selectFunc)) {
            throw new TypeError();
        }

        //var startTime = new Date().getTime();
        var newValues = Array(this.length);

        for (var i = 0; i < this.length; i++) {
            var elem = this[i];
            var value = selectFunc(elem, i);
            newValues[i] = value;
        }

        //var elapsedMs = new Date().getTime() - startTime;
        return newValues;
    }

    var maxStackSize = 75 * 1000;

    /// signature:  arrayMin(aray)
    ///     summary: returns the item in the array with the smallest value
    ///     snippet: var aray = [3, 5, 2, 1];
    ///     snippet: var myMax = arrayMin(aray);        // myMax will be set to 1.
    ///     returns: the item in the array with the smallest value
    /// signature: arrayMin(func)
    ///     summary: returns the item in the array for which calling func produces the smallest value
    ///     paramType(func): function
    ///     snippet: var aray = [-5, 3, 0, 3];
    ///     snippet: var myMax = arrayMin(Math.abs);        // myMax will be set to 0
    ///     returns: the item in the array for which calling func produces the smallest value
    function arrayMin(itemFunc) {
        //var startTime = new Date().getTime();
        var mm = Number.MAX_VALUE;

        if (vp.utils.isFunction(itemFunc)) {
            for (var i = 0; i < this.length; i++) {
                var value = itemFunc(this[i]);

                // the below code is 2x faster than: mm = Math.max(mm, aray[i]);
                if (value < mm) {
                    mm = value;
                }
            }
        } else {
            //---- this top code is about 10x as fast as the botoom, but crashes with length around 150K ----
            if (this.length <= maxStackSize) {
                mm = Math.min.apply(Math, this);
            } else {
                for (var i = 0; i < this.length; i++) {
                    // the below code is 2x faster than: mm = Math.min(mm, aray[i]);
                    if (this[i] < mm) {
                        mm = this[i];
                    }
                }
            }
        }

        //var elapsedMs = new Date().getTime() - startTime;
        return mm;
    }

    function arrayMax(itemFunc) {
        //var startTime = new Date().getTime();
        var mm = -Number.MAX_VALUE;

        if (vp.utils.isFunction(itemFunc)) {
            for (var i = 0; i < this.length; i++) {
                var value = itemFunc(this[i]);

                // the below code is 2x faster than: mm = Math.max(mm, aray[i]);
                if (value > mm) {
                    mm = value;
                }
            }
        } else {
            //---- this top code is about 10x as fast as the botoom, but crashes with length around 150K ----
            if (this.length <= maxStackSize) {
                mm = Math.max.apply(Math, this);
            } else {
                for (var i = 0; i < this.length; i++) {
                    // the below code is 2x faster than: mm = Math.max(mm, aray[i]);
                    if (this[i] > mm) {
                        mm = this[i];
                    }
                }
            }
        }

        //var elapsedMs = new Date().getTime() - startTime;
        return mm;
    }

    /// this function groups data by 1 or more grouping columns.  returns an
    /// array of records:  { key: keyValue, values: recordArray }
    function arrayGroupBy() {
        var args = [];
        for (var _i = 0; _i < (arguments.length - 0); _i++) {
            args[_i] = arguments[_i + 0];
        }
        var groupObj = {};

        for (var i = 0; i < this.length; i++) {
            var record = this[i];
            var key = "";

            if (args.length > 0) {
                for (var k = 0; k < args.length; k++) {
                    var colName = args[k];

                    if (k > 0) {
                        key += "^";
                    }

                    key += record[colName];
                }
            } else {
                //---- no keys specified - assume this is a vector of values & group by simliar values ----
                key = record.toString();
            }

            var list = groupObj[key];
            if (list === undefined) {
                list = [];
                groupObj[key] = list;
            }

            list.push(record);
        }

        //---- now build list of groups to return ----
        var groups = [];
        for (var key2 in groupObj) {
            var list = groupObj[key2];

            var group = { key: key2, values: list };
            groups.push(group);
        }

        return groups;
    }

    /// return a copy of the specified array (contains references to same elements).
    /// this works true arrays and objects like Int32Array.
    function arrayClone() {
        var newAray = null;

        if (this) {
            if (this.slice) {
                newAray = this.slice(0);
            } else {
                newAray = [];

                for (var i = 0; i < this.length; i++) {
                    newAray[i] = this[i];
                }
            }
        }

        return newAray;
    }

    function arrayTake(count) {
        var newArray = this.slice(0, count);
        return newArray;
    }

    /// signature:  arrayRemove(item)
    ///     summary:    removes the specified item from the array.
    ///     paramType(item): object
    ///     snippet:    var aray = [3, 4, 5, 6];
    ///     snippet:    arrayRemove(aray, 6);         // aray should now contain [3, 4, 5]
    ///     returns:    null.
    function arrayRemove(elem) {
        var index = this.indexOf(elem);
        if (index > -1) {
            this.splice(index, 1);
        }
    }

    /// signature:  arrayRemoveAt(index)
    ///     summary:    removes the item at the specified index from the array.
    ///     paramType(index): integer number
    ///     snippet:    var aray = [3, 4, 5, 6];
    ///     snippet:    arrayRemoveAt(aray, 0);         // aray should now contain [4, 5, 6]
    ///     returns:    null.
    function arrayRemoveAt(index) {
        if (index > -1) {
            this.splice(index, 1);
        }
    }

    function arrayInsert(index, value) {
        if (index > -1) {
            this.splice(index, 0, value);
        }
    }

    /// signature:  arrayWhere(func)
    ///     summary: creates a new array by only including elements of the current array that return true for the specified function
    ///     paramType(func): function
    ///     snippet: var aray = [3, 5, 2, 1];
    ///     snippet: var newAray = arrayWhere(aray, function(n) { return n >= 3; });  // newAray will be: [3, 5]
    ///     returns: the new array
    ///
    /// "arrayWhere" uses the callback function to conditionally include each record of the array
    /// in the output stream.  One of our lightweight linq functions.
    function arrayWhere(whereFunc) {
        //var startTime = new Date().getTime();
        var newValues = [];

        for (var i = 0; i < this.length; i++) {
            var value = this[i];
            if (whereFunc(value, i)) {
                newValues.push(value);
            }
        }

        //var elapsedMs = new Date().getTime() - startTime;
        return newValues;
    }

    /// signature:  arar.orderByNum()
    ///     summary: creates a copy of the current array with the items sorted in increasing numeric value
    ///     snippet: var aray = [3, 5, 2, 1];
    ///     snippet: var newAray = aray.orderByNum();     // newAray will be: [1, 2, 3, 5]
    ///     returns: the new array
    /// signature:  aray.orderByNum(func)
    ///     summary: creates a copy of the current array with the items sorted in increasing numeric value, using value returned from calling "func"
    ///     paramType(func): function
    ///     snippet: var aray = [-3, 5, -2, 1];
    ///     snippet: var newAray = aray.orderByNum(Math.abs);     // newAray will be: [1, 2, 3, 5]
    ///     returns: the new array
    ///
    /// "orderByNum" uses the callback function to produce a key for each record in the
    /// array so the array can be sorted.  One of the VuePlotCore lightweight linq functions.
    function arrayOrderByNum(keyFunc) {
        //var startTime = new Date().getTime();
        var newValues = this.slice(0);

        if (keyFunc === undefined) {
            //---- JavaScript default: alphabetic, ascending sort ----
            newValues.sort(function (a, b) {
                return (+a) - (+b);
            });
        } else {
            newValues.sort(function (a, b) {
                var ka = keyFunc(a);
                var kb = keyFunc(b);

                return (+ka) - (+kb);
            });
        }

        //var elapsedMs = new Date().getTime() - startTime;
        return newValues;
    }

    /// signature:  arar.orderByStr()
    ///
    /// "orderByStr" uses the optional callback function to produce a key for each record in the
    /// array so the array can be sorted by string values.  One of our lightweight linq functions.
    function arrayOrderByStr(keyFunc) {
        //var startTime = new Date().getTime();
        var newValues = this.slice(0);

        if (keyFunc === undefined) {
            //---- JavaScript default: alphabetic, ascending sort ----
            newValues.sort();
        } else {
            newValues.sort(function (a, b) {
                var ka = keyFunc(a) + "";
                var kb = keyFunc(b) + "";

                //---- this works for strings and numbers ----
                return (ka > kb) ? 1 : ((ka == kb) ? 0 : -1);
            });
        }

        //var elapsedMs = new Date().getTime() - startTime;
        return newValues;
    }

    /// signature:  arrayDistinct()
    ///     summary: creates a copy of the current array with duplicated items removed
    ///     snippet: var aray = [3, 5, 3, 1];
    ///     snippet: var newAray = arrayDistinct(aray);     // newAray will be: [3, 5, 1]
    ///     returns: the new array
    /// signature:  arrayDistinct(func)
    ///     summary: creates a copy of the current array with items that produce duplicates values (when calling func) removed
    ///     paramType(func): function
    ///     snippet: var aray = [-3, 5, 3, 1];
    ///     snippet: var newAray = arrayDistinct(aray);     // newAray will be: [-3, 5, 1]
    ///     returns: the new array
    ///
    /// "distinct" returns the values in the array with duplicates removed, based on the values
    /// returned for each array entry by the idFunc.
    function arrayDistinct(idFunc) {
        var dict = {};
        var newValues = [];

        for (var i = 0; i < this.length; i++) {
            var value = this[i];

            var id = (idFunc) ? idFunc(value) : value;
            if (!dict.hasOwnProperty(id)) {
                //---- its unique; add it ----
                dict[id] = 1;
                newValues.push(this[i]);
            }
        }

        return newValues;
    }

    function arrayGenerate(root, tagName, callBack) {
        var ss = null;

        var ss = vp.data.generateItems(root, tagName, this);

        if (callBack) {
            //---- for best perf, share one singleWrapper to wrap all objects ----
            var wrapper = vp.dom.createSingleWrapper(null);

            for (var i = 0; i < this.length; i++) {
                var dataItem = this[i];

                wrapper.elem = ss[i];
                wrapper[0] = ss[i];

                callBack(wrapper, dataItem, i);
            }
        }

        return ss;
    }

    /// colName is optional; if specified, array entires will be treated as records and colName will be used a key
    /// to extract the value to be summed.  If not specified, array entries will be treated like numbers and summed directly.
    function arraySum(colNameOrCallback) {
        var total = 0;

        if (vp.utils.isFunction(colNameOrCallback)) {
            for (var i = 0; i < this.length; i++) {
                var value = this[i];
                value = +colNameOrCallback(value, i);

                total += value;
            }
        } else if (vp.utils.isString(colNameOrCallback)) {
            var colName = colNameOrCallback;

            for (var i = 0; i < this.length; i++) {
                total += this[i][colName];
            }
        } else {
            for (var i = 0; i < this.length; i++) {
                total += this[i];
            }
        }

        return total;
    }

    /// this function coverts a dataset in "wide" format to "long" format.
    ///     - "wide" format is where each attribute is in its own column.
    ///     - "long" format is where all non-id attributes are represents in 2 columns: "attribute", "value".
    ///
    /// parameters: list of id columns (those that are preserved).  Other columns are transformed into name/value columns
    function arrayWideToLong(col1) {
        var records = [];

        if (this.length > 0) {
            //---- build list of OTHER columns ----
            var others = [];
            var curr = this[0];
            var preserved = vp.utils.argumentsAsArray(arguments);

            for (var cn in curr) {
                if (preserved.indexOf(cn) == -1) {
                    others.push(cn);
                }
            }

            for (var i = 0; i < this.length; i++) {
                var curr = this[i];

                for (var j = 0; j < others.length; j++) {
                    var other = others[j];
                    var record = {};

                    for (var a = 0; a < preserved.length; a++) {
                        var colName = preserved[a];
                        record[colName] = curr[colName];
                    }

                    //---- transfer OTHER column ----
                    record.attribute = other;
                    record.value = curr[other];

                    records.push(record);
                }
            }
        }

        return records;
    }

    /// this function coverts a dataset in "long" format to "wide" format.
    ///     - "wide" format is where each attribute is in its own column.
    ///     - "long" format is where all non-id attributes are represents in 2 columns: "attribute", "value".
    ///
    /// parameters:
    ///     - array of id columns (to define a change in the logical record)
    ///     - attributeColName
    ///     - valueColName
    function arrayLongToWide(idColList, attributeColName, valueColName) {
        var records = [];

        if (this.length > 0) {
            //---- emit an OUTPUT record whenever the key changes or an attribute repeats ----
            var record = {};
            var newRecord = true;

            for (var i = 0; i < this.length; i++) {
                var curr = this[i];
                var changed = false;

                for (var a = 0; a < idColList.length; a++) {
                    var colName = idColList[a];
                    if (curr[colName] != record[colName]) {
                        changed = true;
                        break;
                    }
                }

                //---- have this record seen this attribue before? ----
                var attrName = curr.attribute;
                if (record[attrName]) {
                    changed = true;
                }

                if (changed) {
                    if (i > 0) {
                        //---- output previous record ----
                        records.push(record);
                    }

                    record = {};
                    newRecord = true;
                }

                if (newRecord) {
                    for (var a = 0; a < idColList.length; a++) {
                        var colName = idColList[a];
                        record[colName] = curr[colName];
                    }

                    newRecord = false;
                }

                //---- transfer name/value pairs from this record ----
                record[attrName] = curr.value;
            }

            //---- add last record ----
            records.push(record);
        }

        return records;
    }

    /// arrayReorder:  build a new array consisting of "partialValuesInOrder" and then any remaining values in "aray".
    function arrayReorder(partialValuesInOrder) {
        var outAray = [];
        var aray = this.clone();

        for (var i = 0; i < partialValuesInOrder.length; i++) {
            var value = partialValuesInOrder[i];

            outAray.push(value);
            aray.remove(value);
        }

        //---- add remaining keys ----
        outAray = outAray.concat(aray);
        return outAray;
    }

    /// arrayRemoveValues:  return a new array consisting of elements of "arayOrig" when "values" are removed.
    function arrayRemoveValues(values) {
        var outAray = [];
        var aray = this.clone();

        for (var i = 0; i < values.length; i++) {
            var value = values[i];

            aray.remove(value);
        }

        return aray;
    }

    //---- safely extend Array functions (so that are NOT enumerable) ----
    //---- we extend array with each helper function using this method, so our help functions won't show up during a "for in" operation ----
    function extendArray(helperName, helperFunc) {
        if (Array.prototype[helperName] === undefined) {
            Object.defineProperty(Array.prototype, helperName, { enumerable: false, value: helperFunc });
        }
    }

    //---- now add our array helper functions ----
    extendArray("distinct", arrayDistinct);
    extendArray("generate", arrayGenerate);
    extendArray("groupBy", arrayGroupBy);
    extendArray("max", arrayMax);
    extendArray("min", arrayMin);
    extendArray("orderByNum", arrayOrderByNum);
    extendArray("orderByStr", arrayOrderByStr);
    extendArray("remove", arrayRemove);
    extendArray("removeAt", arrayRemoveAt);
    extendArray("sum", arraySum);
    extendArray("take", arrayTake);
    extendArray("insert", arrayInsert);
    extendArray("where", arrayWhere);
})(vp || (vp = {}));

//# sourceMappingURL=array.js.map

///----------------------------------------------------------------
/// (from _helpers\colorPalettes.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// colorPalettes.ts.  Copyright (c) 2014 Microsoft Corporation.
///     - a set of helper functions for creating color palettes (sets of colors).
///-----------------------------------------------------------------------------------------------------------------
/// <summary>
/// Predefined and custom color palettes.  A color palette is an array of colors that can be
/// used to with an Interpolator or a Scale to sample as discrete or continous colors.
///
/// note: below functions are continuous, unless marked as "discrete".
///
/// Predefined:
///     - blueRed
///     - redGreen
///     - surface
///     - grays(n)
///     - reds(n)
///     - greens(n)
///     - blues(n)
///     - rainbow(n)            (discrete)
///     - rainbowPairs(n)       (discrete)
///
/// Custom:
///     - darkLight(cr, ...)
///     - darkLightDark(cr, cr2)
///     - lightDark(cr, ...)
///     - hueSteps(cr, n)       (discrete)
///     - analogs(cr)           (discrete)
///     - shades(cr, n)
///
/// </summary>
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    ///<reference path="../scripts/allfiles.ts" />
    (function (colorPalettes) {
        /// <summary>
        /// Predefined color scheme for displaying negative and positive continous values:
        ///     DarkBlue, DarkRed
        /// </summary>
        function blueRed() {
            return [vp.color.colors.darkblue, vp.color.colors.darkred];
        }
        colorPalettes.blueRed = blueRed;

        /// <summary>
        /// Predefined color scheme for displaying negative and positive continous values:
        ///     DarkRed, LightRed, LightGreen, DarkGreen
        /// </summary>
        function redGreen() {
            return [vp.color.colors.darkred, vp.color.rgbFromHsl(0, 1, .8), vp.color.colors.lightgreen, vp.color.colors.darkgreen];
        }
        colorPalettes.redGreen = redGreen;

        /// <summary>
        /// Predefined color scheme for surface colors:
        ///     DarkBlue, Aqua, Yellow, DarkRed
        /// </summary>
        /// <returns></returns>
        function surface() {
            var palette = ["rgb(0, 0, 143)", "rgb(0, 0, 255)", "rgb(0, 255, 255)", "rgb(255, 255, 0)", "rgb(255, 0, 0)", "rgb(128, 0, 0)"];
            var stops = [0, 1 / 8, 3 / 8, 5 / 8, 7 / 8, 1];

            palette.stops = stops;
            return palette;
        }
        colorPalettes.surface = surface;

        /// <summary>
        /// Predefined color scheme for shades of gray
        /// </summary>
        /// <returns></returns>
        function grays(steps, startPercent, endPercent) {
            startPercent = startPercent || 1;
            endPercent = endPercent || 0;

            return vp.colorPalettes.shades(vp.color.colors.gray, steps, startPercent, endPercent);
        }
        colorPalettes.grays = grays;

        /// <summary>
        /// Predefined color scheme for shades of red
        /// </summary>
        /// <returns></returns>
        function reds(steps) {
            return vp.colorPalettes.shades(vp.color.colors.red, steps);
        }
        colorPalettes.reds = reds;

        /// <summary>
        /// Predefined color scheme for shades of green
        /// </summary>
        /// <returns></returns>
        function greens(steps) {
            return vp.colorPalettes.shades(vp.color.colors.green, steps);
        }
        colorPalettes.greens = greens;

        /// <summary>
        /// Predefined color scheme using the specified number of hues spaced
        /// around the color wheel.
        /// </summary>
        /// <returns></returns>
        function rainbow(steps) {
            var values = [];
            var stepSize = 1 / steps;

            for (var i = 0; i < steps; i++) {
                var hue = i * stepSize;
                values[i] = vp.color.rgbFromHsl(hue, 1, .5);
            }

            return values;
        }
        colorPalettes.rainbow = rainbow;

        /// <summary>
        /// Predefined color scheme using the specified number of hues spaced
        /// around the color wheel.  Each hue generates 2 colors: light and dark versions
        /// of the hue.
        /// </summary>
        /// <returns></returns>
        function rainbowPairs(steps) {
            var values = [];
            var stepSize = 1 / steps;

            for (var i = 0; i < steps; i++) {
                var hue = i * stepSize;

                values.push(vp.color.rgbFromHsl(hue, 1, .3));
                values.push(vp.color.rgbFromHsl(hue, 1, .7));
            }

            return values;
        }
        colorPalettes.rainbowPairs = rainbowPairs;

        /// <summary>
        /// Generates a custom color scheme, using a dark and light version of each
        /// specifed color.
        /// </summary>
        /// <returns></returns>
        function darkLight(color1) {
            var values = [];

            for (var i = 0; i < arguments.length; i++) {
                var hsl = vp.color.hslFromRgb(arguments[i]);

                values.push(vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), .30));
                values.push(vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), .70));
            }

            return values;
        }
        colorPalettes.darkLight = darkLight;

        /// <summary>
        /// Generates a custom color scheme, using a dark and light version of each
        /// specifed color.
        /// </summary>
        /// <returns></returns>
        function darkLightDark(cr, cr2) {
            var hsl = vp.color.hslFromRgb(cr);
            var hsl2 = vp.color.hslFromRgb(cr2);

            var colors = [
                vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), .20),
                vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), .80),
                vp.color.rgbFromHsl(hsl2.hue(), hsl2.saturation(), .80),
                vp.color.rgbFromHsl(hsl2.hue(), hsl2.saturation(), .20)
            ];

            return colors;
        }
        colorPalettes.darkLightDark = darkLightDark;

        /// <summary>
        /// Generates a custom color scheme, using a light and dark version of each
        /// specifed color.
        /// </summary>
        /// <returns></returns>
        function lightDark(color1) {
            var values = [];

            for (var i = 0; i < arguments.length; i++) {
                var hsl = vp.color.hslFromRgb(arguments[i]);

                values.push(vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), .70));
                values.push(vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), .30));
            }

            return values;
        }
        colorPalettes.lightDark = lightDark;

        /// <summary>
        /// Returns a set of colors whose hues are equally spaces in the color wheel.
        /// </summary>
        /// <param name="color"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        function hueSteps(color, steps) {
            var colors = [];
            var hsl = vp.color.hslFromRgb(color);
            var hue = hsl.hue();
            var step = 1 / steps;

            for (var i = 0; i < steps; i++) {
                var hx = vp.color.normalizeHue(hue + i * step);
                colors[i] = vp.color.rgbFromHsl(hx, hsl.saturation(), hsl.lightness());
            }

            return colors;
        }
        colorPalettes.hueSteps = hueSteps;

        /// <summary>
        /// Returns the set of 4 analog colors, based on the specified color.
        /// </summary>
        /// <param name="color"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        function analogs(color) {
            var colors = [];
            var hsl = vp.color.hslFromRgb(color);
            var hue = hsl.hue();
            var step = 1 / 9;

            colors[0] = color;

            var h1 = vp.color.normalizeHue(hue + step);
            var h2 = vp.color.normalizeHue(hue + .5);
            var h3 = vp.color.normalizeHue(hue + .5 + step);

            colors[1] = vp.color.rgbFromHsl(h1, hsl.saturation(), hsl.lightness());
            colors[2] = vp.color.rgbFromHsl(h2, hsl.saturation(), hsl.lightness());
            colors[3] = vp.color.rgbFromHsl(h3, hsl.saturation(), hsl.lightness());

            return colors;
        }
        colorPalettes.analogs = analogs;

        /// <summary>
        /// Returns the specified number of shades of a color.
        /// </summary>
        /// <param name="color"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        function shades(color, count, startPercent, endPercent) {
            startPercent = (startPercent === undefined) ? .98 : startPercent;
            endPercent = (endPercent === undefined) ? .09 : endPercent;

            if (count < 1) {
                vp.utils.error("Count must be at least 1");
            }

            var colors = [];
            if (count == 1) {
                colors.push(color);
            } else {
                var hsl = vp.color.hslFromRgb(color);

                var step = (endPercent - startPercent) / (count - 1);
                var index = 0;

                if (step >= 0) {
                    for (var percent = startPercent; vp.utils.floatLeq(percent, endPercent); percent += step) {
                        colors[index++] = vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), percent);
                    }
                } else {
                    for (var percent = startPercent; vp.utils.floatGeq(percent, endPercent); percent += step) {
                        colors[index++] = vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), percent);
                    }
                }
            }

            return colors;
        }
        colorPalettes.shades = shades;
    })(vp.colorPalettes || (vp.colorPalettes = {}));
    var colorPalettes = vp.colorPalettes;
})(vp || (vp = {}));
//# sourceMappingURL=colorPalettes.js.map

///----------------------------------------------------------------
/// (from _helpers\dataUtils.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// dataUtils.ts.  Copyright (c) 2014 Microsoft Corporation.
///   - part of the vuePlotCore library - data binding and related functions.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    ///<reference path="../scripts/allfiles.ts" />
    (function (_data) {
        function clamp(value, min, max) {
            if (value < min) {
                value = min;
            } else if (value > max) {
                value = max;
            }

            return value;
        }
        _data.clamp = clamp;

        //---- creates a hash object to hold a data item and its data index ----
        function dataPairHolder(dataItem, dataIndex) {
            var pair = { dataItem: dataItem, dataIndex: dataIndex };
            return pair;
        }
        _data.dataPairHolder = dataPairHolder;

        function dataRepeat(value, count) {
            var values = [];

            for (var i = 0; i < count; i++) {
                values[i] = value;
            }

            return values;
        }
        _data.dataRepeat = dataRepeat;

        function lerp(percent, a, b) {
            return a + percent * (b - a);
        }
        _data.lerp = lerp;

        function makeLastData(data) {
            var lastRecord = (data.length) ? data[0] : null;
            var lastData = [];
            var lastIndex = 0;

            for (var i = 0; i < data.length; i++) {
                var origRecord = data[i];
                var record = { current: origRecord, index: i, last: lastRecord, lastIndex: lastIndex };
                lastData.push(record);

                lastRecord = origRecord;
                lastIndex = i;
            }

            return lastData;
        }
        _data.makeLastData = makeLastData;

        function generateItems(root, tagName, data) {
            var elemArray = [];

            var start = Date.now();

            if (root.multiAppend) {
                elemArray = root.multiAppend(tagName, data.length);

                for (var i = 0; i < elemArray.length; i++) {
                    var elem = elemArray[i];

                    var dataItem = data[i];

                    vp.dom.dataItem(elem, dataItem);
                    vp.dom.dataIndex(elem, i);
                }
            } else {
                for (var i = 0; i < data.length; i++) {
                    //---- this does the right thing for canvas, SVG, and HTML elements ----
                    var elem = root.append(tagName);

                    var dataItem = data[i];

                    elem.dataItem(dataItem);
                    elem.dataIndex(i);

                    elemArray.push(elem[0]);
                }
            }

            var elapsed = Date.now() - start;

            //alert("append of " + data.length + " elements took: " + elapsed + "ms");
            var ss = vp.dom.wrapElements(elemArray);
            return ss;
        }
        _data.generateItems = generateItems;

        /// public: dataJoin(data, "name", data2, "name2", ...)
        /// this joins the data in each array into a new array, with each field given the associated name.
        function dataJoin(data, name1) {
            var records = [];

            for (var i = 0; i < data.length; i++) {
                //---- loop thru all the fields and create a record ----
                var record = {};

                for (var a = 0; a < arguments.length; a += 2) {
                    var dataX = arguments[a];
                    var nameX = arguments[a + 1];

                    var valueX = dataX[i];

                    record[nameX] = valueX;
                }

                records.push(record);
            }

            return records;
        }
        _data.dataJoin = dataJoin;

        /// public: $.dataFrame(desc)
        /// this builds an array of records whose name/vector pairs are given as key/values of the desc object.
        function dataFrame(desc) {
            var records = [];
            var firstVector = null;

            for (var k in desc) {
                firstVector = desc[k];
                break;
            }

            if (firstVector) {
                for (var i = 0; i < firstVector.length; i++) {
                    //---- loop thru all the fields and create a record ----
                    var record = {};

                    for (var name in desc) {
                        record[name] = desc[name][i];
                    }

                    records.push(record);
                }
            }

            return records;
        }
        _data.dataFrame = dataFrame;

        /// public: dataSelect(data, fieldName)
        /// "data" is an array of records.
        /// "fieldName" is the name of one of the record's fields.
        /// returns an array of "fieldName" values (one entry from each record in data).
        function dataSelect(data, field) {
            var values = [];

            if (!field) {
                //---- if no field specified, just return the data as is ----
                values = data;
            } else if (data.length > 0) {
                var firstRecord = data[0];
                if (firstRecord[field] !== undefined) {
                    values = data.map(function (data, index) {
                        return data[field];
                    });
                }
            }

            return values;
        }
        _data.dataSelect = dataSelect;

        /**  builds a matrix of records in X and Y, dim size x size, with a "value" field that has some peaks and valleys. */
        function peaks(size, flatten) {
            var baseNum = 3;
            var incr = (2 * baseNum) / size;
            var rows = [];

            for (var y = -baseNum; y <= baseNum; y += incr) {
                var row = (flatten) ? rows : [];

                for (var x = -baseNum; x <= baseNum; x += incr) {
                    //z =  3*(1-x)^2*exp(-(x^2) - (y+1)^2) ...
                    //   - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ...
                    //   - 1/3*exp(-(x+1)^2 - y^2)
                    var z1 = 3 * (1 - x) * (1 - x) * Math.exp(-(x * x) - (y + 1) * (y + 1));
                    var z2 = -10 * (x / 5 - x * x * x - Math.pow(y, 5)) * Math.exp(-(x * x) - (y * y));
                    var z3 = -1 / 3 * Math.exp(-(x + 1) * (x + 1) - (y * y));

                    var z = z1 + z2 + z3;

                    //var value = 5*Math.sin(x) + 4*Math.cos(y);
                    var record = { x: x, y: y, z: z };
                    row.push(record);
                }

                if (row != rows) {
                    rows.push(row);
                }
            }

            return rows;
        }
        _data.peaks = peaks;
    })(vp.data || (vp.data = {}));
    var data = vp.data;
})(vp || (vp = {}));
//# sourceMappingURL=dataUtils.js.map

///----------------------------------------------------------------
/// (from _helpers\hsl.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// hsl.ts.  Copyright (c) 2014 Microsoft Corporation.
///     - part of the VuePlotCore library.
///     - a class that represents a color in HSL (hue, saturation, luminance) color space.
///-----------------------------------------------------------------------------------------------------------------
// Specifies an HSLA color value (stored as int + 3 floats).  Designed to support HSL color values as specified
/// for SVG.  Adapted from: http://www.w3.org/TR/css3-color/#hsl-color.  The SVG order is Hsla for creation.
///
/// CTR should accept 5 forms:
///     - hsl (3-4 floats)
///     - rgb (3-4 floats)
///
/// Should provide 2 ToXXX() functions:
///     - toRgb()
///     - toString()
///
/// Should provide 4 public READONLY properties:
///     - var hue
///     - var saturation
///     - var lightness
///     - var alpha
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    ///<reference path="../scripts/allfiles.ts" />
    (function (color) {
        var hsl = (function () {
            function hsl(hue, saturation, lightness, alpha) {
                this._hue = hue;
                this._saturation = saturation;
                this._lightness = lightness;

                //---- init code ----
                this._alpha = (alpha === undefined) ? 1 : alpha;
            }
            /// public: toRgb()
            hsl.prototype.toRgb = function () {
                var rgb = vp.color.rgbFromHsl(this);
                return rgb;
            };

            hsl.prototype.toString = function () {
                return "{H: " + this._hue + ", S: " + this._saturation + ", L: " + this._lightness + ", A: " + this._alpha + "}";
            };

            hsl.prototype.lighten = function () {
                var light = Math.min(1, this._lightness + .13);
                return new vp.color.hsl(this._hue, this._saturation, light, this._alpha);
            };

            hsl.prototype.darken = function () {
                var light = Math.max(0, this._lightness - .13);
                return new vp.color.hsl(this._hue, this._saturation, light, this._alpha);
            };

            /// public: hue
            hsl.prototype.hue = function () {
                return this._hue;
            };

            /// public: saturation
            hsl.prototype.saturation = function () {
                return this._saturation;
            };

            /// public: lightness
            hsl.prototype.lightness = function () {
                return this._lightness;
            };

            /// public: alpha
            hsl.prototype.alpha = function () {
                return this._alpha;
            };
            return hsl;
        })();
        color.hsl = hsl;

        /// static public: vp.color.hslFromRgb()
        /// "rgb" should be a 3 or 4 element array of numbers, each 0-255.
        function hslFromRgb(rgb) {
            if (vp.utils.isString(rgb)) {
                rgb = vp.color.getColorFromString(rgb);
            }

            //---- convert RGB to HSL ----
            ///
            /// adapted from: http://130.113.54.154/~monger/hsl-rgb.html
            ///
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;

            var alpha = (rgb.length > 3) ? rgb[3] / 255 : 1;

            var min = Math.min(r, Math.min(g, b));
            var max = Math.max(r, Math.max(g, b));

            var lightness = (max + min) / 2;
            var saturation = 0;
            var hue = 0;

            if (max == min) {
                //---- some shade of gray ----
                saturation = 0;
                hue = 0; // actually undefined, but this is usual way to handle
            } else {
                if (lightness < .5) {
                    saturation = (max - min) / (max + min);
                } else {
                    saturation = (max - min) / (2 - max - min);
                }

                if (r == max) {
                    hue = (g - b) / (max - min);
                } else if (g == max) {
                    hue = 2 + (b - r) / (max - min);
                } else {
                    hue = 4 + (r - g) / (max - min);
                }

                //---- hue should now be in range 0..6 ----
                hue *= 60;
                if (hue < 0) {
                    hue += 360;
                }

                hue /= 360; // convert to a percentage
            }

            return new vp.color.hsl(hue, saturation, lightness, 1);
        }
        color.hslFromRgb = hslFromRgb;

        /// static public: vp.color.rgbFromHsl()
        function rgbFromHsl(hsl) {
            var args = [];
            for (var _i = 0; _i < (arguments.length - 1); _i++) {
                args[_i] = arguments[_i + 1];
            }
            if (arguments.length == 3) {
                hsl = new vp.color.hsl(arguments[0], arguments[1], arguments[2]);
            }

            //---- HSL to RGB Conversion----
            ///
            /// adapted from: http://www.w3.org/TR/2003/CR-css3-color-20030514/
            ///
            var m2 = 0;
            var ll = hsl.lightness();
            var s = hsl.saturation();
            var hue = hsl.hue();

            if (ll <= .5) {
                m2 = ll * (s + 1);
            } else {
                m2 = ll + s - ll * s;
            }

            var m1 = ll * 2 - m2;

            var red = vp.color.hueToRgb(m1, m2, hue + 1 / 3);
            var green = vp.color.hueToRgb(m1, m2, hue);
            var blue = vp.color.hueToRgb(m1, m2, hue - 1 / 3);

            //---- we represent RGB values as 3-4 element numeric arrays ----
            var r = vp.data.clamp(Math.round(red * 255), 0, 255);
            var g = vp.data.clamp(Math.round(green * 255), 0, 255);
            var b = vp.data.clamp(Math.round(blue * 255), 0, 255);
            var a = vp.data.clamp(Math.round(hsl.alpha() * 255), 0, 255);

            return [r, g, b, a];
        }
        color.rgbFromHsl = rgbFromHsl;

        function hueToRgb(m1, m2, h) {
            if (h < 0) {
                h = h + 1;
            }

            if (h > 1) {
                h = h - 1;
            }

            if (h * 6 < 1) {
                return m1 + (m2 - m1) * h * 6;
            }

            if (h * 2 < 1) {
                return m2;
            }

            if (h * 3 < 2) {
                return m1 + (m2 - m1) * (2 / 3 - h) * 6;
            }

            return m1;
        }
        color.hueToRgb = hueToRgb;

        function normalizeHue(value) {
            if (value < 0) {
                value = 1 + value;
            } else if (value > 1) {
                value = value - 1;
            }

            value = vp.data.clamp(value, 0, 1);

            value = Math.floor(value) - value; // just fractional part
            value = Math.abs(value);

            return value;
        }
        color.normalizeHue = normalizeHue;
    })(vp.color || (vp.color = {}));
    var color = vp.color;
})(vp || (vp = {}));
//# sourceMappingURL=hsl.js.map

///----------------------------------------------------------------
/// (from _helpers\math.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// mathHelpers.ts.  Copyright (c) 2013 Microsoft Corporation.
///     - part of SandLib library.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    function mathLog10(arg) {
        var result = Math.log(arg) / Math.LN10;
        return result;
    }

    ////---- safely extend MATH functions (so that are NOT enumerable) ----
    ////---- we extend Math with each helper function using this method, so our help functions won't show up during a "for in" operation ----
    //export function extendMath(helperName: string, helperFunc)
    //{
    //    if (Math..prototype[helperName] === undefined)
    //    {
    //        Object.defineProperty(Math.prototype, helperName, { enumerable: false, value: helperFunc });
    //    }
    //}
    //---- just directly add the static methods ----
    if (Math.log10 === undefined) {
        Math.log10 = mathLog10;
    }
})(vp || (vp = {}));

//# sourceMappingURL=math.js.map

///----------------------------------------------------------------
/// (from _helpers\scanner.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// scanner.ts.  Copyright (c) 2014 Microsoft Corporation.
///            part of the vuePlot library - general purpose text scanner class
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    (function (utils) {
        //---- enum: this._tokenType ----
        (function (tokenType) {
            tokenType[tokenType["none"] = 0] = "none";
            tokenType[tokenType["operator"] = 1] = "operator";
            tokenType[tokenType["id"] = 2] = "id";
            tokenType[tokenType["string"] = 3] = "string";
            tokenType[tokenType["number"] = 4] = "number";
            tokenType[tokenType["comment"] = 5] = "comment";
            tokenType[tokenType["newLine"] = 6] = "newLine";
            tokenType[tokenType["space"] = 7] = "space";
            tokenType[tokenType["eof"] = 8] = "eof";
        })(utils.tokenType || (utils.tokenType = {}));
        var tokenType = utils.tokenType;

        //---- class: scanner ----
        var scanner = (function () {
            function scanner(str) {
                //---- private state ----
                this._index = 0;
                this._tokenType = 0 /* none */;
                this._token = "";
                this._spacesSkipped = 0;
                this._str = "";
                this.init(str);
            }
            scanner.prototype.init = function (str) {
                this._str = str;
                this._index = 0;
                this._tokenType = 0 /* none */;
                this._token = "";
            };

            /// public readonly: this._tokenType
            scanner.prototype.tokenType = function () {
                return this._tokenType;
            };

            scanner.prototype.spacesSkipped = function () {
                return (this._spacesSkipped > 0);
            };

            /// public readonly: this._token
            scanner.prototype.token = function () {
                return this._token;
            };

            scanner.prototype.isStartOfNum = function (str, ch, index) {
                var isNum = ((ch >= '0') && (ch <= '9'));
                if (!isNum) {
                    if ((ch == ".") && (index + 1 < str.length)) {
                        var ch = str[index + 1];
                        isNum = ((ch >= '0') && (ch <= '9'));
                    }
                }

                return isNum;
            };

            scanner.prototype.isDigitChar = function (ch, isFirst) {
                var isDigit = ((ch >= "0") && (ch <= "9"));
                isDigit = isDigit || (ch == ".");

                return isDigit;
            };

            /// public: scan()
            scanner.prototype.scan = function () {
                this._spacesSkipped = 0;

                while ((this._index < this._str.length) && ((this._str[this._index] == " ") || (this._str[this._index] == "\t") || (this._str[this._index].charCodeAt(0) == 160))) {
                    this._index++;
                    this._spacesSkipped++;
                }

                if (this._index >= this._str.length) {
                    this._tokenType = 8 /* eof */;
                } else {
                    var ch = this._str[this._index];

                    if (ch == "\n") {
                        this._index++;
                        this._tokenType = 6 /* newLine */;
                    } else if ((this._index < this._str.length - 1) && (this._str[this._index] == "/") && (this._str[this._index + 1] == "/")) {
                        var start = this._index;
                        this._index += 2;
                        while ((this._index < this._str.length) && (this._str[this._index] != "\n")) {
                            this._index++;
                        }

                        this._token = this._str.substring(start, this._index);
                        this._tokenType = 5 /* comment */;
                    } else if ((ch == "\"") || (ch == "\'")) {
                        var quote = this._str[this._index];
                        var start = this._index;
                        this._index++;

                        while ((this._index < this._str.length) && (this._str[this._index] != quote) && (this._str[this._index] != "\n")) {
                            this._index++;
                        }

                        //---- skip over ending quote ----
                        if ((this._index < this._str.length) && (this._str[this._index] == quote)) {
                            this._index++;
                        }

                        this._token = this._str.substring(start, this._index);
                        this._tokenType = 3 /* string */;
                    } else if (this.isStartOfNum(this._str, ch, this._index)) {
                        var start = this._index;

                        while ((this._index < this._str.length) && (this.isDigitChar(this._str[this._index], false))) {
                            this._index++;
                        }

                        //---- see if there is a factional part ----
                        if ((this._index < this._str.length) && (this._str[this._index] == '.')) {
                            this._index++;

                            while ((this._index < this._str.length) && ((this._str[this._index] >= '0') && (this._str[this._index] <= '9'))) {
                                this._index++;
                            }
                        }

                        this._token = this._str.substring(start, this._index);
                        this._tokenType = 4 /* number */;
                    } else if ((this._str[this._index].toLowerCase() >= 'a') && (this._str[this._index].toLowerCase() <= 'z')) {
                        var start = this._index;

                        while (this._index < this._str.length) {
                            if ((this._str[this._index] >= '0') && (this._str[this._index] <= '9')) {
                            } else if ((this._str[this._index].toLowerCase() >= 'a') && (this._str[this._index].toLowerCase() <= 'z')) {
                            } else {
                                break;
                            }

                            this._index++;
                        }

                        this._token = this._str.substring(start, this._index);
                        this._tokenType = 2 /* id */;
                    } else {
                        ///     operators: +, -, *, /, (), ++, --, <, <=, >, >=, ==, !=, =, +=, -=, *=, /=, ?:, [], !,
                        ///         ., &&, ||
                        this._token = this._str[this._index];
                        this._index++;

                        var t2 = (this._index < this._str.length) ? (this._token + this._str[this._index]) : "";

                        //---- look for double char operator ----
                        if ((t2 == "()") || (t2 == "++") || (t2 == "--") || (t2 == "<=") || (t2 == ">=") || (t2 == "==") || (t2 == "!=") || (t2 == "+=") || (t2 == "-=") || (t2 == "*=") || (t2 == "/=") || (t2 == "&&") || (t2 == "||")) {
                            this._token = t2;
                            this._index++;
                        }

                        this._tokenType = 1 /* operator */;
                    }
                }

                this._index = this._index; // update our class field

                return this._tokenType;
            };
            return scanner;
        })();
        utils.scanner = scanner;
    })(vp.utils || (vp.utils = {}));
    var utils = vp.utils;
})(vp || (vp = {}));
//# sourceMappingURL=scanner.js.map

///----------------------------------------------------------------
/// (from _helpers\string.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// string.ts.  Copyright (c) 2013 Microsoft Corporation.
///     - part of VuePlotCore library.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    /// signature:  stringStartsWith(prefix)
    ///     summary: returns true if the string starts with the specified prefix
    ///     paramType(prefix): string
    ///     snippet: var name = "Dr. Smith";
    ///     snippet: var isDoctor = stringStartsWith(name, "Dr. ");        // isDoctor will be true
    ///     returns: true if the string starts with the prefix; false otherwise
    function stringStartsWith(prefix) {
        var found = false;

        if (this.substr(0, prefix.length) == prefix) {
            found = true;
        }

        return found;
    }

    /// signature:  stringEndsWith(suffix)
    ///     summary: returns true if the string ends with the specified suffix
    ///     paramType(suffix): string
    ///     snippet: var animal = "cats";
    ///     snippet: var isPlural = stringEndsWith(animal, "s");        // isPlural will be true
    ///     returns: true if the string ends with the suffix; false otherwise
    function stringEndsWith(suffix) {
        var found = false;

        if (this.substr(this.length - suffix.length, suffix.length) == suffix) {
            found = true;
        }

        return found;
    }

    /// signature:  stringLeftTrim()
    ///     summary: return the string with the leading spaces removed
    ///     snippet: var name = " cat ";
    ///     snippet: var newName = stringLeftTrim(name);       // newName will be "cat "
    ///     returns: returns the newly trimmed string
    function stringLeftTrim() {
        var value = this;
        if (value.length > 0) {
            var i = 0;

            while ((value[i] == ' ') || (value[i] == '\t')) {
                i++;
                if (i >= value.length) {
                    break;
                }
            }

            value = this.substring(i);
        }

        return value;
    }

    /// signature:  stringRightTrim()
    /// summary: return the string with the trailing spaces removed
    /// snippet: var name = " cat ";
    /// snippet: var newName = stringRightTrim(name);         // newName will be " cat"
    function stringRightTrim() {
        var value = this;
        if (value.length > 0) {
            var i = value.length - 1;

            while ((value[i] == ' ') || (value[i] == '\t')) {
                i--;
                if (i < 0) {
                    break;
                }
            }

            value = this.substring(0, i + 1);
        }

        return value;
    }

    /// signature:  stringContains(str)
    ///     summary: return true if the string contains the "str" substring
    ///     paramType(str): string
    ///     snippet: var animals = "dog, cat, rabbit";
    ///     snippet: var hasCat = stringContains(animals, "cat");         // hasCat will be true
    ///     returns: returns true if the string contains the substring; false otherwise
    function stringContains(substr) {
        var index = this.indexOf(substr);
        return index > -1;
    }

    ///** replaces all occurences of 'target' with 'replacement' in 'str'. */
    //export function stringReplace(target, replacement)
    //{
    //    str = str.replace(RegExp(target, "g"), replacement);
    //    return str;
    //}
    // Changes the first character of the supplied string to upper-case.
    function stringCapitalize() {
        if (!this || (this.length == 0)) {
            return this;
        }

        var capFirstChar = this[0].toUpperCase();

        return (capFirstChar + ((this.length > 1) ? this.substring(1) : ''));
    }

    //---- safely extend String functions (so that are NOT enumerable) ----
    //---- we extend String with each helper function using this method, so our help functions won't show up during a "for in" operation ----
    function extendString(helperName, helperFunc) {
        if (String.prototype[helperName] === undefined) {
            Object.defineProperty(String.prototype, helperName, { enumerable: false, value: helperFunc });
        }
    }

    //---- now add our string helper functions ----
    extendString("startsWith", stringStartsWith);
    extendString("endsWith", stringEndsWith);
    extendString("ltrim", stringLeftTrim);
    extendString("rtrim", stringRightTrim);
    extendString("contains", stringContains);

    //extendString("replace", stringReplace);
    extendString("capitalize", stringCapitalize);
})(vp || (vp = {}));

//# sourceMappingURL=string.js.map

///----------------------------------------------------------------
/// (from _helpers\utilities.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// utilities.ts.  Copyright (c) 2013 Microsoft Corporation.
///                part of the vuePlot library - misc utility functions.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    (function (utils) {
        function cb(thisObj, func) {
            var wrapper = function (thisObj, func) {
                if ((!thisObj) || (!func)) {
                    vp.utils.error("Bad vp.cb() call: both arguments must be non-null");
                }

                this.thisObj = thisObj;
                this.func = func;
                var self = this;

                this.callIt = function () {
                    return self.func.apply(self.thisObj, arguments);
                };
            };

            var wrapFunc = new wrapper(thisObj, func);
            return wrapFunc.callIt;
        }
        utils.cb = cb;

        //export function getMousePosition(e)
        //{
        //    var x: number = 0;
        //    var y: number = 0;
        //    // Handle a non-IE 'touch' event
        //    if ((<string>e.type).startsWith('touch') && (e.changedTouches != undefined) && (e.changedTouches.length > 0))
        //    {
        //        x = e.changedTouches[0].pageX;
        //        y = e.changedTouches[0].pageY;
        //    }
        //    else
        //    {
        //        x = <number> e.pageX;
        //        y = <number> e.pageY;
        //    }
        //    return { x: x, y: y };
        //}
        /** When set to a function, the function is called before an error is reported. */
        utils.onError = null;

        function error(msg, lineNum) {
            var omitThrow = false;

            if (lineNum) {
                msg += " [line: " + lineNum + "]";
            }

            if (vp.utils.onError) {
                omitThrow = vp.utils.onError(msg);
            }

            if (!omitThrow) {
                throw msg;
            }
        }
        utils.error = error;

        function jsonToStr(obj) {
            var value = "";

            if (obj instanceof Int32Array) {
                //---- support for this is marginal, at best, depending on browser. ----
                //---- we convert to a map whose keys are the index ----
                if (utils.isIE) {
                    //---- IE doesn't handle this at all; must do it manually ----
                    var map = {};
                    var ia = obj;

                    for (var i = 0; i < ia.length; i++) {
                        map[i] = ia[i];
                    }

                    value = "Int32Array" + JSON.stringify(map);
                } else {
                    value = "Int32Array" + JSON.stringify(obj);
                }
            } else {
                value = JSON.stringify(obj);
            }

            return value;
        }
        utils.jsonToStr = jsonToStr;

        function getFileExtension(name) {
            name = name.toLowerCase();
            var ext = "";

            var index = name.lastIndexOf(".");
            if (index > -1) {
                ext = name.substr(index);
            }

            return ext;
        }
        utils.getFileExtension = getFileExtension;

        function jsonFromStr(str) {
            var data = null;

            //---- note: JSON.parse() cannot handle "Int32Array{...}" ----
            if (str.startsWith("Int32Array")) {
                str = str.substr(10); // skip over Int32Array

                var objWithKeys = JSON.parse(str);
                var keys = vp.utils.keys(objWithKeys);

                //---- first pass: get exact length of new Int32Array ----
                var length = 0;
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];

                    //---- watch out for non-numeric keys (other properties on map) ----
                    var index = +key;
                    if (!isNaN(index)) {
                        length++;
                    }
                }

                var ia = vp.utils.int32Array(length);

                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];

                    //---- watch out for non-numeric keys (other properties on map) ----
                    var index = +key;
                    if (!isNaN(index)) {
                        var value = objWithKeys[key];
                        ia[index] = +value;
                    }
                }

                data = ia;
            } else {
                data = JSON.parse(str);
            }

            return data;
        }
        utils.jsonFromStr = jsonFromStr;

        function float32Array(length) {
            var vector = null;

            if (typeof Float32Array === "undefined") {
                vector = new Array(length);
            } else {
                vector = new Float32Array(length);
            }

            return vector;
        }
        utils.float32Array = float32Array;

        function int32Array(length) {
            var vector = null;

            if (typeof Int32Array === "undefined") {
                vector = new Array(length);
            } else {
                vector = new Int32Array(length);
            }

            return vector;
        }
        utils.int32Array = int32Array;

        function toRadians(value) {
            return value * Math.PI / 180;
        }
        utils.toRadians = toRadians;

        function toHex2(value) {
            var str = value.toString(16);
            if (str.length == 1) {
                str = "0" + str;
            }

            return str;
        }
        utils.toHex2 = toHex2;

        function makeCtxColorStr(cr3) {
            var red = vp.data.clamp(Math.round(cr3[0]), 0, 255);
            var green = vp.data.clamp(Math.round(cr3[1]), 0, 255);
            var blue = vp.data.clamp(Math.round(cr3[2]), 0, 255);

            //---- use hex format to compare correctly with ctx colors ----
            var str = "#" + this.toHex2(red) + this.toHex2(green) + this.toHex2(blue);
            return str;
        }
        utils.makeCtxColorStr = makeCtxColorStr;

        /// prevents the default event handling from happening.
        function cancelEventDefault(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }

            e.returnValue = false;
        }
        utils.cancelEventDefault = cancelEventDefault;

        /// prevents the event from bubbling to other controls.
        function cancelEventBubble(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            e.cancelBubble = false;
        }
        utils.cancelEventBubble = cancelEventBubble;

        function argumentsAsArray(args) {
            var array = [];

            for (var a = 0; a < args.length; a++) {
                array.push(args[a]);
            }
            return array;
        }
        utils.argumentsAsArray = argumentsAsArray;

        function setTimer(interval, callback) {
            return setInterval(callback, interval);
        }
        utils.setTimer = setTimer;

        function clearTimer(handle) {
            clearInterval(handle);
        }
        utils.clearTimer = clearTimer;

        function setOneShotTimer(interval, callback) {
            return setTimeout(callback, interval);
        }
        utils.setOneShotTimer = setOneShotTimer;

        function clearOneShotTimer(handle) {
            clearTimeout(handle);
        }
        utils.clearOneShotTimer = clearOneShotTimer;

        function globalEval(js, wantReturn) {
            //---- eval in global context by adding a script element to the <head> ----
            var script = document.createElement("script");
            script.type = "text/javascript";
            script.text = (wantReturn) ? "window._evalResult = " + js : js;

            var head = document.getElementsByTagName("head")[0];
            if (!head) {
                throw "Error - HTML missing head element (required for globalEval)";
            }

            head.appendChild(script);
            head.removeChild(script);

            var window = Window;
            var retVal = (wantReturn) ? window._evalResult : undefined;

            return retVal;
        }
        utils.globalEval = globalEval;

        //------------------------------------------------------------------------------------------------
        /// internal - supports "thisWrapper()"
        function wrapper(func, thisObj) {
            this.func = func;
            this.thisObj = thisObj;
            var self = this;

            this.callIt = function (e) {
                self.func.call(self.thisObj, e);
            };
        }

        function mapValue(value, fromMin, fromMax, toMin, toMax) {
            var range = fromMax - fromMin;
            var percent = (range) ? (value - fromMin) / range : 1;

            var newValue = toMin + percent * (toMax - toMin);
            return newValue;
        }
        utils.mapValue = mapValue;

        ///
        /// timing: range(1000*1000) takes 842ms on roland's home machine (3/23/2012).
        ///
        function range(from, to, incr) {
            //var startTime = new Date().getTime();
            var values = [];

            if (vp.utils.isUndefined(incr)) {
                incr = 1;
            }

            if (vp.utils.isUndefined(to)) {
                to = from;
                from = 1;
            }

            //---- guard against infinite loops ----
            if (incr == 0) {
            } else if ((from < to) && (incr < 0)) {
            } else if ((from > to) && (incr > 0)) {
            } else if ((from > to) && (incr < 0)) {
                for (var value = from; floatGeq(value, to); value += incr) {
                    values.push(value);
                }
            } else if ((from < to) && (incr > 0)) {
                for (var value = from; floatLeq(value, to); value += incr) {
                    values.push(value);
                }
            }

            //var elapsedMs = new Date().getTime() - startTime;
            return values;
        }
        utils.range = range;

        /// get a list of the key/value parameters for the current page url.
        function getCmdParams(cmd) {
            var params = {};

            if (cmd) {
                var pairs = cmd.split("&");
                for (var i = 0; i < pairs.length; i++) {
                    var pair = pairs[i];

                    var pp = pair.split("=");

                    if (pp.length > 1) {
                        var key = pp[0].toLowerCase();
                        params[key] = pp[1];
                    } else {
                        params[pair] = "";
                    }
                }
            }

            return params;
        }
        utils.getCmdParams = getCmdParams;

        /// get a list of the key/value parameters for the current page url.
        function getUrlParams() {
            var url = window.location.href;
            var params = {};

            var index = url.indexOf("?");
            if (index == -1) {
                //---- using hash tag to save state? ----
                index = url.indexOf("#");
            }

            if (index > -1) {
                params = getCmdParams(url.substring(index + 1));
            }

            return params;
        }
        utils.getUrlParams = getUrlParams;

        /// returns the directory portion of the current page's URL (excludes the page name)
        function getUrlDirectory() {
            var url = window.location.href;
            var index = url.lastIndexOf("/");
            if (index > -1) {
                url = url.substr(0, index);
            }

            return url;
        }
        utils.getUrlDirectory = getUrlDirectory;

        /// used for floating point comparisons.
        utils.epsilon = .00001;

        /// return true if a <= b (using floating point comparison).
        function floatLeq(a, b) {
            return (b - a) >= -utils.epsilon;
        }
        utils.floatLeq = floatLeq;

        function floatLess(a, b) {
            return (!floatGeq(a, b));
        }
        utils.floatLess = floatLess;

        /// return true if a >= b (using floating point comparison).
        function floatGeq(a, b) {
            return (a - b) >= -utils.epsilon;
        }
        utils.floatGeq = floatGeq;

        /// return true if a == b (using floating point comparison).
        function floatEq(a, b) {
            return Math.abs(a - b) <= utils.epsilon;
        }
        utils.floatEq = floatEq;

        /// add "keys" (list of dict properties) for browsers (like IE) that don't yet implement it.
        function keys(obj) {
            var keys = [];

            if (obj.keys) {
                keys = obj.keys;
            } else {
                for (var k in obj) {
                    if (obj.hasOwnProperty(k)) {
                        keys.push(k);
                    }
                }
            }

            return keys;
        }
        utils.keys = keys;

        /// return true if object has one or more dictionary keys.
        function hasKey(obj) {
            /// fastest cross-browser test
            var count = 0;

            for (var k in obj) {
                count++;
                break;
            }

            return (count > 0);
        }
        utils.hasKey = hasKey;

        //--- opera doesn't have Object.keys so we use this wrapper ----
        function numberOfKeys(theObject) {
            if (Object.keys)
                return Object.keys(theObject).length;

            var n = 0;
            for (var key in theObject)
                ++n;

            return n;
        }
        utils.numberOfKeys = numberOfKeys;

        /// return the size of the text in a SPAN element whose class is the specified class.
        function measureText(text, spanClass) {
            var span = document.createElement("span");
            document.body.appendChild(span);
            vp.dom.text(span, text);
            vp.dom.setClass(span, spanClass);

            var sz = { width: vp.dom.width(span), height: vp.dom.height(span) };
            document.body.removeChild(span);

            return sz;
        }
        utils.measureText = measureText;

        /// return the size of the text in an SVG element whose class is the specified class.
        function measureSvgText(svgNode, text, className) {
            var textElem = document.createElementNS('http://www.w3.org/2000/svg', "text");
            svgNode.append(textElem);
            vp.dom.setClass(textElem, className);

            var xx = vp.dom.getBounds(textElem);

            var rect = textElem.getBoundingClientRect();
            svgNode.remove(textElem);

            var sz = { width: rect.width, height: rect.height };
            return sz;
        }
        utils.measureSvgText = measureSvgText;

        function routePropCalls(from, to) {
            for (var i = 2; i < arguments.length; i++) {
                var methodName = arguments[i];

                if (vp.utils.isArray(methodName)) {
                    for (var m = 0; m < methodName.length; m++) {
                        var methName = methodName[m];

                        var method = to[methName];
                        from[methName] = makePropRouteCallFunc(from, to, method);
                    }
                } else {
                    var method = to[methodName];
                    from[methodName] = makePropRouteCallFunc(from, to, method);
                }
            }
        }
        utils.routePropCalls = routePropCalls;

        function routeFuncCalls(from, to) {
            for (var i = 2; i < arguments.length; i++) {
                var methodName = arguments[i];
                var method = to[methodName];

                from[methodName] = makeFuncRouteCallFunc(from, to, method);
            }
        }
        utils.routeFuncCalls = routeFuncCalls;

        function routePropCallsPost(from, to, postCall) {
            for (var i = 3; i < arguments.length; i++) {
                var methodName = arguments[i];
                var method = to[methodName];

                from[methodName] = makePropRouteCallFunc(from, to, method, postCall);
            }
        }
        utils.routePropCallsPost = routePropCallsPost;

        /// internal (needs to be a separate func due to closure rules.
        function makePropRouteCallFunc(from, to, method, postCall) {
            return function () {
                var result = method.apply(to, arguments);

                //---- if this is not a getter, we want to return "from" as then chaining object ----
                if (arguments.length > 0) {
                    result = from;
                }

                if (vp.utils.isDefined(postCall)) {
                    postCall.apply(from);
                }

                return result;
            };
        }

        /// internal (needs to be a separate func due to closure rules.
        function makeFuncRouteCallFunc(from, to, method, postCall) {
            return function () {
                var result = method.apply(to, arguments);

                if (vp.utils.isDefined(postCall)) {
                    postCall.apply(from);
                }

                return result;
            };
        }

        function generateFunc(args, body, maker) {
            var exp = "function foo(" + args + ")\n" + body + "";
            var func = null;

            if (maker == "eval") {
                func = eval("(" + exp + ")");
            } else if (maker == "script") {
                //---- inject a script element ----
                var script = document.createElement("script");
                document.body.appendChild(script);
                script.text = exp;

                func = window["foo"];
            } else if (maker == "Function") {
                func = Function(args, body);
            }

            return func;
        }
        utils.generateFunc = generateFunc;

        // Makes a deep copy of the supplied object
        function deepCopy(objectToCopy) {
            var copy = objectToCopy ? JSON.parse(JSON.stringify(objectToCopy)) : null;

            return (copy);
        }
        utils.deepCopy = deepCopy;

        function getCanvasOrSvgParent(elem) {
            var parentElem = elem;

            if (parentElem.rootContainer) {
                //---- canvas element ----
                parentElem = parentElem.rootContainer.canvas;
            } else {
                while (parentElem && parentElem.tagName != "svg") {
                    //---- get parent of group ----
                    parentElem = vp.dom.parent(parentElem);
                }
            }

            return parentElem;
        }
        utils.getCanvasOrSvgParent = getCanvasOrSvgParent;

        function getCrispTranslate(container, x, y) {
            var parentElem = this.getCanvasOrSvgParent(container);

            //var rc = vp.dom.getBounds(this._container);  // uses elem.getBBox() which is not reliable for an SVG document
            var rc = parentElem.getBoundingClientRect();

            //---- goal is to move GROUP to .5, .5 pixel boundary, relative to our html document ----
            var xDoc = rc.left + x;
            var xFraction = xDoc - Math.floor(xDoc);
            var xOffset = .5 - xFraction;

            var yDoc = rc.top + y;
            var yFraction = yDoc - Math.floor(yDoc);
            var yOffset = .5 - yFraction;

            x += xOffset;
            y += yOffset;

            return { x: x, y: y };
        }
        utils.getCrispTranslate = getCrispTranslate;
    })(vp.utils || (vp.utils = {}));
    var utils = vp.utils;
})(vp || (vp = {}));
//# sourceMappingURL=utilities.js.map
///-----------------------------------------------------------------------------------------------------------------
/// selectedSet.ts.  Copyright (c) 2014 Microsoft Corporation.
///              part of the vuePlot library - selected set functions.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (dom) {
        var selectedSet = (function () {
            //select = Array.prototype.select;
            function selectedSet(elements) {
                //---- make "selectedSet" look/act like an array object ---
                this.length = 0;
                this.push = Array.prototype.push;
                this.sort = Array.prototype.sort;
                this.splice = Array.prototype.splice;
                this.indexOf = Array.prototype.indexOf;
                if (elements) {
                    var sameCtr = true;
                    var lastCtr = "";

                    for (var i = 0; i < elements.length; i++) {
                        var elem = elements[i];

                        this.push(elem);

                        if (i == 0) {
                            lastCtr = elem.ctr;
                        } else {
                            if (elem.ctr != lastCtr) {
                                sameCtr = false;
                            }
                        }
                    }

                    //---- extend this wrapper if elem with custom control properties ----
                    if ((elements.length > 0) && (sameCtr)) {
                        var elem = elements[0];

                        if ((elem.control) && (elem.control.extendWrapper)) {
                            elem.control.extendWrapper(this);
                        }
                    }
                }
            }
            selectedSet.prototype.frameRateChanged = function (fpsCallBack) {
                var appendedElements = [];
                var firstContainer = null;

                this.each(function (index, container) {
                    vp.dom.frameRateChanged(this, fpsCallBack);
                });

                return this;
            };

            //---- ADD the content to the selected set of containers ----
            selectedSet.prototype.add = function (content) {
                var ss = null;
                var firstContainer = true;

                this.each(function (index, container) {
                    var newElems = vp.dom.add(container, content);

                    if (firstContainer) {
                        ss = vp.dom.wrapElements(newElems);
                        firstContainer = false;
                    }
                });

                return ss;
            };

            /// remove all children (childNodes) of each item in the selected set.
            selectedSet.prototype.clear = function () {
                return this.each(function (index, element) {
                    vp.dom.clear(element);
                });
            };

            selectedSet.prototype.show = function (showIt) {
                return this.each(function (index, element) {
                    vp.dom.show(this, showIt);
                });
            };

            selectedSet.prototype.showToggle = function () {
                return this.each(function (index, element) {
                    vp.dom.showToggle(this);
                });
            };

            selectedSet.prototype.hide = function (showIt) {
                return this.each(function (index, element) {
                    vp.dom.hide(this);
                });
            };

            selectedSet.prototype.collapse = function () {
                return this.each(function (index, element) {
                    vp.dom.collapse(this);
                });
            };

            selectedSet.prototype.expand = function () {
                return this.each(function (index, element) {
                    vp.dom.expand(this);
                });
            };

            /// gets the {left,top} offset of the HTML/SVG/Canvas element from the document origin.
            selectedSet.prototype.docOffset = function (elem) {
                var value = null;

                if (this.length > 0) {
                    value = vp.dom.docOffset(elem);
                }

                return value;
            };

            selectedSet.prototype.left = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.left(this[0]);
                    }

                    return value;
                } else {
                    //---- SET value ----
                    return this.each(function (index, element) {
                        vp.dom.left(this, value);
                    });
                }
            };

            selectedSet.prototype.top = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.top(this[0]);
                    }

                    return value;
                } else {
                    //---- SET value ----
                    return this.each(function (index, element) {
                        vp.dom.top(this, value);
                    });
                }
            };

            selectedSet.prototype.width = function (value) {
                if (arguments.length == 0) {
                    var value = null;
                    if (this.length > 0) {
                        value = vp.dom.width(this[0]);
                    }

                    return value;
                } else {
                    //---- SET value ----
                    var origValue = value;

                    return this.each(function (index, element) {
                        if (vp.utils.isFunction(origValue)) {
                            value = origValue(index, element);
                        }

                        vp.dom.width(this, value);
                    });
                }
            };

            selectedSet.prototype.css = function (name, value) {
                if (arguments.length == 1) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.css(this[0], name);
                    }

                    return value;
                }

                //---- SET value ----
                var origValue = value;

                return this.each(function (index, element) {
                    if (vp.utils.isFunction(origValue)) {
                        value = origValue(index, element);
                    }

                    vp.dom.css(this, name, value);
                });
            };

            selectedSet.prototype.height = function (value) {
                if (arguments.length == 0) {
                    var value = null;
                    if (this.length > 0) {
                        value = vp.dom.height(this[0]);
                    }

                    return value;
                }

                //---- SET value ----
                var origValue = value;

                return this.each(function (index, element) {
                    if (vp.utils.isFunction(origValue)) {
                        value = origValue(index, element);
                    }

                    vp.dom.height(this, value);
                });
            };

            /// get total height of first element
            selectedSet.prototype.totalHeight = function () {
                var value = null;
                if (this.length > 0) {
                    value = vp.dom.totalHeight(this[0]);
                }

                return value;
            };

            /// get total width of first element
            selectedSet.prototype.totalWidth = function () {
                var value = null;
                if (this.length > 0) {
                    value = vp.dom.totalWidth(this[0]);
                }

                return value;
            };

            selectedSet.prototype.toolTipEnabled = function (value) {
                if (arguments.length == 0) {
                    value = (this.length > 0) ? this[0].toolTipEnabled : false;
                    return value;
                }

                return this.each(function (index, element) {
                    vp.dom.toolTipEnabled(element, value);
                });
            };

            selectedSet.prototype.animate = function (duration, ease, container) {
                return this.each(function (index, element) {
                    vp.dom.animate(this, duration, ease, container);
                });
            };

            selectedSet.prototype.onAnimationComplete = function (completedFunc) {
                return this.each(function (index, element) {
                    vp.dom.onAnimationComplete(this, completedFunc);
                });
            };

            selectedSet.prototype.remove = function () {
                return this.each(function (index, element) {
                    if (this.animation == null) {
                        vp.dom.remove(this);
                    } else {
                        this.animation.deleteElementsOnCompleted(this);
                    }
                });
            };

            selectedSet.prototype.attr = function (name, value) {
                if (arguments.length == 1) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.attr(this[0], name);
                    }

                    return value;
                }

                //---- SET value ----
                var origValue = value;

                return this.each(function (index, element) {
                    vp.dom.attr(this, name, value);
                });
            };

            selectedSet.prototype.prop = function (name, value) {
                if (arguments.length == 1) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.prop(this[0], name);
                    }

                    return value;
                }

                //---- SET value ----
                var origValue = value;

                return this.each(function (index, element) {
                    vp.dom.prop(this, name, value);
                });
            };

            selectedSet.prototype.attrXlink = function (name, origValue) {
                return this.attrNS("http://www.w3.org/1999/xlink", name, origValue);
            };

            selectedSet.prototype.attrNS = function (ns, name, value) {
                return this.each(function (index, element) {
                    vp.dom.attrNS(element, ns, name, value);
                });
            };

            selectedSet.prototype.hLine = function (x1, x2, y, makeCrisp) {
                return this.each(function (index, element) {
                    vp.dom.hLine(element, x1, x2, y, makeCrisp);
                });
            };

            selectedSet.prototype.vLine = function (y1, y2, x, makeCrisp) {
                return this.each(function (index, element) {
                    vp.dom.vLine(element, y1, y2, x, makeCrisp);
                });
            };

            selectedSet.prototype.bounds = function (x, y, width, height) {
                return this.each(function (index, element) {
                    vp.dom.bounds(element, x, y, width, height);
                });
            };

            selectedSet.prototype.radius = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    value = (this.length > 0) ? vp.dom.radius(this[0]) : 0;
                    return value;
                }

                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.radius(this, value);
                });
            };

            selectedSet.prototype.tabIndex = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    value = (this.length > 0) ? vp.dom.tabIndex(this[0]) : 0;
                    return value;
                }

                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.tabIndex(this, value);
                });
            };

            selectedSet.prototype.opacity = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.opacity(this[0]);
                    }

                    return value;
                }

                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.opacity(this, value);
                });
            };

            selectedSet.prototype.checked = function (value) {
                //---- GET value ----
                if (arguments.length == 0) {
                    value = null;

                    if (this.length > 0) {
                        value = vp.dom.checked(this[0]);
                    }

                    return value;
                }

                //---- SET value ----
                return this.each(function (index, element) {
                    //---- animation not supported for "checked" ----
                    vp.dom.checked(this, value);
                });
            };

            selectedSet.prototype.position = function (x, y) {
                return this.each(function (index, element) {
                    vp.dom.position(element, x, y);
                });
            };

            selectedSet.prototype.absPosition = function (left, top) {
                return this.each(function (index, element) {
                    vp.dom.absPosition(element, left, top);
                });
            };

            selectedSet.prototype.removeProp = function (name) {
                return this.each(function (index, element) {
                    //---- animation not supported for this operation ----
                    vp.dom.removeProp(this, name);
                });
            };

            selectedSet.prototype.center = function (cx, cy) {
                return this.each(function (index, element) {
                    vp.dom.center(element, cx, cy);
                });
            };

            selectedSet.prototype.id = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.id(this[0]);
                    }
                    return value;
                } else {
                    //---- SET value ----
                    return this.each(function (index, element) {
                        vp.dom.id(this, value);
                    });
                }
            };

            selectedSet.prototype.addClass = function (name) {
                return this.each(function (index, element) {
                    vp.dom.addClass(this, name);
                });
            };

            selectedSet.prototype.removeClass = function (name) {
                return this.each(function (index, element) {
                    vp.dom.removeClass(this, name);
                });
            };

            selectedSet.prototype.hasClass = function (name) {
                var hasIt = false;

                if (this.length > 0) {
                    hasIt = vp.dom.hasClass(this[0], name);
                }

                return hasIt;
            };

            selectedSet.prototype.getBounds = function (relToParent) {
                var result = null;

                if (this.length > 0) {
                    result = vp.dom.getBounds(this[0], relToParent);
                }

                return result;
            };

            selectedSet.prototype.setClass = function (name) {
                return this.each(function (index, element) {
                    vp.dom.setClass(this, name);
                });
            };

            selectedSet.prototype.toggleClass = function (name) {
                return this.each(function (index, element) {
                    vp.dom.toggleClass(this, name);
                });
            };

            selectedSet.prototype.attach = function (eventName, funcToCall, useCapture) {
                return this.each(function (index, element) {
                    vp.events.attach(this, eventName, funcToCall, useCapture);
                });
            };

            selectedSet.prototype.detach = function (eventName, funcToCall, useCapture) {
                return this.each(function (index, element) {
                    vp.events.detach(this, eventName, funcToCall, useCapture);
                });
            };

            selectedSet.prototype.transform = function (value) {
                return this.each(function (index, element) {
                    vp.dom.transform(this, value);
                });
            };

            selectedSet.prototype.translate = function (x, y, makeCrisp) {
                return this.each(function (index, element) {
                    if (makeCrisp) {
                        var result = vp.utils.getCrispTranslate(this, x, y);
                        x = result.x;
                        y = result.y;
                    }

                    vp.dom.translate(this, x, y);
                });
            };

            selectedSet.prototype.transformOrigin = function (value) {
                if (arguments.length == 0) {
                    value = (this.length > 0) ? vp.dom.transformOrigin(this[0]) : undefined;
                    return value;
                }

                return this.each(function (index, element) {
                    vp.dom.transformOrigin(value);
                });
            };

            selectedSet.prototype.addStop = function (offset, color, opacity) {
                return this.each(function (index, element) {
                    vp.dom.addStop(this, offset, color, opacity);
                });
            };

            selectedSet.prototype.textBaseline = function (alignType, rc) {
                return this.each(function (index, element) {
                    vp.dom.textBaseline(element, alignType, rc);
                });
            };

            selectedSet.prototype.from = function (x1, y1) {
                return this.each(function (index, element) {
                    vp.dom.from(element, x1, y1);
                });
            };

            selectedSet.prototype.to = function (x2, y2) {
                return this.each(function (index, element) {
                    vp.dom.to(element, x2, y2);
                });
            };

            selectedSet.prototype.font = function (family, size, weight, style) {
                return this.each(function (index, element) {
                    vp.dom.font(element, family, size, weight, style);
                });
            };

            selectedSet.prototype.dataPair = function (dataItem, dataIndex) {
                return this.each(function (index, element) {
                    vp.dom.dataPair(this, dataItem, dataIndex);
                });
            };

            selectedSet.prototype.data = function (value) {
                if (arguments.length == 0) {
                    var anyElem = this[0];

                    return (anyElem.data) ? anyElem.data() : null;
                }

                return this.each(function (index, element) {
                    var anyElem = element;
                    if (anyElem.data) {
                        anyElem.data(value);
                    }
                });
            };

            selectedSet.prototype.dataItem = function (dataItem) {
                if (dataItem != null) {
                    return this.each(function (index, element) {
                        this.dataItem = dataItem;
                    });
                } else {
                    return this[0].dataItem;
                }
            };

            selectedSet.prototype.dataIndex = function (value) {
                if (value != null) {
                    return this.each(function (index, element) {
                        this.dataIndex = value;
                    });
                } else {
                    return (this.length == 0) ? null : this[0].dataIndex;
                }
            };

            selectedSet.prototype.customAttr = function (name, value) {
                if (arguments.length == 1) {
                    value = (this.length > 0) ? vp.dom.customAttr(this[0], name) : undefined;
                    return value;
                }

                return this.each(function (index, element) {
                    vp.dom.customAttr(element, name, value);
                });
            };

            selectedSet.prototype.text = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    value = null;

                    if (this.length > 0) {
                        value = vp.dom.text(this[0]);
                    }

                    return value;
                }

                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.text(this, value);
                });
            };

            selectedSet.prototype.title = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    value = null;

                    if (this.length > 0) {
                        value = vp.dom.title(this[0]);
                    }

                    return value;
                }

                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.title(this, value);
                });
            };

            selectedSet.prototype.value = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.value(this[0]);
                    }

                    return value;
                }

                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.value(this, value);
                });
            };

            selectedSet.prototype.html = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    return (this.length == 0) ? null : this[0].innerHTML;
                }

                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.html(this, value);
                });
            };

            selectedSet.prototype.colors = function (fill, stroke, strokeWidth) {
                return this.each(function (index, element) {
                    vp.dom.colors(this, fill, stroke, strokeWidth);
                });
            };

            selectedSet.prototype.href = function (value) {
                return this.attrNS("http://www.w3.org/1999/xlink", "href", value);
            };

            selectedSet.prototype.safeHref = function (value, fallback) {
                if ((!value) || (value.length == 0)) {
                    value = fallback;
                }

                return this.each(function (index, element) {
                    vp.dom.href(this, value);
                });
            };

            selectedSet.prototype.kids = function () {
                var kids = [];

                if (this.length > 0) {
                    kids = vp.dom.children(this[0]);
                }

                var wrappedKids = vp.dom.wrapElements(kids);
                return wrappedKids;
            };

            selectedSet.prototype.elementSizes = function (callBack) {
                var value = undefined;

                if (this.length > 0) {
                    value = vp.dom.elementSizes(this[0]);
                }

                return value;
            };

            selectedSet.prototype.background = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    return (this.length == 0) ? null : this[0].background;
                }

                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.background(this, value);
                });
            };

            selectedSet.prototype.focus = function () {
                if (this.length > 0) {
                    vp.dom.focus(this[0]);
                }

                return this;
            };

            selectedSet.prototype.dataId = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    return (this.length == 0) ? null : vp.dom.dataItem(this[0]);
                }

                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.dataItem(this, value);
                });
            };

            selectedSet.prototype.shapeId = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    return (this.length == 0) ? null : vp.dom.shapeId(this[0]);
                }

                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.shapeId(this, value);
                });
            };

            /// get element at specified index.  fails silently if index is not a number or out of range.
            selectedSet.prototype.get = function (index) {
                var element = null;

                if (vp.utils.isNumber(index)) {
                    if ((index >= 0) && (index < this.length)) {
                        element = this[index];
                    }
                }

                return element;
            };

            selectedSet.prototype.element = function () {
                return this.get(0);
            };

            /// wrap the element at specified index.  fails silently if index is not a number or out of range.
            selectedSet.prototype.wrap = function (index) {
                var element = this.get(index);
                var ss = null;

                if (element) {
                    ss = vp.dom.wrapElements(element);
                }

                return ss;
            };

            selectedSet.prototype.toArray = function () {
                return Array.prototype.slice.call(this, 0);
            };

            //---- eachsignature: callback(index, element) ----
            selectedSet.prototype.each = function (callback) {
                for (var i = 0; i < this.length; i++) {
                    var elem = this[i];

                    //---- callback with this=elem and 2 params ----
                    callback.call(elem, i, elem);
                }

                return this;
            };

            //---- eachWrappedsignature: callback(index, element) ----
            selectedSet.prototype.eachWrapped = function (callback) {
                var sw = vp.dom.createSingleWrapper(null);

                for (var i = 0; i < this.length; i++) {
                    var elem = this[i];
                    sw.elem = elem;

                    //---- callback with this=wrapper(elem) and 2 params ----
                    callback.call(sw, i, sw);
                }

                return this;
            };

            /// adds the specified element/array to the selected set.
            selectedSet.prototype.merge = function (elemOrArray) {
                var newElements = null;

                if (elemOrArray instanceof vp.dom.selectedSet) {
                    elemOrArray = elemOrArray.toArray();
                } else if (elemOrArray instanceof vp.canvas.canvasSelectedSet) {
                    elemOrArray = elemOrArray.toArray();
                } else if (elemOrArray instanceof vp.dom.singleWrapperSuperClass) {
                    elemOrArray = elemOrArray.elem;
                }

                if (vp.utils.isArray(elemOrArray)) {
                    newElements = this.toArray().concat(elemOrArray);
                } else {
                    newElements = this.toArray();
                    newElements.push(elemOrArray);
                }

                var newSet = new vp.dom.selectedSet(newElements);

                return newSet;
            };

            //---- remove the selected set from their parent ----
            selectedSet.prototype.removeCore = function (content) {
                this.each(function (index, element) {
                    vp.dom.remove(element);
                });
            };

            selectedSet.prototype.append = function (content) {
                return vp.dom.appendCoreMulti(this, content, "append");
            };

            selectedSet.prototype.prepend = function (content) {
                return vp.dom.appendCoreMulti(this, content, "prepend");
            };

            selectedSet.prototype.insertBefore = function (content) {
                return vp.dom.appendCoreMulti(this, content, "insertBefore");
            };

            selectedSet.prototype.insertAfter = function (content) {
                return vp.dom.appendCoreMulti(this, content, "insertAfter");
            };

            //---- extend vuePlot selected set to add "context()" ----
            //---- use to obtain a Canvas (2d) or WebGL (3d) context ----
            selectedSet.prototype.context = function (origRequest) {
                var cc = null;
                var value = null;

                for (var i = 0; i < this.length; i++) {
                    var elem = this[i];

                    var contextRequest = origRequest;

                    if (elem.getContext) {
                        if (contextRequest == "3d") {
                            //---- works for IE11, Chrome, Safari, FireFox ----
                            contextRequest = "experimental-webgl";

                            //---- setting alpha=false prevents alpha values that we output from compositing with other DOM elements ----
                            value = elem.getContext(contextRequest, { alpha: false });
                        } else {
                            value = elem.getContext(contextRequest);
                        }
                    }

                    if (value == null) {
                        if (origRequest == "2d") {
                            //alert("This browser doesn't support HTML 5 Canvas.  Try IE9");
                        } else {
                            //alert("This browser doesn't support WebGL.  Try latest Chrome or Firefox");
                        }
                    }

                    if (value != null) {
                        if (elem.canvasContainerElement != null) {
                            //---- reuse existing object (prevent duplicates w/diff info) ----
                            cc = elem.canvasContainerElement;
                            cc.ctx = value;
                            cc.contextRequest = origRequest;
                        } else {
                            cc = new vp.canvas.canvasContainerElement(elem, value, origRequest);
                        }
                    }

                    break;
                }

                return cc;
            };
            return selectedSet;
        })();
        dom.selectedSet = selectedSet;
    })(vp.dom || (vp.dom = {}));
    var dom = vp.dom;
})(vp || (vp = {}));
//# sourceMappingURL=$selectedSet.js.map

///----------------------------------------------------------------
/// (from _dom\$singleWrapper.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// singleWrapper.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - class that wraps a single element (HTML, SVG, Canvas, or WebGL item).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (dom) {
        

        /** class that wraps a single element (HTML, SVG, Canvas, or WebGL item). */
        var singleWrapperSuperClass = (function () {
            function singleWrapperSuperClass(elem) {
                this.prop = null;
                this.elem = elem;

                //---- these are one and the same ----
                this.prop = this.customAttr;

                //---- we want calling code to be able to treat this as an array (so it doesn't have to special case ss vs. this) ----
                var self = this;
                self.length = 0;

                //---- make "selectedSet" look/act like an array object ---
                self.push = Array.prototype.push;
                self.splice = Array.prototype.splice;
                self.indexOf = Array.prototype.indexOf;
                self.select = Array.prototype.select;

                self.push(elem);

                //---- remove this as soon as all 15 controls are converted to TypeScript ----
                //---- extend this wrapper if elem with custom control properties ----
                var anyElem = elem;

                if ((anyElem) && (anyElem.control) && (anyElem.control.extendWrapper)) {
                    anyElem.control.extendWrapper(this);
                }
            }
            singleWrapperSuperClass.prototype.element = function (value) {
                if (arguments.length == 0) {
                    return this.elem;
                }

                this[0] = value;
                this.elem = value;
            };

            singleWrapperSuperClass.prototype.css = function (name, value) {
                if (arguments.length == 1) {
                    return vp.dom.css(this.elem, name);
                }

                vp.dom.css(this.elem, name, value);
                return this;
            };

            singleWrapperSuperClass.prototype.hLine = function (x1, x2, y, makeCrisp) {
                vp.dom.hLine(this.elem, x1, x2, y, makeCrisp);
                return this;
            };

            singleWrapperSuperClass.prototype.vLine = function (y1, y2, x, makeCrisp) {
                vp.dom.vLine(this.elem, y1, y2, x, makeCrisp);
                return this;
            };

            singleWrapperSuperClass.prototype.bounds = function (x, y, width, height) {
                vp.dom.bounds(this.elem, x, y, width, height);
                return this;
            };

            singleWrapperSuperClass.prototype.colors = function (fill, stroke, strokeWidth) {
                vp.dom.colors(this.elem, fill, stroke, strokeWidth);
                return this;
            };

            singleWrapperSuperClass.prototype.text = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.text(this.elem);
                }

                vp.dom.text(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.tabIndex = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.tabIndex(this.elem);
                }

                vp.dom.tabIndex(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.title = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.title(this.elem);
                }

                vp.dom.title(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.value = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.value(this.elem);
                }

                vp.dom.value(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.html = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.html(this.elem);
                }

                vp.dom.html(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.show = function (showIt) {
                vp.dom.show(this.elem, showIt);
                return this;
            };

            singleWrapperSuperClass.prototype.showToggle = function () {
                vp.dom.showToggle(this.elem);
                return this;
            };

            singleWrapperSuperClass.prototype.hide = function (showIt) {
                vp.dom.hide(this.elem);
                return this;
            };

            singleWrapperSuperClass.prototype.collapse = function () {
                vp.dom.collapse(this.elem);
                return this;
            };

            singleWrapperSuperClass.prototype.expand = function () {
                vp.dom.expand(this.elem);
                return this;
            };

            singleWrapperSuperClass.prototype.dataIndex = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.dataIndex(this.elem);
                }

                vp.dom.dataIndex(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.data = function (value) {
                var anyElem = this.elem;

                if (arguments.length == 0) {
                    return (anyElem.data) ? anyElem.data() : null;
                }

                if (anyElem.data) {
                    anyElem.data(value);
                }

                return this;
            };

            singleWrapperSuperClass.prototype.dataItem = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.dataItem(this.elem);
                }

                vp.dom.dataItem(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.dataPair = function (dataItem, dataIndex) {
                vp.dom.dataPair(this.elem, dataItem, dataIndex);
                return this;
            };

            singleWrapperSuperClass.prototype.to = function (x, y) {
                vp.dom.to(this.elem, x, y);
                return this;
            };

            singleWrapperSuperClass.prototype.from = function (x, y) {
                vp.dom.from(this.elem, x, y);
                return this;
            };

            singleWrapperSuperClass.prototype.attach = function (name, callBack, useCapture) {
                vp.events.attach(this.elem, name, callBack, useCapture);
                return this;
            };

            singleWrapperSuperClass.prototype.detach = function (name, callBack, useCapture) {
                vp.events.detach(this.elem, name, callBack, useCapture);
                return this;
            };

            singleWrapperSuperClass.prototype.transform = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.transform(this.elem);
                }

                vp.dom.transform(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.translate = function (x, y, makeCrisp) {
                if (typeof makeCrisp === "undefined") { makeCrisp = false; }
                if (makeCrisp) {
                    var result = vp.utils.getCrispTranslate(this.elem, x, y);
                    x = result.x;
                    y = result.y;
                }

                vp.dom.translate(this.elem, x, y);
                return this;
            };

            singleWrapperSuperClass.prototype.transformOrigin = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.transformOrigin(this.elem);
                }

                vp.dom.transformOrigin(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.href = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.href(this.elem);
                }

                vp.dom.href(this.elem, value);
                return this;
                // return vp.dom.attrNS("http://www.w3.org/1999/xlink", "href", value);
            };

            singleWrapperSuperClass.prototype.safeHref = function (value, fallback) {
                if ((!value) || (value.length == 0)) {
                    value = fallback;
                }

                vp.dom.href(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.font = function (family, size, weight, style) {
                vp.dom.font(this.elem, family, size, weight, style);
                return this;
            };

            singleWrapperSuperClass.prototype.setClass = function (value) {
                vp.dom.setClass(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.hasClass = function (value) {
                var returnValue = vp.dom.hasClass(this.elem, value);
                return returnValue;
            };

            singleWrapperSuperClass.prototype.addClass = function (value) {
                vp.dom.addClass(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.removeClass = function (value) {
                vp.dom.removeClass(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.toggleClass = function (value) {
                vp.dom.toggleClass(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.id = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.id(this.elem);
                }

                vp.dom.id(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.getBounds = function (relToParent) {
                return vp.dom.getBounds(this.elem, relToParent);
            };

            singleWrapperSuperClass.prototype.center = function (cx, cy) {
                vp.dom.center(this.elem, cx, cy);
                return this;
            };

            singleWrapperSuperClass.prototype.position = function (x, y) {
                vp.dom.position(this.elem, x, y);
                return this;
            };

            singleWrapperSuperClass.prototype.absPosition = function (left, top) {
                vp.dom.absPosition(this.elem, left, top);
                return this;
            };

            singleWrapperSuperClass.prototype.opacity = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.opacity(this.elem);
                }

                vp.dom.opacity(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.radius = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.radius(this.elem);
                }

                vp.dom.radius(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.attr = function (name, value) {
                if (arguments.length == 1) {
                    return vp.dom.attr(this.elem, name);
                }

                vp.dom.attr(this.elem, name, value);
                return this;
            };

            singleWrapperSuperClass.prototype.customAttr = function (name, value) {
                if (arguments.length == 1) {
                    return vp.dom.customAttr(this.elem, name);
                }

                vp.dom.customAttr(this.elem, name, value);
                return this;
            };

            singleWrapperSuperClass.prototype.remove = function () {
                vp.dom.remove(this.elem);
                return this;
            };

            singleWrapperSuperClass.prototype.toolTipEnabled = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.toolTipEnabled(this.elem);
                }

                vp.dom.toolTipEnabled(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.height = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.height(this.elem);
                }

                vp.dom.height(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.width = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.width(this.elem);
                }

                vp.dom.width(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.totalHeight = function () {
                return vp.dom.totalHeight(this.elem);
            };

            singleWrapperSuperClass.prototype.totalWidth = function () {
                return vp.dom.totalWidth(this.elem);
            };

            singleWrapperSuperClass.prototype.left = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.left(this.elem);
                }

                vp.dom.left(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.top = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.top(this.elem);
                }

                vp.dom.top(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.checked = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.checked(this.elem);
                }

                vp.dom.checked(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.clear = function () {
                vp.dom.clear(this.elem);
                return this;
            };

            singleWrapperSuperClass.prototype.add = function (content) {
                var elems = vp.dom.add(this.elem, content);
                var ss = vp.dom.wrapElements(elems);

                return ss;
            };

            singleWrapperSuperClass.prototype.append = function (content) {
                var ss = vp.dom.append(this.elem, content);
                return ss;
            };

            singleWrapperSuperClass.prototype.prepend = function (content) {
                var ss = vp.dom.prepend(this.elem, content);
                return ss;
            };

            singleWrapperSuperClass.prototype.insertBefore = function (content) {
                var ss = vp.dom.insertBefore(this.elem, content);
                return ss;
            };

            singleWrapperSuperClass.prototype.insertAfter = function (content) {
                var ss = vp.dom.insertAfter(this.elem, content);
                return ss;
            };

            singleWrapperSuperClass.prototype.addStop = function (offset, color, opacity) {
                vp.dom.addStop(this.elem, offset, color, opacity);
                return this;
            };

            singleWrapperSuperClass.prototype.textBaseline = function (alignType, rc) {
                vp.dom.textBaseline(this.elem, alignType, rc);
                return this;
            };

            singleWrapperSuperClass.prototype.animate = function (duration, ease, container) {
                vp.dom.animate(this.elem, duration, ease, container);
                return this;
            };

            singleWrapperSuperClass.prototype.onAnimationComplete = function (callback) {
                vp.dom.onAnimationComplete(this.elem, callback);
                return this;
            };

            singleWrapperSuperClass.prototype.frameRateChanged = function (callBack) {
                vp.dom.frameRateChanged(this.elem, callBack);
                return this;
            };

            /// creates a new selectedSet from the current this.elem and the specified element/array.
            singleWrapperSuperClass.prototype.merge = function (elemOrArray) {
                var newElements = null;

                if (elemOrArray instanceof vp.dom.selectedSet) {
                    elemOrArray = elemOrArray.toArray();
                } else if (elemOrArray instanceof vp.dom.singleWrapperSuperClass) {
                    elemOrArray = elemOrArray.elem;
                }

                if (vp.utils.isArray(elemOrArray)) {
                    newElements = this.toArray().concat(elemOrArray);
                } else {
                    newElements = this.toArray();
                    newElements.push(elemOrArray);
                }

                var newSet = new vp.dom.selectedSet(newElements);

                return newSet;
            };

            singleWrapperSuperClass.prototype.toArray = function () {
                return [this.elem];
            };

            singleWrapperSuperClass.prototype.wrap = function (index) {
                var we = null;

                if (index == 0) {
                    we = vp.dom.wrapElements(this.elem);
                }

                return we;
            };

            singleWrapperSuperClass.prototype.kids = function () {
                var kids = vp.dom.children(this.elem);
                var wrappedKids = vp.dom.wrapElements(kids);

                return wrappedKids;
            };

            singleWrapperSuperClass.prototype.each = function (callback) {
                //---- pass our element to callback as wrapped ("this") ----
                callback.call(this, 0, this);
                return this;
            };

            singleWrapperSuperClass.prototype.elementSizes = function () {
                return vp.dom.elementSizes(this.elem);
            };

            singleWrapperSuperClass.prototype.focus = function () {
                vp.dom.focus(this.elem);
                return this;
            };

            singleWrapperSuperClass.prototype.background = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.background(this.elem);
                }

                vp.dom.background(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.dataId = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.dataId(this.elem);
                }

                vp.dom.dataId(this.elem, value);
                return this;
            };

            singleWrapperSuperClass.prototype.shapeId = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.shapeId(this.elem);
                }

                vp.dom.shapeId(this.elem, value);
                return this;
            };
            return singleWrapperSuperClass;
        })();
        dom.singleWrapperSuperClass = singleWrapperSuperClass;

        /** class that wraps a single element (HTML, SVG, Canvas, or WebGL item). */
        var singleWrapperClass = (function (_super) {
            __extends(singleWrapperClass, _super);
            function singleWrapperClass() {
                _super.apply(this, arguments);
                this.ctr = "vp.singleWrapper";
            }
            return singleWrapperClass;
        })(singleWrapperSuperClass);
        dom.singleWrapperClass = singleWrapperClass;

        function createSingleWrapper(elem) {
            return new singleWrapperClass(elem);
        }
        dom.createSingleWrapper = createSingleWrapper;
    })(vp.dom || (vp.dom = {}));
    var dom = vp.dom;
})(vp || (vp = {}));
//# sourceMappingURL=$singleWrapper.js.map

///----------------------------------------------------------------
/// (from _dom\basicSelect.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// basicSelect.ts.  Copyright (c) 2014 Microsoft Corporation.
///              part of the vuePlot library - selectand related support.
///              Note: this file must be processed first in its folder.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (dom) {
        /// internal.
        /// elements: the list of collected elements to add matches to.
        function getElementsCore(elements, parentElem, byId, byClass, byTag, byColon, name) {
            //vp.utils.debug("getElementsCore: parentElem=" + parentElem + ", parentElem.tagName=" + parentElem.tagName);
            if ((parentElem.id == "canvases") || (parentElem.id == "2dRect")) {
                var dummy2 = 0;
            }

            var kids = vp.dom.children(parentElem);
            if ((kids) && (kids.length > 0)) {
                for (var i = 0; i < kids.length; i++) {
                    var elem = kids[i];

                    if (elem.tagName == "svg") {
                        var a = 9;
                    }

                    if (byId) {
                        if (elem.id == name) {
                            elements.push(elem);
                        }
                    } else if (byTag) {
                        if ((elem.tagName) && (elem.tagName.toLowerCase() == name)) {
                            elements.push(elem);
                        }
                    } else if (byColon) {
                        if (colonTest(elem, name)) {
                            elements.push(elem);
                        }
                    } else if (byClass) {
                        if (vp.dom.hasClass(elem, name)) {
                            elements.push(elem);
                        }
                    } else {
                        //---- must be "*" (include everything) ----
                        elements.push(elem);
                    }

                    var grandKids = vp.dom.children(elem);
                    if ((grandKids) && (grandKids.length > 0)) {
                        //---- search the children of "elem" and add the matches to "elements" ----
                        getElementsCore(elements, elem, byId, byClass, byTag, byColon, name);
                    }
                }
            }
        }

        /// internal: return true if element meets condition of specified colon filter
        function colonTest(elem, name) {
            var meets = false;

            /// for perf reasons, we don't call out to utility functions to check for values; that
            /// cross-browser code is duplicated here.
            if (elem != null) {
                if (name == "checked") {
                    meets = elem.checked;
                } else if (name == "hidden") {
                    meets = (elem.visibility == "hidden");
                } else if (name == "visible") {
                    meets = (elem.visibility != "hidden");
                } else if (name == "selected") {
                    meets = (elem.selected === true);
                } else if (name == "checked") {
                    meets = (elem.checked === true);
                } else if (name == "disabled") {
                    meets = (elem.disabled);
                } else if (name == "enabled") {
                    meets = (elem.disabled === undefined);
                } else if (name == "input") {
                    meets = (elem.tagName.toLowerCase() == "input");
                } else if (name == "radio") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "radio"));
                } else if (name == "button") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "button"));
                } else if (name == "checkbox") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "checkbox"));
                } else if (name == "button") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "button"));
                } else if (name == "password") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "password"));
                } else if (name == "text") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "text"));
                } else if (name == "submit") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "submit"));
                }
            }
            return meets;
        }

        function getElementsInSelectorString(parentElem, selector) {
            var ss = selector.trim();
            var elements = [];
            var byId = false;
            var byTag = false;
            var byClass = false;
            var byColon = false;

            var name = "";

            if (parentElem == null) {
                parentElem = document;
            } else if (parentElem.length) {
                parentElem = parentElem[0]; // unwrap parent, if needed
            }

            //---- keep it very simple for now ----
            if (ss.startsWith("#")) {
                byId = true;
                name = ss.substring(1).ltrim();
            } else if (ss.startsWith(".")) {
                byClass = true;
                name = ss.substring(1).ltrim();
            } else if (ss.startsWith(":")) {
                byColon = true;
                name = ss.substring(1).ltrim();
            } else if (ss != "*") {
                byTag = true;
                name = ss.toLowerCase();
            }

            getElementsCore(elements, parentElem, byId, byClass, byTag, byColon, name);

            return elements;
        }
        dom.getElementsInSelectorString = getElementsInSelectorString;

        function wrapElements(elemOrArray) {
            var ss = null;

            if (vp.utils.isArray(elemOrArray)) {
                if (elemOrArray.length == 1) {
                    ss = vp.dom.createSingleWrapper(elemOrArray[0]);
                } else {
                    ss = new vp.dom.selectedSet(elemOrArray);
                }
            } else if (elemOrArray) {
                ss = vp.dom.createSingleWrapper(elemOrArray);
            }

            return ss;
        }
        dom.wrapElements = wrapElements;

        /// upwrap(elem): return unwrapped version of elem (can be wrapper or unwrapped element)
        function unwrap(elem) {
            if (elem.length) {
                elem = elem[0];
            }

            return elem;
        }
        dom.unwrap = unwrap;
    })(vp.dom || (vp.dom = {}));
    var dom = vp.dom;
})(vp || (vp = {}));

var vp;
(function (vp) {
    function select(p1, p2) {
        var parentElem = null;
        var selector = null;

        if (p2) {
            //---- selection string specified ----
            parentElem = p1;
            selector = p2;
        } else if (vp.utils.isString(p1)) {
            //---- only p1=string specified ----
            parentElem = document.body;
            selector = p1;
        } else {
            //---- only p1=NON-string specified ----
            parentElem = p1;
            selector = null;
        }

        //return new vp.dom.selectedSet(rootElement, selectStr);
        if (vp.utils.isString(selector)) {
            var elems = vp.dom.getElementsInSelectorString(parentElem, selector);
            return vp.dom.wrapElements(elems);
        } else if (vp.utils.isArray(parentElem)) {
            return vp.dom.wrapElements(parentElem);
        } else if (parentElem != null) {
            return vp.dom.wrapElements(parentElem);
        } else {
            return new vp.dom.selectedSet();
        }
    }
    vp.select = select;
})(vp || (vp = {}));
//# sourceMappingURL=basicSelect.js.map

///----------------------------------------------------------------
/// (from _dom\canvasSelectedSet.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// canvasSelectedSet.ts.  Copyright (c) 2014 Microsoft Corporation.
///     Part of the vuePlotCore library - holds a set of canvas items that actions can be executed against.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (canvas) {
        //---- class: canvasSelectedSet ----
        var canvasSelectedSet = (function (_super) {
            __extends(canvasSelectedSet, _super);
            //---- "fnCanvas" functions live here ----
            function canvasSelectedSet(parentElem, selector) {
                _super.call(this);

                this.ctr = "vp.canvas.canvasSelectedSet";
                this.parentElem = parentElem;
                this.selector = selector;

                if (vp.utils.isString(selector)) {
                    var elems = vp.dom.getElementsInSelectorString(parentElem, selector);

                    for (var i = 0; i < elems.length; i++) {
                        this.push(elems[i]);
                    }
                } else if (vp.utils.isArray(selector)) {
                    for (var i = 0; i < selector.length; i++) {
                        this.push(selector[i]);
                    }
                } else if (selector != null) {
                    //---- assume it is a single element ----
                    this.push(selector);
                }
            }
            /// adds the specified element/array to the selected set.
            canvasSelectedSet.prototype.merge = function (elemOrArray) {
                var newElements = null;

                if (elemOrArray instanceof vp.canvas.canvasSelectedSet) {
                    elemOrArray = elemOrArray.toArray();
                }

                if (vp.utils.isArray(elemOrArray)) {
                    newElements = this.toArray().concat(elemOrArray);
                } else {
                    var aray = this.toArray();
                    aray.push(elemOrArray);
                    newElements = aray;
                }

                var newSet = new vp.canvas.canvasSelectedSet(this.parentElem, newElements);

                return newSet;
            };

            /// rapidly creates and appends the specified "str" canvas element for the specified "count".
            canvasSelectedSet.prototype.multiAppend = function (str, count) {
                var appendedElements = [];

                if (this.length > 0) {
                    //---- for now, only support first container ----//
                    var container = this[0];

                    for (var i = 0; i < count; i++) {
                        var elem = container.append(str);
                        appendedElements.push(elem);
                    }
                }

                return appendedElements;
            };

            canvasSelectedSet.prototype.updateBounds = function (w, h) {
                return this.each(function (index, container) {
                    this.updateBounds(w, h);
                });
            };

            canvasSelectedSet.prototype.initShaderAnimations = function (duration, onCompleteCallback) {
                return this.each(function (index, container) {
                    this.initShaderAnimations(duration, onCompleteCallback);
                });
            };

            canvasSelectedSet.prototype.resetShaderAnimations = function () {
                return this.each(function (index, container) {
                    this.resetShaderAnimations();
                });
            };

            canvasSelectedSet.prototype.pointSize = function (value) {
                if (arguments.length == 0) {
                    value = (this.length > 0) ? this[0].pointSize() : undefined;
                    return value;
                }

                return this.each(function (index, container) {
                    this.pointSize(value);
                });
            };

            canvasSelectedSet.prototype.usePointSprites = function (value) {
                if (arguments.length == 0) {
                    value = (this.length > 0) ? this[0].usePointSprites() : undefined;
                    return value;
                }

                return this.each(function (index, container) {
                    this.usePointSprites(value);
                });
            };

            canvasSelectedSet.prototype.usePointSize = function (value) {
                if (arguments.length == 0) {
                    value = (this.length > 0) ? this[0].usePointSize() : undefined;
                    return value;
                }

                return this.each(function (index, container) {
                    this.usePointSize(value);
                });
            };

            canvasSelectedSet.prototype.markRebuildNeeded = function () {
                return this.each(function (index, container) {
                    this.markRebuildNeeded();
                });
            };

            canvasSelectedSet.prototype.append = function (content) {
                var appendedElements = [];
                var firstContainer = null;

                this.each(function (index, container) {
                    if (firstContainer == null) {
                        firstContainer = container;
                    }

                    if (content instanceof vp.dom.selectedSet) {
                        content = content.toArray();
                    } else if (content instanceof vp.dom.singleWrapperSuperClass) {
                        content = content.elem;
                    }

                    if (vp.utils.isArray(content)) {
                        for (var i = 0; i < content.length; i++) {
                            var child = content[i];
                            var element = container.appendChild(child);
                            appendedElements.push(element);
                        }
                    } else if (vp.utils.isString(content)) {
                        var canvasElement = this.append(content);
                        if (canvasElement != null) {
                            //---- transfer data info from parent container ----
                            canvasElement.dataItem = container.dataItem;
                            canvasElement.dataIndex = container.dataIndex;

                            appendedElements.push(canvasElement);
                        }
                    } else if (content != null) {
                        container.appendChild(content);
                        appendedElements.push(content);
                    }
                });

                var ss = null;

                if (firstContainer != null) {
                    ss = new vp.canvas.canvasSelectedSet(firstContainer, appendedElements);
                }

                return ss;
            };

            canvasSelectedSet.prototype.attr = function (name, origValue) {
                return this.each(function (index, element) {
                    var value = origValue;

                    if (typeof origValue === "function") {
                        value = origValue(element.dataItem, element.dataIndex);
                    }

                    if (vp.utils.isUndefined(this.animation)) {
                        //---- no animation is active - just set in instantly ----
                        //this[name] = value;
                        //this.markRebuildNeeded();
                        this.setAttribute(name, value);
                    } else {
                        //---- add to current animation ----
                        this.animation.animateAttr(element, name, value);
                    }
                });
            };
            return canvasSelectedSet;
        })(vp.dom.selectedSet);
        canvas.canvasSelectedSet = canvasSelectedSet;

        function canvasSelect(selectStr) {
            return new vp.canvas.canvasSelectedSet(document.body, selectStr);
        }
        canvas.canvasSelect = canvasSelect;

        function selectContext(selectObj, contextName) {
            var ssCanvas = vp.canvas.canvasSelect();
            var elems = null;

            if (vp.utils.isString(selectObj)) {
                elems = vp.dom.getElementsInSelectorString(document.body, selectObj);
            } else {
                elems = [selectObj]; // assume it is a canvas element
            }

            var ss = new vp.dom.selectedSet(elems);

            if (ss.length > 0) {
                var cc = ss.context(contextName);
                if (cc != null) {
                    ssCanvas = ssCanvas.merge(cc);
                }
            }

            return ssCanvas;
        }
        canvas.selectContext = selectContext;
    })(vp.canvas || (vp.canvas = {}));
    var canvas = vp.canvas;
})(vp || (vp = {}));
//# sourceMappingURL=canvasSelectedSet.js.map

///----------------------------------------------------------------
/// (from _dom\canvasUtils.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// canvasUtils.ts.  Copyright (c) 2014 Microsoft Corporation.
///                part of the vuePlotCore library - misc utility functions for canvas.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (internal) {
        var parsePathDataAndGenerateDrawFunc = (function () {
            function parsePathDataAndGenerateDrawFunc(dstr) {
                this.index = 0;
                this.firstPt = { x: 0, y: 0 };
                this.lastPt = { x: 0, y: 0 };
                this.firstPointSeen = false;
                this.minX = Number.MAX_VALUE;
                this.minY = Number.MAX_VALUE;
                this.maxX = -Number.MAX_VALUE;
                this.maxY = -Number.MAX_VALUE;
                this.d = dstr;
            }
            parsePathDataAndGenerateDrawFunc.prototype.parse = function () {
                var funcStr = "function (ctx)\r\n" + "{\r\n";

                var cmd = "";

                /// sample: d="M 100 100 L 300 100 L 200 300 z"
                /// uppercase cmd letter: absolute coordinates, lowercase: relative coordinates
                ///
                /// M=move, L=line, Z=close, H=horizontal line, V=vertical line, C=cubic bezier, S=reflective cubic bezier
                /// Q=quadratic bezier, T=reflective quadratic, A=arc
                var lastIndex = -1;
                var d = this.d;

                while (this.index < d.length) {
                    this.skipSpaces(d);

                    if (this.index == lastIndex) {
                        vp.utils.error("Error: internal error in parsePathDataAndGenerateDrawFunc()");
                    }

                    if (this.index >= d.length) {
                        break;
                    }

                    lastIndex = this.index;

                    var ch = d[this.index];
                    var isLower = ((ch >= "a") && (ch <= "z"));
                    var isUpper = ((ch >= "A") && (ch <= "Z"));

                    if ((isLower) || (isUpper)) {
                        //---- new cmd specified ----
                        cmd = ch;
                        this.index++;

                        this.skipSpaces(d);
                        //---- process this cmd even if no params avail ----
                        //if (this.index >= d.length)
                        //{
                        //    break;
                        //}
                    } else {
                        vp.utils.error("Error: unrecognized token in path: " + ch);
                    }

                    //---- process current command ----
                    if ((cmd == "M") || (cmd == "m")) {
                        this.firstPointSeen = false; // get ready for a new first point

                        var pt = this.parsePoint(d, cmd == "m");

                        funcStr += "    ctx.moveTo(" + pt.x + ", " + pt.y + ");\r\n";
                    } else if ((cmd == "L") || (cmd == "l")) {
                        var pt = this.parsePoint(d, cmd == "l");

                        funcStr += "    ctx.lineTo(" + pt.x + ", " + pt.y + ");\r\n";
                    } else if (cmd == "X") {
                        var cx = this.parseNumber(d);
                        var cy = this.parseNumber(d);
                        var r = this.parseNumber(d);
                        var startAngle = this.parseNumber(d);
                        var endAngle = this.parseNumber(d);
                        var antiClock = this.parseNumber(d);

                        funcStr += "    ctx.arc(" + cx + ", " + cy + "," + r + "," + startAngle + "," + endAngle + "," + antiClock + ");\r\n";
                    } else if ((cmd == "A") || (cmd == "a")) {
                        vp.utils.error("Error - 'A' (arc) command in path not currently supported by VuePlot");
                        //---- not supported (code below is incomplete ----
                        //var rx = parseNumber(d);
                        //var ry = parseNumber(d);
                        //var xRotate = parseNumber(d);
                        //var largeArc = parseNumber(d);
                        //var sweepFlag = parseNumber(d);
                        //var ptEnd = parsePoint(d, cmd == "a");
                        //var ptCenter = xx;
                        //var radius = rx;
                        //var startAngle = xx;
                        //var endAngle = yy;
                        //funcStr += "    ctx.arc(" + ptCenter.x + ", " + ptCenter.y + "," + radius + "," +
                        //    startAngle + "," + endAngle + "," + sweepFlag + ");\r\n";
                    } else if ((cmd == "Z") || (cmd == "z")) {
                        //if (this.firstPointSeen)
                        //{
                        //    //---- close path with straight line to first point ----
                        //    funcStr += "ctx.lineTo(" + this.firstPt.x + ", " + this.firstPt.y + ");\r\n";
                        //}
                        funcStr += "ctx.closePath();\r\n";
                    } else {
                        vp.utils.error("Error: unrecognized cmd in path: " + cmd);
                    }
                }

                funcStr += "}\r\n";
                var bb = vp.geom.rect(this.minX, this.minY, this.maxX - this.minX, this.maxY - this.minY);

                return [funcStr, bb];
            };

            parsePathDataAndGenerateDrawFunc.prototype.skipSpaces = function (d) {
                while (this.index < this.d.length) {
                    var ch = this.d[this.index];

                    if ((ch == ' ') || (ch == "\t") || (ch == "\r") || (ch == '\n') || (ch == ",")) {
                        this.index++;
                    } else {
                        break;
                    }
                }
            };

            parsePathDataAndGenerateDrawFunc.prototype.parseNumber = function (d) {
                this.skipSpaces(d);
                var isNegative = false;
                var value = 0;
                var d = this.d;

                if (this.index < d.length) {
                    var ch = d[this.index];
                    if (ch == "+") {
                        this.index++;
                    } else if (ch == '-') {
                        this.index++;
                        isNegative = true;
                    }

                    var start = this.index;

                    while (this.index < d.length) {
                        var ch = d[this.index];

                        if ((ch == '.') || ((ch >= '0') && (ch <= '9'))) {
                            this.index++;
                        } else {
                            break;
                        }
                    }

                    var str = d.substr(start, this.index - start);
                    value = parseFloat(str);
                }

                if (isNegative) {
                    value = -value;
                }

                this.index = this.index;

                return value;
            };

            parsePathDataAndGenerateDrawFunc.prototype.parsePoint = function (d, isRelative) {
                /// <number> [ "," ] <number>    (skip spaces in-between each element)
                var x = this.parseNumber(d);
                var y = this.parseNumber(d);

                if (isRelative) {
                    x += this.lastPt.x;
                    y += this.lastPt.y;
                }

                var pt = { x: x, y: y };

                this.onPointSeen(pt);

                return pt;
            };

            parsePathDataAndGenerateDrawFunc.prototype.onPointSeen = function (pt) {
                if (!this.firstPointSeen) {
                    this.firstPt = pt;
                    this.firstPointSeen = true;
                }

                this.lastPt = pt;

                this.minX = Math.min(this.minX, pt.x);
                this.minY = Math.min(this.minY, pt.y);

                this.maxX = Math.max(this.maxX, pt.x);
                this.maxY = Math.max(this.maxY, pt.y);
            };
            return parsePathDataAndGenerateDrawFunc;
        })();
        internal.parsePathDataAndGenerateDrawFunc = parsePathDataAndGenerateDrawFunc;
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));
//# sourceMappingURL=canvasUtils.js.map

///----------------------------------------------------------------
/// (from _dom\colors.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// colors.ts.  Copyright (c) 2014 Microsoft Corporation.
///             part of the vuePlot library - color helper and related functions.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (color) {
        color.colors = {};

        color.colors.aliceblue = [240, 248, 255];
        color.colors.antiquewhite = [250, 235, 215];
        color.colors.aqua = [0, 255, 255];
        color.colors.aquamarine = [127, 255, 212];
        color.colors.azure = [240, 255, 255];
        color.colors.beige = [245, 245, 220];
        color.colors.bisque = [255, 228, 196];
        color.colors.black = [0, 0, 0];
        color.colors.blanchedalmond = [255, 235, 205];
        color.colors.blue = [0, 0, 255];
        color.colors.blueviolet = [138, 43, 226];
        color.colors.brown = [165, 42, 42];
        color.colors.burlywood = [222, 184, 135];
        color.colors.cadetblue = [95, 158, 160];
        color.colors.chartreuse = [127, 255, 0];
        color.colors.chocolate = [210, 105, 30];
        color.colors.coral = [255, 127, 80];
        color.colors.cornflowerblue = [100, 149, 237];
        color.colors.cornsilk = [255, 248, 220];
        color.colors.crimson = [220, 20, 60];
        color.colors.cyan = [0, 255, 255];
        color.colors.darkblue = [0, 0, 139];
        color.colors.darkcyan = [0, 139, 139];
        color.colors.darkgoldenrod = [184, 134, 11];
        color.colors.darkgray = [169, 169, 169];
        color.colors.darkgreen = [0, 100, 0];
        color.colors.darkkhaki = [189, 183, 107];
        color.colors.darkmagenta = [139, 0, 139];
        color.colors.darkolivegreen = [85, 107, 47];
        color.colors.darkorange = [255, 140, 0];
        color.colors.darkorchid = [153, 50, 204];
        color.colors.darkred = [139, 0, 0];
        color.colors.darksalmon = [233, 150, 122];
        color.colors.darkseagreen = [143, 188, 143];
        color.colors.darkslateblue = [72, 61, 139];
        color.colors.darkslategray = [47, 79, 79];
        color.colors.darkturquoise = [0, 206, 209];
        color.colors.darkviolet = [148, 0, 211];
        color.colors.deeppink = [255, 20, 147];
        color.colors.deepskyblue = [0, 191, 255];
        color.colors.dimgray = [105, 105, 105];
        color.colors.dodgerblue = [30, 144, 255];
        color.colors.firebrick = [178, 34, 34];
        color.colors.floralwhite = [255, 250, 240];
        color.colors.forestgreen = [34, 139, 34];
        color.colors.fuchsia = [255, 0, 255];
        color.colors.gainsboro = [220, 220, 220];
        color.colors.ghostwhite = [248, 248, 255];
        color.colors.gold = [255, 215, 0];
        color.colors.goldenrod = [218, 165, 32];
        color.colors.gray = [128, 128, 128];
        color.colors.green = [0, 128, 0];
        color.colors.greenyellow = [173, 255, 47];
        color.colors.honeydew = [240, 255, 240];
        color.colors.hotpink = [255, 105, 180];
        color.colors.indianred = [205, 92, 92];
        color.colors.indigo = [75, 0, 130];
        color.colors.ivory = [255, 255, 240];
        color.colors.khaki = [240, 230, 140];
        color.colors.lavender = [230, 230, 250];
        color.colors.lavenderblush = [255, 240, 245];
        color.colors.lawngreen = [124, 252, 0];
        color.colors.lemonchiffon = [255, 250, 205];
        color.colors.lightblue = [173, 216, 230];
        color.colors.lightcoral = [240, 128, 128];
        color.colors.lightcyan = [224, 255, 255];
        color.colors.lightgoldenrodyellow = [250, 250, 210];
        color.colors.lightgray = [211, 211, 211];
        color.colors.lightgreen = [144, 238, 144];
        color.colors.lightpink = [255, 182, 193];
        color.colors.lightsalmon = [255, 160, 122];
        color.colors.lightseagreen = [32, 178, 170];
        color.colors.lightskyblue = [135, 206, 250];
        color.colors.lightslategray = [119, 136, 153];
        color.colors.lightsteelblue = [176, 196, 222];
        color.colors.lightyellow = [255, 255, 224];
        color.colors.lime = [0, 255, 0];
        color.colors.limegreen = [50, 205, 50];
        color.colors.linen = [250, 240, 230];
        color.colors.magenta = [255, 0, 255];
        color.colors.maroon = [128, 0, 0];
        color.colors.mediumaquamarine = [102, 205, 170];
        color.colors.mediumblue = [0, 0, 205];
        color.colors.mediumorchid = [186, 85, 211];
        color.colors.mediumpurple = [147, 112, 219];
        color.colors.mediumseagreen = [60, 179, 113];
        color.colors.mediumslateblue = [123, 104, 238];
        color.colors.mediumspringgreen = [0, 250, 154];
        color.colors.mediumturquoise = [72, 209, 204];
        color.colors.mediumvioletred = [199, 21, 133];
        color.colors.midnightblue = [25, 25, 112];
        color.colors.mintcream = [245, 255, 250];
        color.colors.mistyrose = [255, 228, 225];
        color.colors.moccasin = [255, 228, 181];
        color.colors.navajowhite = [255, 222, 173];
        color.colors.navy = [0, 0, 128];
        color.colors.oldlace = [253, 245, 230];
        color.colors.olive = [128, 128, 0];
        color.colors.olivedrab = [107, 142, 35];
        color.colors.orange = [255, 165, 0];
        color.colors.orangered = [255, 69, 0];
        color.colors.orchid = [218, 112, 214];
        color.colors.palegoldenrod = [238, 232, 170];
        color.colors.palegreen = [152, 251, 152];
        color.colors.paleturquoise = [175, 238, 238];
        color.colors.palevioletred = [219, 112, 147];
        color.colors.papayawhip = [255, 239, 213];
        color.colors.peachpuff = [255, 218, 185];
        color.colors.peru = [205, 133, 63];
        color.colors.pink = [255, 192, 203];
        color.colors.plum = [221, 160, 221];
        color.colors.powderblue = [176, 224, 230];
        color.colors.purple = [128, 0, 128];
        color.colors.red = [255, 0, 0];
        color.colors.rosybrown = [188, 143, 143];
        color.colors.royalblue = [65, 105, 225];
        color.colors.saddlebrown = [139, 69, 19];
        color.colors.salmon = [250, 128, 114];
        color.colors.sandybrown = [244, 164, 96];
        color.colors.seagreen = [46, 139, 87];
        color.colors.seashell = [255, 245, 238];
        color.colors.sienna = [160, 82, 45];
        color.colors.silver = [192, 192, 192];
        color.colors.skyblue = [135, 206, 235];
        color.colors.slateblue = [106, 90, 205];
        color.colors.slategray = [112, 128, 144];
        color.colors.snow = [255, 250, 250];
        color.colors.springgreen = [0, 255, 127];
        color.colors.steelblue = [70, 130, 180];
        color.colors.tan = [210, 180, 140];
        color.colors.teal = [0, 128, 128];
        color.colors.thistle = [216, 191, 216];
        color.colors.tomato = [255, 99, 71];
        color.colors.transparent = [255, 255, 255];
        color.colors.turquoise = [64, 224, 208];
        color.colors.violet = [238, 130, 238];
        color.colors.wheat = [245, 222, 179];
        color.colors.white = [255, 255, 255];
        color.colors.whitesmoke = [245, 245, 245];
        color.colors.yellow = [255, 255, 0];
        color.colors.yellowgreen = [154, 205, 50];

        ///--------------------------------------------------------
        /// parse 1 of 147 predefined SVG color names
        /// and return its value as a 3 element number array.
        ///--------------------------------------------------------
        function getColorFromName(name) {
            var value = color.colors[name.toLowerCase()];
            if (vp.utils.isUndefined(value)) {
                //value = colors.black;
            }

            return value;
        }
        color.getColorFromName = getColorFromName;

        function getRandomColor() {
            var keys = vp.utils.keys(color.colors);
            var index = Math.round(Math.random() * keys.length - 1);
            var colorName = keys[index];

            return color.colors[colorName];
        }
        color.getRandomColor = getRandomColor;

        ///--------------------------------------------------------
        /// parse 3 or 6 char hex string without leading "#"
        /// and return its value as a 3 element number array.
        ///--------------------------------------------------------
        function getColorFromHexString(str) {
            var value = color.colors.black;

            if (str.length == 3) {
                var redStr = str[0] + str[0];
                var r = parseInt(redStr, 16);

                var greenStr = str[1] + str[1];
                var g = parseInt(greenStr, 16);

                var blueStr = str[2] + str[2];
                var b = parseInt(blueStr, 16);

                value = [r, g, b];
            } else if (str.length == 6) {
                var redStr = str[0] + str[1];
                var r = parseInt(redStr, 16);

                var greenStr = str[2] + str[3];
                var g = parseInt(greenStr, 16);

                var blueStr = str[4] + str[5];
                var b = parseInt(blueStr, 16);

                value = [r, g, b];
            }

            return value;
        }
        color.getColorFromHexString = getColorFromHexString;

        function parseRGBPart(part) {
            var value = 0;

            part = part.trim();
            if (part.endsWith("%")) {
                //---- remove the "%" ----
                part = part.substring(0, part.length - 1).trim();
                var percent = parseFloat(part);
                value = Math.max(0, Math.min(255, Math.round(255 * percent)));
            } else {
                value = parseInt(part);
            }

            return value;
        }

        ///--------------------------------------------------------
        /// parse a comma separate rgb string (should be: xx, xx, xx)
        /// and return its value as a 3 element number array.  Each "xx"
        /// is either an integer number or a float followed by a "%" char.
        ///--------------------------------------------------------
        function getColorFromRgbString(str) {
            var value = color.colors.black;

            var parts = str.split(',');
            if (parts.length == 3) {
                var r = parseRGBPart(parts[0]);
                var g = parseRGBPart(parts[1]);
                var b = parseRGBPart(parts[2]);

                value = [r, g, b];
            } else if (parts.length == 4) {
                var r = parseRGBPart(parts[0]);
                var g = parseRGBPart(parts[1]);
                var b = parseRGBPart(parts[2]);
                var a = parseRGBPart(parts[3]);

                value = [r, g, b]; // for now, don't return the "a"
            }

            return value;
        }
        color.getColorFromRgbString = getColorFromRgbString;

        /// converts an array of 3 RGB numbers (0-255) into a valid HTML/SVG color string.
        function toColor(r, g, b, a) {
            var str = null;

            if (vp.utils.isString(r)) {
                str = r; // already a color string
            } else {
                if (arguments.length == 1) {
                    var aray = r;

                    r = aray[0];
                    g = aray[1];
                    b = aray[2];

                    if (aray.length > 3) {
                        a = aray[3];
                    }
                }

                var red = vp.data.clamp(Math.round(r), 0, 255);
                var green = vp.data.clamp(Math.round(g), 0, 255);
                var blue = vp.data.clamp(Math.round(b), 0, 255);

                //if (true)       // for now, always use just 3 colors   // a === undefined)
                if (a === undefined) {
                    //---- caution: SVG (at least in IE9) does NOT accept spaces betweeen commas ----
                    str = ("rgb(" + red + "," + green + "," + blue + ")");
                } else {
                    var alpha = vp.data.clamp(Math.round(a), 0, 255);

                    str = ("rgba(" + red + "," + green + "," + blue + "," + alpha + ")");
                }
            }

            return str;
        }
        color.toColor = toColor;

        function getColorFromString(str) {
            var value = str;

            if (vp.utils.isString(str)) {
                str = str.trim();

                if (str.startsWith("#")) {
                    value = getColorFromHexString(str.substring(1));
                } else if (str.startsWith("rgb(")) {
                    value = getColorFromRgbString(str.substring(4, str.length - 1));
                } else if (str.startsWith("rgba(")) {
                    value = getColorFromRgbString(str.substring(5, str.length - 1));
                } else {
                    value = getColorFromName(str);
                }
            }

            return value;
        }
        color.getColorFromString = getColorFromString;

        /// public: interpolateColors(color1, color2, percent)
        /// interpolate between color1 and color2, using "percent".
        /// returns the interpolated value.
        function interpolateColors(color1, color2, percent) {
            if (!vp.utils.isArray(color1)) {
                color1 = getColorFromString(color1);
            }

            if (!vp.utils.isArray(color2)) {
                color2 = getColorFromString(color2);
            }

            var value = [];

            for (var i = 0; i < 3; i++) {
                var min = color1[i];
                var max = color2[i];

                value[i] = min + percent * (max - min);
            }

            return value;
        }
        color.interpolateColors = interpolateColors;

        function isValidColor(value) {
            var isValid = false;

            if (vp.utils.isNumber(value)) {
                isValid = true;
            } else if (vp.utils.isString(value)) {
                var parts = getColorFromString(value);
                isValid = (parts !== undefined);
            }

            return isValid;
        }
        color.isValidColor = isValidColor;

        function colorFromPalette(palette, index) {
            index = (index % palette.length); // recycle entires to fulfill request
            var cr = palette[index];

            if (!vp.utils.isString(cr)) {
                cr = toColor(cr);
            }

            return cr;
        }
        color.colorFromPalette = colorFromPalette;
    })(vp.color || (vp.color = {}));
    var color = vp.color;
})(vp || (vp = {}));
//# sourceMappingURL=colors.js.map

///----------------------------------------------------------------
/// (from _dom\dom.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// dom.ts.  Copyright (c) 2014 Microsoft Corporation.
///            part of the vuePlot library - getters and setters for element attributes and CSS properties.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (dom) {
        /// get/set the "left" css propperty (relative to its parent).  this supports HTML elements,
        /// including the SVG and Canvas documents.
        /// SVG and Canvas children should use the "x" and "cx" attributes.
        function left(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                //---- try SVG first (since elem.offsetLeft returns "0" on Chrome for SVG elements) ----
                if (elem.getBBox) {
                    //---- SVG element ----
                    var rc = elem.getBBox();
                    value = rc.x;
                } else {
                    //---- try modern HTML ----
                    value = elem.offsetLeft;

                    if (value === undefined) {
                        if (elem.getOffset) {
                            //---- canvas element ----
                            value = elem.getOffset().x;
                        }
                    }
                }

                return value;
            } else {
                //---- SET value ----
                if (vp.utils.isNumber(value)) {
                    //---- ensure number without units get interpreted as pixels ----
                    value = value + "px";
                }

                if (vp.utils.isUndefined(elem.animation)) {
                    //---- no animation is active - just set in instantly ----
                    elem.style.left = value;
                } else {
                    //---- add to current animation object ----
                    elem.animation.animateAttr(elem, "left", value, undefined, undefined, undefined, true);
                }
            }
        }
        dom.left = left;

        /// get/set the "top" css propperty (relative to its parent).  this supports HTML elements,
        /// including the SVG and Canvas documents.
        /// SVG and Canvas children should use the "x" and "cx" attributes.
        function top(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                //---- try SVG first (since elem.offsetLeft returns "0" on Chrome for SVG elements) ----
                if (elem.getBBox) {
                    //---- SVG element ----
                    var rc = elem.getBBox();
                    value = rc.y;
                } else {
                    //---- ftry modern HTML ----
                    value = elem.offsetTop;

                    if (value === undefined) {
                        if (elem.getOffset) {
                            //---- canvas element ----
                            value = elem.getOffset().y;
                        }
                    }
                }

                return value;
            } else {
                //---- SET value ----
                if (vp.utils.isNumber(value)) {
                    //---- ensure number without units get interpreted as pixels ----
                    value = value + "px";
                }

                if (vp.utils.isUndefined(elem.animation)) {
                    //---- no animation is active - just set it instantly ----
                    elem.style.top = value;
                } else {
                    //---- add to current animation object ----
                    elem.animation.animateAttr(elem, "top", value, undefined, undefined, undefined, true);
                }
            }
        }
        dom.top = top;

        /// public getBounds(elem) - return a RECT that represents the x, y, width, height relative
        /// to its parent.  Works for HTML, SVG, and CANVAS elements.
        function getBounds(elem, relToParent) {
            var rc = undefined;

            //---- checking "getBoundingClientRect" was working but now seems to have broken ----
            //---- switched to check getBBox first on 10/23/2012 - rfernand ----
            if (elem.getBBox) {
                var rcx = elem.getBBox();

                //---- convert to true rect ----
                var rc = vp.geom.rect(rcx.x, rcx.y, rcx.width, rcx.height);

                if ((!relToParent) && (elem.parentNode)) {
                    var rcp = getBounds(elem.parentNode, false);

                    rc = vp.geom.offsetRect(rc, rcp.left, rcp.top);
                }
            } else if (elem.getBoundingClientRect) {
                rc = elem.getBoundingClientRect();

                if ((relToParent) && (elem.parentNode)) {
                    var rcp = elem.parentNode.getBoundingClientRect();

                    rc = vp.geom.offsetRect(rc, -rcp.left, -rcp.top);
                }
            }

            return rc;
        }
        dom.getBounds = getBounds;

        function parentOffset(elem) {
            return { left: left(elem), top: top(elem) };
        }
        dom.parentOffset = parentOffset;

        /// return size of browser window.
        function windowSize() {
            return { width: window.innerWidth, height: window.innerHeight };
        }
        dom.windowSize = windowSize;

        /// return the actual width of the specified element.
        function getWidth(elem) {
            //---- get "width" value ----
            var width = 0;
            if (elem) {
                try  {
                    if ((elem == window) || (elem == document)) {
                        width = windowSize().width;
                    } else if (elem.rootContainer) {
                        //---- this is a vueplot canvasContainerElement ----
                        if (elem.rootContainer == elem) {
                            elem = elem.canvas;
                            width = elem.getBoundingClientRect().width;
                        } else {
                            //---- its a canvas 2d/3d lightweight element ----
                            width = elem.getWidth.call(elem);
                        }
                    } else if ((elem.tagName == "svg") && (vp.utils.isFireFox)) {
                        //---- SVG document on FireFox ----
                        if (elem.clientWidth) {
                            //---- svg document on Chrome needs this ----
                            width = elem.clientWidth;
                        }

                        if (width == 0) {
                            //---- sampleData.html needs this checked before checking elem.width.baseVal ----
                            if ((elem.style) && (elem.style.width !== undefined)) {
                                width = getCssNumber(elem.style.width, vp.dom.width(elem.parentNode));
                            }
                        }

                        if (width == 0) {
                            if ((elem.width) && (elem.width.baseVal)) {
                                width = getBaseVal(elem, "width", elem.width);
                            }
                        }
                    } else {
                        //---- give getBBox() priority since FireFox computes text height wrong using getBoundingClientRect ----
                        if (vp.utils.isFireFox && elem.getBBox) {
                            width = elem.getBBox().width;
                        } else if (vp.utils.isSvgDocOrElement(elem)) {
                            //---- SVG document not on FireFox ----
                            if (elem.clientWidth) {
                                //---- svg document on Chrome needs this ----
                                width = elem.clientWidth;
                            } else if (!vp.utils.isFireFox && elem.getBBox) {
                                width = elem.getBBox().width;
                            } else {
                                try  {
                                    width = elem.getBoundingClientRect().width;
                                } catch (ex) {
                                }

                                //---- simplfy this ASAP ----
                                if (width == 0) {
                                    if ((elem.width) && (elem.width.baseVal)) {
                                        width = getBaseVal(elem, "width", elem.width);
                                    } else {
                                        //---- last resort ----
                                        width = parseFloat(window.getComputedStyle(elem).width);
                                    }
                                }

                                //---- should check this sooner? ----
                                if ((width == 0) || (isNaN(width))) {
                                    width = +elem.getAttribute("width");
                                }
                            }
                        } else {
                            //---- HTML element ----
                            width = elem.offsetWidth;
                        }
                    }
                } catch (ex) {
                }
            }

            return width;
        }
        dom.getWidth = getWidth;

        function totalWidth(elem) {
            var width = getWidth(elem);

            //---- add borders ----
            var cs = window.getComputedStyle(elem);
            var bs = parseFloat(cs["borderLeftWidth"]) + parseFloat(cs["borderRightWidth"]);

            width += bs;
            return width;
        }
        dom.totalWidth = totalWidth;

        function totalHeight(elem) {
            var height = getHeight(elem);

            //---- add borders ----
            var cs = window.getComputedStyle(elem);
            var bs = parseFloat(cs["borderTopWidth"]) + parseFloat(cs["borderBottomWidth"]);

            height += bs;
            return height;
        }
        dom.totalHeight = totalHeight;

        function elementSizes(elem) {
            //---- core width/height ----
            var width = getWidth(elem);
            var height = getHeight(elem);

            var cs = window.getComputedStyle(elem);

            //---- margins ----
            var marginWidth = parseFloat(cs["marginLeft"]) + parseFloat(cs["marginRight"]);
            var marginHeight = parseFloat(cs["marginTop"]) + parseFloat(cs["marginBottom"]);

            //---- borders ----
            var borderWidth = parseFloat(cs["borderLeftWidth"]) + parseFloat(cs["borderRightWidth"]);
            var borderHeight = parseFloat(cs["borderTopWidth"]) + parseFloat(cs["borderBottomWidth"]);

            //---- padding ----
            var paddingWidth = parseFloat(cs["paddingLeft"]) + parseFloat(cs["paddingRight"]);
            var paddingHeight = parseFloat(cs["paddingTop"]) + parseFloat(cs["paddingBottom"]);

            var sizes = {
                width: width, height: height,
                marginWidth: marginWidth, marginHeight: marginHeight,
                borderWidth: borderWidth, borderHeight: borderHeight,
                paddingWidth: paddingWidth, paddingHeight: paddingHeight
            };

            return sizes;
        }
        dom.elementSizes = elementSizes;

        function getBaseVal(elem, propName, prop) {
            var value = 0;

            try  {
                if ((prop) && (prop.baseVal)) {
                    var unitType = prop.baseVal.unitType;
                    if ((unitType == 1) || (unitType == 5)) {
                        value = prop.baseVal.value;
                    } else if (unitType == 2) {
                        //---- percentage (of parent) ----
                        if ((elem) && (elem.parentNode)) {
                            var pValue = 0;
                            var parent = elem.parentNode;

                            if (vp.utils.isSvgElement(parent)) {
                                pValue = attr(parent, propName);
                            } else if (vp.utils.isCanvasChild(parent)) {
                                pValue = attr(parent, propName);
                            } else {
                                pValue = css(parent, propName);
                            }

                            var factor = prop.baseVal.valueInSpecifiedUnits;

                            value = factor / 100 * pValue;
                        }
                    }
                }
            } catch (err) {
            }

            return value;
        }
        dom.getBaseVal = getBaseVal;

        /// return the actual height of the specified element.
        function getHeight(elem) {
            //--- get "height" value ----
            var height = 0;
            if (elem) {
                try  {
                    if ((elem == window) || (elem == document)) {
                        height = windowSize().height;
                    } else if (elem.rootContainer) {
                        //---- this is a vueplot canvasContainerElement ----
                        if (elem.rootContainer == elem) {
                            elem = elem.canvas;
                            height = elem.getBoundingClientRect().height;
                        } else {
                            //---- its a canvas 2d/3d lightweight element ----
                            height = elem.getHeight.call(elem);
                        }
                    } else if ((elem.tagName == "svg") && (vp.utils.isFireFox)) {
                        //---- SVG document on FireFox ----
                        if (elem.clientHeight) {
                            //---- svg document on Chrome needs this ----
                            height = elem.clientHeight;
                        }

                        if (height == 0) {
                            if ((elem.style) && (elem.style.height !== undefined)) {
                                height = getCssNumber(elem.style.height, vp.dom.height(elem.parentNode));
                            }
                        }

                        if (height == 0) {
                            if ((elem.height) && (elem.height.baseVal)) {
                                height = getBaseVal(elem, "height", elem.height);
                            }
                        }
                    } else {
                        //---- give getBBox() priority since FireFox computes text height wrong using getBoundingClientRect ----
                        if (vp.utils.isFireFox && elem.getBBox) {
                            height = elem.getBBox().height;
                        } else if (vp.utils.isSvgDocOrElement(elem)) {
                            //---- SVG document not on FireFox ----
                            if (elem.clientHeight) {
                                //---- svg document on Chrome needs this ----
                                height = elem.clientHeight;
                            } else if (!vp.utils.isFireFox && elem.getBBox) {
                                height = elem.getBBox().height;
                            } else {
                                try  {
                                    height = elem.getBoundingClientRect().height;
                                } catch (ex) {
                                }

                                //---- simplfy this ASAP ----
                                if (height == 0) {
                                    if ((elem.height) && (elem.height.baseVal)) {
                                        height = getBaseVal(elem, "height", elem.height);
                                    } else {
                                        //---- last resort ----
                                        height = parseFloat(window.getComputedStyle(elem).height);
                                    }
                                }

                                //---- should check this sooner? ----
                                if ((height == 0) || (isNaN(height))) {
                                    height = +elem.getAttribute("height");
                                }
                            }
                        } else {
                            //---- HTML element ----
                            height = elem.offsetHeight;
                        }
                    }
                } catch (ex) {
                }
            }

            return height;
        }
        dom.getHeight = getHeight;

        function setWidth(elem, value) {
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                var isSvg = vp.utils.isSvgDocOrElement(elem);
                if (isSvg || vp.utils.isCanvasChild(elem)) {
                    elem.setAttribute("width", value);

                    //---- .css does its own triggerResize() call, but setAttribute does NOT ----
                    vp.events.triggerResize(elem);
                } else {
                    if (vp.utils.isNumber(value)) {
                        value = value + "px"; // important to have units specified for HTML elements
                    }

                    css(elem, "width", value);
                }
            } else {
                //---- add to current animation object ----
                elem.animation.animateAttr(elem, "width", value, undefined, undefined, undefined, true);
            }
        }
        dom.setWidth = setWidth;

        function setHeight(elem, value) {
            //---- SET value ----
            if (vp.utils.isUndefined(elem.animation)) {
                 {
                    var isSvg = vp.utils.isSvgDocOrElement(elem);

                    if (isSvg || vp.utils.isCanvasChild(elem)) {
                        elem.setAttribute("height", value);

                        //---- .css does its own triggerResize() call, but setAttribute does NOT ----
                        vp.events.triggerResize(elem);
                    } else {
                        if (vp.utils.isNumber(value)) {
                            value = value + "px"; // important to have units specified for HTML elements
                        }

                        css(elem, "height", value);
                    }
                }
            } else {
                //---- add to current animation object ----
                elem.animation.animateAttr(elem, "height", value, undefined, undefined, undefined, true);
            }
        }
        dom.setHeight = setHeight;

        function width(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                return getWidth(elem);
            }

            setWidth(elem, value);
        }
        dom.width = width;

        function height(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                return getHeight(elem);
            }

            //---- SET value ----
            setHeight(elem, value);
        }
        dom.height = height;

        function background(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                return css(elem, "background");
            }

            //---- SET value ----
            css(elem, "background", value);
        }
        dom.background = background;

        /// parse a css style string as a number.
        function getCssNumber(cssValueStr, parentValue) {
            //---- can get fancier in future, but see if this basic functionality helps ----
            var value = 0;

            if (cssValueStr != "") {
                value = parseFloat(cssValueStr);
            }

            if (cssValueStr.endsWith("%")) {
                if (vp.utils.isNumber(parentValue)) {
                    //---- base percentage of size/width of parent ----
                    value = (value * parentValue) / 100;
                }
            }

            return value;
        }
        dom.getCssNumber = getCssNumber;

        function center(elem, cx, cy) {
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttribute("cx", cx);
                elem.setAttribute("cy", cy);
            } else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "cx", cx);
                elem.animation.animateAttr(elem, "cy", cy);
            }
        }
        dom.center = center;

        function from(elem, x1, y1) {
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttribute("x1", x1);
                elem.setAttribute("y1", y1);
            } else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "x1", x1);
                elem.animation.animateAttr(elem, "y1", y1);
            }
        }
        dom.from = from;

        function font(elem, family, size, weight, style) {
            if (weight === false) {
                weight = undefined;
            } else if (weight === true) {
                weight = "bold";
            }

            if (style === false) {
                style = undefined;
            } else if (style === true) {
                style = "italic";
            }

            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttribute("font-family", family);
                elem.setAttribute("font-size", size);

                if (weight != undefined) {
                    elem.setAttribute("font-weight", weight);
                }

                if (style != undefined) {
                    elem.setAttribute("font-style", style);
                }
            } else {
                //---- add to current animation ----
                this.animation.animateAttr(elem, "font-family", family);
                this.animation.animateAttr(elem, "font-size", size);

                if (weight != undefined) {
                    this.animation.animateAttr(elem, "font-weight", weight);
                }

                if (style != undefined) {
                    this.animation.animateAttr(elem, "font-style", style);
                }
            }
        }
        dom.font = font;

        function to(elem, x2, y2) {
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttribute("x2", x2);
                elem.setAttribute("y2", y2);
            } else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "x2", x2);
                elem.animation.animateAttr(elem, "y2", y2);
            }
        }
        dom.to = to;

        function translate(elem, x, y) {
            transform(elem, "translate(" + x + "," + y + ")");
        }
        dom.translate = translate;

        function transform(elem, strTransform) {
            if (arguments.length == 1) {
                var value = undefined;

                if (vp.utils.isSvgDocOrElement(elem)) {
                    value = elem.getAttribute("transform");
                } else if (vp.utils.isCanvasChild(elem)) {
                    value = elem.getTransform();
                } else if (vp.utils.isDefined(elem.style.transform)) {
                    value = elem.style.transform;
                } else if (vp.utils.isDefined(elem.style.msTransform)) {
                    value = elem.style.msTransform;
                } else if (vp.utils.isDefined(elem.style.webkitTransform)) {
                    value = elem.style.webkitTransform;
                } else if (vp.utils.isDefined(elem.style.MozTransform)) {
                    value = elem.style.MozTransform;
                }

                return value;
            }

            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                if (vp.utils.isSvgDocOrElement(elem)) {
                    elem.setAttribute("transform", strTransform);
                } else if (vp.utils.isCanvasChild(elem)) {
                    elem.setTransform(strTransform);
                } else if (vp.utils.isDefined(elem.style.transform)) {
                    elem.style.transform = strTransform;
                } else if (vp.utils.isDefined(elem.style.msTransform)) {
                    elem.style.msTransform = strTransform;
                } else if (vp.utils.isDefined(elem.style.webkitTransform)) {
                    elem.style.webkitTransform = strTransform;
                } else if (vp.utils.isDefined(elem.style.MozTransform)) {
                    elem.style.MozTransform = strTransform;
                }
            } else {
                //---- add to current animation ----
                //---- TODO: add support for transform here ----
                elem.animation.animateAttr(elem, "transform", strTransform);
            }
        }
        dom.transform = transform;

        function transformOrigin(elem, value) {
            if (arguments.length === 0) {
                return elem.getAttribute("transforOrigin");
            }

            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                if (vp.utils.isSvgDocOrElement(elem)) {
                    elem.setAttribute("transformOrigin", value);
                }
                //else if (vp.utils.isDefined(elem.style.transformOrigin))
                //{
                //    elem.style.transformOrigin = value;
                //}
                //else if (vp.utils.isDefined(elem.style.msTransformOrigin))
                //{
                //    elem.style.msTransformOrigin = value;
                //}
                //else if (vp.utils.isDefined(elem.style.webkitTransformOrigin))
                //{
                //    elem.style.webkitTransformOrigin = value;
                //}
                //else if (vp.utils.isDefined(elem.style.MozTransformOrigin))
                //{
                //    elem.style.MozTransformOrigin = value;
                //}
            } else {
                //---- add to current animation ----
                //---- TODO: add support for transform here ----
                elem.animation.animateAttr(elem, "transformOrigin", value);
            }
        }
        dom.transformOrigin = transformOrigin;

        function position(elem, x, y) {
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttribute("x", x);
                elem.setAttribute("y", y);
            } else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "x", x);
                elem.animation.animateAttr(elem, "y", y);
            }
        }
        dom.position = position;

        function absPosition(elem, left, top) {
            css(elem, "position", "absolute");

            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                css(elem, "left", left);
                css(elem, "top", top);
            } else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "left", left, undefined, undefined, undefined, true);
                elem.animation.animateAttr(elem, "top", top, undefined, undefined, undefined, true);
            }
        }
        dom.absPosition = absPosition;

        /// private
        function isSizeName(name) {
            var isSizeName = ((name == "width") || (name == "height") || (name == "radius"));
            return isSizeName;
        }
        dom.isSizeName = isSizeName;

        function attr(elem, name, value) {
            if (arguments.length == 2) {
                //---- GET value ----
                if (elem) {
                    var needGetAttr = true;

                    if ((elem.control) && (elem.control.getAttribute)) {
                        var isSizeName = isSizeName(name);

                        if (!isSizeName) {
                            //---- let control handle the attribute GET ----
                            value = elem.control.getAttribute(name);
                            needGetAttr = false;
                        }
                    }

                    if (needGetAttr) {
                        value = elem.getAttribute(name);
                    }
                }
                return value;
            }

            //---- SET value ----
            var origValue = value;

            if (typeof origValue === "function") {
                value = origValue(elem.dataItem, elem.dataIndex);
            }

            //if (name == "opacity" && +value == 0)
            //{
            //    var a = 4242;
            //}
            //---- if attribute is not animatable, we need to apply now ----
            var isAttrAnimatable = isPropertyAnimatable(name);

            if ((vp.utils.isUndefined(elem.animation)) || (!isAttrAnimatable)) {
                var needSetAttr = true;

                //---- no animation is active - just set in instantly ----
                if ((elem.control) && (elem.control.setAttribute)) {
                    var isSizeName = isSizeName(name);
                    if (!isSizeName) {
                        if (value + "" === "NaN") {
                            //---- help  debug case where font-family get sets to "Nan" ----
                            var a = 9;
                        }

                        //---- let control handle the attribute SET ----
                        elem.control.setAttribute(name, value);
                        needSetAttr = false;
                    }
                }

                if (needSetAttr) {
                    if (value + "" === "NaN") {
                        var a = 9;
                        vp.utils.error("Error: cannot set attr value to NaN: " + name);
                    }

                    elem.setAttribute(name, value);
                }

                if ((name == "width") || (name == "height") || (name == "radius")) {
                    vp.events.triggerResize(elem);
                }
            } else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, name, value);
            }
        }
        dom.attr = attr;

        function attrNS(elem, ns, name, value) {
            if (arguments.length == 3) {
                //---- GET value ----
                value = elem.getAttributeNS(ns, name);
                return value;
            }

            //---- SET value ----
            var origValue = value;

            if (typeof origValue === "function") {
                value = origValue(elem.dataItem, elem.dataIndex);
            }

            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttributeNS(ns, name, value);
            } else {
                //---- add to current animation ----
                //---- TODO: pass "ns" along to animation... ----
                elem.animation.animateAttr(elem, name, value);
            }
        }
        dom.attrNS = attrNS;

        function href(elem, value) {
            //---- if element has this defined - call it instead ----
            if (vp.utils.isFunction(elem.hrefOverride)) {
                return elem.hrefOverride(value);
            } else {
                if (arguments.length == 1) {
                    if (vp.utils.isSvgDocOrElement(elem)) {
                        value = attrNS(elem, "http://www.w3.org/1999/xlink", "href");
                    } else {
                        value = elem.getAttribute("href");
                    }

                    return value;
                }

                if (vp.utils.isSvgDocOrElement(elem)) {
                    attrNS(elem, "http://www.w3.org/1999/xlink", "href", value);
                } else {
                    elem.setAttribute("href", value);
                }
            }
        }
        dom.href = href;

        function prop(elem, name, value) {
            if (arguments.length == 2) {
                //---- GET value ----
                value = elem[name];
                return value;
            }

            //---- SET value ----
            var origValue = value;

            if (typeof origValue === "function") {
                value = origValue(elem.dataItem, elem.dataIndex);
            }

            //---- animation NOT supported for custom properties (most of them we do NOT want animated) ----
            if (true) {
                //---- no animation is active - just set in instantly ----
                elem[name] = value;
            } else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, name, value);
            }
        }
        dom.prop = prop;

        //---- todo: we should probably only define one of these and zap the other one ---
        dom.customAttr = prop;

        /// get/set the "opacity" css property on the item.
        function opacity(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = (elem.rootContainer) ? elem.opacity : elem.style.opacity;
                return value;
            } else {
                //---- SET value ----
                if (vp.utils.isUndefined(elem.animation)) {
                    //---- no animation is active - just set in instantly ----
                    if (elem.rootContainer) {
                        elem.opacity = value;
                    } else {
                        elem.style.opacity = value;
                    }
                } else {
                    //---- add to current animation ----
                    elem.animation.animateAttr(elem, "opacity", value, undefined, undefined, undefined, true);
                }
            }
        }
        dom.opacity = opacity;

        /// get/set the "checked" property on the item.
        function checked(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.checked;
            } else {
                //---- SET value ----
                elem.checked = value;
            }

            return value;
        }
        dom.checked = checked;

        function removeAttribute(elem, name) {
            elem.removeAttribute(name);
        }
        dom.removeAttribute = removeAttribute;

        function removeProp(elem, name) {
            return delete elem[name];
        }
        dom.removeProp = removeProp;

        function id(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.getAttribute("id");
                return value;
            } else {
                //---- SET value ----
                elem.setAttribute("id", value);
            }
        }
        dom.id = id;

        function toolTipEnabled(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.toolTipEnabled;
                return value;
            } else {
                //---- SET value ----
                elem.toolTipEnabled = value;
            }
        }
        dom.toolTipEnabled = toolTipEnabled;

        function getClass(elem) {
            var name = "";

            if ((vp.utils.isSvgDocOrElement(elem)) && (elem.getAttribute)) {
                name = elem.getAttribute("class");
            } else {
                name = elem.className;
            }

            if (name == null) {
                name = "";
            }

            return name;
        }
        dom.getClass = getClass;

        /// sets the class name of the element to just the specified name.
        function setClass(elem, name) {
            if ((vp.utils.isSvgDocOrElement(elem)) && (elem.getAttribute)) {
                elem.setAttribute("class", name);
            } else {
                elem.className = name;
            }
        }
        dom.setClass = setClass;

        /// add the specified class name to the element, if it doesn't already have it.
        function addClass(elem, name) {
            if (!hasClass(elem, name)) {
                var cnBefore = getClass(elem);
                var newName = "";

                if (cnBefore == "") {
                    newName = name;
                } else {
                    newName = cnBefore + " " + name;
                }

                setClass(elem, newName);
            }
        }
        dom.addClass = addClass;

        /// returns true if the element has the specified class name.
        function hasClass(elem, name) {
            var hasIt = false;
            var cn = getClass(elem);

            if ((cn == name) || (cn.startsWith(name + " ")) || (cn.endsWith(" " + name)) || (cn.contains(" " + name + " "))) {
                hasIt = true;
            }

            return hasIt;
        }
        dom.hasClass = hasClass;

        /// removes the specified class name from the element, if it is found in it.
        function removeClass(elem, name) {
            var cn = getClass(elem);
            var nameLen = name.length;
            var newcn = cn;

            if (cn == name) {
                newcn = "";
            } else {
                var index = (cn.indexOf(" " + name + " "));
                if (index > -1) {
                    newcn = cn.substring(0, index) + cn.substring(index + nameLen + 1);
                } else {
                    if (cn.endsWith(" " + name)) {
                        var len = cn.length - (nameLen + 1);
                        newcn = cn.substring(0, len);
                    } else if (cn.startsWith(name + "")) {
                        newcn = cn.substring(name.length + 1);
                    }
                }
            }

            if (newcn != cn) {
                setClass(elem, newcn);
            }
        }
        dom.removeClass = removeClass;

        /// if the class name is found in the element, it is removed.  otherwise, it is added.
        function toggleClass(elem, name) {
            if (hasClass(elem, name)) {
                removeClass(elem, name);
            } else {
                addClass(elem, name);
            }
        }
        dom.toggleClass = toggleClass;

        /// if the class name is found in the element, it is removed.  otherwise, it is added.
        function tabIndex(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.getAttribute(elem, "tabIndex");
                return value;
            } else {
                //---- SET value ----
                var actualValue = value;

                if (typeof value === "function") {
                    actualValue = value(elem.dataItem, elem.dataIndex);
                }

                elem.setAttribute("tabIndex", value);
            }
        }
        dom.tabIndex = tabIndex;

        /// get/set the "text" property on the element.
        function text(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.textContent;
                return value;
            } else {
                //---- SET value ----
                var actualValue = value;

                if (typeof value === "function") {
                    actualValue = value(elem.dataItem, elem.dataIndex);
                }

                elem.textContent = actualValue;
            }
        }
        dom.text = text;

        /// return the "title" child, if any, for the element.
        function getTitleChild(elem) {
            var title = null;

            for (var i = 0; i < elem.childNodes.length; i++) {
                var child = elem.childNodes[i];
                if (child.tagName == "title") {
                    title = child;
                    break;
                }
            }

            return title;
        }
        dom.getTitleChild = getTitleChild;

        /// get/set the "title" property on the element (standard tooltip).
        function title(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = null;

                if (vp.utils.isSvgElement(elem)) {
                    var title = getTitleChild(elem);
                    if (title) {
                        value = title.textContent;
                    }
                } else if (elem.getAttribute) {
                    value = elem.getAttribute("title");
                }

                return value;
            } else {
                //---- SET value ----
                var actualValue = value;

                if (typeof value === "function") {
                    actualValue = value(elem.dataItem, elem.dataIndex);
                }

                if (vp.utils.isSvgElement(elem)) {
                    var title = getTitleChild(elem);
                    if (!title) {
                        title = vp.dom.createSvg("title");
                        elem.appendChild(title);
                    }

                    title.textContent = value;
                    //---- seems to work without this, for HTML and SVG, except for IE/SVG ----
                    //---- and for IE/SVG, this doesn't help ----
                    //---- for native tooltips honoring newline chars ----
                    //css(title, "white-space", "pre-wrap");
                } else {
                    elem.setAttribute("title", actualValue);
                }
            }
        }
        dom.title = title;

        function html(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.innerHTML;
                return value;
            } else {
                //---- SET value ----
                var actualValue = value;

                if (typeof value === "function") {
                    actualValue = value(elem.dataItem, elem.dataIndex);
                }

                elem.innerHTML = actualValue;
            }
        }
        dom.html = html;

        /// get/set the "value" property on the element.
        function value(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.value;
                return value;
            } else {
                //---- SET value ----
                var actualValue = value;

                if (typeof value === "function") {
                    actualValue = value(elem.dataItem, elem.dataIndex);
                }

                elem.value = actualValue;
            }
        }
        dom.value = value;

        /// remove all childNodes or children of the element.
        function clear(element) {
            if (vp.utils.isCanvasChild(element)) {
                element.clear();
            } else if (vp.utils.isCanvasContainer(element)) {
                element.clear();
            } else if (element.childNodes) {
                while (element.childNodes.length > 0) {
                    var child = element.childNodes[0];
                    element.removeChild(child);
                    //---- Firefox doesn't allow this; is it needed? ----
                    //child.parentNode = null;
                }
            }
        }
        dom.clear = clear;

        /// remove the element from its parent.
        function remove(element) {
            var parentNode = element.parentNode;
            if (parentNode != null) {
                parentNode.removeChild(element);
            }
        }
        dom.remove = remove;

        /// hide an element.
        function hide(elem) {
            visibility(elem, "hidden");
        }
        dom.hide = hide;

        /// collapse an element.
        function collapse(elem) {
            //vp.visibility(elem, "collapse");
            css(elem, "display", "none");
        }
        dom.collapse = collapse;

        /// uncollapse an element.
        function expand(elem) {
            //vp.visibility(elem, "collapse");
            css(elem, "display", "block");
        }
        dom.expand = expand;

        /// show an element.
        function show(elem, showIt) {
            if (showIt === false) {
                visibility(elem, "hidden");
            } else {
                visibility(elem, "visible");
            }
        }
        dom.show = show;

        function visibility(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                if (elem.rootContainer == elem) {
                    value = elem.canvas.style.visibility;
                } else if (elem.rootContainer) {
                    //---- its a canvas lightweight element ----
                    value = elem.visibility;
                } else {
                    //---- normal HTML/SVG element ----
                    value = elem.style.visibility;
                }

                return value;
            }

            //---- SET value ----
            if (elem.rootContainer == elem) {
                elem.canvas.style.visibility = value;
            } else if (elem.rootContainer) {
                //---- its a canvas lightweight element ----
                elem.visibility = value;
            } else {
                //---- normal HTML/SVG element ----
                elem.style.visibility = value;
            }
        }
        dom.visibility = visibility;

        /// toggle an element between hidden and visible
        function showToggle(elem) {
            var vis = visibility(elem);
            if ((vis == "") || (vis == "visible")) {
                visibility(elem, "collapse");
            } else {
                visibility(elem, "visible");
            }
        }
        dom.showToggle = showToggle;

        function isPropertyAnimatable(name) {
            var nonAnimators = ["title", "d", "font-family", "cursor", "stroke-dasharray"];
            var isAnimatable = (nonAnimators.indexOf(name) == -1);

            return isAnimatable;
        }

        /// get/set single CSS style property.
        function css(elem, prop, value) {
            if (elem.canvas) {
                elem = elem.canvas;
            } else if (elem.rootContainer) {
                //---- if child of a canvas, use the getAttribute/setAttribute functions for all properties ----
                return attr(elem, prop, value);
            }

            //---- provide translation from prop names like "short-shape" to "shortShape" for Firefox ----
            var index = prop.indexOf('-');
            while (index > -1) {
                prop = prop.substr(0, index) + prop.substr(index + 1, 1).toUpperCase() + prop.substr(index + 2);
                index = prop.indexOf('-');
            }

            if (arguments.length == 2) {
                //---- GET value ----
                if (prop == "width") {
                    value = getWidth(elem);
                } else if (prop == "height") {
                    value = getHeight(elem);
                } else {
                    value = elem.style[prop];
                }

                return value;
            }

            //---- if attribute is not animatable, we need to apply now ----
            var isAttrAnimatable = isPropertyAnimatable(name);

            //---- SET value ----
            if ((vp.utils.isUndefined(elem.animation)) || (!isAttrAnimatable)) {
                //---- set it directly ----
                if (vp.utils.isNumber(value)) {
                    if ((prop != "z-index") && (prop != "zIndex") && (prop != "opacity")) {
                        value += "px";
                    }
                }

                if ((prop == "height") && (value) && (value.startsWith("0"))) {
                    var dummmy = 9;
                }

                if (value + "" === "NaN") {
                    //---- help  debug case where font-family get sets to "Nan" ----
                    var a = 23;
                }

                elem.style[prop] = value;

                if ((prop == "width") || (prop == "height") || (prop == "radius")) {
                    vp.events.triggerResize(elem);
                }
            } else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, prop, value, undefined, undefined, undefined, true);
            }
        }
        dom.css = css;

        function parent(elem) {
            var parent = null;

            if (elem.parentNode) {
                parent = elem.parentNode;
            }

            return parent;
        }
        dom.parent = parent;

        function children(parentElem, includeAll) {
            var kids = [];

            if ((parentElem.tagName == "CANVAS") && (parentElem.canvasContainerElement)) {
                parentElem = parentElem.canvasContainerElement;
            }

            if ((parentElem.ctr == "vp.dom.selectedSet") || (parentElem.ctr == "vp.canvas.canvasSelectedSet")) {
                for (var i = 0; i < parentElem.length; i++) {
                    var hisKids = children(parentElem[i]);
                    kids = kids.concat(hisKids);
                }
            } else if (parentElem.ctr == "vp.singleWrapper") {
                kids = children(parentElem.elem);
            } else if (parentElem.children) {
                kids = parentElem.children;
            } else if (parentElem.childNodes) {
                //---- SVG document ----
                kids = parentElem.childNodes;
            }

            //---- convert from HTML Collection to array, if needed ----
            if (!vp.utils.isArray(kids)) {
                var collect = kids;
                kids = [];

                for (var i = 0; i < collect.length; i++) {
                    kids.push(collect[i]);
                }
            }

            //---- include indirect children, if specified ----
            if (includeAll) {
                for (var i = 0; i < kids.length; i++) {
                    var ikids = children(kids[i]);
                    kids = kids.concat(ikids);
                }
            }

            return kids;
        }
        dom.children = children;

        function childNodes(parentElem, includeAll) {
            var kids = [];

            if ((parentElem.tagName == "CANVAS") && (parentElem.canvasContainerElement)) {
                parentElem = parentElem.canvasContainerElement;
            }

            if ((parentElem.ctr == "vp.dom.selectedSet") || (parentElem.ctr == "vp.canvas.canvasSelectedSet")) {
                for (var i = 0; i < parentElem.length; i++) {
                    var hisKids = childNodes(parentElem[i]);
                    kids = kids.concat(hisKids);
                }
            } else if (parentElem.ctr == "vp.singleWrapper") {
                kids = childNodes(parentElem.elem);
            } else if (parentElem.childNodes) {
                kids = parentElem.childNodes;
            }

            //---- convert from HTML Collection to array, if needed ----
            if (!vp.utils.isArray(kids)) {
                var collect = kids;
                kids = [];

                for (var i = 0; i < collect.length; i++) {
                    kids.push(collect[i]);
                }
            }

            //---- include indirect children, if specified ----
            if (includeAll) {
                for (var i = 0; i < kids.length; i++) {
                    var ikids = childNodes(kids[i]);
                    kids = kids.concat(ikids);
                }
            }

            return kids;
        }
        dom.childNodes = childNodes;

        function bounds(elem, x, y, width, height) {
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                if (height === undefined) {
                    //---- for circle-types ----
                    elem.setAttribute("cx", x);
                    elem.setAttribute("cy", y);
                    elem.setAttribute("r", width);
                } else {
                    if (vp.utils.isSvgDocOrElement(elem) || vp.utils.isCanvasChild(elem)) {
                        elem.setAttribute("x", x);
                        elem.setAttribute("y", y);
                        elem.setAttribute("width", width);
                        elem.setAttribute("height", height);
                    } else {
                        css(elem, "left", x);
                        css(elem, "top", y);
                        css(elem, "width", width);
                        css(elem, "height", height);
                    }
                }
            } else {
                //---- add to current animation ----
                if (height === undefined) {
                    //---- for circle-types ----
                    elem.animation.animateAttr(elem, "cx", x);
                    elem.animation.animateAttr(elem, "cy", y);
                    elem.animation.animateAttr(elem, "r", width);
                } else {
                    if (vp.utils.isSvgDocOrElement(elem) || vp.utils.isCanvasChild(elem)) {
                        elem.animation.animateAttr(elem, "x", x);
                        elem.animation.animateAttr(elem, "y", y);
                        elem.animation.animateAttr(elem, "width", width);
                        elem.animation.animateAttr(elem, "height", height);
                    } else {
                        elem.animation.animateAttr(elem, "left", x, undefined, undefined, undefined, true);
                        elem.animation.animateAttr(elem, "top", y, undefined, undefined, undefined, true);
                        elem.animation.animateAttr(elem, "width", width, undefined, undefined, undefined, true);
                        elem.animation.animateAttr(elem, "height", height, undefined, undefined, undefined, true);
                    }
                }
            }
        }
        dom.bounds = bounds;

        function colors(elem, fill, stroke, strokeWidth) {
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                if (fill !== undefined) {
                    elem.setAttribute("fill", fill);
                }

                if (stroke !== undefined) {
                    elem.setAttribute("stroke", stroke);
                }

                if (strokeWidth != undefined) {
                    elem.setAttribute("stroke-width", strokeWidth);
                }
            } else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "fill", fill);
                elem.animation.animateAttr(elem, "stroke", stroke);
                elem.animation.animateAttr(elem, "strokeWidth", strokeWidth);
            }
        }
        dom.colors = colors;

        function addStop(brush, offset, color, opacity) {
            var ss = "stop-color: " + color;
            if (opacity != null) {
                ss += "; stop-opacity: " + opacity;
            }

            if (vp.utils.isUndefined(brush.animation)) {
                //---- no animation is active - just set in instantly ----
                var stop = document.createElementNS("http://www.w3.org/2000/svg", "stop");

                stop.setAttribute("offset", offset);
                stop.setAttribute("style", ss);

                brush.appendChild(stop);
            } else {
                //---- add to current animation ----
                //---- TODO: support animation of stops ----
                //brush.animation.animateAttr(brush, "x", x);
                //brush.animation.animateAttr(brush, "y", y);
            }
        }
        dom.addStop = addStop;

        function dataItem(elem, value) {
            if (arguments.length == 1) {
                return elem.dataItem;
            }

            elem.dataItem = value;
        }
        dom.dataItem = dataItem;

        function dataIndex(elem, value) {
            if (arguments.length == 1) {
                return elem.dataIndex;
            }

            elem.dataIndex = value;
        }
        dom.dataIndex = dataIndex;

        function animate(elem, duration, ease, container, delay) {
            var anyElem = elem;

            if (duration) {
                //---- store the animation object on the element so it can be retreived later, if needed ----
                anyElem.animation = new vp.animation.animationClass(elem, duration, ease, container, delay);
            } else {
                delete anyElem.animation; // mark it as not animating, so we set attributes, etc. directly
            }
        }
        dom.animate = animate;

        function onAnimationComplete(elem, completedFunc) {
            elem.animation.onAnimationComplete(completedFunc);
        }
        dom.onAnimationComplete = onAnimationComplete;

        function frameRateChanged(elem, callBack) {
            elem.frameRateChanged = callBack;
        }
        dom.frameRateChanged = frameRateChanged;

        function radius(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.getAttribute("radius");
                return value;
            }

            //---- SET value ----
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttribute("radius", value);
            } else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "radius", value);
            }
        }
        dom.radius = radius;

        function returnFalse() {
            return false;
        }
        dom.returnFalse = returnFalse;

        function dataPair(elem, dataItem, dataIndex) {
            elem.dataItem = dataItem;
            elem.dataIndex = dataIndex;
        }
        dom.dataPair = dataPair;

        function focus(elem) {
            elem.focus();
        }
        dom.focus = focus;

        function dataId(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.dataItem.dataId;
                return value;
            }

            //---- SET value ----
            elem.dataItem.dataId = value;
        }
        dom.dataId = dataId;

        function shapeId(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.dataItem.shapeId;
                return value;
            }

            //---- SET value ----
            elem.dataItem.shapeId = value;
        }
        dom.shapeId = shapeId;

        /* This sets the attributes on the line element "elem" to make it a vertical line.  If "makeCrisp"
        is set to true, and the stroke-width is set to an odd whole number, the line is drawn "crisp",
        without antialiasing. */
        function vLine(elem, y1, y2, x, makeCrisp) {
            if (makeCrisp) {
                //---- NOTE: this code assumes that a parent elelment has offset our points to .5, .5 boundaries, relatative to the HTML document ----
                attr(elem, "shape-rendering", "crispEdges");

                y1 = .5 + Math.round(y1);
                y2 = .5 + Math.round(y2);

                x = 0 + Math.round(x); // this one does not get a .5 offset here
            }

            //---- SET value ----
            attr(elem, "y1", y1);
            attr(elem, "y2", y2);
            attr(elem, "x1", x);
            attr(elem, "x2", x);
        }
        dom.vLine = vLine;

        /* This sets the attributes on the line element "elem" to make it a horizontal line.  If "makeCrisp"
        is set to true, and the stroke-width is set to an odd whole number, the line is drawn "crisp",
        without antialiasing. */
        function hLine(elem, x1, x2, y, makeCrisp) {
            if (makeCrisp) {
                //---- NOTE: this code assumes that a parent elelment has offset our points to .5, .5 boundaries, relatative to the HTML document ----
                attr(elem, "shape-rendering", "crispEdges");

                x1 = .5 + Math.round(x1);
                x2 = .5 + Math.round(x2);

                y = 0 + Math.round(y); // this one does not get a .5 offset here
            }

            //---- SET value ----
            attr(elem, "y1", y);
            attr(elem, "y2", y);
            attr(elem, "x1", x1);
            attr(elem, "x2", x2);
        }
        dom.hLine = hLine;

        /// used to temp. disable HTML element selection by the user with mouse/touch
        /// during a control's dragging operation.
        function enableElementSelection(elem, enable) {
            if (enable) {
                if (vp.utils.isDefined(elem.onselectstart)) {
                    elem.onselectstart = null;
                } else if (vp.utils.isDefined(elem.style.MozUserSelect)) {
                    //---- restore default of "text" ----
                    elem.style.MozUserSelect = "text";
                } else if (elem.onmousedown == returnFalse) {
                    elem.onmousedown = null;
                }
            } else {
                if (vp.utils.isDefined(elem.onselectstart)) {
                    elem.onselectstart = returnFalse;
                } else if (vp.utils.isDefined(elem.style.MozUserSelect)) {
                    elem.style.MozUserSelect = "none";
                } else {
                    //---- caution: this could break other things ----
                    elem.onmousedown = returnFalse;
                }
            }
        }
        dom.enableElementSelection = enableElementSelection;

        /// returns the scroll offset for the HTML page.  This value is in pixels from the document origin.
        /// verified correct by roland on 6/21/2013 on Windows 8 for: IE10, Chrome 27, and FireFox 21.0.
        function getBodyScroll() {
            return { x: window.pageXOffset, y: window.pageYOffset };
        }
        dom.getBodyScroll = getBodyScroll;

        /// gets the {left,top} offset of the HTML/SVG/Canvas element from the document origin.
        /// verified correct by roland on 5/12/2012 on Windows 7 for: IE9, Chrome 18.0, and FireFox 11.0.
        /// testing included HMTL document, HTML element, SVG doc, SVG element, Canvas 2d doc, Canvas 2d elem,
        /// Canvas 3d doc, Canvas 3d elem.
        function docOffset(elem) {
            var left = 0;
            var top = 0;
            var origElem = elem;

            while ((elem) && (elem != document.body)) {
                if ((elem.rootContainer) && (elem.rootContainer == elem)) {
                    elem = elem.canvas;
                }

                if (elem.rootContainer) {
                    //---- its a canvas 2d/3d lightweight element ----
                    var offset = elem.getOffset();

                    left += offset.x;
                    top += offset.y;
                } else if ((elem.tagName == "svg") && (!vp.utils.isIE)) {
                    //---- special handling for SVG document for Chrome/FireFox ----
                    //---- these browsers do wierd things when a viewBox is set on the SVG document, so we use this workaround ----
                    if (vp.utils.isFireFox) {
                        //---- FireFox ----
                        //var rc = elem.getBoundingClientRect();
                        // problem: getBoundingClinetRect() varies with viewBox on svgdoc, so it is not simple to use.
                        // as our workaround, we use elem.getBBox() for parent offset and then the location of the parent.
                        var vb = elem.viewBox;
                        if ((vb) && (vb.baseVal) && (vb.baseVal.width > 0) && (vb.baseVal.height > 0)) {
                            //---- viewbox is active ----
                            //---- add offset to parent ----
                            var box = elem.getBBox();
                            left += box.x;
                            top += box.y;

                            //---- wait - getBBox() is measured from outside box of parent (not content); so we need to ----
                            //---- adjust by adding the left/top margin and the left/top border size (yuck) ----
                            left -= getCssNumber(elem.parentNode.style.marginLeft);
                            left -= getCssNumber(elem.parentNode.style.borderLeft);

                            top -= getCssNumber(elem.parentNode.style.marginTop);
                            top -= getCssNumber(elem.parentNode.style.borderTop);
                            //---- and continue up the hierarchy ----
                        } else {
                            //---- viewbox is inactive ----
                            var rc = elem.getBoundingClientRect();

                            left += rc.left;
                            top += rc.top;

                            //---- this stuff is really strange; now we seem to need to offset it by getBBox() ----
                            var bb = elem.getBBox();
                            left -= bb.x;
                            top -= bb.y;

                            break;
                        }
                    } else {
                        //---- Chrome ----
                        if (vp.utils.isDefined(elem.offsetLeft)) {
                            //---- this fixes "mouse" and "panAndZoom" samples for Chrome, but more adjustments may be needed ----
                            //---- we also need to work for "stdChart" bar selection dragging ----
                            //---- as a temp workaround, use 2 code paths (one for active viewBox, one for other case) ----
                            var vb = elem.viewBox;
                            if ((vb) && (vb.baseVal) && (vb.baseVal.width > 0) && (vb.baseVal.height > 0)) {
                                //---- viewbox is active ----
                                left += elem.offsetLeft;
                                top += elem.offsetTop;
                                break;
                            } else {
                                //---- viewbox is inactive ----
                                var rc = elem.getBoundingClientRect();

                                left += rc.left;
                                top += rc.top;

                                break;
                            }
                        }
                    }
                    //            if (elem.parentNode)
                    //            {
                    //                //--- get location of parent ----
                    //                var rc = elem.parentNode.getBoundingClientRect();
                    //                left += rc.left;
                    //                top += rc.top;
                    //            }
                    //            //---- add location of svg doc relative to parent ----
                    //            left += elem.clientLeft;
                    //            top += elem.clientTop;
                } else {
                    //---- HTML element ----
                    //---- "modern browser" assumption - we rely on getBoundClientRect() to do the hard work ----
                    var rc = elem.getBoundingClientRect();

                    left += rc.left;
                    top += rc.top;

                    break;
                }

                elem = elem.parentNode;
            }

            //---- must always add the scroll offset of the body ----
            var bs = getBodyScroll();
            left += bs.x;
            top += bs.y;

            return { left: left, top: top };
        }
        dom.docOffset = docOffset;

        function textBaseline(textElem, alignType, rc) {
            var yCorrection = 0;

            if (textBaseline instanceof vp.canvas.canvasTextElement) {
                textElem.setAttribute("textBaseline", alignType);
            } else {
                var yPos = +textElem.getAttribute("y");

                if (!rc) {
                    rc = textElem.getBBox();
                }

                yCorrection = yPos - rc.y;
                var height = rc.height;

                var delta = 0;

                if (alignType == "top") {
                    //---- align TOP ----
                    delta = yCorrection;
                } else if (alignType == "bottom") {
                    //---- align BOTTOM ----
                    delta = yCorrection - height;
                } else if (alignType == "middle") {
                    //---- align BOTTOM ----
                    delta = yCorrection - height / 2;
                }

                textElem.setAttribute("dy", delta);
            }

            return yCorrection;
        }
        dom.textBaseline = textBaseline;
    })(vp.dom || (vp.dom = {}));
    var dom = vp.dom;
})(vp || (vp = {}));
//# sourceMappingURL=dom.js.map

///----------------------------------------------------------------
/// (from _dom\events.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// event.ts.  Copyright (c) 2014 Microsoft Corporation.
///            part of the vuePlot library - keyboard, mouse, and touch related event handling.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (events) {
        //---- keyCodes (for keyboard test, see: http://unixpapa.com/js/testkey.html) ----
        events.keyCodes = {
            //enter: "Enter", shift: 16, ctrl: 17, alt: 18, escape: "Esc", left: 37, up: 38, right: 39, down: 40,
            enter: 13, shift: 16, ctrl: 17, alt: 18, escape: 27, left: 37, up: 38, right: 39, down: 40,
            insert: 45, home: 36, pageUp: 33, "delete": 46, end: 35, pageDown: 34, space: 32,
            A: 65, Z: 90
        };

        var _isDragDropEnabled = true;

        events.keyboardKeys = {};

        /// cross-browser support for cancelling an event.
        function cancelEvent(evt) {
            if (evt.preventDefault) {
                evt.preventDefault();
            } else {
                return false;
            }
        }
        events.cancelEvent = cancelEvent;

        function monitorKeyboard(enable) {
            if (enable) {
                attach(window, "keydown", onKeyDown);
                attach(window, "keyup", onKeyUp);
            } else {
                detach(window, "keydown", onKeyDown);
                detach(window, "keyup", onKeyUp);
            }
        }
        events.monitorKeyboard = monitorKeyboard;

        function isKeyPressed(keyCode) {
            return (events.keyboardKeys[keyCode] == "down");
        }
        events.isKeyPressed = isKeyPressed;

        /// used by vp.monitorKeyboard.
        function onKeyDown(evt) {
            events.keyboardKeys[evt.keyCode] = "down";
            //vp.utils.debug("keydown: " + evt.keyCode);
        }

        /// used by vp.monitorKeyboard.
        function onKeyUp(evt) {
            events.keyboardKeys[evt.keyCode] = "up";
            //vp.utils.debug("keyup: " + evt.keyCode);
        }

        /// returns the current mouse positon from the event object "e".  This value is in logical window space,
        /// which includes scroll offsets.
        function mousePosition(e, relToParent) {
            //    var isIe = (document.all);
            //    var xPos = (isIe) ? window.event.clientX + document.documentElement.scrollLeft : e.pageX;
            //    var yPos = (isIe) ? window.event.clientY + document.documentElement.scrollTop : e.pageY;
            var x = e.pageX;
            var y = e.pageY;

            // Handle a non-IE 'touch' event
            if (e.type.startsWith('touch') && (e.changedTouches != undefined) && (e.changedTouches.length > 0)) {
                x = e.changedTouches[0].pageX;
                y = e.changedTouches[0].pageY;
            }

            if (relToParent) {
                var off = vp.dom.docOffset(relToParent);
                x -= off.left;
                y -= off.top;
            }

            return { x: x, y: y };
        }
        events.mousePosition = mousePosition;

        var mouseMoveWrapper = function (e) {
            //---- set by SetCapture ----
        };

        var mouseUpWrapper = function (e) {
            //---- set by SetCapture ----
        };

        /// captures the mouse for mouse events on "element".  if "setCapture" is not supported by
        /// the browser, it tries to simulate it.  The "mouseMoveCallback" and "mouseUpCallback", if supplied,
        /// are attached to the best element for the situation.
        ///
        /// tested on roland's home machine - 8/5/2012.  seems to work perfectly now on IE9, Chrome, Firefox!
        ///   - no blue selection as we drag
        ///   - no system drag/drop interference
        ///   - cursor stays as specified during drag
        ///   - on releaseCapture(), all is restored to normal.
        function setCapture(element, evt, mouseMoveCallback, mouseUpCallback) {
            var useCapture = (element.setCapture);

            mouseMoveWrapper = function (e) {
                e.vp_element = element;
                mouseMoveCallback(e);
            };

            mouseUpWrapper = function (e) {
                e.vp_element = element;
                mouseUpCallback(e);
            };

            if (useCapture) {
                //---- listen to events on the ELEMENT ----
                if (mouseMoveCallback) {
                    attach(element, "mousemove", mouseMoveWrapper);
                }

                if (mouseUpCallback) {
                    attach(element, "mouseup", mouseUpWrapper);
                }

                //---- prevent text selection by browser during our drag operation (for FireFox) ----
                vp.dom.enableElementSelection(document.body, false);

                element.setCapture();

                element._turnedOffDrawDrop = null;
            } else {
                //---- listen to events on the DOCUMENT ----
                if (mouseMoveCallback) {
                    attach(document, "mousemove", mouseMoveWrapper);
                }

                if (mouseUpCallback) {
                    attach(document, "mouseup", mouseUpWrapper);
                }

                //---- prevent text selection by browser during our drag operation (for Chrome) ----
                vp.dom.enableElementSelection(document.body, false);

                element._turnedOffDrawDrop = enableDragDrop(false);

                var cursorState = vp.dom.css(element, "cursor");
                if (cursorState) {
                    //---- create a style sheet that keeps cursor constant during capture ----
                    var sheet = new vp.dom.styleSheetClass().addRule("*", "cursor: " + cursorState).id("vp_setCapture_ss");
                }
            }

            if (evt) {
                evt.preventDefault(); // don't allow selection to select text, etc. during our capture
                evt.stopPropagation();
                evt.cancelBubble = true;
            }

            return useCapture;
        }
        events.setCapture = setCapture;

        function setFocus(elem) {
            while ((elem) && (!elem.focus)) {
                elem = vp.dom.parent(elem);
            }

            if (elem.focus) {
                elem.focus();
            }
        }
        events.setFocus = setFocus;

        /// captures the mouse for mouse events on "element".
        function releaseCapture(element, evt, mouseMoveCallback, mouseUpCallback) {
            var callRelease = (element.releaseCapture);

            if (callRelease) {
                element.releaseCapture();

                //---- clear events on the ELEMENT ----
                if (mouseMoveWrapper) {
                    detach(element, "mousemove", mouseMoveWrapper);
                    mouseMoveWrapper = null;
                }

                if (mouseUpWrapper) {
                    detach(element, "mouseup", mouseUpWrapper);
                    mouseUpWrapper = null;
                }

                //---- re-enable text selection by browser (for FireFox) ----
                vp.dom.enableElementSelection(document.body, true);
            } else {
                //---- clear events on the DOCUMENT ----
                if (mouseMoveWrapper) {
                    detach(document, "mousemove", mouseMoveWrapper);
                    mouseMoveWrapper = null;
                }

                if (mouseUpWrapper) {
                    detach(document, "mouseup", mouseUpWrapper);
                    mouseUpWrapper = null;
                }

                //---- re-enable text selection by browser (for Chrome) ----
                vp.dom.enableElementSelection(document.body, true);

                if (element._turnedOffDrawDrop) {
                    enableDragDrop(true);
                }

                //---- remove the stylesheet, if we created it ----
                var elem = document.getElementById("vp_setCapture_ss");
                if (elem) {
                    vp.dom.remove(elem);
                }
            }

            return callRelease;
        }
        events.releaseCapture = releaseCapture;

        function stopDragDrop(evt) {
            evt.dataTransfer.dropEffect = 'none';
            evt.stopPropagation();
            evt.preventDefault();
        }

        function enableDragDrop(isEnabled) {
            if (_isDragDropEnabled != isEnabled) {
                var body = vp.select(document.body);

                body.attach("dragstart", function (e) {
                    return _isDragDropEnabled = true;
                });

                body.attr("draggable", isEnabled);

                if (isEnabled) {
                    body.detach("dragenter", stopDragDrop);
                    body.detach("ondragover", stopDragDrop);
                    body.detach("ondrop", stopDragDrop);
                } else {
                    body.attach("dragenter", stopDragDrop);
                    body.attach("ondragover", stopDragDrop);
                    body.attach("ondrop", stopDragDrop);
                }

                _isDragDropEnabled = isEnabled;
            }
        }
        events.enableDragDrop = enableDragDrop;

        function attach(elem, eventName, funcToCall, useCapturePhase) {
            if ((eventName == "mousewheel") && (vp.utils.isFireFox)) {
                eventName = "DOMMouseScroll";
            }

            if ((eventName == "resize") && (elem != window)) {
                //---- add support for resize events on non-window elements ----
                if (!elem.resizeEvent) {
                    if (elem.tagName == "circle") {
                        elem.resizeEvent = { prevWidth: vp.dom.width(elem), prevRadius: vp.dom.attr(elem, "radius"), callBacks: [] };
                    } else {
                        elem.resizeEvent = { prevWidth: vp.dom.width(elem), prevHeight: vp.dom.height(elem), callBacks: [] };
                    }
                }

                elem.resizeEvent.callBacks.push(funcToCall);
            } else {
                if ((elem.control) && (elem.control.addEventListener)) {
                    //---- let the control handle the event management ----
                    elem.control.addEventListener(eventName, funcToCall);
                } else if (elem.addEventListener) {
                    elem.addEventListener(eventName, funcToCall, useCapturePhase);
                } else if (elem.attachEvent) {
                    elem.attachEvent(eventName, funcToCall);
                }
            }
        }
        events.attach = attach;

        /// trigger the vuePlot "resize" event on the specified elem.
        function triggerResize(elem) {
            //---- has someone hooked the "resize" event on this elem? ----
            if (!elem.resizeEvent) {
                //---- try his kids ----
                var kids = vp.dom.children(elem);
                for (var i = 0; i < kids.length; i++) {
                    triggerResize(kids[i]);
                }
            } else {
                var resizeEvent = elem.resizeEvent;

                //---- see if at least one of size properties has really changed ----
                var changed = false;

                if (elem.tagName == "circle") {
                    var radius = elem.attr("radius");
                    changed = (radius != resizeEvent.prevRadius);
                    if (changed) {
                        resizeEvent.prevRadius = radius;
                    }
                } else {
                    var width = vp.dom.width(elem);
                    var changeWidth = (width != resizeEvent.prevWidth);
                    if (changeWidth) {
                        resizeEvent.prevWidth = width;
                    }

                    var height = vp.dom.height(elem);
                    var changeHeight = (height != resizeEvent.prevHeight);
                    if (changeHeight) {
                        resizeEvent.prevHeight = height;
                    }

                    changed = (changeWidth || changeHeight);
                }

                if (changed) {
                    var callBacks = resizeEvent.callBacks;

                    for (var i = 0; i < callBacks.length; i++) {
                        var callBack = callBacks[i];
                        var e = { target: elem, type: "resize", currentTarget: elem, cancelable: false, bubbles: false };

                        callBack(e);
                    }
                }
            }
        }
        events.triggerResize = triggerResize;

        /// window was resized; trigger the "resize" event on the element and all its children
        function triggerResizeRecursive(elem) {
            if (elem.resizeEvent) {
                triggerResize(elem);
            }

            var kids = vp.dom.children(elem);
            if ((kids) && (kids.length > 0)) {
                for (var i = 0; i < kids.length; i++) {
                    triggerResizeRecursive(kids[i]);
                }
            }
        }

        function wheelDelta(evt) {
            return (evt.detail) ? -40 * evt.detail : evt.wheelDelta;
        }
        events.wheelDelta = wheelDelta;

        function detach(elem, eventName, funcToCall, useCapture) {
            if ((eventName == "mousewheel") && (vp.utils.isFireFox)) {
                eventName = "DOMMouseScroll";
            }

            if ((eventName == "resize") && (elem != window)) {
                //---- add support for resize events on non-window elements ----
                if (elem.resizeEvent) {
                    var callBacks = elem.resizeEvent.callBacks;

                    for (var i = 0; i < callBacks.length; i++) {
                        if (callBacks[i] == funcToCall) {
                            callBacks.removeAt(i);
                        }
                    }
                }
            } else {
                if ((elem.control) && (elem.control.removeEventListener)) {
                    //---- let the control handle the event management ----
                    elem.control.removeEventListener(eventName, funcToCall);
                } else if (elem.removeEventListener) {
                    elem.removeEventListener(eventName, funcToCall);
                } else if (elem.detachEvent) {
                    elem.detachEvent(eventName, funcToCall);
                }
            }
        }
        events.detach = detach;

        /// returns the HTML, SVG, or lightweight cavnas element at the specified x,y
        /// (pixels from document origin).
        function elementFromPoint(x, y) {
            //---- first, get the HTML or SVG element from the DOM ----
            var elem = document.elementFromPoint(x, y);
            if (elem != null) {
                //---- now, see if there is a canvas element at that location ----
                if (elem.canvasContainerElement) {
                    //---- make x, y relative to canvas ----
                    var off = vp.dom.docOffset(elem);
                    x -= off.left;
                    y -= off.top;

                    elem = elem.canvasContainerElement.getCanvasElementAtPoint(x, y);
                }
            }

            return elem;
        }
        events.elementFromPoint = elementFromPoint;

        //---- local init code ----
        attach(window, "resize", function (e) {
            triggerResizeRecursive(document.body);
        });
    })(vp.events || (vp.events = {}));
    var events = vp.events;
})(vp || (vp = {}));
//module vp
//{
//    export function attach(elem, eventName, funcToCall, useCapturePhase?)
//    {
//        return vp.events.attach(elem, eventName, funcToCall, useCapturePhase);
//    }
//    export function detach(elem, eventName, funcToCall, useCapturePhase?)
//    {
//        return vp.events.detach(elem, eventName, funcToCall, useCapturePhase);
//    }
//    export function mousePosition(e, relToParent?: any)
//    {
//        return vp.events.mousePosition(e, relToParent);
//    }
//}
//# sourceMappingURL=events.js.map

///----------------------------------------------------------------
/// (from _dom\inkHitTest.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// inkHitTest.ts.  Copyright (c) 2014 Microsoft Corporation.
///     - part of the vuePlotCore library
///     - does ink based hit testing of a shape and rectangle, using a temp. canvas
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (internal) {
        var inkHitTest = (function () {
            function inkHitTest(rect) {
                //---- private state ----
                this.tempCanvas = null;
                this.root = null;
                this.ctx = null;
                this.rect = rect;
                this.w = rect.width;
                this.h = rect.height;

                //---- create a temp. canvas object to render to ----
                this.tempCanvas = vp.select(document.body).append("canvas").id("$_tempCanvas").attr("width", this.w + "").attr("height", this.h + "");

                this.root = vp.canvas.selectContext("#$_tempCanvas", "2d");
                this.ctx = this.root[0].ctx;
            }
            inkHitTest.prototype.transferAttrs = function (fromElem, toElem, attrNameList) {
                //---- unwrap toElem ----
                toElem = (toElem.length) ? toElem[0] : toElem;

                for (var i = 0; i < attrNameList.length; i++) {
                    var name = attrNameList[i];
                    var value = (name == "text") ? vp.dom.text(fromElem) : vp.dom.attr(fromElem, name);

                    if (value !== undefined) {
                        vp.dom.attr(toElem, name, value);
                    }
                }
            };

            inkHitTest.prototype.canvasElemFromSvg = function (canvasRoot, svgElem) {
                //---- add svgElem to canvasRoot ----
                var canvasElem = null;

                if (svgElem.tagName == "g") {
                    canvasElem = canvasRoot.append("g");
                    this.transferAttrs(svgElem, canvasElem, []);
                } else if (svgElem.tagName == "rect") {
                    canvasElem = canvasRoot.append("rect");
                    this.transferAttrs(svgElem, canvasElem, ["x", "y", "width", "height"]);
                } else if (svgElem.tagName == "line") {
                    canvasElem = canvasRoot.append("line");
                    this.transferAttrs(svgElem, canvasElem, ["x1", "y1", "x2", "y2"]);
                } else if (svgElem.tagName == "circle") {
                    canvasElem = canvasRoot.append("circle");
                    this.transferAttrs(svgElem, canvasElem, ["cx", "cy", "r"]);
                } else if (svgElem.tagName == "ellipse") {
                    canvasElem = canvasRoot.append("ellipse");
                    this.transferAttrs(svgElem, canvasElem, ["cx", "cy", "rx", "ry"]);
                } else if (svgElem.tagName == "path") {
                    canvasElem = canvasRoot.append("path");
                    this.transferAttrs(svgElem, canvasElem, ["d"]);
                } else if (svgElem.tagName == "polyline") {
                    canvasElem = canvasRoot.append("polyline");
                    this.transferAttrs(svgElem, canvasElem, ["points"]);
                } else if (svgElem.tagName == "polygon") {
                    canvasElem = canvasRoot.append("polygon");
                    this.transferAttrs(svgElem, canvasElem, ["points"]);
                } else if (svgElem.tagName == "text") {
                    canvasElem = canvasRoot.append("text");
                    this.transferAttrs(svgElem, canvasElem, [
                        "x", "y", "text", "dx", "dy", "font-size", "font-width", "font-weight",
                        "font-style", "font-family"]);
                } else {
                    //vp.utils.error("unsupported SVG element: " + svgElem.tagName);
                }

                if (canvasElem) {
                    //---- transfer common attributes -----
                    this.transferAttrs(svgElem, canvasElem, ["transform", "fill", "stroke", "stroke-width"]);

                    //---- unwrap canvasElem ----
                    canvasElem = (canvasElem.length) ? canvasElem[0] : canvasElem;

                    //---- don't interfere with our high-level transform ----
                    canvasElem.transform = null;
                } else {
                    canvasElem = vp.select(""); // empty wrapper
                }

                return canvasElem;
            };

            inkHitTest.prototype.addCanvasChild = function (canvasParent, svgElem) {
                if (svgElem.tagName) {
                    canvasParent = this.canvasElemFromSvg(canvasParent, svgElem);

                    //---- now add children of svgElem ----
                    var kids = vp.dom.children(svgElem);
                    if (kids.length > 0) {
                        var wcp = vp.dom.wrapElements(canvasParent);

                        for (var i = 0; i < kids.length; i++) {
                            this.addCanvasChild(wcp, kids[i]);
                        }
                    }
                }
            };

            inkHitTest.prototype.close = function () {
                //---- remove temp canvas ----
                this.root[0].close(); // stop drawing
                this.tempCanvas.remove();
            };

            inkHitTest.prototype.doesShapeOverlap = function (svgShape) {
                var shapeWidth = vp.dom.width(svgShape);
                var shapeHeight = vp.dom.height(svgShape);

                this.root.clear(); // remove previous shapes

                this.addCanvasChild(this.root, svgShape);

                //---- clear the canvas ----
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.clearRect(0, 0, this.w, this.h);

                //---- set the transform so that only the rect area of the shape will be drawn on the canvas ----
                var x = -this.rect.left;
                var y = -this.rect.top;
                this.ctx.setTransform(1, 0, 0, 1, x, y);

                //---- draw the shape ----
                this.root[0].drawAll(this.ctx);

                //---- get the pixels in the canvas ----
                var imageData = this.ctx.getImageData(0, 0, this.w, this.h);

                var intersects = false;

                //---- now, walk each pixel and see if any ink is present ----
                var index = 0;
                for (var r = 0; r < this.h; r++) {
                    if (intersects) {
                        break;
                    }

                    for (var c = 0; c < this.w; c++) {
                        if (intersects) {
                            break;
                        }

                        for (var p = 0; p < 4; p++) {
                            if (imageData.data[index++]) {
                                intersects = true;
                                break;
                            }
                        }
                    }
                }

                return intersects;
            };
            return inkHitTest;
        })();
        internal.inkHitTest = inkHitTest;
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));
//# sourceMappingURL=inkHitTest.js.map

///----------------------------------------------------------------
/// (from _dom\insertAppend.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// insertAppend.ts.  Copyright (c) 2014 Microsoft Corporation.
///                   part of the vuePlot library - handles inserting and appending content to containers.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (dom) {
        function createHtml(tagName) {
            var element = document.createElement(tagName);
            return element;
        }
        dom.createHtml = createHtml;

        function createSvg(tagName) {
            var nsSvg = "http://www.w3.org/2000/svg";
            var svgElem = document.createElementNS(nsSvg, tagName);

            return svgElem;
        }
        dom.createSvg = createSvg;

        /** createElement(parent, tagName) - creates an HTML, SVG, or CANVAS element with the specified tagName.
        returns: the newly created element (unwrapped). */
        function createElement(parent, tagName) {
            var element = null;

            var parentElem = (parent.element) ? parent.element() : parent;

            if ((tagName.toLowerCase() == "svg") || (vp.utils.isSvgDocOrElement(parentElem))) {
                //---- normal SVG container ----
                element = document.createElementNS('http://www.w3.org/2000/svg', tagName);
            } else {
                var tagNameLower = tagName.toLowerCase();
                var element = null;

                if (tagNameLower.startsWith("vp.")) {
                    var ctr = eval(tagName);
                    if (vp.utils.isFunction(ctr)) {
                        //---- create the vuePlot visual control ----
                        var obj = ctr.call();
                        if (vp.utils.isDefined(obj.tagName)) {
                            element = obj;
                        } else {
                            element = obj.domElement;
                        }
                    }
                } else {
                    //---- regular HTML element ----
                    element = document.createElement(tagName);
                }
            }

            return element;
        }
        dom.createElement = createElement;

        /// this was created to help speed up our slow create and append routines by looping at the
        /// lowest level possible.
        function createElements(parent, tagName, count) {
            var elements = [];

            var parentElem = (parent.element) ? parent.element() : parent;

            if ((tagName.toLowerCase() == "svg") || (vp.utils.isSvgDocOrElement(parentElem))) {
                for (var i = 0; i < count; i++) {
                    var elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);
                    elements[i] = elem;
                }
            } else {
                var tagNameLower = tagName.toLowerCase();
                var element = null;

                if (tagNameLower.startsWith("vp.")) {
                    var ctr = eval(tagName);
                    if (vp.utils.isFunction(ctr)) {
                        for (var i = 0; i < count; i++) {
                            //---- create the vuePlot visual control ----
                            var obj = ctr.call();
                            if (vp.utils.isDefined(obj.tagName)) {
                                element = obj;
                            } else {
                                element = obj.domElement;
                            }

                            elements[i] = element;
                        }
                    }
                } else {
                    for (var i = 0; i < count; i++) {
                        element = document.createElement(tagName);
                        elements[i] = element;
                    }
                }
            }

            return elements;
        }
        dom.createElements = createElements;

        /// internal.
        function insertOrAppend(container, child, insertOp) {
            var returnValue = null;

            var addingToContainer = ((insertOp == "append") || (insertOp == "prepend"));

            if ((insertOp == "append") || ((addingToContainer) && (container.children.length == 0))) {
                returnValue = container.appendChild(child);
            } else if (insertOp == "prepend") {
                returnValue = container.insertBefore(child, container.children[0]);
            } else if (insertOp == "insertBefore") {
                var parent = container.parentNode;
                returnValue = parent.insertBefore(child, container);
            } else if (insertOp == "insertAfter") {
                var parent = container.parentNode;
                returnValue = parent.insertBefore(child, container.nextSibling);
            }

            return returnValue;
        }

        //---- INTERNAL: appends the content into the container, using the specified insertOp, and returns ----
        //---- an array of appended elements. ----
        function appendCoreSingle(container, content, insertOp) {
            var appendedElements = [];

            //---- look for all 3 "select set" types ----
            if (content instanceof vp.dom.selectedSet) {
                content = content.toArray();
            } else if (content.ctr == "vp.canvas.canvasSelectedSet") {
                content = content.toArray();
            } else if (content instanceof vp.dom.singleWrapperSuperClass) {
                //---- special handling since "content" is already wrapped ----
                var element = insertOrAppend(container, content.elem, insertOp);

                appendedElements = content; // already wrapped (don't rewrap)
            }

            //else if (content instanceof vp.marks.markBaseClass)
            //{
            //    var element = insertOrAppend(container, content._container, insertOp);
            //    appendedElements = content;      // already wrapped (don't rewrap)
            //}
            if (appendedElements.length == 0) {
                if (vp.utils.isArray(content)) {
                    for (var i = 0; i < content.length; i++) {
                        var child = content[i];
                        var element = insertOrAppend(container, child, insertOp);

                        appendedElements.push(element);
                    }
                } else if (vp.utils.isString(content)) {
                    var element = vp.dom.createElement(container, content);
                    if (element != null) {
                        //---- transfer data info from parent container ----
                        element.dataItem = container.dataItem;
                        element.dataIndex = container.dataIndex;

                        insertOrAppend(container, element, insertOp);

                        appendedElements.push(element);
                    }
                } else if (vp.utils.isFunction(content)) {
                    //---- call func to get content to append ----
                    var elemFromFunc = content(this);

                    var element = insertOrAppend(container, elemFromFunc, insertOp);

                    appendedElements.push(element);
                } else if (content != null) {
                    var element = insertOrAppend(container, content, insertOp);

                    appendedElements.push(element);
                }
            }

            return appendedElements;
        }

        //---- add specified content to container & return added elements as ARRAY ----
        //---- seems to be used only for HTML "select" element? ----
        //---- TODO: merge this with "vp.appendCoreSingle" (using a callBack functon to do the append/insert/add!) ----
        function add(container, content) {
            var addedElements = [];
            var element;

            //---- look for all 3 "select set" types ----
            if (content instanceof vp.dom.selectedSet) {
                content = content.toArray();
            } else if (content.ctr == "vp.canvas.canvasSelectedSet") {
                content = content.toArray();
            } else if (content instanceof vp.dom.singleWrapperSuperClass) {
                content = [content.elem];
            }

            if (vp.utils.isArray(content)) {
                for (var i = 0; i < content.length; i++) {
                    var child = content[i];
                    element = container.add(child);
                    addedElements.push(element);
                }
            } else if (vp.utils.isString(content)) {
                if (vp.utils.isSvgDocOrElement(container)) {
                    //---- normal SVG container ----
                    element = document.createElementNS('http://www.w3.org/2000/svg', content);
                    if (element != null) {
                        //---- transfer data info from parent container ----
                        element.dataItem = container.dataItem;
                        element.dataIndex = container.dataIndex;

                        container.add(element);
                        addedElements.push(element);
                    }
                } else {
                    //---- regular HTML element ----
                    element = document.createElement(content);
                    if (element != null) {
                        //---- transfer data info from parent container ----
                        element.dataItem = container.dataItem;
                        element.dataIndex = container.dataIndex;

                        container.add(element);
                        addedElements.push(element);
                    }
                }
            } else if (content != null) {
                container.add(content);
                addedElements.push(element);
            }

            return addedElements;
        }
        dom.add = add;

        //---- append into specified container and return elements in a wrapper ----
        function append(container, content) {
            var elements = null;

            if (container.tagName == "CANVAS") {
                if (!container.canvasContainerElement) {
                    //---- build a canvasContainerElement on the fly ----
                    container = vp.canvas.selectContext(container, "2d")[0];
                } else {
                    //---- switch from canvas element to our associated canvas container object ----
                    container = container.canvasContainerElement;
                }
            }

            if (container.append) {
                //---- its a canvasContainer or canvasGroup element ----
                elements = container.append(content);
            } else {
                elements = appendCoreSingle(container, content, "append");
            }

            if (!vp.utils.isSelectedSet(elements)) {
                elements = vp.dom.wrapElements(elements);
            }

            return elements;
        }
        dom.append = append;

        //---- append into specified container ----
        function appendElements(container, elements) {
            if (container.append) {
                for (var i = 0; i < elements.length; i++) {
                    container.append(elements[i]);
                }
            } else {
                for (var i = 0; i < elements.length; i++) {
                    container.appendChild(elements[i]);
                }
            }
        }
        dom.appendElements = appendElements;

        //---- prepend into specified container ----
        function prepend(container, content) {
            var elements = appendCoreSingle(container, content, "prepend");
            return vp.dom.wrapElements(elements);
        }
        dom.prepend = prepend;

        //---- insert content before specified container ----
        function insertBefore(container, content) {
            var elements = appendCoreSingle(container, content, "insertBefore");
            return vp.dom.wrapElements(elements);
        }
        dom.insertBefore = insertBefore;

        //---- insert content after specified container ----
        function insertAfter(container, content) {
            var elements = appendCoreSingle(container, content, "insertAfter");
            return vp.dom.wrapElements(elements);
        }
        dom.insertAfter = insertAfter;

        /// INTERNAL.
        function appendCoreMulti(self, content, insertOp) {
            var appendedElements = [];
            var firstContainer = true;

            self.each(function (index, container) {
                var newElements = appendCoreSingle(container, content, insertOp);
                if (firstContainer) {
                    appendedElements = newElements;
                    firstContainer = false;
                }
            });

            var ss = vp.dom.wrapElements(appendedElements);
            return ss;
        }
        dom.appendCoreMulti = appendCoreMulti;
    })(vp.dom || (vp.dom = {}));
    var dom = vp.dom;
})(vp || (vp = {}));
//# sourceMappingURL=insertAppend.js.map

///----------------------------------------------------------------
/// (from _dom\isFuncs.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// isFuncs.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - functions for testing object categories
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (utils) {
        utils.isFireFox = navigator.userAgent.toLowerCase().contains("firefox");
        utils.isChrome = navigator.userAgent.toLowerCase().contains("chrome");

        //export var isIE = (navigator.appName == 'Microsoft Internet Explorer');
        //export var isIE = navigator.userAgent.contains("Trident");
        utils.isIE = navigator.userAgent.toLowerCase().contains("trident");
        utils.isIE11 = navigator.userAgent.contains("Trident/7.0");

        function isUndefined(obj) {
            return (typeof obj === "undefined");
        }
        utils.isUndefined = isUndefined;

        function isDefined(obj) {
            return (!(typeof obj === "undefined"));
        }
        utils.isDefined = isDefined;

        /// returns true if obj is a VuePlot visualization element.
        function isVuePlotControl(obj) {
            return (obj && (!(typeof obj.control === "undefined")));
        }
        utils.isVuePlotControl = isVuePlotControl;

        /// is obj an svg child element?
        function isSvgElement(obj) {
            var isSvg = (obj && obj.tagName == "svg") ? false : vp.utils.isSvgDocOrElement(obj);
            return isSvg;
        }
        utils.isSvgElement = isSvgElement;

        /// is this element an svg document or svg child element?
        function isSvgDocOrElement(elem) {
            var isSvg = false;
            var parent = elem;

            while ((parent != null) && (parent != document)) {
                if (parent.tagName == "svg") {
                    isSvg = true;
                    break;
                }

                if (parent.tagName == "foreignObject") {
                    isSvg = false;
                    break;
                }

                if (parent.parentNode == null) {
                    // CHW: return true when root is an SVG.*Element
                    var cname = parent.constructor.toString();

                    if (cname.match(/object SVG.*Element/i)) {
                        // consider part of SVG tree if root element is an SVG element
                        isSvg = true;
                        break;
                    }
                }

                parent = parent.parentNode;
            }

            return isSvg;
        }
        utils.isSvgDocOrElement = isSvgDocOrElement;

        /// is obj an HTML 5 canvas ----
        function isCanvas(obj) {
            return ((obj != null) && (obj.tagName == "CANVAS"));
        }
        utils.isCanvas = isCanvas;

        /// is obj a lightweight canvas child? ----
        function isCanvasChild(obj) {
            return ((obj != null) && (obj.rootContainer) && (obj.rootContainer.canvas.tagName == "CANVAS"));
        }
        utils.isCanvasChild = isCanvasChild;

        function isCanvasContainer(obj) {
            return ((obj != null) && (obj.rootContainer == obj));
        }
        utils.isCanvasContainer = isCanvasContainer;

        /// returns true if obj is a function.
        function isFunction(obj) {
            return (typeof obj === "function");
        }
        utils.isFunction = isFunction;

        /// returns true if obj is a number.
        function isNumber(obj) {
            return (typeof obj === "number");
        }
        utils.isNumber = isNumber;

        /// returns true if obj is an object (not a primitive).
        function isObject(obj) {
            return (typeof obj === "object");
        }
        utils.isObject = isObject;

        /// returns true if obj is a boolean value (true/false).
        function isBoolean(obj) {
            return (typeof obj === "boolean");
        }
        utils.isBoolean = isBoolean;

        /// returns true if obj is a number and not a NAN and not infinity
        function isValidNumber(obj) {
            return ((typeof obj === "number") && (!isNaN(obj)) && (isFinite(obj)));
        }
        utils.isValidNumber = isValidNumber;

        /// returns true if obj is an array.
        function isArray(obj) {
            //return (typeof this === "array");
            return (obj == null) ? false : Object.prototype.toString.call(obj) === "[object Array]";
        }
        utils.isArray = isArray;

        /// returns true if obj is a string.
        function isString(obj) {
            return (typeof obj === "string");
        }
        utils.isString = isString;

        /// returns true if obj is a selected set.
        function isSelectedSet(elem) {
            return ((elem.ctr == "vp.dom.selectedSet") || (elem instanceof vp.dom.singleWrapperSuperClass));
        }
        utils.isSelectedSet = isSelectedSet;
    })(vp.utils || (vp.utils = {}));
    var utils = vp.utils;
})(vp || (vp = {}));
//# sourceMappingURL=isFuncs.js.map

///----------------------------------------------------------------
/// (from _dom\styleSheet.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// styleSheet.ts.  Copyright (c) 2014 Microsoft Corporation.
///                part of the vuePlot library - misc utility functions.
///
///     - adapted from code on the web.  Need URL...
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (dom) {
        var styleSheetClass = (function () {
            function styleSheetClass() {
                //---- local state ----
                this._styleSheet = null;
                this._elem = null;
                this._elem = document.createElement('style');
                this._elem.type = 'text/css';

                //---- append to document <head> section ----
                var head0 = document.getElementsByTagName('head')[0];
                head0.appendChild(this._elem);

                //---- elem is not the final sheet object, so get the newly created sheet ----
                this._styleSheet = document.styleSheets[document.styleSheets.length - 1];
            }
            //---- add a rule to this style sheet ----
            styleSheetClass.prototype.addRule = function (selector, style) {
                var myRules = this._styleSheet.rules || this._styleSheet.cssRules;

                var atIndex = myRules.length;
                this._styleSheet.insertRule(selector + ' {' + style + '}', atIndex);

                return this;
            };

            //---- remove this style sheet from the document
            styleSheetClass.prototype.remove = function () {
                this._styleSheet.remove();
            };

            styleSheetClass.prototype.sheet = function () {
                return this._styleSheet;
            };

            /// propety: id
            styleSheetClass.prototype.id = function (value) {
                if (arguments.length === 0) {
                    return vp.dom.id(this._elem);
                }

                vp.dom.id(this._elem, value);
            };
            return styleSheetClass;
        })();
        dom.styleSheetClass = styleSheetClass;

        function createStyleSheet() {
            return new styleSheetClass();
        }
        dom.createStyleSheet = createStyleSheet;
    })(vp.dom || (vp.dom = {}));
    var dom = vp.dom;
})(vp || (vp = {}));
//# sourceMappingURL=styleSheet.js.map

///----------------------------------------------------------------
/// (from _dom\utils.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// utils.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - general utility functions
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (utils) {
        utils.appStartTime = +Date.now();

        function indexKeyFunc(dataRecord, index) {
            return index;
        }
        utils.indexKeyFunc = indexKeyFunc;

        /// send "msg" to the browser debug console, if present.
        function debug(msg) {
            if (window.console && window.console.log) {
                var now = +Date.now() - vp.utils.appStartTime;
                var secs = now / 1000;
                var time = "@" + secs.toFixed(3);

                console.log(time + ": " + msg);
            }
        }
        utils.debug = debug;

        /// test condition - use alert if false
        function assert(cond, msg) {
            if (!cond) {
                alert("vp.assert: conditon failed");
            }
        }
        utils.assert = assert;

        /// return true if object has one or more dictionary keys.
        function hasKeys(obj) {
            /// fastest cross-browser test
            var count = 0;

            for (var k in obj) {
                count++;
                break;
            }

            return (count > 0);
        }
        utils.hasKeys = hasKeys;

        utils.computedStyles = {};

        function getComputedStyleFromClass(shapeName, parentClassName, className) {
            var key = shapeName + "^" + className;
            var cs = utils.computedStyles[key];
            if (!cs) {
                //---- create a temp SVG document ----
                var svg = vp.select(document.body).append("svg").addClass(parentClassName);

                var elem = svg.append(shapeName).addClass(className);

                //---- let browser system compute all casdaded styles as of this moment ----
                var css = window.getComputedStyle(elem[0]);

                //---- copy a subset of the properties we need because when we ----
                //---- remove our temp. elements, the css will be updated and useless to us ----
                cs = {
                    fill: css.fill, stroke: css.stroke, strokeWidth: css.strokeWidth, opacity: css.opacity,
                    fontFamily: css.fontFamily, fontSize: css.fontSize, fontWeight: css.fontWeight, fontStyle: css.fontStyle,
                    strokeDasharray: css.strokeDasharray, strokeDashoffset: css.strokeDashoffset, textAnchor: css.textAnchor
                };

                utils.computedStyles[key] = cs;

                //---- clean up temp stuff ----
                elem.remove();
                svg.remove();
            }

            return cs;
        }
        utils.getComputedStyleFromClass = getComputedStyleFromClass;

        function getShapeId(element) {
            var id = "";
            var elem = element;

            if (elem.dataItem) {
                id = elem.dataItem.dataId + "," + elem.dataItem.key + ", " + elem.dataItem.shapeId;
            }

            return id;
        }
        utils.getShapeId = getShapeId;

        function toArray(pseudoArray) {
            var elems = [];

            for (var i = 0; i < pseudoArray.length; i++) {
                var elem = pseudoArray[i];
                elems.push(elem);
            }

            return elems;
        }
        utils.toArray = toArray;

        /** find HTML, SVG, or canvas elements that overlap with specificed rcBounds. */
        function getElementsInBounds(container, rcBounds, rcAdjusted) {
            var elems = [];

            var svgDoc = this.getCanvasOrSvgParent(container);

            if (svgDoc && svgDoc.getIntersectionList) {
                //---- very strange: getIntersectionList requires you to create the SVGRect this way ----
                var rc = svgDoc.createSVGRect();
                rc.x = rcBounds.left;
                rc.y = rcBounds.top;
                rc.width = rcBounds.width;
                rc.height = rcBounds.height;

                //---- returns a nodeList, which is not an array ----
                var nodeList = svgDoc.getIntersectionList(rc, null);

                elems = vp.utils.toArray(nodeList);
            } else {
                rcBounds = rcAdjusted;

                var kids = vp.dom.children(container);
                var svgIntersectCount = 0;

                for (var k = 0; k < kids.length; k++) {
                    var kid = kids[k];
                    if (kid.tagName != "defs") {
                        var rcLight = vp.dom.getBounds(kid, true);

                        //---- start with simple BOUNDING BOX test ----
                        var intersects = vp.geom.rectIntersectsRect(rcBounds, rcLight);

                        if (intersects) {
                            elems.push(kid);

                            if (vp.utils.isSvgElement(kid)) {
                                svgIntersectCount++;
                            }
                        }
                    }
                }

                //---- now, render to canvas and do test there ----
                //---- we can do more precise testing on SVG shapes, but limit shapes to prevent long waits ----
                if ((svgIntersectCount > 0) && (svgIntersectCount <= 100)) {
                    //---- do a more precise test using inkHitTest --
                    elems = getElementsInkHitTest(rcBounds, elems);
                }
            }

            //---- filter out non-SHAPES ----
            elems = elems.where(function (elem, index) {
                var id = getShapeId(elem);
                return (id != null && id != "");
            });

            //---- remove duplicates (so that 2 shapes for same id don't cancel each other out) ----
            elems = elems.distinct(function (elem, index) {
                return getShapeId(elem);
            });

            return elems;
        }
        utils.getElementsInBounds = getElementsInBounds;

        function getElementsInkHitTest(rcBand, elems) {
            var newElems = [];
            var inkHitTest = null;

            try  {
                for (var k = 0; k < elems.length; k++) {
                    var elem = elems[k];
                    var intersects = true;

                    if (vp.utils.isSvgElement(elem)) {
                        var tag = elem.tagName;
                        if ((tag != "rect") && (tag != "image") && (tag != "text")) {
                            //---- complex shape passes bounding box test ----
                            //---- we need to draw shape on a temp canvas to see if it overlaps rect ----
                            if (!inkHitTest) {
                                //--- small tweak required to rcBand for inkHit testing (why?) ----
                                var rcInk = vp.geom.rect(rcBand.left, rcBand.top + 4, rcBand.width, rcBand.height);
                                inkHitTest = new vp.internal.inkHitTest(rcInk);
                            }

                            intersects = inkHitTest.doesShapeOverlap(elem);
                        }
                    }

                    if (intersects) {
                        newElems.push(elem);
                    }
                }
            } finally {
                if (inkHitTest) {
                    inkHitTest.close();
                }
            }

            return newElems;
        }
    })(vp.utils || (vp.utils = {}));
    var utils = vp.utils;
})(vp || (vp = {}));
//# sourceMappingURL=utils.js.map

///----------------------------------------------------------------
/// (from _dom\wrapperTests.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// wrapperTests.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - works out (in the small) how to design our classes to support function wrapping.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    /// Lessons learned:
    ///     - Interfaces: use "T" as return signature for wrapper functions
    ///     - Base Classes: use "T" name as return signature for wrapper functions
    ///     - Outer Classes: use class name as return signature for all wrapper functions
    ///     - Select function: should return a concrete version of the IWrapper interface ("IWrapperOuter")
    ///
    ///     - it is important that interfaces return "T" and not "MyInterface<T>" so that the chaining
    ///       doesn't get stuck at a base interface level - it always needs to reflect the chaining methods of
    ///       the outer class.
    (function (internal) {
        var SmallWrapperImpl = (function () {
            function SmallWrapperImpl() {
            }
            SmallWrapperImpl.prototype.background = function (value) {
                return this;
            };

            SmallWrapperImpl.prototype.close = function () {
                return this;
            };

            SmallWrapperImpl.prototype.foo = function () {
                var abc;
                abc.background("hi there").background("sdf").foo().background("asdf").background("sdf").foo();

                return this;
            };
            return SmallWrapperImpl;
        })();
        internal.SmallWrapperImpl = SmallWrapperImpl;

        function smallSelect(abc) {
            return new SmallWrapper3Impl();
        }
        internal.smallSelect = smallSelect;

        function testSmallSelect() {
            var wrapper = smallSelect("abc");

            wrapper.background("sdf").background("werw").fill("wer").background("wer").close().fill("sdf");
        }

        var SmallWrapper2Base = (function () {
            function SmallWrapper2Base() {
            }
            SmallWrapper2Base.prototype.background = function (value) {
                return this;
            };

            SmallWrapper2Base.prototype.fill = function (value) {
                return this;
            };

            SmallWrapper2Base.prototype.close = function () {
                return this;
            };

            SmallWrapper2Base.prototype.foobar = function () {
                var abc;

                abc.foobar().background("asdf").fill("asdf").fill("sdf").background("asdf").foobar().fill("asdf").background("sdf").fill("er").foobar().close().foobar();

                return this;
            };
            return SmallWrapper2Base;
        })();
        internal.SmallWrapper2Base = SmallWrapper2Base;

        var SmallWrapper2Impl = (function (_super) {
            __extends(SmallWrapper2Impl, _super);
            function SmallWrapper2Impl() {
                _super.apply(this, arguments);
            }
            return SmallWrapper2Impl;
        })(SmallWrapper2Base);
        internal.SmallWrapper2Impl = SmallWrapper2Impl;

        var SmallWrapper3Impl = (function (_super) {
            __extends(SmallWrapper3Impl, _super);
            function SmallWrapper3Impl() {
                _super.apply(this, arguments);
            }
            return SmallWrapper3Impl;
        })(SmallWrapper2Impl);
        internal.SmallWrapper3Impl = SmallWrapper3Impl;
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));
//# sourceMappingURL=wrapperTests.js.map
///-----------------------------------------------------------------------------------------------------------------
/// markBase.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - data-based generation "mark" base class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (marks) {
        /** Base class for all other mark classes. */
        var markBaseClass = (function (_super) {
            __extends(markBaseClass, _super);
            /** "container" can be null, a string ("svg", "canvas", or "webGl"), or a container (SVG doc, SVG "g", Canvas element,
            or a canvas group element).  "shapeName" is name of the shape when an SVG or Canavas container is used.
            "glShapeName" is the name of the associated vuePlot webGl shape. */
            function markBaseClass(container, shapeName, glShapeName, useWebGl, className) {
                _super.call(this, container);
                this._seriesIndex = 0;
                this._seriesCount = 1;
                this._animationDuraton = 0;
                this._onShaderCallback = null;
                this._data = null;
                this._fromGlParams = null;
                this._computedStyle = undefined;

                var result = this.createContainerIfNeeded(container);
                container = result.container;
                useWebGl = (result.useWebGl !== undefined) ? result.useWebGl : useWebGl;

                this._container = container;
                this.elem = container;
                this._shapeName = shapeName;
                this._glShapeName = glShapeName;
                this._className = className;

                this._jsParser = new marks.jsParserClass();

                //---- support for eBook calling ----
                var useWebGL = ((window["$usingWebGL"] === true || useWebGl) && (glShapeName != null));

                if (useWebGL) {
                    this._containerType = 3 /* glCanvas */;

                    this._glBuilder = new marks.glBuilderClass(container, glShapeName);
                    this._glBuilder.statsCallback(function (fps, shapesDrawn, elapsed) {
                        var w = window;
                        if (w.$setMarkStats) {
                            w.$setMarkStats(fps, shapesDrawn);
                        }
                    });
                } else {
                    if (container.tagName.toLowerCase() == "canvas") {
                        this._containerType = 1 /* canvasElem */;
                    } else if (container.rootContainer) {
                        this._containerType = 2 /* canvasGroup */;
                    } else {
                        this._containerType = 0 /* svg */;
                    }
                }

                if (this._containerType == 1 /* canvasElem */) {
                    //var request = (useWebGL) ? "3d" : "2d";
                    var canvasContainerElem = vp.canvas.selectContext(container, "2d")[0];
                    canvasContainerElem.clear();

                    this._container = canvasContainerElem;
                }

                var rootElem = this._container;
                if (!useWebGL) {
                    //---- create our own GROUP that will parent the generated shapes ----
                    var id = "rootElem-" + ((className) ? className : shapeName);

                    var groupElem = vp.select(container).append("g").id(id);

                    rootElem = groupElem[0];
                }

                this._rootElem = rootElem;

                //---- NOTE: "rootElem" is the container that shapes will be generated into ----
                this._dataAnimMgr = new vp.animation.dataAnimMgrExClass(rootElem, null, shapeName, "markBaseClass");
                this._dataAnimMgr.animDuration(this._animationDuraton);

                this._dataAnimMgr.statsCallback(function (fps, shapesDrawn, elapsed) {
                    var w = window;
                    if (w.$setMarkStats) {
                        w.$setMarkStats(fps, shapesDrawn);
                    }
                });

                if (className) {
                    if (this._containerType == 1 /* canvasElem */ || this._containerType == 2 /* canvasGroup */) {
                        var parentClassName = vp.select(this._container).attr("className");

                        this._computedStyle = vp.utils.getComputedStyleFromClass(shapeName, parentClassName, className);
                    }
                }
            }
            markBaseClass.prototype.createContainerIfNeeded = function (container) {
                if (!container) {
                    container = "svg";
                }

                var useWebGl = undefined;

                if (vp.utils.isString(container)) {
                    var containType = container;
                    useWebGl = (containType == "webGl");

                    if (containType == "svg") {
                        container = vp.dom.createSvg("svg");
                    } else if (containType == "canvas" || useWebGl) {
                        container = vp.dom.createElement(null, "canvas");
                    } else {
                        throw "Error - container string must be 'svg', 'canvas', or 'webGl', but was '" + containType + "'";
                    }
                }

                return { container: container, useWebGl: useWebGl };
            };

            markBaseClass.prototype.rootElem = function () {
                return this._rootElem;
            };

            markBaseClass.prototype.translate = function (x, y, makeCrispAdjustment) {
                if (typeof makeCrispAdjustment === "undefined") { makeCrispAdjustment = false; }
                if (this._rootElem) {
                    vp.select(this._rootElem).translate(x, y, makeCrispAdjustment);
                }

                return this;
            };

            markBaseClass.prototype.onShade = function (callback) {
                if (arguments.length === 0) {
                    return this._onShaderCallback;
                }

                this._onShaderCallback = callback;
                return this;
            };

            markBaseClass.prototype.update = function () {
                var args = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    args[_i] = arguments[_i + 0];
                }
                var myArgs = [undefined].concat(args);

                this.generate.apply(this, myArgs);
            };

            markBaseClass.prototype.generate = function (data) {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < (arguments.length - 1); _i++) {
                    args[_i] = arguments[_i + 1];
                }
                //---- support a few shortcuts for specifying the data ----
                if (data === true) {
                    //---- 1 row of dummy data ----
                    data = [1];
                } else if (data === false) {
                    //---- 0 rows of dummy data ----
                    data = [];
                } else if (vp.utils.isNumber(data)) {
                    data = vp.utils.range(data);
                }

                if (data !== undefined) {
                    this._data = data;
                }

                if (!this._onShaderCallback) {
                    throw "Error - onUpdate callback not defined for mark during generate() call";
                }

                var context = null;
                var transition = null;

                for (var a = 0; a < args.length; a++) {
                    var arg = args[a];
                    if (arg instanceof vp.marks.transitionClass) {
                        transition = arg;
                    } else {
                        context = arg;
                    }
                }

                if (this._containerType == 3 /* glCanvas */) {
                    var glParams = this._jsParser.getGlParams(this._onShaderCallback, context);

                    this._glBuilder.drawScene(this._data, transition, glParams, this._fromGlParams);
                    this._fromGlParams = glParams;
                } else {
                    this.eraseCanvas();

                    if (transition) {
                        this._dataAnimMgr.animDelay(transition._delay).animDuration(transition._animDuration).animEasing(transition._animEasing).keyFunc(transition._primaryKey).enterAnim(transition._enter).exitAnim(transition._exit).updateAnim(transition._update);
                    }

                    if (data === undefined) {
                        this._dataAnimMgr.updateWithoutDataChange();
                    } else {
                        this._dataAnimMgr.setData(data);
                    }

                    this._dataAnimMgr.updateShapes(this._seriesIndex, this._seriesCount, function (elem, data, index, isNew) {
                        _this.applyClass(elem);

                        _this._onShaderCallback(elem, data.data, index, isNew, context, transition);

                        _this.postProcessShape(elem);
                    });
                }
            };

            markBaseClass.prototype.applyClass = function (elem) {
                if (this._className) {
                    var containType = this._containerType;

                    if (containType == 0 /* svg */) {
                        //---- just addClass on the element ----
                        vp.select(elem).addClass(this._className);
                    } else if (this._computedStyle) {
                        //---- build style for named class ----
                        //var style = { fill: "gray", stroke: "black", strokeWidth: 1 };
                        elem.applyStyle(this._computedStyle);
                    }
                }
            };

            markBaseClass.prototype.postProcessShape = function (element) {
            };

            markBaseClass.prototype.clear = function () {
                this._dataAnimMgr.clear();

                this.eraseCanvas();

                return this;
            };

            markBaseClass.prototype.eraseCanvas = function () {
                if (this._glBuilder) {
                    this._glBuilder.clear();
                } else {
                    //vp.select(this._groupElem)
                    //    .clear();
                    var ctx = this._container.ctx;
                    if (ctx) {
                        var canvas = vp.select(this._container.canvas);

                        var w = canvas.width();
                        var h = canvas.height();

                        ctx.clearRect(0, 0, w, h);
                    }
                }
            };
            return markBaseClass;
        })(vp.dom.singleWrapperSuperClass);
        marks.markBaseClass = markBaseClass;

        var markBase = (function (_super) {
            __extends(markBase, _super);
            function markBase() {
                _super.apply(this, arguments);
            }
            return markBase;
        })(markBaseClass);
        marks.markBase = markBase;

        (function (containerType) {
            containerType[containerType["svg"] = 0] = "svg";
            containerType[containerType["canvasElem"] = 1] = "canvasElem";
            containerType[containerType["canvasGroup"] = 2] = "canvasGroup";
            containerType[containerType["glCanvas"] = 3] = "glCanvas";
            containerType[containerType["glGroup"] = 4] = "glGroup";
        })(marks.containerType || (marks.containerType = {}));
        var containerType = marks.containerType;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=$markBase.js.map

///----------------------------------------------------------------
/// (from _marks\circleMark.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// circleMark.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas CIRCLE primitives.  Can be used with animations.  Core function
        is "update()". */
        var circleMarkClass = (function (_super) {
            __extends(circleMarkClass, _super);
            function circleMarkClass(container, className) {
                _super.call(this, container, "circle", null, undefined, className);
            }
            return circleMarkClass;
        })(marks.markBaseClass);
        marks.circleMarkClass = circleMarkClass;

        function createCircleMark(container, className) {
            return new circleMarkClass(container, className);
        }
        marks.createCircleMark = createCircleMark;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=circleMark.js.map

///----------------------------------------------------------------
/// (from _marks\composerMark.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// composerMark.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlotCore library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas group primitives.  Can be used with animations.  Core function
        is "update()". */
        var composerMarkClass = (function (_super) {
            __extends(composerMarkClass, _super);
            function composerMarkClass(container, className, ctrCallback) {
                _super.call(this, container, "g", null, false, className);
                this._elemShaderInstances = {};

                this._ctrCallback = ctrCallback;
            }
            composerMarkClass.prototype.localShader = function (elem, data, index, isNew, context, transition) {
                var shaderInst = null;

                if (isNew) {
                    var instance = this._ctrCallback(elem);
                    this._elemShaderInstances[elem] = instance;
                } else {
                    shaderInst = this._elemShaderInstances[elem];
                }

                //---- call the instance to shade the composed shape ----
                shaderInst.shadeMarks(transition, data.data, index, isNew, context);
                //---- finally, call the user callback, via the baseclass ----
                //super.localShader(elem, data, index, isNew, context, transition);
            };
            return composerMarkClass;
        })(marks.markBaseClass);
        marks.composerMarkClass = composerMarkClass;

        function createComposerMark(container, className, ctrCallback) {
            return new composerMarkClass(container, className, ctrCallback);
        }
        marks.createComposerMark = createComposerMark;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=composerMark.js.map

///----------------------------------------------------------------
/// (from _marks\ellipseMark.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// ellipseMark.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas ellipse primitives.  Can be used with animations.  Core function
        is "update()". */
        var ellipseMarkClass = (function (_super) {
            __extends(ellipseMarkClass, _super);
            function ellipseMarkClass(container, className) {
                _super.call(this, container, "ellipse", null, false, className);
            }
            return ellipseMarkClass;
        })(marks.markBaseClass);
        marks.ellipseMarkClass = ellipseMarkClass;

        function createEllipseMark(container, className) {
            return new ellipseMarkClass(container, className);
        }
        marks.createEllipseMark = createEllipseMark;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=ellipseMark.js.map

///----------------------------------------------------------------
/// (from _marks\glBuilder.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// glBuilder.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlotCore library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allFiles.ts" />
var vp;
(function (vp) {
    (function (marks) {
        /** WebGL helper class for marks. */
        var glBuilderClass = (function () {
            function glBuilderClass(canvas, glShapeName) {
                this._trans3d = null;
                this._animation = null;
                this._usingPosition = false;
                this._shapeVertices = null;
                this._usingWidth = false;
                this._randomVectors = {};
                //---- stats ----
                this._animStartTime = 0;
                this._animFrameCount = 0;
                this._animFPS = 0;
                this._shapesDrawn = 0;
                this._statsCallback = null;
                this._canvas = canvas;
                this._gl = canvas.getContext("webgl");
                this._glShapeName = glShapeName;

                if (!this._gl) {
                    this._gl = canvas.getContext("experimental-webgl");
                }

                if (!this._gl) {
                    alert("Your browser does not support WebGL");
                    return;
                }

                var rotation = 0;
                var elevation = 90;
                var width = vp.select(canvas).width();
                var height = vp.select(canvas).height();

                this._trans3d = vp.plotBox.createTransform3d(width, height, rotation, elevation, 0, width, 0, height, -1, 1);
            }
            glBuilderClass.prototype.init = function (data, glParams, fromGlParams) {
                this._gl.viewportWidth = this._canvas.width;
                this._gl.viewportHeight = this._canvas.height;

                this.initBuffers(data, glParams, fromGlParams);

                this.initShaders(glParams, fromGlParams);
            };

            glBuilderClass.prototype.updateScreenSize = function (w, h) {
                var changed = false;

                //---- prevent negative numbers ----
                w = Math.max(0, w);
                h = Math.max(0, h);
                var gl = this._gl;

                if (gl) {
                    if (w != gl.viewportWidth) {
                        gl.viewportWidth = w;
                        changed = true;
                    }

                    if (h != gl.viewportHeight) {
                        gl.viewportHeight = h;
                        changed = true;
                    }
                }

                if (changed) {
                    this._trans3d.screenWidth(w).screenHeight(h).xMax(w).yMax(h).rebuild();
                    //this.onMatrixChanged();
                    //this.deleteHitTestMap();      // needs to be rebuilt
                }
            };

            glBuilderClass.prototype.buildVertexShader = function (glParams, fromGlParams) {
                var usePosition = this._usingPosition;

                var a = "//---- data buffers ----\n";
                a += "attribute float index;\n";

                if (usePosition) {
                    var vdim = this._shapeVertices.length / 3;

                    a += "attribute float vertexIndex_;\n";
                }

                for (var i = 0; i < glParams.dataColNames.length; i++) {
                    var colName = glParams.dataColNames[i];
                    a += "attribute float " + colName + ";\n";
                }

                for (var i = 0; i < glParams.randomColNames.length; i++) {
                    var colName = glParams.randomColNames[i];
                    a += "attribute float " + colName + ";\n";
                }

                a += "\n";
                a += "//---- constants ----\n";
                if (usePosition) {
                    a += "uniform vec3 vertices_[" + vdim + "];\n";
                }

                a += "uniform mat4 mvpMatrix_;\n";
                a += "uniform vec3 colors_[3];\n";
                a += "uniform float colorIndex_;\n";

                if (fromGlParams) {
                    a += "uniform float colorIndexFrom_;\n";
                    a += "uniform float percent_;\n";
                }
                a += "\n";

                a += "//---- shader output variables ----\n";
                a += "varying vec4 vColor;\n";
                a += "\n";
                a += "%functions%";

                a += "void main(void)\n";
                a += "{\n";

                a += "%cmds%";

                a += "  vColor = color_;\n";

                if (usePosition) {
                    if (this._usingWidth) {
                        a += "  vec3 v_ = vertices_[int(vertexIndex_)];\n";
                        a += "  vec3 pos_ = vec3(v_.x * width_, v_.y * height_, 0) + vec3(x_, y_, 0.0);\n";
                        a += "  gl_Position = mvpMatrix_ * vec4(pos_, 1.0);\n";
                    } else {
                        a += "  vec3 pos_ = vertices_[int(vertexIndex_)] * size_ + vec3(x_, y_, 0.0);\n";
                        a += "  gl_Position = mvpMatrix_ * vec4(pos_, 1.0);\n";
                    }
                } else {
                    a += "  gl_Position = mvpMatrix_ * vec4(x_, y_, 0.0, 1.0);\n";
                    a += "  gl_PointSize = size_;  \n";
                }

                a += "}\n";

                return a;
            };

            glBuilderClass.prototype.fragShader = function () {
                var a = "\n \
                     precision mediump float;\n \
                     varying vec4 vColor;\n \
                            \n \
                     void main(void )\n \
                     {\n \
                        gl_FragColor =  vColor;  \n \
                     }\n \
                ";

                return a;
            };

            glBuilderClass.prototype.clear = function () {
                if (this._gl) {
                    var gl = this._gl;
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                }
            };

            glBuilderClass.prototype.drawScene = function (data, transition, glParams, fromGlParams) {
                var _this = this;
                this._usingPosition = (this._glShapeName != "point");

                this.init(data, glParams, fromGlParams);

                var gl = this._gl;

                //---- clear screen with BLACK color ----
                var cr = vp.select(this._canvas).css("background-color");
                var bg = vp.color.getColorFromString(cr);

                gl.clearColor(bg[0] / 255, bg[1] / 255, bg[2] / 255, 1);
                gl.enable(gl.DEPTH_TEST);

                //gl.enable(0x8642);     // gl.PROGRAM_POINT_SIZE  (undefined in some browsers)
                //gl.pointSize(33);      // for some reason, this one was not implemented (but vertex shader DOES support gl_pointSize)
                //---- enable blending ----
                gl.enable(gl.BLEND);
                gl.disable(gl.DEPTH_TEST); // must turn off (takes priority over blending)

                //---- IE11 bug workaround - use simple blending because IE11 doesn't support the below alternative ----
                //gl.blendFunc(gl.SRC_ALPHA, gl.DST_ALPHA);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                //---- set the shader constants ----
                this.setShaderConstants(glParams, fromGlParams);

                gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

                gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);

                //---- set up buffer mapping ----
                var floats = 1;

                if (this._usingPosition) {
                    floats++;
                }

                floats += glParams.dataColNames.length;
                floats += glParams.randomColNames.length;

                var strideInBytes = floats * 4;

                var buffOffset = 0;

                if (this._shaderProgram.alIndex > -1) {
                    gl.vertexAttribPointer(this._shaderProgram.alIndex, 1, gl.FLOAT, false, strideInBytes, buffOffset);
                }
                buffOffset += 4; // we always add INDEX data, so always offset by 4 here

                if (this._usingPosition) {
                    if (this._shaderProgram.alVertexIndex > -1) {
                        gl.vertexAttribPointer(this._shaderProgram.alVertexIndex, 1, gl.FLOAT, false, strideInBytes, buffOffset);
                    }
                    buffOffset += 4;
                }

                for (var i = 0; i < glParams.dataColNames.length; i++) {
                    var dataColName = glParams.dataColNames[i];

                    if (this._shaderProgram[dataColName] > -1) {
                        gl.vertexAttribPointer(this._shaderProgram[dataColName], 1, gl.FLOAT, false, strideInBytes, buffOffset);
                    }
                    buffOffset += 4;
                }

                for (var i = 0; i < glParams.randomColNames.length; i++) {
                    var randColName = glParams.randomColNames[i];

                    if (this._shaderProgram[randColName] > -1) {
                        gl.vertexAttribPointer(this._shaderProgram[randColName], 1, gl.FLOAT, false, strideInBytes, buffOffset);
                    }
                    buffOffset += 4;
                }

                this.drawSceneFrame(0);

                //---- start an animation ----
                if (fromGlParams && transition) {
                    var update = transition.update;

                    var duration = (update && update.duration !== undefined) ? update.duration : transition.duration();
                    var easing = (update && update.easeing !== undefined) ? update.easeing : transition.easing();
                    var delay = (update && update.delay !== undefined) ? update.delay : transition.delay();

                    this._animStartTime = +Date.now();
                    this._animFrameCount = 0;

                    var animation = vp.animation.createAnimation(null, duration, easing, null, delay).onFrame(function (percent) {
                        _this.drawSceneFrame(percent);
                    }).onAnimationComplete(function () {
                        var elapsed = +Date.now() - _this._animStartTime;
                        _this._animFPS = Math.round(_this._animFrameCount / (elapsed / 1000));

                        if (_this._statsCallback) {
                            _this._statsCallback(_this._animFPS, _this._shapesDrawn, elapsed);
                        }
                    });
                }
            };

            glBuilderClass.prototype.drawSceneFrame = function (percent) {
                var gl = this._gl;

                //---- clear viewport ----
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                //---- update percent constant ----
                this._gl.uniform1f(this._shaderProgram.ulPercent, percent);

                //vp.utils.debug("drawSceneFrame: percent=" + percent);
                //---- DRAW PRIMITIVES ----
                if (this._usingPosition) {
                    gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
                } else {
                    gl.drawArrays(gl.POINTS, 0, this._vertexBuffer.numItems);
                }

                this._shapesDrawn = this._vertexBuffer.numItems;
                this._animFrameCount++;
            };

            glBuilderClass.prototype.applyShaderParams = function (shader, glParams, fromGlParams) {
                var cmd = "  float x_ = " + glParams.x + ";\n";
                cmd += "  float y_ = " + glParams.y + ";\n";

                if (this._usingWidth) {
                    cmd += "  float width_ = " + glParams.width + ";\n";
                    cmd += "  float height_ = " + glParams.height + ";\n";
                } else if (this._glShapeName == "line2d") {
                    cmd += "  float size_ = 1.0;\n";
                    cmd += "  float strokeWidth_ = " + glParams.strokeWidth + ";\n";
                } else {
                    cmd += "  float size_ = " + glParams.size + ";\n";
                }

                cmd += "  float opacity_ = " + glParams.opacity + ";\n";
                cmd += "  vec4 color_ = vec4(colors_[int(colorIndex_)], opacity_);\n";
                cmd += "\n";

                var cmds = glParams.cmds + cmd;

                if (fromGlParams) {
                    //--- run code in a inner block so we avoid variable name conflicts ----
                    var cmdFrom = "\n";
                    cmdFrom += "  if (percent_ < 1.0)\n";

                    cmdFrom += "  {\n";
                    cmdFrom += fromGlParams.cmds;
                    cmdFrom += "\n";
                    cmdFrom += "    float xFrom_ = " + fromGlParams.x + ";\n";
                    cmdFrom += "    float yFrom_ = " + fromGlParams.y + ";\n";
                    cmdFrom += "    float sizeFrom_ = " + fromGlParams.size + ";\n";
                    cmdFrom += "    vec4 colorFrom_ = vec4(colors_[int(colorIndexFrom_)], 1.0);\n";
                    cmdFrom += "\n";
                    cmdFrom += "    x_ = mix(xFrom_, x_, percent_);\n";
                    cmdFrom += "    y_ = mix(yFrom_, y_, percent_);\n";
                    cmdFrom += "    size_ = mix(sizeFrom_, size_, percent_);\n";
                    cmdFrom += "    color_ = mix(colorFrom_, color_, percent_);\n";
                    cmdFrom += "  }\n";

                    cmds += cmdFrom;
                }

                //---- add translated statements ----
                var str = shader.replace(/%functions%/, glParams.functions);
                var str = str.replace(/%cmds%/, cmds);

                return str;
            };

            glBuilderClass.prototype.getShader = function (gl, id, glParams, fromGlParams) {
                var str = (id == "shader-fs") ? this.fragShader() : this.buildVertexShader(glParams, fromGlParams);

                var shader;
                if (id == "shader-fs") {
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                } else if (id == "shader-vs") {
                    str = this.applyShaderParams(str, glParams, fromGlParams);

                    //---- store for easy access by VuePlot eBook UI ----
                    var w = window;
                    if (w.setVertexShader) {
                        w.setVertexShader(this._canvas, str);
                    }

                    shader = gl.createShader(gl.VERTEX_SHADER);
                } else {
                    return null;
                }

                gl.shaderSource(shader, str);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    alert(gl.getShaderInfoLog(shader));
                    return null;
                }

                return shader;
            };

            glBuilderClass.prototype.initShaders = function (glParams, fromGlParams) {
                var w = window;
                var gl = this._gl;

                this._shaderProgram = this._gl.createProgram();
                var program = this._shaderProgram;

                var fragmentShader = this.getShader(this._gl, "shader-fs", null, null);
                var vertexShader = this.getShader(this._gl, "shader-vs", glParams, fromGlParams);

                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    alert("Could not initialise shaders");
                }

                gl.useProgram(program);

                //---- attribute locations ----
                //---- map "index" to buffer ----
                program.alIndex = gl.getAttribLocation(program, "index");
                if (program.alIndex > -1) {
                    gl.enableVertexAttribArray(program.alIndex);
                }

                program.alVertexIndex = gl.getAttribLocation(program, "vertexIndex_");
                if (program.alVertexIndex > -1) {
                    gl.enableVertexAttribArray(program.alVertexIndex);
                }

                for (var i = 0; i < glParams.dataColNames.length; i++) {
                    var dataColName = glParams.dataColNames[i];

                    program[dataColName] = gl.getAttribLocation(program, dataColName);
                    if (program[dataColName] > -1) {
                        gl.enableVertexAttribArray(program[dataColName]);
                    }
                }

                for (var i = 0; i < glParams.randomColNames.length; i++) {
                    var randColName = glParams.randomColNames[i];

                    program[randColName] = gl.getAttribLocation(program, randColName);
                    if (program[randColName] > -1) {
                        gl.enableVertexAttribArray(program[randColName]);
                    }
                }

                //---- constant locations ----
                program.ulVertices = gl.getUniformLocation(program, "vertices_");
                program.ulColors = gl.getUniformLocation(program, "colors_");
                program.ulColorIndex = gl.getUniformLocation(program, "colorIndex_");
                program.ulColorIndexFrom = gl.getUniformLocation(program, "colorIndexFrom_");
                program.mvpMatrixUniform = gl.getUniformLocation(program, "mvpMatrix_");
                program.ulPercent = gl.getUniformLocation(program, "percent_");
                //alert("shaders initialized");
            };

            glBuilderClass.prototype.setShaderConstants = function (glParams, fromGlParams) {
                var gl = this._gl;
                var program = this._shaderProgram;

                this._gl.uniform1f(this._shaderProgram.ulPercent, 0);

                var usingStroke = (this._glShapeName == "line2d");

                //---- color palette ----
                var cr = (usingStroke) ? glParams.stroke : glParams.fill;
                if (!cr || cr.length != 3) {
                    cr = [0, 0, 0];
                }

                var crFrom = [.7, .2, .2];
                if (fromGlParams) {
                    crFrom = (usingStroke) ? fromGlParams.stroke : fromGlParams.fill;
                    if (!crFrom || crFrom.length != 3) {
                        crFrom = [.7, .2, .2];
                    }
                }

                gl.uniform3fv(program.ulColors, [
                    cr[0], cr[1], cr[2],
                    crFrom[0], crFrom[1], crFrom[2],
                    .2, .2, .7]); // blue

                if (this._shapeVertices) {
                    gl.uniform3fv(program.ulVertices, this._shapeVertices);
                }

                gl.uniform1f(this._shaderProgram.ulColorIndex, 0); // to color
                gl.uniform1f(this._shaderProgram.ulColorIndexFrom, 1); // from color

                //---- set MATRIX from camera ----
                var mvp = this._trans3d.getMatrix();

                gl.uniformMatrix4fv(program.mvpMatrixUniform, false, mvp.toArray());
            };

            glBuilderClass.prototype.initBuffers = function (data, glParams, fromGlParams) {
                this._vertexBuffer = this._gl.createBuffer();
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);

                var vertexBuff = [];
                var shape = this._glShapeName;
                var verticesPerRecord = 0;

                //---- add INDEX and SHAPE info ----
                if (shape == "point") {
                    verticesPerRecord = this.setPointVertices(data);
                } else if (shape == "triangle") {
                    verticesPerRecord = this.setTriangleVertices(data);
                } else if (shape == "rect2d") {
                    verticesPerRecord = this.setRect2dVertices(data);
                } else if (shape == "line2d") {
                    verticesPerRecord = this.setLine2dVertices(data);
                } else {
                    throw "Error: unsupported WebGl mark shape=" + shape;
                }

                //---- this number is independent of stride per vertex ----
                this._vertexBuffer.numItems = (verticesPerRecord == 0) ? (data.length) : (verticesPerRecord * data.length);

                for (var i = 0; i < data.length; i++) {
                    for (var j = 0; j < Math.max(1, verticesPerRecord); j++) {
                        //---- add a triangle vertex index----
                        vertexBuff.push(i); // record index

                        if (verticesPerRecord > 0) {
                            vertexBuff.push(j); // vertex index
                        }

                        for (var c = 0; c < glParams.origColNames.length; c++) {
                            var colName = glParams.origColNames[c];
                            if (colName == "value_number") {
                                var value = +data[i];
                            } else {
                                var value = +data[i][colName];
                            }

                            vertexBuff.push(value); // data column value
                        }

                        for (var c = 0; c < glParams.randomColNames.length; c++) {
                            var colName = "random" + (c + 1) + "_";
                            var vector = this.getRandomVector(colName, data.length);

                            var value = vector[i];
                            vertexBuff.push(value); // data column value
                        }
                    }
                }

                //var colCount = glParams.origColNames.length;
                this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(vertexBuff), this._gl.STATIC_DRAW);
                //alert("buffers initialized");
            };

            glBuilderClass.prototype.getRandomVector = function (name, count) {
                var vector = this._randomVectors[name];
                if (vector === undefined) {
                    vector = [];

                    for (var i = 0; i < count; i++) {
                        vector.push(Math.random());
                    }

                    this._randomVectors[name] = vector;
                } else if (vector.length < count) {
                    var oldCount = vector.length;

                    for (var i = oldCount; i < count; i++) {
                        vector.push(Math.random());
                    }
                }

                return vector;
            };

            glBuilderClass.prototype.setPointVertices = function (data) {
                this._shapeVertices = null;
                this._usingWidth = false;

                return 0;
            };

            glBuilderClass.prototype.setTriangleVertices = function (data) {
                var verticesPerRecord = 3;

                //---- single triangle: X, Y, Z ----
                var vertices = [
                    -.5, .5, 0,
                    .5, .5, 0,
                    .0, -.5, 0
                ];

                this._shapeVertices = vertices;
                this._usingWidth = false;

                return verticesPerRecord;
            };

            glBuilderClass.prototype.setRect2dVertices = function (data) {
                var vertexBuff = [];
                var verticesPerRecord = 6;

                //---- draw with x,y in upper left corner ----
                var vertices = [
                    1, 1, 0,
                    0, 1, 0,
                    0, 0, 0,
                    1, 1, 0,
                    0, 0, 0,
                    1, 0, 0
                ];

                this._shapeVertices = vertices;
                this._usingWidth = true;

                return verticesPerRecord;
            };

            glBuilderClass.prototype.setLine2dVertices = function (data) {
                var vertexBuff = [];
                var verticesPerRecord = 6;

                //---- draw with x,y in upper left corner ----
                var vertices = [
                    1, 1, 0,
                    0, 1, 0,
                    0, 0, 0,
                    1, 1, 0,
                    0, 0, 0,
                    1, 0, 0
                ];

                this._shapeVertices = vertices;
                this._usingWidth = false;

                return verticesPerRecord;
            };

            glBuilderClass.prototype.statsCallback = function (value) {
                this._statsCallback = value;
                return this;
            };
            return glBuilderClass;
        })();
        marks.glBuilderClass = glBuilderClass;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=glBuilder.js.map

///----------------------------------------------------------------
/// (from _marks\groupMark.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// groupMark.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas group primitives.  Can be used with animations.  Core function
        is "update()". */
        var groupMarkClass = (function (_super) {
            __extends(groupMarkClass, _super);
            function groupMarkClass(container, className) {
                _super.call(this, container, "g", null, false, className);
            }
            return groupMarkClass;
        })(marks.markBaseClass);
        marks.groupMarkClass = groupMarkClass;

        function createGroupMark(container, className) {
            return new groupMarkClass(container, className);
        }
        marks.createGroupMark = createGroupMark;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=groupMark.js.map

///----------------------------------------------------------------
/// (from _marks\imageMark.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// imageMark.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas image primitives.  Can be used with animations.  Core function
        is "update()". */
        var imageMarkClass = (function (_super) {
            __extends(imageMarkClass, _super);
            function imageMarkClass(container, className) {
                _super.call(this, container, "image", null, false, className);
            }
            return imageMarkClass;
        })(marks.markBaseClass);
        marks.imageMarkClass = imageMarkClass;

        function createImageMark(container, className) {
            return new imageMarkClass(container, className);
        }
        marks.createImageMark = createImageMark;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=imageMark.js.map

///----------------------------------------------------------------
/// (from _marks\jsParser.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// jsParser.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (marks) {
        /** Used to translate JavaScript shader functions into GL shader statements and expressions. */
        var jsParserClass = (function () {
            function jsParserClass() {
                this._context = null;
            }
            jsParserClass.prototype.makeRecordColumnName = function (name) {
                name = name.replace(/ /g, "_");
                return "data_" + name + "_";
            };

            jsParserClass.prototype.colorToGlColor = function (ca) {
                if ((ca.indexOf(",") > -1) && (ca.indexOf("(") == -1)) {
                    //---- its a string of 3 rgb numbers ----
                    ca = ca.split(",");
                } else {
                    ca = vp.color.getColorFromString(ca);
                }

                //---- GL wants normalized colors ----
                if (!ca) {
                    ca = [0, 0, 0];
                } else {
                    ca = [ca[0] / 255, ca[1] / 255, ca[2] / 255];
                }

                return ca;
            };

            jsParserClass.prototype.removeQuotes = function (name) {
                name = name.trim();

                if (name.startsWith("\"")) {
                    name = name.substr(1, name.length - 2).trim(); // remove quotes
                }

                return name;
            };

            jsParserClass.prototype.fixupNumber = function (value) {
                //---- ensure number is a float ----
                if (value.indexOf(".") == -1) {
                    value += ".0";
                }

                return value;
            };

            jsParserClass.prototype.processRecordColumn = function (token, attrBlock) {
                //---- make sure we only add name once ----
                var newColumn = false;

                if (attrBlock.origColNames.indexOf(token) == -1) {
                    attrBlock.origColNames.push(token);
                    newColumn = true;
                }

                //---- make the flat name safe for mixing with other user code ----
                token = this.makeRecordColumnName(token);

                if (newColumn) {
                    attrBlock.dataColNames.push(token);
                }

                return token;
            };

            jsParserClass.prototype.translateExp = function (line, usage, attrBlock) {
                var isCdRef = false;
                var isMathRef = false;
                var isvpRef = false;
                var isRecordRef = false;
                var isFirstToken = true;

                var scanner = new vp.utils.scanner(line);
                var tt = scanner.scan();
                var exp = "";

                while (tt != 8 /* eof */) {
                    var token = scanner.token();

                    if (tt == 4 /* number */) {
                        token = this.fixupNumber(token);
                        exp += " " + token;
                    } else if (tt == 1 /* operator */) {
                        if (token == ".") {
                            if (isCdRef || isMathRef || isvpRef || isRecordRef) {
                                token = null;
                            }
                        } else if (isRecordRef) {
                            //---- code used "record" without the dot qualified - record is really just a number ----
                            var lastToken = this.processRecordColumn("value", attrBlock);
                            exp += " " + lastToken;
                        }

                        //---- output the operator ----
                        if (token) {
                            exp += " " + token;
                        }
                    } else if (tt == 2 /* id */) {
                        if (token == "Math") {
                            isMathRef = true;
                            token = null;
                        } else if (token == "cd") {
                            isCdRef = true;
                            token = null;
                        } else if (token == "vp") {
                            isvpRef = true;
                            token = null;
                        } else if (token == "record") {
                            isRecordRef = true;
                            token = null;
                        } else {
                            if (isMathRef) {
                                //---- just handle the exceptions since most are supported ----
                                if (token == "PI") {
                                    token = "3.14159265";
                                } else if (token == "random") {
                                    var count = attrBlock.randomColNames.length + 1;
                                    var randColName = "random" + count + "_";
                                    attrBlock.randomColNames.push(randColName);

                                    token = randColName;

                                    //---- effectively remove the () in the input string ----
                                    scanner.scan(); // skip over "random" to "()"
                                } else {
                                    //---- output token unchanged ----
                                }
                            } else if (isCdRef) {
                                token = this._context[token];

                                //---- is it a number? ----
                                if (!isNaN(+token)) {
                                    token = this.fixupNumber(token + "");
                                }
                            } else if (isRecordRef) {
                                token = this.processRecordColumn(token, attrBlock);
                            } else if (isvpRef) {
                                break;
                            }

                            isCdRef = false;
                            isMathRef = false;
                            isvpRef = false;
                            isRecordRef = false;
                        }

                        if (token == "var") {
                            token = "float";
                        } else if (token == "function" && isFirstToken) {
                            break;
                        }

                        if (token) {
                            exp += " " + token;
                        }
                    } else if (tt == 3 /* string */) {
                        exp += " " + token;
                    } else {
                        //---- ignore comments, newlines, etc ----
                    }

                    tt = scanner.scan();
                }

                if (isRecordRef) {
                    //---- code used "record" without the dot qualified - record is really just a number ----
                    var lastToken = this.processRecordColumn("value_number", attrBlock);
                    exp += " " + lastToken;
                }

                if (usage == "color") {
                    var str = this.removeQuotes(exp);
                    exp = this.colorToGlColor(str);
                }

                return exp;
            };

            jsParserClass.prototype.translateJsStatements = function (lines, attrBlock) {
                var bracketLevel = 0;

                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i].trim();

                    if (line.startsWith(".attr(")) {
                        this.translateAttrCall(line, attrBlock);
                        continue;
                    } else if (line.startsWith("function")) {
                        continue;
                    } else if (line.startsWith("vp.select(")) {
                        continue;
                    } else if (line == "{") {
                        bracketLevel++;

                        if (bracketLevel == 1) {
                            continue;
                        }
                    } else if (line == "}") {
                        bracketLevel--;

                        if (bracketLevel == 0) {
                            continue;
                        }
                    }

                    var cmd = this.translateExp(line, "cmd", attrBlock);

                    if (cmd && cmd.trim() != "") {
                        attrBlock.cmds += cmd + "\n";
                    }
                }
            };

            jsParserClass.prototype.translateAttrCall = function (line, attrBlock) {
                var part = line.substr(6);

                if (part.length && part[part.length - 1] == ")") {
                    part = part.substr(0, part.length - 1).trim();
                }

                //---- divide pair at first space ----
                var name = part;
                var value = "";

                var index = part.indexOf(" ");
                if (index > -1) {
                    name = part.substr(0, index).trim();
                    value = part.substr(index + 1).trim();
                }

                if (name.length && name[name.length - 1] == ",") {
                    //---- remove trailing comma ----
                    name = name.substr(0, name.length - 1).trim();
                }

                name = this.removeQuotes(name);

                if (name == "width") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.width = value;
                } else if (name == "height") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.height = value;
                } else if (name == "size") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.size = value;
                } else if (name == "stroke-width") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.strokeWidth = value;
                } else if (name == "opacity") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.opacity = value;
                } else if (name == "fill") {
                    value = this.translateExp(value, "color", attrBlock);
                    attrBlock.fill = value;
                } else if (name == "stroke") {
                    value = this.translateExp(value, "color", attrBlock);
                    attrBlock.stroke = value;
                } else if (name == "x" || name == "cx") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.x = value;
                } else if (name == "y" || name == "cy") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.y = value;
                }
            };

            jsParserClass.prototype.getGlParams = function (shaderCallback, context) {
                this._context = context;

                var size = "20.0";
                var fill = [0, 0, 1, 1];
                var stroke = [0, 0, 1, 1];
                var x = ".5";
                var y = ".5";
                var cmds = "";

                var attrBlock = {
                    size: size, width: size, height: size, fill: fill, stroke: stroke, x: x, y: y, opacity: "1.0", strokeSize: 1,
                    cmds: cmds, origColNames: [], dataColNames: [], randomColNames: [], functions: ""
                };

                var code = shaderCallback.toString();

                //alert("code=" + code);
                var lines = code.split("\n");
                this.translateJsStatements(lines, attrBlock);

                //if (attrBlock.randomCount)
                //{
                //    //---- use von Neumann's middle square method, with slight modification ----
                //    var rf = "float random(float seed1, float seed2)\n";
                //    rf += "{\n";
                //    rf += "  seed1 = seed1 + 17.3;\n";
                //    rf += "  seed2 = seed2 + 29.1;\n";
                //    rf += "  seed1 = fract((seed1*seed1 + seed2*seed2)*1024.0);\n";
                //    rf += "  return seed1;\n";
                //    rf += "}\n\n";
                //    attrBlock.functions += rf;
                //}
                return attrBlock;
            };
            return jsParserClass;
        })();
        marks.jsParserClass = jsParserClass;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=jsParser.js.map

///----------------------------------------------------------------
/// (from _marks\lineMark.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// lineMark.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas line primitives.  Can be used with animations.  Core function
        is "update()". */
        var lineMarkClass = (function (_super) {
            __extends(lineMarkClass, _super);
            function lineMarkClass(container, className) {
                _super.call(this, container, "line", null, false, className);
            }
            return lineMarkClass;
        })(marks.markBaseClass);
        marks.lineMarkClass = lineMarkClass;

        function createLineMark(container, className) {
            return new lineMarkClass(container, className);
        }
        marks.createLineMark = createLineMark;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=lineMark.js.map

///----------------------------------------------------------------
/// (from _marks\pathMark.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// pathMark.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas path primitives.  Can be used with animations.  Core function
        is "update()". */
        var pathMarkClass = (function (_super) {
            __extends(pathMarkClass, _super);
            function pathMarkClass(container, className) {
                _super.call(this, container, "path", null, false, className);
            }
            return pathMarkClass;
        })(marks.markBaseClass);
        marks.pathMarkClass = pathMarkClass;

        function createPathMark(container, className) {
            return new pathMarkClass(container, className);
        }
        marks.createPathMark = createPathMark;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=pathMark.js.map

///----------------------------------------------------------------
/// (from _marks\pointMark.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// pointMark.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (marks) {
        /** Supports data-based generation of WebGL POINT primitives.  Can be used with animations.  Core function
        is "update()". */
        var pointMarkClass = (function (_super) {
            __extends(pointMarkClass, _super);
            function pointMarkClass(container, useWebGl, className) {
                _super.call(this, container, "rect", "point", useWebGl, className);
            }
            pointMarkClass.prototype.postProcessShape = function (element) {
                var wrap = vp.select(element);
                var size = wrap.attr("size");

                wrap.attr("width", size).attr("height", size);
            };
            return pointMarkClass;
        })(marks.markBaseClass);
        marks.pointMarkClass = pointMarkClass;

        function createPointMark(container, className) {
            return new pointMarkClass(container, false, className);
        }
        marks.createPointMark = createPointMark;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=pointMark.js.map

///----------------------------------------------------------------
/// (from _marks\rect2dMark.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// rect2dMark.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (marks) {
        /** Supports data-based generation of WebGL rect2d primitives.  Can be used with animations.  Core function
        is "update()". */
        var rect2dMarkClass = (function (_super) {
            __extends(rect2dMarkClass, _super);
            function rect2dMarkClass(container, useWebGl, className) {
                _super.call(this, container, "rect", "rect2d", useWebGl, className);
            }
            rect2dMarkClass.prototype.postProcessShape = function (element) {
                var wrap = vp.select(element);
                var size = wrap.attr("size");

                wrap.attr("width", size).attr("height", size);
            };
            return rect2dMarkClass;
        })(marks.markBaseClass);
        marks.rect2dMarkClass = rect2dMarkClass;

        function createRect2dMark(container, useWebGl, className) {
            return new rect2dMarkClass(container, useWebGl, className);
        }
        marks.createRect2dMark = createRect2dMark;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=rect2dMark.js.map

///----------------------------------------------------------------
/// (from _marks\rectangleMark.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// rectangleMark.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas RECT primitives.  Can be used with animations.  Core function
        is "update()". */
        var rectangleMarkClass = (function (_super) {
            __extends(rectangleMarkClass, _super);
            function rectangleMarkClass(container, className) {
                _super.call(this, container, "rect", null, false, className);
            }
            return rectangleMarkClass;
        })(marks.markBaseClass);
        marks.rectangleMarkClass = rectangleMarkClass;

        function createRectangleMark(container, className) {
            return new rectangleMarkClass(container, className);
        }
        marks.createRectangleMark = createRectangleMark;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=rectangleMark.js.map

///----------------------------------------------------------------
/// (from _marks\textMark.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// textMark.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas text primitives.  Can be used with animations.  Core function
        is "update()". */
        var textMarkClass = (function (_super) {
            __extends(textMarkClass, _super);
            function textMarkClass(container, className) {
                _super.call(this, container, "text", null, false, className);
            }
            return textMarkClass;
        })(marks.markBaseClass);
        marks.textMarkClass = textMarkClass;

        function createTextMark(container, className) {
            return new textMarkClass(container, className);
        }
        marks.createTextMark = createTextMark;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=textMark.js.map

///----------------------------------------------------------------
/// (from _marks\transition.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// transition.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - holds animation settings that can be passed to mark.update() functions.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (marks) {
        /** Supports data-based generation of SVG text primitives.  Can be used with animations.  Core function
        is "update()". */
        var transitionClass = (function () {
            function transitionClass() {
                //---- core properties ----
                this._animDuration = 1000;
                this._animEasing = null;
                this._delay = 0;
                this._primaryKey = undefined;
                //---- group overrides ----
                this._enter = vp.animation.makeEffects(0 /* none */, 3 /* right */);
                this._exit = vp.animation.makeEffects(0 /* none */, 1 /* left */);
                this._update = null;
            }
            transitionClass.prototype.primaryKey = function (columnOrFunc) {
                if (arguments.length === 0) {
                    return this._primaryKey;
                }

                this._primaryKey = columnOrFunc;
                return this;
            };

            transitionClass.prototype.duration = function (ms) {
                if (arguments.length === 0) {
                    return this._animDuration;
                }

                this._animDuration = ms;
                return this;
            };

            transitionClass.prototype.delay = function (ms) {
                if (arguments.length === 0) {
                    return this._delay;
                }

                this._delay = ms;
                return this;
            };

            transitionClass.prototype.enter = function (effect) {
                if (arguments.length === 0) {
                    return this._enter;
                }

                this._enter = effect;
                return this;
            };

            transitionClass.prototype.exit = function (effect) {
                if (arguments.length === 0) {
                    return this._exit;
                }

                this._exit = effect;
                return this;
            };

            transitionClass.prototype.update = function (effect) {
                if (arguments.length === 0) {
                    return this._update;
                }

                this._update = effect;
                return this;
            };

            transitionClass.prototype.easing = function (ease) {
                if (arguments.length === 0) {
                    return this._animEasing;
                }

                if (ease === true) {
                    ease = new vp.eases.powEase(2);
                }

                this._animEasing = ease;
                return this;
            };
            return transitionClass;
        })();
        marks.transitionClass = transitionClass;

        function createTransition() {
            return new transitionClass();
        }
        marks.createTransition = createTransition;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=transition.js.map

///----------------------------------------------------------------
/// (from _marks\triangleMark.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// triangleMark.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (marks) {
        /** Supports data-based generation of WebGL triangle primitives.  Can be used with animations.  Core function
        is "update()". */
        var triangleMarkClass = (function (_super) {
            __extends(triangleMarkClass, _super);
            function triangleMarkClass(container, className) {
                _super.call(this, container, null, "triangle", true, className);
            }
            triangleMarkClass.prototype.postProcessShape = function (element) {
                var wrap = vp.select(element);
                var size = wrap.attr("size");

                wrap.attr("width", size).attr("height", size);
            };
            return triangleMarkClass;
        })(marks.markBaseClass);
        marks.triangleMarkClass = triangleMarkClass;

        function createTriangleMark(container, className) {
            return new triangleMarkClass(container, className);
        }
        marks.createTriangleMark = createTriangleMark;
    })(vp.marks || (vp.marks = {}));
    var marks = vp.marks;
})(vp || (vp = {}));
//# sourceMappingURL=triangleMark.js.map
///-----------------------------------------------------------------------------------------------------------------
/// animation.ts.  Copyright (c) 2014 Microsoft Corporation.
///   - part of the vuePlotCore library
///-----------------------------------------------------------------------------------------------------------------
/// class: animation
/// creates a set of animations for the specified "elem".
///
/// "elem" is an UNWRAPPED HTML/SVG/Canvas elem.
/// "duration" is the time in milliseconds that the animation lasts.
/// "easeObj" is an optional object to control start and end easing.
/// "container" is an  optional animation container (which controls multiple animations).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (animation) {
        var animationClass = (function () {
            function animationClass(elem, duration, easeObj, parentAnimation, delay) {
                this.ctr = "vp.animiation";
                //---- private state ----
                this._children = [];
                this.elementsBeingAnimated = [];
                this.elemsToDelete = [];
                this.completedFunc = null;
                this.onFrameCallback = null;
                this.removed = [];
                this.timer = null;
                this.timeStarted = undefined;
                this.delaying = false;
                this._frameCount = 0;
                if (vp.utils.isUndefined(duration)) {
                    duration = 1000;
                }

                if (easeObj === true) {
                    easeObj = new vp.eases.powEase(2);
                }

                this.elem = elem;
                this.duration = duration;
                this.easeObj = easeObj;
                this.container = parentAnimation;
                this.delay = delay;

                if (parentAnimation) {
                    parentAnimation.add(this);
                } else {
                    this.setTimer();
                }

                this.timeStarted = Date.now();

                this.delaying = (delay > 0);

                if (elem) {
                    this.initAnim(elem);
                }
                ////---- add this animation to the list of active animations on the container ----
                //if (this.elem.rootContainer)        // canvas element
                //{
                //    this.elem.rootContainer.addAnimation(this);
                //}
                //vp.utils.debug("animation object created");
            }
            animationClass.prototype.setTimer = function () {
                var _this = this;
                this.timer = vp.animation.requestAnimationFrame(function (e) {
                    _this.animateFrame();
                });
                //vp.utils.debug("timer created: " + this.timer);
            };

            /// move the specified anim off the active children list to the "removed" list.
            animationClass.prototype.remove = function (anim) {
                this._children.remove(anim);
                this.removed.push(anim);
            };

            animationClass.prototype.frameCount = function () {
                return this._frameCount;
            };

            /// internal.
            animationClass.prototype.getSlideLoc = function (slideLoc, elem) {
                var parent = vp.dom.parent(elem);
                var pw = vp.dom.width(parent);
                var ph = vp.dom.height(parent);

                //---- compute OFFSET from current position ----
                var x = 0;
                var y = 0;

                if ((slideLoc == 1 /* left */) || (slideLoc == "left")) {
                    x = -pw; //-2000;
                } else if ((slideLoc == 3 /* right */) || (slideLoc == "right")) {
                    x = pw;
                } else if ((slideLoc == 2 /* top */) || (slideLoc == "top")) {
                    y = -ph;
                } else if ((slideLoc == 4 /* bottom */) || (slideLoc == "bottom")) {
                    y = ph;
                }

                return { x: x, y: y };
            };

            animationClass.prototype.initAnim = function (elem) {
                elem.animation = this;

                elem._origTransform = undefined;
                elem._transformAnim = undefined;

                this.elementsBeingAnimated.push(elem);
            };

            animationClass.prototype.clearAnim = function (elem) {
                //---- delete animation properties added to elem ----
                delete elem.animation;
                delete elem._origTransform;
                delete elem._transformAnim;
            };

            // CHW: new function
            animationClass.prototype.getTranslateTo = function (trans) {
                var parts = this.parseTransform(trans);
                var locTo = null;

                for (var i = 0; i < parts.length; i++) {
                    if (parts[i].name == "translate") {
                        locTo = { x: parts[i].p0, y: parts[i].p1 };
                        break;
                    }
                }

                return locTo;
            };

            /// public: applyEffect(elem, effect, isEnter)
            animationClass.prototype.applyEffect = function (elem, effect, isEnter) {
                if (isEnter) {
                    this.applyEnterEffect(elem, effect);
                } else {
                    this.applyExitEffect(elem, effect);
                }
            };

            /// public: applyEnterEffect(elem, effect)
            animationClass.prototype.applyEnterEffect = function (elem, effect) {
                var startingChildIndex = this._children.length;

                if (effect.fadeType) {
                    if ((effect.fadeType == 1 /* fade */) || (effect.fadeType == "fade")) {
                        // CHW: end up at current opacity; 1 if not set yet
                        var curOpacity = vp.dom.attr(elem, "opacity");

                        if (curOpacity == null)
                            curOpacity = 1;

                        //---- don't use "attr" here, since it will create yet another animation child ----
                        //vp.dom.attr(elem, "opacity", 0);
                        elem.setAttribute("opacity", "0");

                        this.animateAttr(elem, "opacity", 0, curOpacity);
                    }
                }

                if (effect.slideLoc) {
                    var locFrom = this.getSlideLoc(effect.slideLoc, elem);

                    // CHW: use current location, even if transformed, as destination of enter effect
                    var locTo = this.getTranslateTo(vp.dom.transform(elem));

                    if (locTo == null) {
                        var elemAny = elem;
                        var origTransform = elemAny._origTransform;

                        locTo = this.getTranslateTo(origTransform);
                        if (locTo == null) {
                            //---- if elem has no transform, just use (0,0) as the "to" value ----
                            //locTo = { x: vp.dom.attr(elem, "x"), y: vp.dom.attr(elem, "y") }
                            locTo = { x: 0, y: 0 };
                        }
                    }

                    if (locFrom.x) {
                        this.animateAttr(elem, "translate.x", locFrom.x, locTo.x);
                    }

                    if (locFrom.y) {
                        this.animateAttr(elem, "translate.y", locFrom.y, locTo.y);
                    }
                }

                if (effect.growOrigin) {
                    if ((effect.growOrigin != 0 /* none */) && (effect.growOrigin != "none")) {
                        var w = vp.dom.width(elem);
                        var h = vp.dom.height(elem);

                        var x = vp.dom.left(elem);
                        var y = vp.dom.top(elem);

                        if ((effect.growOrigin == 1 /* left */) || (effect.growOrigin == "left")) {
                            this.animateAttr(elem, "scale.x", 0, 1, x, y);
                        } else if ((effect.growOrigin == 2 /* top */) || (effect.growOrigin == "top")) {
                            this.animateAttr(elem, "scale.y", 0, 1, x, y);
                        } else if ((effect.growOrigin == 3 /* right */) || (effect.growOrigin == "right")) {
                            this.animateAttr(elem, "scale.x", 0, 1, x + w, y);
                        } else if ((effect.growOrigin == 4 /* bottom */) || (effect.growOrigin == "bottom")) {
                            this.animateAttr(elem, "scale.y", 0, 1, x, y + h);
                        } else if ((effect.growOrigin == 5 /* center */) || (effect.growOrigin == "center")) {
                            this.animateAttr(elem, "scale.x", 0, 1, x + w / 2, y + h / 2);
                            this.animateAttr(elem, "scale.y", 0, 1, x + w / 2, y + h / 2);
                        }
                    }
                }

                if (effect.rotateAngle) {
                    var w = vp.dom.width(elem);
                    var h = vp.dom.height(elem);

                    var x = vp.dom.left(elem);
                    var y = vp.dom.top(elem);

                    this.animateAttr(elem, "rotate", effect.rotateAngle, 0, x + w / 2, y + h / 2);
                }

                //---- for enter animations, we don't want to restore the origTransform at the end ----
                var elemAny = elem;
                elemAny._origTransform = undefined;

                //---- apply first frame NOW (so we don't see pre-anim version of shape) ----
                this.animateFrameCore(0, startingChildIndex);
            };

            /// public: applyExitEffect(elem, effect)
            animationClass.prototype.applyExitEffect = function (elem, effect) {
                var startingChildIndex = this._children.length;

                if (effect.fadeType) {
                    if ((effect.fadeType == 1 /* fade */) || (effect.fadeType == "fade")) {
                        // CHW: only set current opacity if not set
                        var curOpacity = vp.dom.attr(elem, "opacity");

                        if (curOpacity == null) {
                            //---- don't use "attr" here, since it will create yet another animation child ----
                            //vp.dom.attr(elem, "opacity", 1);
                            elem.setAttribute("opacity", "1");
                        }

                        this.animateAttr(elem, "opacity", 0);
                    }
                }

                if (effect.slideLoc) {
                    var loc = this.getSlideLoc(effect.slideLoc, elem);

                    // CHW: TODO use current location, even if transformed, as source of exit effect
                    if (loc.x) {
                        this.animateAttr(elem, "translate.x", 0, loc.x);
                    }

                    if (loc.y) {
                        this.animateAttr(elem, "translate.y", 0, loc.y);
                    }
                }

                if (effect.growOrigin) {
                    if ((effect.growOrigin != 0 /* none */) && (effect.growOrigin != "none")) {
                        var w = vp.dom.width(elem);
                        var h = vp.dom.height(elem);

                        var x = vp.dom.left(elem);
                        var y = vp.dom.top(elem);

                        if ((effect.growOrigin == 1 /* left */) || (effect.growOrigin == "left")) {
                            this.animateAttr(elem, "scale.x", 1, 0, x, y);
                        } else if ((effect.growOrigin == 2 /* top */) || (effect.growOrigin == "top")) {
                            this.animateAttr(elem, "scale.y", 1, 0, x, y);
                        } else if ((effect.growOrigin == 3 /* right */) || (effect.growOrigin == "right")) {
                            this.animateAttr(elem, "scale.x", 1, 0, x + w, y);
                        } else if ((effect.growOrigin == 4 /* bottom */) || (effect.growOrigin == "bottom")) {
                            this.animateAttr(elem, "scale.y", 1, 0, x, y + h);
                        } else if ((effect.growOrigin == 5 /* center */) || (effect.growOrigin == "center")) {
                            this.animateAttr(elem, "scale.x", 1, 0, x + w / 2, y + h / 2);
                            this.animateAttr(elem, "scale.y", 1, 0, x + w / 2, y + h / 2);
                        }
                    }
                }

                if (effect.rotateAngle) {
                    var w = vp.dom.width(elem);
                    var h = vp.dom.height(elem);

                    var x = vp.dom.left(elem);
                    var y = vp.dom.top(elem);

                    this.animateAttr(elem, "rotate", 0, effect.rotateAngle, x + w / 2, y + h / 2);
                }

                //---- for exit animations, we don't want to restore the origTransform at the end ----
                var elemAny = elem;
                elemAny._origTransform = undefined;

                //---- apply first frame NOW (so we don't see pre-anim version of shape) ----
                this.animateFrameCore(0, startingChildIndex);
            };

            /// private.
            animationClass.prototype.getTransformObject = function (elem) {
                var elemAny = elem;
                var ta = elemAny._transformAnim;
                if (ta == null) {
                    elemAny._origTransform = vp.dom.transform(elem);

                    ta = new vp.animation.transformAnimation(this, elem);
                    elemAny._transformAnim = ta;

                    this.addAnimation(ta);
                }

                return ta;
            };

            /// private.
            animationClass.prototype.parseTransformParams = function (scanner, transObj, paramCount) {
                var paramNum = 0;
                var tt = scanner.tokenType();

                while (tt == 4 /* number */) {
                    var pname = "p" + paramNum++;
                    transObj[pname] = scanner.token();

                    tt = scanner.scan();

                    //---- look for optional comma ----
                    if (scanner.token() == ",") {
                        tt = scanner.scan(); // skip over comma
                    }
                }

                return (paramNum == paramCount);
            };

            //---- parse a transform string into an array of transform part objects (translate, scale, rotate, skew) ----
            /// private.
            animationClass.prototype.parseTransform = function (str) {
                var parts = [];

                if (str != null) {
                    var scanner = new vp.utils.scanner(str);
                    var tt = scanner.scan();
                    var paramCounts = { scale: 2, translate: 2, rotate: 3, skew: 2 };

                    while (tt != 8 /* eof */) {
                        if (tt != 2 /* id */) {
                            //---- looks like an error; just stop parsing ----
                            parts = [];
                            break;
                        }

                        var transObj = { name: scanner.token() };
                        parts.push(transObj);

                        tt = scanner.scan();
                        if (scanner.token() == "(") {
                            tt = scanner.scan();
                            var counts = paramCounts[transObj.name];

                            if (!this.parseTransformParams(scanner, transObj, counts)) {
                                // CHW: handle some common cases that used to look like errors
                                if (transObj.name == "scale" && transObj["p0"]) {
                                    // scale with one parameter; second parameter should equal first
                                    transObj["p1"] = transObj["p0"];
                                } else if (transObj.name == "translate" && transObj["p0"]) {
                                    // translate with one parameter; second parameter should be 0
                                    transObj["p1"] = "0";
                                } else {
                                    //---- looks like an error; just stop parsing ----
                                    parts = [];
                                    break;
                                }
                            }

                            if (scanner.token() != ")") {
                                //---- looks like an error; just stop parsing ----
                                parts = [];
                                break;
                            }

                            tt = scanner.scan(); // get nextname
                        }
                    }
                }

                return parts;
            };

            /// private.
            animationClass.prototype.getFromValue = function (elem, isStyle, propOwner, name) {
                var from = 0;

                // the BELOW code should be changed - it adds a direct property that later down overrides the attribute
                // for an SVG elem like "rect".
                ////---- initialize property with default value, if needed ----
                //if ((propOwner[name] === undefined) || (propOwner[name] === ""))
                //{
                //    propOwner[name] = 0;
                //}
                if (isStyle) {
                    from = vp.dom.css(elem, name);
                } else if (elem.getAttribute) {
                    var av = elem.getAttribute(name);
                    if (av) {
                        if (av.baseVal != undefined) {
                            from = vp.dom.getBaseVal(elem, name, av);
                        } else if (av.value != undefined) {
                            from = parseFloat(av.value);
                        } else {
                            from = parseFloat(av);
                        }
                    } else {
                        //---- try style again after all ----
                        from = vp.dom.attr(elem, name);
                    }
                } else if (name in propOwner) {
                    if (elem.rootContainer) {
                        from = propOwner[name];
                    } else {
                        from = (propOwner[name].baseVal) ? vp.dom.getBaseVal(elem, name, propOwner[name]) : 0;
                    }
                }

                return from;
            };

            /// private animatePointsValue()
            animationClass.prototype.animatePointsValue = function (elem, name, isStyle, fromValue, value) {
                var from = vp.dom.attr(elem, "points");
                if (from != value) {
                    var animate = new animation.pointsAnimation(this, elem, name, from, value);
                    this.addAnimation(animate);
                }
            };

            /// private animateColorValue()
            animationClass.prototype.animateColorValue = function (elem, name, isStyle, fromValue, value) {
                var from = fromValue;
                if (vp.utils.isUndefined(from)) {
                    from = (isStyle) ? elem.style[name] : (elem.getAttribute) ? elem.getAttribute(name) : elem[name];
                }

                from = vp.color.getColorFromString(from);
                value = vp.color.getColorFromString(value);

                var areDiff = false;

                if (from == null) {
                    areDiff = (value != null);
                } else if (value == null) {
                    areDiff = true;
                } else if ((from[0] != value[0]) || (from[1] != value[1]) || (from[2] != value[2])) {
                    areDiff = true;
                }

                if (areDiff) {
                    var animate = new animation.colorAnimation(this, elem, name, from, value);
                    this.addAnimation(animate);
                }
            };

            /// private animateColorValue()
            animationClass.prototype.animateTransformValue = function (elem, name, isStyle, fromValue, value) {
                var ta = this.getTransformObject(elem);
                var from = fromValue;

                if (vp.utils.isUndefined(from)) {
                    if (isStyle) {
                        from = vp.dom.css(elem, "transform");
                    } else {
                        from = vp.dom.attr(elem, "transform");
                    }
                }

                //---- parse "transform" strings into theirparts ----
                var fromParts = this.parseTransform(from);
                var toParts = this.parseTransform(value);

                for (var i = 0; i < toParts.length; i++) {
                    var toPart = toParts[i];
                    var fromPart = (i < fromParts.length) ? fromParts[i] : null;

                    if ((fromPart) && (fromPart.name != toPart.name)) {
                        break;
                    }

                    if (toPart.name == "translate") {
                        var fromX = (fromPart) ? fromPart.p0 : 0;
                        var toX = toPart.p0;

                        var fromY = (fromPart) ? fromPart.p1 : 0;
                        var toY = toPart.p1;

                        ta.makeTransform("translate.x", fromX, toX);
                        ta.makeTransform("translate.y", fromY, toY);
                    } else if (toPart.name == "scale") {
                        var fromX = (fromPart) ? fromPart.p0 : 1;
                        var toX = toPart.p0;

                        var fromY = (fromPart) ? fromPart.p1 : 1;
                        var toY = toPart.p1;

                        ta.makeTransform("scale.x", fromX, toX);
                        ta.makeTransform("scale.y", fromY, toY);
                    } else if (toPart.name == "rotate") {
                        var from = (fromPart) ? fromPart.p0 : 0;
                        var to = toPart.p0;

                        ta.makeTransform("rotate", from, to, toPart.p1, toPart.p2);
                    }
                }
            };

            /// public: animateAttr() - add the specified attribute/value to children (attributes) being animated.
            animationClass.prototype.animateAttr = function (elem, name, value, value2, cx, cy, isStyle) {
                vp.utils.debug("animateAttr: name=" + name + ", value=" + value);

                var animate = null;
                var fromValue = undefined;
                var propOwner = (isStyle) ? elem.style : elem;

                if (value2 !== undefined) {
                    fromValue = value;
                    value = value2;
                }

                if ((name == "color") || (name == "fill") || (name == "stroke")) {
                    //---- remove any previous animation using this name/element ----
                    this.removeChild(elem, name);

                    //---- COLOR value ----
                    this.animateColorValue(elem, name, isStyle, fromValue, value);
                } else if (name == "points") {
                    //---- remove any previous animation using this name/element ----
                    this.removeChild(elem, name);

                    //---- set of points for a line or polygon element ----
                    this.animatePointsValue(elem, name, isStyle, fromValue, value);
                } else if (name == "transform") {
                    //---- TRANSFORM value ----
                    this.animateTransformValue(elem, name, isStyle, fromValue, value);
                } else if ((name == "scale") || (name == "translate") || (name == "rotate")) {
                    //---- TRANSFORM value ----
                    var ta = this.getTransformObject(elem);

                    ta.makeTransform(name, fromValue, value, cx, cy);
                } else if ((name.startsWith("scale.")) || (name.startsWith("translate.")) || (name.startsWith("rotate."))) {
                    //---- TRANSFORM value ----
                    var ta = this.getTransformObject(elem);

                    ta.makeTransform(name, fromValue, value, cx, cy);
                } else {
                    //---- remove any previous animation using this name/element ----
                    this.removeChild(elem, name);

                    //---- NUMERIC value ----
                    var from = fromValue;
                    if (vp.utils.isUndefined(from)) {
                        from = this.getFromValue(elem, isStyle, propOwner, name);

                        if (vp.utils.isUndefined(from)) {
                            from = 0;
                        }
                    }

                    if (!vp.utils.floatEq(from, value)) {
                        var animate = new animation.numberAnimation(this, elem, name, from, value, isStyle);
                        this.addAnimation(animate);
                    }
                }

                //---- if this is a child of a webGL canvas, add to new animatons list ----
                if (animate != null) {
                    if ((elem.rootContainer) && (elem.rootContainer.glHelper))
                        if (animation.shaderAnimationMgr) {
                            animation.shaderAnimationMgr.addNewAnimation(animate);
                        }
                }
            };

            /// public.
            animationClass.prototype.deleteElementOnCompleted = function (elem) {
                this.elemsToDelete.push(elem);
            };

            animationClass.prototype.removeChild = function (elem, name) {
                for (var i = this._children.length - 1; i >= 0; i--) {
                    var child = this._children[i];

                    if (child.element == elem && child.name == name) {
                        this._children.removeAt(i);
                        vp.utils.debug("animation.removeChild: removed name=" + name);

                        break;
                    }
                }
            };

            /// private.
            animationClass.prototype.addAnimation = function (newChild) {
                if (newChild.name && newChild.name != "") {
                    //---- we MUST ensure that any previous animation of same elem and name are removed ----
                    //---- if we don't, a previous created animation could finish first and we end up with older final value. ----
                    //for (var i = this._children.length - 1; i >= 0; i--)
                    //{
                    //    var child = this._children[i];
                    //    if (child.elem == newChild.elem && child.name == newChild.name)
                    //    {
                    //        this._children.removeAt(i);
                    //        break;
                    //    }
                    //}
                }

                if (newChild.name == "y") {
                    vp.utils.debug("addAnim: name=y, to=" + newChild.to);
                }

                this._children.push(newChild);
            };

            /// called each frame to animate all contains attribute animations.  must return true when
            /// we have reached percent=1 (100%).
            animationClass.prototype.animateFrame = function () {
                //---- on first frame of first animation, see if a common setset of the GL animations ----
                //---- (those with the same duration) can be moved onto the shader animation list ---
                if (animation.shaderAnimationMgr) {
                    animation.shaderAnimationMgr.processNewAnimations();
                }

                var elapsed = Date.now() - this.timeStarted;

                if (this.delaying) {
                    //vp.utils.debug("anim: delay frame");
                    if (elapsed >= this.delay) {
                        this.delaying = false;
                        this.timeStarted = Date.now();
                        elapsed = 0;
                    }
                } else {
                    var percent = elapsed / this.duration;

                    if (percent > 1) {
                        percent = 1;
                    } else if (percent < 0) {
                        percent = 0;
                    } else {
                        //---- apply easing fuction ----
                        if (this.easeObj) {
                            percent = this.easeObj.ease(percent);
                        }
                    }

                    //vp.utils.debug("anim: percent: " + percent);
                    this.animateFrameCore(percent);
                }

                if (this.timer) {
                    this.setTimer();
                }

                return (percent == 1);
            };

            animationClass.prototype.children = function () {
                return this._children;
            };

            animationClass.prototype.animateFrameCore = function (percent, startingChildIndex) {
                if (startingChildIndex !== undefined) {
                    for (var i = startingChildIndex; i < this._children.length; i++) {
                        this._children[i].animateFrame(percent);
                    }
                } else {
                    for (var i = 0; i < this._children.length; i++) {
                        this._children[i].animateFrame(percent);
                    }

                    this._frameCount++;

                    if (this.onFrameCallback) {
                        this.onFrameCallback(percent, this);
                    }
                }

                if (percent == 1) {
                    this.onAnimationStopped();
                }
            };

            /// public.
            animationClass.prototype.stop = function () {
                var stopped = false;
                vp.utils.debug("animation CANCELED");

                if (true) {
                    //---- move all elems into their final position instantly ----
                    var percent = 1;

                    for (var i = 0; i < this._children.length; i++) {
                        this._children[i].animateFrame(percent);
                    }

                    this.onAnimationStopped();
                    stopped = true;
                }

                return stopped;
            };

            animationClass.prototype.onAnimationComplete = function (arg) {
                if (arguments.length == 0) {
                    return this.completedFunc;
                }

                this.completedFunc = arg;
                return this;
            };

            animationClass.prototype.onFrame = function (arg) {
                if (arguments.length == 0) {
                    return this.onFrameCallback;
                }

                this.onFrameCallback = arg;
                return this;
            };

            /// private.
            animationClass.prototype.onAnimationStopped = function () {
                //---- stop further animations ----
                if (this.timer) {
                    clearInterval(this.timer);

                    vp.utils.debug("timer CLEARED: " + this.timer);
                    this.timer = null;
                }

                //---- remove associated elements from their containers ----
                if (this.elemsToDelete.length > 0) {
                    for (var i = 0; i < this.elemsToDelete.length; i++) {
                        var elem = this.elemsToDelete[i];
                        vp.dom.remove(elem);

                        vp.utils.assert(elem.parentNode == null);
                    }

                    vp.utils.debug("onAnimationStopped: removed children=" + this.elemsToDelete.length);

                    this.elemsToDelete = [];
                }

                if (this.completedFunc) {
                    this.completedFunc(this);
                }

                //---- remove this animation from the list of active animations on the container ----
                //if (this.elem.rootContainer)        // canvas element
                //{
                //    this.elem.rootContainer.removeAnimation(this);
                //}
                //---- remove the animation property so that subsequent property changes are normal ----
                var elements = this.elementsBeingAnimated;

                for (var i = 0; i < elements.length; i++) {
                    this.clearAnim(elements[i]);
                }

                if (this.elem) {
                    this.clearAnim(this.elem);
                }
            };
            return animationClass;
        })();
        animation.animationClass = animationClass;

        function createAnimation(elem, duration, easeObj, container, delay) {
            return new animationClass(elem, duration, easeObj, container, delay);
        }
        animation.createAnimation = createAnimation;

        function requestAnimationFrame(callback) {
            var timer = null;

            if (window.requestAnimationFrame) {
                window.requestAnimationFrame(callback);
                timer = -1;
            } else {
                timer = setTimeout(callback, 1000 / 60);
            }

            return timer;
        }
        animation.requestAnimationFrame = requestAnimationFrame;

        function cancelAnimationFrame(timer) {
            if (window.cancelAnimationFrame) {
                window.cancelAnimationFrame(timer);
            } else {
                clearTimeout(timer);
            }
        }
        animation.cancelAnimationFrame = cancelAnimationFrame;

        animation.shaderAnimationMgr = null;
    })(vp.animation || (vp.animation = {}));
    var animation = vp.animation;
})(vp || (vp = {}));
//# sourceMappingURL=animation.js.map

///----------------------------------------------------------------
/// (from animation\animationContainer.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// animationContainer.ts.  Copyright (c) 2014 Microsoft Corporation.
///   - part of the vuePlotCore library
///   - controls multiple animation objects
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (animation) {
        /// class: animationContainer
        /// this is used to contain and control a set of vp.animation classes.  to keep animations
        /// crisp and in sync, a single timer is used in the container class. when stopped
        /// or all child animations are completed, the "completedFunc" is called.
        var animationContainer = (function () {
            function animationContainer() {
                this.ctr = "vp.animationContainer";
                //---- private state ----
                this.children = [];
                this.completedFunc = null;
                this.timer = null;
                this._timeStarted = null;
                this.easeObj = null;
                this.isRunning = false;
            }
            animationContainer.prototype.timeStarted = function () {
                return this._timeStarted;
            };

            /// public: add(anim)
            animationContainer.prototype.add = function (anim) {
                var _this = this;
                if (this.children.length == 0) {
                    //---- start the container when first child is added ---
                    this.timer = animation.requestAnimationFrame(function (e) {
                        _this.animateFrame();
                    });

                    this._timeStarted = new Date();
                    this.isRunning = true;
                }

                this.children.push(anim);
            };

            /// public: stop()
            /// stop the running animation.
            animationContainer.prototype.stop = function () {
                var children = this.children;

                if (this.timer) {
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        child.stop();
                    }

                    this.onStoppedOrCompleted();
                }
            };

            /// public: onCompleted(completedFunc)
            /// set the callback func to be called when animation is stopped or completed.
            animationContainer.prototype.onCompleted = function (completedFuncParam) {
                this.completedFunc = completedFuncParam;
            };

            /// public: clear()
            animationContainer.prototype.clear = function () {
                this.stop();
                this.children = [];
            };

            /// private: onStoppedOrCompleted()
            /// this is called when animation container is explictly stopped or all of the child
            /// animations have completed.
            animationContainer.prototype.onStoppedOrCompleted = function () {
                clearInterval(this.timer);
                this.timer = null;
                this.isRunning = false;

                if (this.completedFunc) {
                    this.completedFunc();
                }
            };

            /// public: animateFrame()
            /// called once every 1/60 of a second or so.  its job is to call each child animation and
            /// keep track of which have completed.
            animationContainer.prototype.animateFrame = function () {
                var _this = this;
                var children = this.children;

                for (var i = children.length - 1; i >= 0; i--) {
                    var child = children[i];
                    var completed = child.animateFrame();

                    if (completed) {
                        children.removeAt(i);
                    }
                }

                if (children.length == 0) {
                    this.onStoppedOrCompleted();
                }

                if (this.timer) {
                    animation.requestAnimationFrame(function () {
                        _this.animateFrame();
                    });
                }
            };
            return animationContainer;
        })();
        animation.animationContainer = animationContainer;
    })(vp.animation || (vp.animation = {}));
    var animation = vp.animation;
})(vp || (vp = {}));
//# sourceMappingURL=animationContainer.js.map

///----------------------------------------------------------------
/// (from animation\colorAnimation.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// colorAnimation.ts.  Copyright (c) 2014 Microsoft Corporation.
///   - part of the vuePlotCore library
///  - animates a color.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (animation) {
        //---- class: colorAnimation ----
        var colorAnimation = (function () {
            function colorAnimation(parent, element, attributeName, fromColor, toColor) {
                this.element = element;
                this.parent = parent;
                this.attributeName = attributeName;

                this.from = vp.color.getColorFromString(fromColor);
                this.to = vp.color.getColorFromString(toColor);

                if (!this.from) {
                    vp.utils.error("colorAnimation: 'from' is not defined");
                }

                if (!this.to) {
                    vp.utils.error("colorAnimation: 'to' is not defined");
                }
            }
            /// private: getAnimateCalue(percent)
            colorAnimation.prototype.getAnimatedValue = function (percent) {
                var from = this.from;
                var to = this.to;

                var r = Math.round(from[0] + percent * (to[0] - from[0]));
                var g = Math.round(from[1] + percent * (to[1] - from[1]));
                var b = Math.round(from[2] + percent * (to[2] - from[2]));

                var value = "rgb(" + r.toString() + "," + g.toString() + "," + b.toString() + ")";
                return value;
            };

            /// public: animateFrame(percent)
            colorAnimation.prototype.animateFrame = function (percent) {
                var value = this.getAnimatedValue(percent);
                this.element.setAttribute(this.attributeName, value);
            };
            return colorAnimation;
        })();
        animation.colorAnimation = colorAnimation;
    })(vp.animation || (vp.animation = {}));
    var animation = vp.animation;
})(vp || (vp = {}));
//# sourceMappingURL=colorAnimation.js.map

///----------------------------------------------------------------
/// (from animation\dataAnimMgrEx.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// dataAnimMgr.ts.  Copyright (c) 2014 Microsoft Corporation.
///   -part of the vuePlot library.
///   - manages a data source with respect to data changes, filtering, and related animation.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (animation) {
        /// class: dataAnimMgr
        var dataAnimMgrExClass = (function () {
            function dataAnimMgrExClass(containerUW, pkFunc, appendSFCtor, layerId, isSeriesLayer) {
                //---- private state ----
                this._enterShapes = [];
                this._updateShapes = [];
                this._exitShapes = [];
                this._updateRows = [];
                this._keys = {};
                this._data = [];
                this._masterAnim = null;
                this._enterDataPairs = [];
                this._dataId = undefined;
                this._seriesCount = 1;
                //_deferredSetDataCall = null;
                this._appendNameOrCallback = null;
                //---- stats ----
                this._animStartTime = 0;
                this._animFPS = 0;
                this._shapesDrawn = 0;
                this._statsCallback = null;
                this.ctr = "vp.dataAnimMgrEx";

                this._container = ((containerUW) && (containerUW.length)) ? containerUW[0] : containerUW;
                this._pkCallback = pkFunc;
                this._appendNameOrCallback = appendSFCtor;
                this._layerId = layerId;
                this._isSeriesLayer = isSeriesLayer;

                //---- group overrides ----
                this._enterAnim = { effect: animation.makeEffects(0 /* none */, 3 /* right */) };
                this._exitAnim = { effect: animation.makeEffects(0 /* none */, 1 /* left */) };
                this._updateAnim = null;

                //---- init code ----
                this._animDelay = 0;
                this._animDuration = 1000;
                this._animEasing = new vp.eases.powEase(2);
                this._masterAnim = new animation.animationContainer();

                if (this._pkCallback === undefined) {
                    //---- provide default key callback ----
                    this._pkCallback = vp.utils.indexKeyFunc;
                }

                this._enterAnim = animation.makeEffects(0 /* none */, 3 /* right */);
                this._exitAnim = animation.makeEffects(0 /* none */, 1 /* left */);
                this._updateAnim = null;
            }
            /** will stop all animations associated with this mgr. */
            dataAnimMgrExClass.prototype.clearActiveAnimations = function () {
                this._masterAnim.stop();
            };

            /// do not assume that "container" has been set here - OK to create new shapes but don't append them yet.
            dataAnimMgrExClass.prototype.setData = function (newData, isNewDataSet, newDataId) {
                this.clearActiveAnimations();

                var existingShapes = this._updateShapes.concat(this._enterShapes);

                if (this._exitShapes.length > 0) {
                    //---- about to overwrite exit shapes - remove them now ----
                    this.removeExitShapesNow(-1);
                }

                this._enterShapes = [];
                this._exitShapes = [];
                this._updateShapes = [];
                this._enterDataPairs = [];
                this._updateRows = [];

                if ((isNewDataSet) || (this._animDuration == 0)) {
                    //---- get rid of all old items ----
                    //if (container)
                    //{
                    //    vp.lear(container);
                    //}
                    this._keys = {};

                    if (newData) {
                        for (var i = 0; i < newData.length; i++) {
                            var pair = { dataItem: newData[i], dataIndex: i };
                            this._enterDataPairs.push(pair);
                        }
                    }

                    this._exitShapes = existingShapes;

                    if (this._animDuration == 0) {
                        //---- keep it simple and remove them all now ----
                        if (this._exitShapes.length > 0) {
                            this.removeExitShapesNow(-1);
                        }
                    }
                } else {
                    for (var i = 0; i < existingShapes.length; i++) {
                        existingShapes[i].notYetFound = true;
                    }

                    if (newData) {
                        var lastUpdateRow = -1;

                        for (var i = 0; i < newData.length; i++) {
                            for (var s = 0; s < this._seriesCount; s++) {
                                var key = this.getFullKey(newData[i], i, s);

                                var uelem = this._keys[key];
                                if (uelem == undefined) {
                                    var pair = { dataItem: newData[i], dataIndex: i };
                                    this._enterDataPairs.push(pair);
                                } else {
                                    uelem.notYetFound = false;

                                    //---- add "i" to  this._updateRows, on first time seen ----
                                    if (lastUpdateRow != i) {
                                        this._updateRows.push(i);
                                        lastUpdateRow = i;
                                    }

                                    //---- update data/dataIndex fields to reflect data change ----
                                    uelem.dataItem.data = newData[i];
                                    uelem.dataIndex = i;

                                    this._updateShapes.push(uelem);
                                }
                            }
                        }
                    }

                    for (var i = 0; i < existingShapes.length; i++) {
                        var elem = existingShapes[i];

                        if (elem.notYetFound === true) {
                            //---- remove key from keys ----
                            var key = this.getFullKey(elem.dataItem, elem.dataIndex, vp.dom.shapeId(elem));
                            delete this._keys[key];

                            //---- update dataIndex to reflect that data is not in current data[] ----
                            elem.dataIndex = -(elem.dataIndex + 1);

                            this._exitShapes.push(elem);
                        }
                    }
                }

                this._data = newData;
                this._dataId = newDataId;

                return this;
            };

            /** this is only called from layers that support series plotting.  It should be called after setData(), but before
            updateShapes().  */
            dataAnimMgrExClass.prototype.setSeriesNames = function (value) {
                if (this._isSeriesLayer) {
                    //---- transform degenerate case to true value ----
                    if (value && value.length == 1 && value[0] == "") {
                        value = [];
                    }

                    this._pendingSeriesNames = value;
                }
            };

            dataAnimMgrExClass.prototype.applySeriesNames = function () {
                if (this._updateRows.length) {
                    var data = this._data;

                    var beforeList = this._seriesNames;
                    if (!beforeList) {
                        beforeList = [];
                    }

                    var afterList = this._pendingSeriesNames;
                    if (!afterList) {
                        afterList = [];
                    }

                    //---- build a seriesIndex update table to map from before si to after si ----
                    var seriesUpdateTable = {};
                    for (var i = 0; i < beforeList.length; i++) {
                        var beforeName = beforeList[i];
                        var afterIndex = afterList.indexOf(beforeName);

                        seriesUpdateTable[i] = afterIndex;
                    }

                    for (var j = this._updateShapes.length - 1; j >= 0; j--) {
                        var elem = this._updateShapes[j];
                        var si = seriesUpdateTable[elem.dataItem.shapeId];

                        if (si == -1) {
                            this._updateShapes.removeAt(j);
                            this._exitShapes.push(elem);

                            //---- remove key from keys ----
                            var key = this.getFullKey(elem.dataItem, elem.dataIndex, vp.dom.shapeId(elem));
                            delete this._keys[key];

                            //---- use seriesIndex=0 to ensure it gets processed in updateShapes() ----
                            elem.dataItem.shapeId = 0;
                        }
                    }

                    for (var j = this._updateShapes.length - 1; j >= 0; j--) {
                        var elem = this._updateShapes[j];
                        var si = seriesUpdateTable[elem.dataItem.shapeId];

                        if (si > -1) {
                            //---- delete OLD key, if it belongs to elem ----
                            var key = this.getFullKey(elem.dataItem, elem.dataIndex, vp.dom.shapeId(elem));
                            if (this._keys[key] == elem) {
                                delete this._keys[key];
                            }

                            //---- UPDATE seriesIndex ----
                            elem.dataItem.shapeId = si;

                            //---- add NEW key ----
                            var key = this.getFullKey(elem.dataItem, elem.dataIndex, vp.dom.shapeId(elem));
                            this._keys[key] = elem;
                        }
                    }

                    for (var i = 0; i < afterList.length; i++) {
                        var afterName = afterList[i];
                        if (beforeList.indexOf(afterName) == -1) {
                            //---- afterName ADDED - create a set of shapes for it ----
                            var pairList = [];
                            for (var j = 0; j < this._updateRows.length; j++) {
                                var row = this._updateRows[j];

                                var pair = { dataItem: data[row], dataIndex: row };
                                pairList.push(pair);
                            }

                            if (pairList.length) {
                                var shapes = this.createMultipleShapes(this._appendNameOrCallback, 1, pairList);
                                this.processNewlyCreatedShapes(shapes, pairList, 1, i);

                                //---- add these new shapes to _enterShapes ----
                                this._enterShapes = this._enterShapes.concat(shapes);
                            }
                        }
                    }
                }

                this._seriesNames = this._pendingSeriesNames;
                this._pendingSeriesNames = null;
            };

            /// public: updateShapes()
            /// call this after a call to setData().
            dataAnimMgrExClass.prototype.updateShapes = function (seriesIndex, totalSeries, callBack, appendStrOrFunc) {
                //---- apply pending series names (was deferred until now, when caller has set our container) ----
                if (this._pendingSeriesNames && this._container) {
                    this.applySeriesNames();
                }

                this._seriesCount = totalSeries;

                //if (deferredSetDataCall)
                //{
                //    var sdc = deferredSetDataCall;
                //    deferredSetDataCall = null;
                //    this.setData(sdc.newData, sdc.isNewDataSet, sdc.newDataId, true);
                //}
                var shapesTouched = [];

                if (seriesIndex == 0) {
                    this._masterAnim.clear();
                }

                var start = +Date.now();
                this.createEnterShapesIfNeeded(this._seriesCount, appendStrOrFunc);
                var enterElapsed = +Date.now() - start;
                var start = +Date.now();

                for (var i = 0; i < this._enterShapes.length; i++) {
                    var uelem = this._enterShapes[i];
                    var shapeId = vp.dom.shapeId(uelem);

                    if (shapeId == seriesIndex) {
                        vp.dom.animate(uelem, 0); // turn off animation for this shape

                        callBack(uelem, uelem.dataItem, uelem.dataIndex, true);

                        shapesTouched.push(uelem);
                    }
                }

                this._animStartTime = +Date.now();

                if (this._updateShapes.length) {
                    this.createUpdateAnimations(seriesIndex, shapesTouched, callBack);
                }

                if (this._enterShapes.length) {
                    this.createEnterAnimations(seriesIndex, shapesTouched, callBack);
                }

                if (this._exitShapes.length) {
                    this.createExitAnimations(seriesIndex, shapesTouched, callBack);
                }

                //---- return all shapes now in plot for this dataAnimMgr / seriesIndex ----
                var wrap = vp.dom.wrapElements(shapesTouched);
                return wrap;
            };

            dataAnimMgrExClass.prototype.createExitAnimations = function (seriesIndex, shapesTouched, callBack) {
                //---- create EXIT animations ----
                // CHW: make sure to call deleteElementsOnCompleted even if no exit effect; also make that duration 0ms
                var _this = this;
                var exitProps = this.buildAnimationProps(this._exitAnim);

                if (true) {
                    //---- create one animation object for all EXIT elements/properties being animated ----
                    var anim = new animation.animationClass(null, exitProps.duration, exitProps.easing, this._masterAnim, exitProps.delay);
                    anim.onAnimationComplete(function (e) {
                        _this.onAnimationComplete(e, "EXIT", seriesIndex);
                    });

                    var aniCount = 0;

                    for (var i = this._exitShapes.length - 1; i >= 0; i--) {
                        var uelem = this._exitShapes[i];

                        if (vp.dom.shapeId(uelem) == seriesIndex) {
                            anim.initAnim(uelem);
                            anim.applyExitEffect(uelem, exitProps.effect);
                            anim.deleteElementOnCompleted(uelem);
                            aniCount++;

                            this._exitShapes.removeAt(i);
                        }
                    }

                    if (aniCount) {
                        //vp.utils.debug("created EXIT animations: count=" + aniCount + ", seriesIndex=" + seriesIndex);
                    }
                } else {
                    //anim = new vp.animation(uelem, 0, exitProps.easing, this._masterAnim, exitProps.delay);
                    //anim.deleteElementsOnCompleted(uelem);
                    this.removeExitShapesNow(seriesIndex);
                }
                //var deleteElapsed = +Date.now() - start;
            };

            dataAnimMgrExClass.prototype.createEnterAnimations = function (seriesIndex, shapesTouched, callBack) {
                var _this = this;
                //---- create ENTER animations ----
                var enterProps = this.buildAnimationProps(this._enterAnim);
                if (enterProps.duration && enterProps.effect) {
                    //---- create one animation object for all ENTER elements/properties being animated ----
                    var anim = new animation.animationClass(null, enterProps.duration, enterProps.easing, this._masterAnim, enterProps.delay);
                    anim.onAnimationComplete(function (e) {
                        _this.onAnimationComplete(e, "ENTER", seriesIndex);
                    });

                    var aniCount = 0;
                    for (var i = 0; i < this._enterShapes.length; i++) {
                        var uelem = this._enterShapes[i];

                        if (vp.dom.shapeId(uelem) == seriesIndex) {
                            anim.initAnim(uelem);
                            anim.applyEnterEffect(uelem, enterProps.effect);
                            aniCount++;
                        }
                    }

                    if (aniCount) {
                        //vp.utils.debug("created ENTER animations: count=" + aniCount + ", seriesIndex=" + seriesIndex);
                    }
                }
            };

            dataAnimMgrExClass.prototype.createUpdateAnimations = function (seriesIndex, shapesTouched, callBack) {
                var _this = this;
                var updateProps = this.buildAnimationProps(this._updateAnim);
                var anim = null;

                if (updateProps.duration) {
                    //---- create one animation object for all UPDATE elements/properties being animated ----
                    anim = animation.createAnimation(null, updateProps.duration, updateProps.easing, this._masterAnim, updateProps.delay);
                    anim.onAnimationComplete(function (e) {
                        _this.onAnimationComplete(e, "UPDATE", seriesIndex);
                    });
                }

                //---- update EXISTING shapes WITH animation ----
                var aniCount = 0;
                for (var i = 0; i < this._updateShapes.length; i++) {
                    var uelem = this._updateShapes[i];

                    if (vp.dom.shapeId(uelem) == seriesIndex) {
                        if (anim) {
                            anim.initAnim(uelem);
                            aniCount++;
                        }

                        callBack(uelem, uelem.dataItem, uelem.dataIndex, false);

                        shapesTouched.push(uelem);
                    }
                }

                if (aniCount) {
                    //vp.utils.debug("created UPDATE animations: count=" + aniCount + ", seriesIndex=" + seriesIndex);
                }
            };

            /// public: getData()
            //---- this has explict "get" signature because we need to specify "isNewDataSet" for setter ----
            dataAnimMgrExClass.prototype.getData = function () {
                return this._data;
            };

            /// remove all shapes from SVG canvas; clear all structures of previous shapes.
            dataAnimMgrExClass.prototype.clear = function () {
                var existingShapes = this._updateShapes.concat(this._enterShapes);

                if (this._exitShapes.length > 0) {
                    //---- about to overwrite exit shapes - remove them now ----
                    this.removeExitShapesNow(-1);
                }

                this._enterShapes = [];
                this._exitShapes = [];
                this._updateShapes = [];
                this._enterDataPairs = [];
                this._keys = [];

                this._exitShapes = existingShapes;
                existingShapes = [];

                if (this._animDuration == 0) {
                    //---- keep it simple and remove them all now ----
                    if (this._exitShapes.length > 0) {
                        this.removeExitShapesNow(-1);
                    }
                }
            };

            dataAnimMgrExClass.prototype.updateWithoutDataChange = function () {
                var existingShapes = this._updateShapes.concat(this._enterShapes);

                if (this._exitShapes.length > 0) {
                    //---- about to overwrite exit shapes - remove them now ----
                    this.removeExitShapesNow(-1);
                }

                this._enterShapes = [];
                this._exitShapes = [];
                this._enterDataPairs = [];
                this._updateShapes = existingShapes;
            };

            dataAnimMgrExClass.prototype.createMultipleShapes = function (appendStrOrFunc, seriesCount, enterDataPairs) {
                var elements = [];
                var start = +Date.now();
                var count = seriesCount * enterDataPairs.length;
                var needAppend = true;

                if (appendStrOrFunc == null) {
                    appendStrOrFunc = this._appendNameOrCallback;
                }

                if (vp.utils.isFunction(appendStrOrFunc)) {
                    for (var s = 0; s < seriesCount; s++) {
                        for (var i = 0; i < enterDataPairs.length; i++) {
                            var pair = enterDataPairs[i];

                            var elem = appendStrOrFunc(pair.dataItem, pair.dataIndex, s, this._data);
                            elements.push(elem);
                        }
                    }
                } else if (appendStrOrFunc) {
                    if (this._container.append) {
                        //---- perf win for CREATE and APPEND ----
                        needAppend = false;

                        for (var i = 0; i < count; i++) {
                            var elem = this._container.append(this._appendNameOrCallback);
                            elements.push(elem);
                        }
                    } else {
                        //---- perf win for CREATE ----
                        elements = vp.dom.createElements(this._container, appendStrOrFunc, count);
                        var createElapsed = +Date.now() - start;
                        var start = +Date.now();
                    }
                }

                if (needAppend) {
                    //---- perf win for APPEND ----
                    vp.dom.appendElements(this._container, elements);
                    var appendElapsed = +Date.now() - start;
                }

                return elements;
            };

            /// private: createShape()
            dataAnimMgrExClass.prototype.createShape = function (appendStrOrFunc, dataRecord, index, key, seriesIndex) {
                var uelem = null;

                if (appendStrOrFunc == null) {
                    appendStrOrFunc = this._appendNameOrCallback;
                }

                if (vp.utils.isFunction(appendStrOrFunc)) {
                    uelem = appendStrOrFunc(dataRecord, index, seriesIndex, this._data);
                } else if (appendStrOrFunc) {
                    uelem = vp.dom.createElement(this._container, appendStrOrFunc);
                }

                if (uelem != null) {
                    vp.dom.append(this._container, uelem);

                    // "dataItem" should look like: { dataId: dd, shapeId: ss, key: kk, data: dataRecord }
                    var dataItemEx = { dataId: 1, shapeId: seriesIndex, key: key, data: dataRecord };

                    uelem.dataItem = dataItemEx;
                    uelem.dataIndex = index;
                }

                return uelem;
            };

            dataAnimMgrExClass.prototype.createEnterShapesIfNeeded = function (seriesCount, appendStrOrFunc) {
                if (this._enterDataPairs.length > 0) {
                    var start = +Date.now();
                    var newShapes = this.createMultipleShapes(appendStrOrFunc, seriesCount, this._enterDataPairs);
                    var multiElapsed = +Date.now() - start;

                    this.processNewlyCreatedShapes(newShapes, this._enterDataPairs, this._seriesCount);
                    this._enterDataPairs = [];

                    this._enterShapes = this._enterShapes.concat(newShapes);
                }
            };

            dataAnimMgrExClass.prototype.processNewlyCreatedShapes = function (newShapes, pairList, seriesCount, seriesIndex) {
                var shapeIndex = 0;

                var start = +Date.now();

                for (var s = 0; s < seriesCount; s++) {
                    for (var i = 0; i < pairList.length; i++) {
                        var pair = pairList[i];
                        var pk = this.getPrimaryKey(pair.dataItem, pair.dataIndex);
                        var si = (seriesIndex === undefined) ? s : seriesIndex;

                        var uelem = newShapes[shapeIndex++];

                        //var uelem = createShape(appendStrOrFunc, pair.dataItem, pair.dataIndex, pk, s);
                        //enterShapes.push(uelem);
                        // "dataItem" should look like: { dataId: dd, shapeId: ss, key: kk, data: dataRecord }
                        var dataItemEx = { dataId: 1, shapeId: si, key: pk, data: pair.dataItem };

                        uelem.dataItem = dataItemEx;
                        uelem.dataIndex = pair.dataIndex;

                        var key = this.getFullKey(pair.dataItem, pair.dataIndex, si, pk);
                        this._keys[key] = uelem;
                    }
                }

                var propsElapsed = +Date.now() - start;
            };

            dataAnimMgrExClass.prototype.onAnimationComplete = function (anim, changeType, seriesIndex) {
                var elapsed = +Date.now() - this._animStartTime;
                this._animFPS = Math.round(anim.frameCount() / (elapsed / 1000));

                if (this._statsCallback) {
                    var count = this._enterShapes.length + this._updateShapes.length;
                    this._statsCallback(this._animFPS, count, elapsed);
                }

                var seriesName = (this._seriesNames) ? this._seriesNames[seriesIndex] : "";

                vp.utils.debug("anim complete: layer=" + this._layerId + ", seriesIndex=" + seriesIndex + ", seriesName=" + seriesName + ", changeType=" + changeType + ", child count=" + anim.children().length);
            };

            dataAnimMgrExClass.prototype.buildAnimationProps = function (anim) {
                var duration = (anim && anim.duration !== undefined) ? anim.duration : this._animDuration;
                var easing = (anim && anim.easeing !== undefined) ? anim.easeing : this._animEasing;
                var delay = (anim && anim.delay !== undefined) ? anim.delay : this._animDelay;
                var effect = (anim && anim.effect !== undefined) ? anim.effect : null;

                if (!effect && anim) {
                    if (anim.fadeType !== undefined || anim.growOrigin !== undefined || anim.slideLoc !== undefined || anim.rotateAngle !== undefined) {
                        //---- anim is a simple effect ----
                        effect = anim;
                    }
                }

                var result = { duration: duration, easing: easing, delay: delay, effect: effect };
                return result;
            };

            dataAnimMgrExClass.prototype.removeExitShapesNow = function (seriesIndex) {
                for (var i = this._exitShapes.length - 1; i >= 0; i--) {
                    var uelem = this._exitShapes[i];

                    if ((seriesIndex == -1) || (vp.dom.shapeId(uelem) == seriesIndex)) {
                        vp.dom.remove(uelem);
                        this._exitShapes.removeAt(i);
                    }
                }

                //exitShapes = [];
                var abc = 9;
            };

            // CHW: new method
            dataAnimMgrExClass.prototype.lookupElement = function (dataItem, dataIndex, seriesIndex) {
                var key = this.getFullKey(dataItem, dataIndex, seriesIndex);
                return this._keys[key];
            };

            /// private: getPrimaryKey()
            dataAnimMgrExClass.prototype.getPrimaryKey = function (dataItem, dataIndex) {
                var key = dataIndex;

                if (dataItem && dataItem.key) {
                    key = dataItem.key;
                } else if (this._pkCallback) {
                    if (vp.utils.isString(this._pkCallback)) {
                        if (dataItem) {
                            key = dataItem[this._pkCallback];
                        }
                    } else {
                        key = this._pkCallback(dataItem, dataIndex);
                    }
                }

                return key;
            };

            /// private: getFullKey()
            dataAnimMgrExClass.prototype.getFullKey = function (dataItem, dataIndex, seriesIndex, key) {
                if (!key) {
                    key = this.getPrimaryKey(dataItem, dataIndex);
                }

                key += "+" + seriesIndex;

                return key;
            };

            /// public property: animDuration
            dataAnimMgrExClass.prototype.animDuration = function (value) {
                if (arguments.length === 0) {
                    return this._animDuration;
                }

                //---- setter ----
                this._animDuration = value;
                return this;
            };

            /// public property: animDelay
            dataAnimMgrExClass.prototype.animDelay = function (value) {
                if (arguments.length === 0) {
                    return this._animDelay;
                }

                //---- setter ----
                this._animDelay = value;
                return this;
            };

            /// public property: animEasing
            dataAnimMgrExClass.prototype.animEasing = function (value) {
                if (arguments.length === 0) {
                    return this._animEasing;
                }

                //---- setter ----
                this._animEasing = (value === true) ? new vp.eases.powEase(2) : value;
                return this;
            };

            /// public property: enterAnim
            dataAnimMgrExClass.prototype.enterAnim = function (value) {
                if (arguments.length === 0) {
                    return this._enterAnim;
                }

                //---- setter ----
                this._enterAnim = value;
                return this;
            };

            /// public property: exitAnim
            dataAnimMgrExClass.prototype.exitAnim = function (value) {
                if (arguments.length === 0) {
                    return this._exitAnim;
                }

                //---- setter ----
                this._exitAnim = value;
                return this;
            };

            /// public property: updateAnim
            dataAnimMgrExClass.prototype.updateAnim = function (value) {
                if (arguments.length === 0) {
                    return this._updateAnim;
                }

                //---- setter ----
                this._updateAnim = value;
                return this;
            };

            /// public property: container
            dataAnimMgrExClass.prototype.container = function (value) {
                if (arguments.length === 0) {
                    return this._container;
                }

                //---- setter ----
                this._container = ((value) && (value.length)) ? value[0] : value;

                return this;
            };

            /// public property: dataId
            dataAnimMgrExClass.prototype.dataId = function (value) {
                if (arguments.length === 0) {
                    return this._dataId;
                }

                //---- setter ----
                this._dataId = value;

                return this;
            };

            /** public property: keyFunc (can be a column name (string) or a callbackthat returns a unique ID for each record). */
            dataAnimMgrExClass.prototype.keyFunc = function (value) {
                if (arguments.length === 0) {
                    return this._pkCallback;
                }

                //---- setter ----
                this._pkCallback = value;

                return this;
            };

            /// public: getExistingShapes()
            dataAnimMgrExClass.prototype.getExistingShapes = function () {
                return this._enterShapes.concat(this._updateShapes);
            };

            dataAnimMgrExClass.prototype.statsCallback = function (value) {
                this._statsCallback = value;
                return this;
            };
            return dataAnimMgrExClass;
        })();
        animation.dataAnimMgrExClass = dataAnimMgrExClass;
    })(vp.animation || (vp.animation = {}));
    var animation = vp.animation;
})(vp || (vp = {}));
//# sourceMappingURL=dataAnimMgrEx.js.map

///----------------------------------------------------------------
/// (from animation\eases.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// eases.ts.  Copyright (c) 2014 Microsoft Corporation.
///            part of the vuePlotCore library - eases for animation.
///
/// - adapted from Microsoft WPF Framework (their ease functions).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (eases) {
        //---- enum: easeMode ----
        (function (EaseMode) {
            EaseMode[EaseMode["easeIn"] = 0] = "easeIn";
            EaseMode[EaseMode["easeOut"] = 1] = "easeOut";
            EaseMode[EaseMode["easeInOut"] = 2] = "easeInOut";
        })(eases.EaseMode || (eases.EaseMode = {}));
        var EaseMode = eases.EaseMode;

        (function (BezierEaseMode) {
            BezierEaseMode[BezierEaseMode["ease"] = 0] = "ease";
            BezierEaseMode[BezierEaseMode["easeIn"] = 1] = "easeIn";
            BezierEaseMode[BezierEaseMode["easeOut"] = 2] = "easeOut";
            BezierEaseMode[BezierEaseMode["easeInOut"] = 3] = "easeInOut";
            BezierEaseMode[BezierEaseMode["linear"] = 4] = "linear";
            BezierEaseMode[BezierEaseMode["maxEase"] = 5] = "maxEase";
        })(eases.BezierEaseMode || (eases.BezierEaseMode = {}));
        var BezierEaseMode = eases.BezierEaseMode;

        //---- class: easeBase ----
        var easeBase = (function () {
            function easeBase() {
                this.easeMode = 2 /* easeInOut */;
            }
            //---- this function is overwritten by subclasses ----
            easeBase.prototype.easeCore = function (t) {
                return t;
            };

            easeBase.prototype.ease = function (t) {
                var value;

                if (this.easeMode == 0 /* easeIn */) {
                    value = this.easeCore(t);
                } else if (this.easeMode == 1 /* easeOut */) {
                    value = 1 - this.easeCore(1 - t);
                } else {
                    if (t < .5) {
                        var coreValue = this.easeCore(t * 2);
                        value = coreValue * .5;
                    } else {
                        var coreValue = this.easeCore(2 * (1 - t));
                        value = (1 - coreValue) * .5 + .5;
                    }
                }

                return value;
            };
            return easeBase;
        })();
        eases.easeBase = easeBase;

        //---- class: floorEase ----
        //----      always uses the first value in a local pair of values. ----
        var floorEase = (function (_super) {
            __extends(floorEase, _super);
            function floorEase() {
                _super.apply(this, arguments);
            }
            floorEase.prototype.easeCore = function (t) {
                return 0;
            };
            return floorEase;
        })(easeBase);
        eases.floorEase = floorEase;

        //---- class: nearestNeighborEase ----
        //----      use the ease that "t" is closest to ----
        var nearestNeighborEase = (function (_super) {
            __extends(nearestNeighborEase, _super);
            function nearestNeighborEase() {
                _super.apply(this, arguments);
            }
            nearestNeighborEase.prototype.easeCore = function (t) {
                return (t < .5) ? 0 : 1;
            };
            return nearestNeighborEase;
        })(easeBase);
        eases.nearestNeighborEase = nearestNeighborEase;

        //---- class: linearEase ----
        //----      use the ease that "t" is closest to ----
        var linearEase = (function (_super) {
            __extends(linearEase, _super);
            function linearEase() {
                _super.apply(this, arguments);
            }
            linearEase.prototype.easeCore = function (t) {
                return t;
            };
            return linearEase;
        })(easeBase);
        eases.linearEase = linearEase;

        //---- class: quadraticEase ----
        var quadraticEase = (function (_super) {
            __extends(quadraticEase, _super);
            function quadraticEase() {
                _super.apply(this, arguments);
            }
            quadraticEase.prototype.easeCore = function (t) {
                return t * t;
            };
            return quadraticEase;
        })(easeBase);
        eases.quadraticEase = quadraticEase;

        //---- class: cubicEase ----
        var cubicEase = (function (_super) {
            __extends(cubicEase, _super);
            function cubicEase() {
                _super.apply(this, arguments);
            }
            cubicEase.prototype.easeCore = function (t) {
                return t * t * t;
            };
            return cubicEase;
        })(easeBase);
        eases.cubicEase = cubicEase;

        //---- class: quarticEase ----
        var quarticEase = (function (_super) {
            __extends(quarticEase, _super);
            function quarticEase() {
                _super.apply(this, arguments);
            }
            quarticEase.prototype.easeCore = function (t) {
                return t * t * t * t;
            };
            return quarticEase;
        })(easeBase);
        eases.quarticEase = quarticEase;

        //---- class: sineEase ----
        var sineEase = (function (_super) {
            __extends(sineEase, _super);
            function sineEase() {
                _super.apply(this, arguments);
            }
            sineEase.prototype.easeCore = function (t) {
                return 1 - Math.sin(Math.PI * .5 * (1 - t));
            };
            return sineEase;
        })(easeBase);
        eases.sineEase = sineEase;

        //---- class: circleEase ----
        var circleEase = (function (_super) {
            __extends(circleEase, _super);
            function circleEase() {
                _super.apply(this, arguments);
            }
            circleEase.prototype.easeCore = function (t) {
                return 1 - Math.sqrt(1 - t * t);
            };
            return circleEase;
        })(easeBase);
        eases.circleEase = circleEase;

        //---- class: backEase ----
        var backEase = (function (_super) {
            __extends(backEase, _super);
            function backEase(amplitude) {
                _super.call(this);
                this.amplitude = amplitude;
            }
            backEase.prototype.easeCore = function (t) {
                return Math.pow(t, 3.0) - t * this.amplitude * Math.sin(Math.PI * t);
            };
            return backEase;
        })(easeBase);
        eases.backEase = backEase;

        //---- class: powEase ----
        var powEase = (function (_super) {
            __extends(powEase, _super);
            function powEase(n) {
                _super.call(this);
                this.n = n;
            }
            powEase.prototype.easeCore = function (t) {
                return Math.pow(t, this.n);
            };
            return powEase;
        })(easeBase);
        eases.powEase = powEase;

        //---- class: stdEaseOut ----
        var stdEaseOut = (function (_super) {
            __extends(stdEaseOut, _super);
            function stdEaseOut() {
                _super.call(this);

                this.easeMode = 1 /* easeOut */;
            }
            stdEaseOut.prototype.easeCore = function (t) {
                return t * t;
            };
            return stdEaseOut;
        })(easeBase);
        eases.stdEaseOut = stdEaseOut;

        //---- class: expEase ----
        var expEase = (function (_super) {
            __extends(expEase, _super);
            function expEase(n) {
                _super.call(this);
                this.n = Math.max(0, n);
            }
            expEase.prototype.easeCore = function (t) {
                if (vp.utils.floatEq(0, this.n)) {
                    return t;
                } else {
                    return (Math.exp(this.n * t) - 1.0) / (Math.exp(this.n) - 1.0);
                }
            };
            return expEase;
        })(easeBase);
        eases.expEase = expEase;

        //---- class: springEase ----
        var springEase = (function (_super) {
            __extends(springEase, _super);
            function springEase(springiness, oscillations) {
                _super.call(this);

                this.springiness = springiness;
                this.oscillations = oscillations;
            }
            springEase.prototype.easeCore = function (t) {
                var expo = 0;

                if (vp.utils.floatEq(this.springiness, 0)) {
                    expo = t;
                } else {
                    expo = (Math.exp(this.springiness * t) - 1.0) / (Math.exp(this.springiness) - 1.0);
                }

                return expo * (Math.sin((Math.PI * 2.0 * this.oscillations + Math.PI * 0.5) * t));
            };
            return springEase;
        })(easeBase);
        eases.springEase = springEase;
    })(vp.eases || (vp.eases = {}));
    var eases = vp.eases;
})(vp || (vp = {}));
//# sourceMappingURL=eases.js.map

///----------------------------------------------------------------
/// (from animation\effects.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// effects.ts.  Copyright (c) 2014 Microsoft Corporation.
///              part of the vuePlotCore library - support for enter/exit animation effects.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (animation) {
        //---- animate opacity ----
        (function (FadeType) {
            FadeType[FadeType["none"] = 0] = "none";
            FadeType[FadeType["fade"] = 1] = "fade";
        })(animation.FadeType || (animation.FadeType = {}));
        var FadeType = animation.FadeType;

        //---- move shape to/from specified location ----
        (function (SlideLoc) {
            SlideLoc[SlideLoc["none"] = 0] = "none";
            SlideLoc[SlideLoc["left"] = 1] = "left";
            SlideLoc[SlideLoc["top"] = 2] = "top";
            SlideLoc[SlideLoc["right"] = 3] = "right";
            SlideLoc[SlideLoc["bottom"] = 4] = "bottom";
        })(animation.SlideLoc || (animation.SlideLoc = {}));
        var SlideLoc = animation.SlideLoc;

        (function (GrowOrigin) {
            GrowOrigin[GrowOrigin["none"] = 0] = "none";
            GrowOrigin[GrowOrigin["left"] = 1] = "left";
            GrowOrigin[GrowOrigin["top"] = 2] = "top";
            GrowOrigin[GrowOrigin["right"] = 3] = "right";
            GrowOrigin[GrowOrigin["bottom"] = 4] = "bottom";
            GrowOrigin[GrowOrigin["center"] = 5] = "center";
        })(animation.GrowOrigin || (animation.GrowOrigin = {}));
        var GrowOrigin = animation.GrowOrigin;

        //---- make an effect object ----
        function makeEffects(fadeType, slideLoc, growOrigin, rotateAngle, rotateCx, rotateCy) {
            var effects = {
                fadeType: fadeType, slideLoc: slideLoc, growOrigin: growOrigin,
                rotateAngle: rotateAngle, rotateCx: rotateCx, rotateCy: rotateCy
            };

            return effects;
        }
        animation.makeEffects = makeEffects;
    })(vp.animation || (vp.animation = {}));
    var animation = vp.animation;
})(vp || (vp = {}));
//# sourceMappingURL=effects.js.map

///----------------------------------------------------------------
/// (from animation\numberAnimation.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// numberAnimation.ts.  Copyright (c) 2014 Microsoft Corporation.
///   - part of the vuePlotCore library
///   - animates a numeric property.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (animation) {
        //---- class: numberAnimation ----
        var numberAnimation = (function () {
            function numberAnimation(parent, element, attributeName, fromValue, toValue, isCssProperty) {
                this.parent = parent;
                this.element = element;
                this.name = attributeName;

                var from = fromValue;
                var to = toValue;
                this.isCssProperty = isCssProperty;

                //---- remove "px" from value ----
                if ((vp.utils.isString(from)) && (from.endsWith("px"))) {
                    from = from.substr(0, from.length - 2);
                }

                //---- remove "px" from value ----
                if ((vp.utils.isString(to)) && (to.endsWith("px"))) {
                    to = to.substr(0, to.length - 2);
                }

                this.from = +from;
                this.to = +to;
            }
            /// private: getAnimatedValue(percent)
            numberAnimation.prototype.getAnimatedValue = function (percent) {
                var value = this.from + percent * (this.to - this.from);
                return value;
            };

            numberAnimation.prototype.isStyled = function () {
                return this.isCssProperty;
            };

            /// public: animateFrame(percent)
            numberAnimation.prototype.animateFrame = function (percent) {
                var value = this.getAnimatedValue(percent);
                var element = this.element;
                var attributeName = this.name;

                if (this.isCssProperty) {
                    if ((attributeName != "z-index") && (attributeName != "opacity")) {
                        value = value + "px";
                    }

                    element.style[attributeName] = value;
                } else if (element[attributeName] == null) {
                    if (value == 0) {
                        var a = 4242;
                    }

                    element.setAttribute(attributeName, value);
                } else {
                    //---- normal case - set using "baseVal.value" ----
                    if (element.rootContainer) {
                        //---- its a canvas element ----
                        //element[attributeName] = value;
                        //element.markDrawNeeded();
                        element.setAttribute(attributeName, value);
                    } else if (element.setAttribute) {
                        element.setAttribute(attributeName, value);
                    } else {
                        //---- its an SVG/HTML element ----
                        if (element[attributeName].baseVal) {
                            element[attributeName].baseVal.value = value;
                        } else {
                            element[attributeName] = value;
                        }
                    }
                }
            };
            return numberAnimation;
        })();
        animation.numberAnimation = numberAnimation;
    })(vp.animation || (vp.animation = {}));
    var animation = vp.animation;
})(vp || (vp = {}));
//# sourceMappingURL=numberAnimation.js.map

///----------------------------------------------------------------
/// (from animation\pointsAnimation.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// pointsAnimation.ts.  Copyright (c) 2014 Microsoft Corporation.
///   - part of the vuePlotCore library
///  - animates between 2 "points" strings (for a line or polygon element).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (animation) {
        //---- class: pointsAnimation ----
        var pointsAnimation = (function () {
            function pointsAnimation(parent, element, attributeName, fromPoints, toPoints) {
                this.element = element;
                this.parent = parent;
                this.attributeName = attributeName;

                var fromPairs = fromPoints.split(' ');
                var toPairs = toPoints.split(' ');
                var xFrom = [];
                var yFrom = [];
                var xTo = [];
                var yTo = [];
                var diffFound = false;

                for (var i = 0; i < fromPairs.length; i++) {
                    var fromPair = fromPairs[i];
                    var xParts = fromPair.split(",");
                    xFrom.push(+xParts[0]);
                    yFrom.push(+xParts[1]);

                    var toPair = toPairs[i];
                    var yParts = toPair.split(",");
                    xTo.push(+yParts[0]);
                    yTo.push(+yParts[1]);

                    if (xFrom != xTo || yFrom != yTo) {
                        diffFound = true;
                    }
                }

                if (!diffFound) {
                    vp.utils.error("pointsAnimation: from/to points are the same");
                }

                if (!xFrom.length || !yFrom.length) {
                    vp.utils.error("pointsAnimation: 'from' is not a valid points string");
                }

                if (!xTo.length || !yTo.length) {
                    vp.utils.error("pointsAnimation: 'to' is not a valid points string");
                }

                this.xFrom = xFrom;
                this.yFrom = yFrom;
                this.xTo = xTo;
                this.yTo = yTo;
            }
            /// private: getAnimateCalue(percent)
            pointsAnimation.prototype.getAnimatedValue = function (percent) {
                var xFrom = this.xFrom;
                var yFrom = this.yFrom;
                var xTo = this.xTo;
                var yTo = this.yTo;

                var value = "";

                for (var i = 0; i < xFrom.length; i++) {
                    var x = xFrom[i] + percent * (xTo[i] - xFrom[i]);
                    var y = yFrom[i] + percent * (yTo[i] - yFrom[i]);

                    if (i == 0) {
                        value = x + "," + y;
                    } else {
                        value += " " + x + "," + y;
                    }
                }

                return value;
            };

            /// public: animateFrame(percent)
            pointsAnimation.prototype.animateFrame = function (percent) {
                var value = this.getAnimatedValue(percent);
                this.element.setAttribute(this.attributeName, value);
            };
            return pointsAnimation;
        })();
        animation.pointsAnimation = pointsAnimation;
    })(vp.animation || (vp.animation = {}));
    var animation = vp.animation;
})(vp || (vp = {}));
//# sourceMappingURL=pointsAnimation.js.map

///----------------------------------------------------------------
/// (from animation\transformAnimation.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// transformAnimation.ts.  Copyright (c) 2014 Microsoft Corporation.
///   - part of the vuePlotCore library
///   - animates a transform (scale, translation, rotation).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (animation) {
        //---- class: transformAnimation ----
        var transformAnimation = (function () {
            function transformAnimation(parent, element) {
                this.parts = [];
                this.parent = parent;
                this.element = element;
            }
            /// public.
            transformAnimation.prototype.makeTransform = function (name, fromValue, toValue, cx, cy) {
                //---- remove any previous PART using this name ----
                this.removePart(name);

                var part = { name: name, from: fromValue, to: toValue, cx: cx, cy: cy };
                this.parts.push(part);
            };

            transformAnimation.prototype.removePart = function (name) {
                for (var i = this.parts.length - 1; i >= 0; i--) {
                    var part = this.parts[i];

                    if (part.name == name) {
                        this.parts.removeAt(i);
                        vp.utils.debug("transformAnimation.removePart: removed name=" + name);

                        break;
                    }
                }
            };

            /// private.
            transformAnimation.prototype.getAnimatedValue = function (percent) {
                //---- build transform string from parts[] ----
                var str = "";
                var parts = this.parts;

                for (var i = 0; i < parts.length; i++) {
                    var part = parts[i];
                    var nextPartName = (i < parts.length - 1) ? parts[i + 1].name : "";

                    var from = +part.from;
                    var to = +part.to;
                    var value = from + percent * (to - from);

                    if (part.name == "scale.x") {
                        var x = value;
                        var y = 1;

                        if (nextPartName == "scale.y") {
                            i++;
                            var nextPart = parts[i];

                            y = +nextPart.from + percent * (+nextPart.to - +nextPart.from);
                        }

                        if (vp.utils.isDefined(part.cx)) {
                            //---- center the scaling at cx, cy ----
                            str += "translate( " + (-part.cx * (x - 1)) + ", " + (-part.cy * (y - 1)) + ") ";
                        }

                        str += "scale(" + x + " " + y + ") ";
                    } else if (part.name == "scale.y") {
                        if (vp.utils.isDefined(part.cx)) {
                            //---- center the scaling at cx, cy ----
                            str += "translate(0 " + (-part.cy * (value - 1)) + ") ";
                        }

                        str += "scale(1 " + value + ") ";
                    } else if (part.name == "translate.x") {
                        var x = value;
                        var y = 0;

                        if (nextPartName == "translate.y") {
                            i++;
                            var nextPart = parts[i];

                            y = +nextPart.from + percent * (+nextPart.to - +nextPart.from);
                        }

                        str += "translate(" + x + " " + y + ") ";
                    } else if (part.name == "translate.y") {
                        str += "translate(0 " + value + ") ";
                    } else if (part.name == "rotate") {
                        str += "rotate(" + value;

                        if (vp.utils.isDefined(part.cx)) {
                            str += " " + part.cx + " " + part.cy;
                        }

                        str += ") ";
                    }
                }

                return str;
            };

            /// public.
            transformAnimation.prototype.animateFrame = function (percent) {
                var transformStr = this.getAnimatedValue(percent).trim();
                this.element.setAttribute("transform", transformStr);
            };
            return transformAnimation;
        })();
        animation.transformAnimation = transformAnimation;
    })(vp.animation || (vp.animation = {}));
    var animation = vp.animation;
})(vp || (vp = {}));
//# sourceMappingURL=transformAnimation.js.map
///-----------------------------------------------------------------------------------------------------------------
/// axisHelperBase.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (visuals) {
        /** The base class for the 4 axisHelper classes.  This class holds drawing data & properties & provides getter/setter access to them.  */
        var axisHelperBaseClass = (function () {
            function axisHelperBaseClass(container, location, useWebGl, makeCrisp) {
                this._ellipsesBounds = null;
                this._axisSize = 100;
                this._expandSpace = 0;
                //---- data ----
                this._name = "";
                //---- drawing parameters ----
                this._drawAxisLine = true;
                this._drawAxisName = true;
                this._ticksOnInside = false;
                this._labelOverflow = 0 /* overWrite */;
                this._labelRotation = 0 /* none */;
                this._nameRotation = 0 /* none */;
                this._onShade = null;
                //---- label sizes ----
                /** minimum spacing between largest label and avail space per label before overflow algorithm applies, for 0, 45, and 90 degree rotations. */
                this._minLabelSpacing = [4, -2, -6];
                /** when set, limits the size of the label space perpendicular to the axis.  */ this._maxPerpendicularSize = undefined;
                //---- internal params (not currently customizable) ----
                this._tickLength = 8;
                this._minorTickLength = 4;
                this._spaceAfterTick = 0;
                this._spaceAfterLabel = 4;
                this._spaceAfterName = 0;
                //---- measurements ----
                this._labelSizes = null;
                this._szMaxText = { width: 0, height: 0 };
                this._availPixelsPerLabel = 0;
                this._actualLabelRotation = 0;
                this._rootMark = vp.marks.createGroupMark(container, "vpxAxis");
                this._rootElem = this._rootMark.rootElem();

                vp.select(this._rootElem).addClass("vpxAxis");

                this._location = location;
                this._makeCrisp = makeCrisp;

                //---- use the groupElem that markBase created as our root elem ----
                var tempParent = this._rootElem;

                var svg = null;
                var fakeLabel = null;

                //---- always append this for measuring ----
                if (tempParent.tagName == "CANVAS" || tempParent.rootContainer) {
                    var svg = vp.select(document.body).append("svg").addClass("vpxAxis").css("opacity", "0").id("fakeSvgForMeasuring");

                    this._fakeSvg = svg;

                    fakeLabel = svg.append("text").addClass("vpxAxisLabel").css("opacity", "0").attr("x", 0).attr("y", 0).id("fakeLabelForMeasuring");
                } else {
                    fakeLabel = vp.select(tempParent).append("text").addClass("vpxAxisLabel").id("fakeLabelForMeasuring").css("opacity", "0");
                }

                //---- leave space for elippses ----
                fakeLabel.text("...");
                var rc = fakeLabel[0].getBBox();

                this._ellipsesBounds = rc;
                this._fakeLabel = fakeLabel[0];
            }
            //---- to be overridden by the subclass ----
            axisHelperBaseClass.prototype.shadeMarks = function (transition, record, index, isNew, context) {
                var group = vp.select(this._rootElem).addClass("vpxAxis");
            };

            axisHelperBaseClass.prototype.rootElem = function () {
                return this._rootElem;
            };

            axisHelperBaseClass.prototype.hide = function (transition) {
                var opacity = +vp.select(this._rootElem).attr("opacity");
                if (opacity) {
                    if (transition) {
                        vp.select(this._rootElem).animate(transition.duration()).attr("opacity", 0);
                    } else {
                        vp.select(this._rootElem).attr("opacity", 0);
                    }
                }
            };

            axisHelperBaseClass.prototype.show = function (transition) {
                var opacity = +vp.select(this._rootElem).attr("opacity");
                if (!opacity) {
                    if (transition) {
                        vp.select(this._rootElem).animate(transition.duration()).attr("opacity", 1);
                    } else {
                        vp.select(this._rootElem).attr("opacity", 1);
                    }
                }
            };

            axisHelperBaseClass.prototype.translate = function (x, y, makeCrispAdjustment) {
                if (makeCrispAdjustment === undefined && this._makeCrisp) {
                    makeCrispAdjustment = true;
                }

                //---- magic offset only works on direct groups? ----
                vp.select(this._rootElem).translate(x, y, makeCrispAdjustment);

                return this;
            };

            axisHelperBaseClass.prototype.rotateText45 = function (wrapElem, yCorrection, rc, alignTo) {
                var angle = 45;
                var anchor = "middle";
                var valign = "middle";

                if (alignTo == 1 /* top */) {
                    //---- rotate at MIDDLE LEFT to keep top of text aligned ----
                    anchor = "start";
                    var rx = rc.x;
                    var ry = rc.y + rc.height / 2;

                    //---- after-rotation adjustments ---
                    rx += rc.width / 2 - 12;
                    ry += 4; //-6;
                } else if (alignTo == 3 /* bottom */) {
                    //---- rotate at BOTTOM RIGHT to keep top of text aligned ----
                    anchor = "end";
                    valign = "bottom";
                    var rx = rc.x + rc.width;
                    var ry = rc.y + rc.height;

                    //---- after-rotation adjustments ---
                    rx -= rc.width / 2 + 2;
                    ry += -(rc.height + 4);
                } else if (alignTo == 2 /* right */) {
                    //---- rotate at TOP RIGHT to keep top of text aligned ----
                    valign = "top";
                    anchor = "end";
                    var rx = rc.x + rc.width;
                    var ry = rc.y;

                    //---- after-rotation adjustments ---
                    rx += -4;
                    ry += -4;
                } else if (alignTo == 0 /* left */) {
                    //---- rotate at TOP LEFT to keep top of text aligned ----
                    valign = "top";
                    anchor = "start";
                    var rx = rc.x;
                    var ry = rc.y;

                    //---- after-rotation adjustments ---
                    rx += 4;
                    ry += -8;
                }

                var rotateStr = "rotate(" + angle + ", " + rx + ", " + ry + ")";

                wrapElem.attr("x", rx).attr("y", ry).attr("text-anchor", anchor).textBaseline(valign).attr("transform", rotateStr);

                //---- approximate sizes for 45 degree rotation ----
                var height = .85 * rc.width;
                var width = .85 * rc.width;

                return { width: width, height: height };
            };

            axisHelperBaseClass.prototype.labelSizes = function (value) {
                if (arguments.length === 0) {
                    var data = {
                        sizes: this._labelSizes,
                        szMaxText: this._szMaxText,
                        pixelsPerLabel: this._availPixelsPerLabel,
                        actualLabelRotation: this._actualLabelRotation
                    };

                    if (!this._labelSizes || !this.labelSizes.length) {
                        data = null;
                    }

                    return data;
                }

                this._labelSizes = (value) ? value.sizes : null;
                this._szMaxText = (value) ? value.szMaxText : { width: 0, height: 0 };
                this._availPixelsPerLabel = (value) ? value.pixelsPerLabel : 0;
                this._actualLabelRotation = (value) ? value.actualLabelRotation : 0;

                return this;
            };

            axisHelperBaseClass.prototype.getAvailablePixelsPerLabelForTruncation = function (actualLabelRotation) {
                var availPixelsPerLabel = 0;

                var perpSize = (this._maxPerpendicularSize > 0) ? this._maxPerpendicularSize : 999999;
                var perpSize45 = Math.sqrt(2) * perpSize;
                var regSize = this._availPixelsPerLabel;

                if (this._location == 0 /* left */ || this._location == 2 /* right */) {
                    //---- vertical axis ----
                    if (actualLabelRotation == 90) {
                        availPixelsPerLabel = regSize;
                    } else if (actualLabelRotation == 45) {
                        availPixelsPerLabel = perpSize45;
                    } else {
                        availPixelsPerLabel = perpSize;
                    }
                } else {
                    //---- horizontal axis ----
                    if (actualLabelRotation == 0) {
                        availPixelsPerLabel = regSize;
                    } else if (actualLabelRotation == 45) {
                        availPixelsPerLabel = perpSize45;
                    } else {
                        availPixelsPerLabel = perpSize;
                    }
                }

                return availPixelsPerLabel;
            };

            axisHelperBaseClass.prototype.shadeTextLabel = function (index, element, cx, cy, text, hAlign, vAlign, alignTo, returnWidth, availPixelsPerLabel) {
                var fullText = text;
                var actualLabelRotation = this._actualLabelRotation;

                //---- TRUNCATE TEXT ----
                if ((availPixelsPerLabel) && (this._labelOverflow == 2 /* ellipses */ || this._labelOverflow == 1 /* truncate */)) {
                    text = this.truncateText(text, availPixelsPerLabel, this._labelOverflow);
                }

                var wrap = vp.select(element).attr("x", cx).attr("y", cy).attr("text-anchor", hAlign).text(text).title(fullText);

                //---- now that properties are all set, VERT ALIGN at "cy" ----
                var rcx = this.getLabelBounds(index, cx, cy, hAlign);
                var yCorrection = rcx.yCorrection;

                if (text != fullText) {
                    rcx = element.getBBox();
                }

                wrap.textBaseline(vAlign, rcx);

                var rc = new vp.geom.rectLight(rcx.x, rcx.y + yCorrection, rcx.width, rcx.height);
                var mySize = (returnWidth) ? rc.width : rc.height;

                if (actualLabelRotation) {
                    if (actualLabelRotation == 45) {
                        var result = this.rotateText45(wrap, yCorrection, rc, alignTo);
                    } else if (actualLabelRotation == 90) {
                        var result = this.rotateText90(wrap, yCorrection, rc, alignTo);
                        //this._maxTextHeight = Math.max(this._maxTextHeight, result.height);
                    }

                    mySize = (returnWidth) ? result.width : result.height;
                } else {
                    //if (index == 0)
                    //{
                    //    //---- just need to do this once for unrotated text ----
                    //    this._maxTextHeight = Math.max(this._maxTextHeight, rc.height);
                    //}
                }

                return mySize;
            };

            axisHelperBaseClass.prototype.getLabelBounds = function (index, x, y, hAlign) {
                var rc = new vp.geom.rectLight(0, 0, 1, 1);
                if (this._labelSizes) {
                    rc = this._labelSizes[index];
                }

                //---- yCorrection is the number text.top is shifted by due to unstoppable alphabetic line vertical alignment ----
                var yCorrection = -rc.y;

                if (hAlign == "middle") {
                    x -= rc.width / 2;
                } else if (hAlign == "end") {
                    x -= rc.width;
                }

                //---- cannot modify system SVGRect; must recreate it ----
                var rcx = { x: x, y: y - yCorrection, width: rc.width, height: rc.height, yCorrection: yCorrection };

                return rcx;
            };

            axisHelperBaseClass.prototype.rotatedSize = function (rotation, normalSize, size90) {
                var newSize = normalSize;

                if (rotation == 90 /* rotate90 */) {
                    newSize = size90;
                } else if (rotation == 45 /* rotate45 */) {
                    newSize = Math.cos(45) * normalSize + Math.sin(45) * size90;
                }

                return newSize;
            };

            axisHelperBaseClass.prototype.rotateText90 = function (wrapElem, yCorrection, rc, alignTo) {
                var angle = 90;

                //---- compute true CENTER of element (where rotation will be done) ----
                var rx = rc.x + rc.width / 2;
                var ry = rc.y + rc.height / 2;

                var rxChanged = false;
                var ryChanged = false;

                //---- adjustsment needed after clean rotation  tp PRESERVE ALIGNMENT ----
                if (alignTo == 0 /* left */) {
                    //---- ALIGN TO LEFT ----
                    rx += (-rc.width / 2); // + rc.height / 4);
                    rxChanged = true;
                } else if (alignTo == 2 /* right */) {
                    //---- ALIGN TO RIGHT ----
                    rx += (+rc.width / 2 - rc.height / 2);
                    rxChanged = true;
                } else if (alignTo == 1 /* top */) {
                    //---- ALIGN TO TOP ----
                    rx += -rc.height / 2 - 5;
                    ry += (+rc.width / 2 - rc.height / 2) + 4;
                    rxChanged = true;
                    ryChanged = true;
                } else if (alignTo == 3 /* bottom */) {
                    //---- ALIGN TO BOTTOM ----
                    ry += -rc.width / 2 - rc.height / 2;
                    ryChanged = true;
                }

                if (rxChanged) {
                    wrapElem.attr("x", rx).attr("text-anchor", "middle");
                }

                if (ryChanged) {
                    wrapElem.attr("y", ry).textBaseline("middle");
                }

                //---- finally, apply the rotation ----
                var rotateStr = "rotate(" + angle + ", " + rx + ", " + ry + ")";

                wrapElem.attr("transform", rotateStr);

                //--- getBBox() doesn't report rotated info, so just calc ourselves ----
                return { width: rc.height, height: rc.width };
            };

            axisHelperBaseClass.prototype.hideTicksIfTooMany = function () {
                var availAxisSize = this._axisSize - 2 * this._expandSpace;

                var pixelsPerTick = availAxisSize / this._tickOffsets.length;
                var minPixelsPerTick = 2;

                if (pixelsPerTick < minPixelsPerTick) {
                    //---- hide the ticks ----
                    this._tickOffsets = [];
                    this._minorTickOffsets = [];
                }
            };

            axisHelperBaseClass.prototype.getActualLabelRotation = function (maxMeasuredWidth, maxMeasuredHeight, axisSize, labelCount) {
                var rotation = this._labelRotation;

                if (rotation == -1 /* auto */) {
                    //---- can labels fit unrotated? ----
                    rotation = 0 /* none */;
                    var pixelsAvailPerLabel = (axisSize / labelCount) - this._minLabelSpacing[0];

                    if (pixelsAvailPerLabel < maxMeasuredWidth) {
                        //---- no; try 45 degrees ----
                        rotation = 45 /* rotate45 */;
                        pixelsAvailPerLabel = (axisSize / labelCount) - this._minLabelSpacing[1];
                        var pixelsRequired = 1.34 * maxMeasuredHeight;

                        if (pixelsAvailPerLabel < pixelsRequired) {
                            //---- no; try 90 degrees ----
                            rotation = 90 /* rotate90 */;
                            pixelsAvailPerLabel = (axisSize / labelCount) - this._minLabelSpacing[2];
                            var pixelsRequired = maxMeasuredHeight;

                            if (pixelsAvailPerLabel < pixelsRequired) {
                                //---- no more rotation remedies to apply ----
                            }
                        }
                    }
                }

                return rotation;
            };

            axisHelperBaseClass.prototype.getAvailPixelsPerLabel = function (actualRotation, availAxisSize, labelCount) {
                var avail = 0;

                if (actualRotation == 0 /* none */) {
                    avail = (availAxisSize / labelCount) - this._minLabelSpacing[0];
                } else if (actualRotation == 45 /* rotate45 */) {
                    avail = (availAxisSize / labelCount) - this._minLabelSpacing[1];
                } else if (actualRotation == 90 /* rotate90 */) {
                    avail = (availAxisSize / labelCount) - this._minLabelSpacing[2];
                }

                return avail;
            };

            /** See if labels can fit the axis, using rotation and trimming. */
            axisHelperBaseClass.prototype.canLabelsFit = function (availAxisSize, labelCount, maxMeasuredWidth, maxMeasuredHeight) {
                //---- unrotated fit ----
                var availPixels0 = (availAxisSize / labelCount) - this._minLabelSpacing[0];
                var neededPixels0 = maxMeasuredWidth;
                var canFit0 = (availPixels0 >= neededPixels0);

                //---- 45 degree fit ----
                var availPixels45 = (availAxisSize / labelCount) - this._minLabelSpacing[1];
                var neededPixels45 = 1.34 * maxMeasuredHeight;
                var canFit45 = (availPixels45 >= neededPixels45);

                //---- 90 degree fit ----
                var availPixels90 = (availAxisSize / labelCount) - this._minLabelSpacing[2];
                var neededPixels90 = maxMeasuredHeight;
                var canFit90 = (availPixels90 >= neededPixels90);

                //---- different for all values of rotation -----
                var canFit = false;
                var rotation = this._labelRotation;

                if (rotation == 0 /* none */) {
                    canFit = canFit0;
                } else if (rotation == 45 /* rotate45 */) {
                    canFit = canFit45;
                } else if (rotation == 90 /* rotate90 */) {
                    canFit = canFit90;
                } else if (rotation == -1 /* auto */) {
                    canFit = (canFit0 || canFit45 || canFit90);
                }

                return canFit;
            };

            axisHelperBaseClass.prototype.measureAllLabels = function (labelStrings) {
                var availAxisSize = this._axisSize - 2 * this._expandSpace;
                var maxMeasuredWidth = 0;
                var maxMeasuredHeight = 0;
                var fakeLabel = this._fakeLabel;
                var labelSizes = null;

                var labels = labelStrings;
                var availPixelsPerLabel = 0;
                var actualLabelRotation = 0 /* none */;

                if (labels.length) {
                    //---- PRE-MEASUREMENT policies ----
                    //---- IMPORTANT PERF: avoid measurement of more labels that could possibly fit ----
                    if (!this.canLabelsFit(availAxisSize, labels.length, this._ellipsesBounds.width / 3, this._ellipsesBounds.height)) {
                        //---- hide labels ----
                        this._labelOffsets = [];
                        this._labelStrings = [];
                    } else {
                        //vp.utils.debug("measureAllLabels: count=" + labels.length);
                        labelSizes = [];

                        for (var i = 0; i < labels.length; i++) {
                            var label = labels[i];

                            //---- set up for measuring "labelStr" ----
                            fakeLabel.textContent = label;

                            var rc = fakeLabel.getBBox();
                            labelSizes.push(rc);

                            maxMeasuredWidth = Math.max(maxMeasuredWidth, rc.width);
                            maxMeasuredHeight = Math.max(maxMeasuredHeight, rc.height);
                        }
                    }

                    //---- POST-MEASUREMENT policies ----
                    //---- apply "auto rotation" policy ----
                    actualLabelRotation = this.getActualLabelRotation(maxMeasuredWidth, maxMeasuredHeight, availAxisSize, labels.length);

                    availPixelsPerLabel = this.getAvailPixelsPerLabel(actualLabelRotation, availAxisSize, labels.length);

                    //---- apply "hide all" policy ----
                    if (this._labelOverflow == 3 /* hideAll */) {
                        var canFit = this.canLabelsFit(availAxisSize, labels.length, maxMeasuredWidth, maxMeasuredHeight);
                        if (!canFit) {
                            //---- hide labels ----
                            this._labelOffsets = [];
                            this._labelStrings = [];
                            labelSizes = null;
                        }
                    }
                }

                this._labelSizes = labelSizes;
                this._availPixelsPerLabel = availPixelsPerLabel;
                this._actualLabelRotation = actualLabelRotation;

                return { width: maxMeasuredWidth, height: maxMeasuredHeight };
            };

            axisHelperBaseClass.prototype.truncateText = function (text, maxLength, overflow) {
                var newStr = "";
                var fakeLabel = this._fakeLabel;

                //---- first, see if whole text fits ----
                fakeLabel.textContent = text;
                var rc = fakeLabel.getBBox();

                if (rc.width <= maxLength) {
                    newStr = text;
                } else {
                    if (overflow == 2 /* ellipses */) {
                        //---- leave space for elippses ----
                        maxLength -= this._ellipsesBounds.width;
                    }

                    //---- do a binary search on the best string ----
                    var low = 0;
                    var high = text.length - 1;

                    while (low <= high) {
                        var next = Math.floor((high + low) / 2);

                        var testStr = text.substr(0, next);
                        fakeLabel.textContent = testStr;

                        var rc = fakeLabel.getBBox();
                        if (rc.width > maxLength) {
                            high = next - 1;
                        } else {
                            low = next + 1;
                            newStr = testStr;
                        }
                    }

                    if (overflow == 2 /* ellipses */) {
                        newStr += "...";
                    }
                }

                return newStr;
            };

            axisHelperBaseClass.prototype.eraseCanvas = function () {
                this._rootElem.eraseCanvas();
            };

            axisHelperBaseClass.prototype.tickOffsets = function (value) {
                if (arguments.length === 0) {
                    return this._tickOffsets;
                }

                this._tickOffsets = value;
                return this;
            };

            axisHelperBaseClass.prototype.minorTickOffsets = function (value) {
                if (arguments.length === 0) {
                    return this._minorTickOffsets;
                }

                this._minorTickOffsets = value;
                return this;
            };

            axisHelperBaseClass.prototype.labelOffsets = function (value) {
                if (arguments.length === 0) {
                    return this._labelOffsets;
                }

                this._labelOffsets = value;
                return this;
            };

            axisHelperBaseClass.prototype.labelStrings = function (value) {
                if (arguments.length === 0) {
                    return this._labelStrings;
                }

                this._labelStrings = value;
                return this;
            };

            axisHelperBaseClass.prototype.drawAxisLine = function (value) {
                if (arguments.length === 0) {
                    return this._drawAxisLine;
                }

                this._drawAxisLine = value;
                return this;
            };

            axisHelperBaseClass.prototype.drawAxisName = function (value) {
                if (arguments.length === 0) {
                    return this._drawAxisName;
                }

                this._drawAxisName = value;
                return this;
            };

            axisHelperBaseClass.prototype.name = function (value) {
                if (arguments.length === 0) {
                    return this._name;
                }

                this._name = value;
                return this;
            };

            axisHelperBaseClass.prototype.labelRotation = function (value) {
                if (arguments.length === 0) {
                    return this._labelRotation;
                }

                this._labelRotation = value;
                return this;
            };

            axisHelperBaseClass.prototype.nameRotation = function (value) {
                if (arguments.length === 0) {
                    return this._nameRotation;
                }

                this._nameRotation = value;
                return this;
            };

            axisHelperBaseClass.prototype.minLabelSpacing = function (value) {
                if (arguments.length === 0) {
                    return this._minLabelSpacing;
                }

                if (!vp.utils.isArray(value)) {
                    value = [value];
                }

                this._minLabelSpacing = value;
                return this;
            };

            axisHelperBaseClass.prototype.maxPerpendicularSize = function (value) {
                if (arguments.length === 0) {
                    return this._maxPerpendicularSize;
                }

                this._maxPerpendicularSize = value;
                return this;
            };

            axisHelperBaseClass.prototype.expandSpace = function (value) {
                if (arguments.length === 0) {
                    return this._expandSpace;
                }

                this._expandSpace = value;
                return this;
            };

            axisHelperBaseClass.prototype.labelOverflow = function (value) {
                if (arguments.length === 0) {
                    return this._labelOverflow;
                }

                this._labelOverflow = value;
                return this;
            };

            axisHelperBaseClass.prototype.onShade = function (value) {
                if (arguments.length === 0) {
                    return this._onShade;
                }

                this._onShade = value;
                return this;
            };
            return axisHelperBaseClass;
        })();
        visuals.axisHelperBaseClass = axisHelperBaseClass;

        /** Specifies how to truncate or hide axis labels that exceed the available space.  If "maxLabelSize" is specified, the
        width of the unrotated label, or the height of the rotated label, is compared to the specified value of "maxLabelSize".  Otherwise, the rotated  size of the
        label in the direction of the axis is compared to the available space between breaks on the axis.  When not enough space is available,
        "LabelOverflow" specifies how the label is drawn. */
        (function (LabelOverflow) {
            //clip,
            /** draws the entire label, even if it results in labels overwriting each other. */
            LabelOverflow[LabelOverflow["overWrite"] = 0] = "overWrite";

            /** truncates the label to fit the available space. */
            LabelOverflow[LabelOverflow["truncate"] = 1] = "truncate";

            /** truncates the label with "..." marks to fit the available space. */
            LabelOverflow[LabelOverflow["ellipses"] = 2] = "ellipses";

            /** hides all of the labels on the axis if any of the labels is too large for the available space. */
            LabelOverflow[LabelOverflow["hideAll"] = 3] = "hideAll";
        })(visuals.LabelOverflow || (visuals.LabelOverflow = {}));
        var LabelOverflow = visuals.LabelOverflow;

        /** Specifies the rotation of the axis labels or name. */
        (function (LabelRotation) {
            LabelRotation[LabelRotation["none"] = 0] = "none";
            LabelRotation[LabelRotation["rotate45"] = 45] = "rotate45";
            LabelRotation[LabelRotation["rotate90"] = 90] = "rotate90";
            LabelRotation[LabelRotation["auto"] = -1] = "auto";
        })(visuals.LabelRotation || (visuals.LabelRotation = {}));
        var LabelRotation = visuals.LabelRotation;

        /** Specifies where the labels are, relative to the axis line.  */
        (function (LabelLocation) {
            LabelLocation[LabelLocation["left"] = 0] = "left";
            LabelLocation[LabelLocation["top"] = 1] = "top";
            LabelLocation[LabelLocation["right"] = 2] = "right";
            LabelLocation[LabelLocation["bottom"] = 3] = "bottom";
        })(visuals.LabelLocation || (visuals.LabelLocation = {}));
        var LabelLocation = visuals.LabelLocation;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=$axisHelperBase.js.map

///----------------------------------------------------------------
/// (from axes\axis.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// axis.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
/// notes on mark composition:
///     - each higher level mark must expose a "generate(data, transition)" method and an "onShade()" getter/setter.
///     - be prepared to generate N copies of the higher level object.
///     - the recommended approach is to derrive from, or own an instance of, a group mark.
///     - most of the core work is done in the lower level mark's "onShade()" function.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (visuals) {
        /** Creates a class that, given explicit information, can draw a change-animated axis.  */
        var axisClass = (function () {
            function axisClass(rootElem, scale, location, useWebGl, makeCrisp) {
                this._breakValues = null;
                this._minorBreakValues = null;
                this._tickCount = 10;
                this._isNameVisible = true;
                this._isAxisVisible = true;
                this._isLabelsVisible = true;
                this._isTicksVisible = true;
                this._hideInteriorLabels = false;
                this._location = location;

                if (location === 3 /* bottom */) {
                    this._helper = new visuals.bottomAxisHelperClass(rootElem, useWebGl, makeCrisp);
                } else if (location === 1 /* top */) {
                    this._helper = new visuals.topAxisHelperClass(rootElem, useWebGl, makeCrisp);
                } else if (location === 0 /* left */) {
                    this._helper = new visuals.leftAxisHelperClass(rootElem, useWebGl, makeCrisp);
                } else if (location === 2 /* right */) {
                    this._helper = new visuals.rightAxisHelperClass(rootElem, useWebGl, makeCrisp);
                } else {
                    throw "location=" + location + " not yet supported!";
                }

                //super(container, useWebGl);
                this._scale = scale;
            }
            axisClass.prototype.shadeMarks = function (clearMeasurements, transition, data, index, isNew, context) {
                var _this = this;
                if (typeof clearMeasurements === "undefined") { clearMeasurements = true; }
                if (clearMeasurements) {
                    this._helper.labelSizes(null);
                    this._helper.labelStrings(null);
                }

                var breaks = this.getActualBreaks();
                var minorBreaks = this.getActualMinorBreaks(breaks);

                var labels = (this._isLabelsVisible) ? this.getActualLabels(breaks) : [];
                var tickOffsets = null;
                var minorOffsets = null;
                var labelOffsets = null;

                var scaleType = this._scale.scaleType();
                if (scaleType == 3 /* category */ || scaleType == 4 /* categoryKey */) {
                    var categoryScale = this._scale;
                    var halfStep = categoryScale.stepSize() / 2;
                    labelOffsets = [];

                    tickOffsets = breaks.map(function (value, index) {
                        var offset = _this._scale.scale(value);

                        if (labels && labels.length) {
                            labelOffsets.push(offset);
                        }

                        return offset - halfStep;
                    });

                    if (tickOffsets.length > 0) {
                        //---- add extra tick at end ----
                        var count = tickOffsets.length;
                        var extraOffset = tickOffsets[count - 1] + 2 * halfStep;
                        tickOffsets.push(extraOffset);
                    }
                } else {
                    //---- scale breaks into TICKOFFSETS ----
                    tickOffsets = breaks.map(function (value, index) {
                        return _this._scale.scale(value);
                    });

                    //---- scale minorBreaks into MINOROFFSETS ----
                    if (!minorBreaks) {
                        minorBreaks = [];
                    }

                    minorOffsets = minorBreaks.map(function (value, index) {
                        return _this._scale.scale(value);
                    });

                    labelOffsets = tickOffsets;
                }

                if (!this._isTicksVisible) {
                    tickOffsets = [];
                    minorOffsets = [];
                }

                if (!this._isLabelsVisible) {
                    labelOffsets = [];
                } else if (this._hideInteriorLabels) {
                    if (labelOffsets.length > 2) {
                        //---- use first and last ----
                        labelOffsets = [labelOffsets[0], labelOffsets[labelOffsets.length - 1]];

                        labels = [labels[0], labels[labels.length - 1]];
                    }
                }

                this._helper.tickOffsets(tickOffsets).minorTickOffsets(minorOffsets).labelOffsets(labelOffsets).labelStrings(labels).name(this._isNameVisible ? this._name : "").drawAxisLine(this._isAxisVisible).expandSpace(this._scale.expandSpace());

                this._helper.shadeMarks(transition, data, index, isNew, context);
            };

            axisClass.prototype.getActualBreaks = function () {
                var breaks = this._breakValues;

                if (!breaks) {
                    var scaleType = this._scale.scaleType();

                    if (scaleType == 3 /* category */ || scaleType == 4 /* categoryKey */) {
                        breaks = vp.utils.keys(this._scale.categoryKeys());
                    } else if (scaleType == 1 /* log */) {
                        var min = this._scale.domainMin();
                        var max = this._scale.domainMax();
                        breaks = [];

                        for (var i = 0; i < 9999999; i++) {
                            var bv = min * Math.pow(10, i);

                            if (bv > max) {
                                break;
                            }

                            breaks.push(bv);
                        }
                    } else if (scaleType == 2 /* exp */) {
                        var min = this._scale.domainMin();
                        var max = this._scale.domainMax();
                        breaks = [];

                        for (var i = 0; i < 9999999; i++) {
                            var bv = min * Math.pow(10, i);

                            if (bv > max) {
                                break;
                            }

                            breaks.push(bv);
                        }
                    } else if (scaleType == 0 /* linear */ || scaleType == 5 /* dateTime */) {
                        var min = this._scale.domainMin();
                        var max = this._scale.domainMax();
                        var step = (max - min) / (this._tickCount - 1);

                        breaks = vp.utils.range(min, max, step);
                    } else {
                        vp.utils.error("axis.generate: unsupported scaleType=" + scaleType);
                    }
                }

                return breaks;
            };

            axisClass.prototype.getActualMinorBreaks = function (breaks) {
                var minor = this._minorBreakValues;

                if (!minor) {
                    var scaleType = this._scale.scaleType();

                    if (scaleType == 1 /* log */) {
                        var min = this._scale.domainMin();
                        var max = this._scale.domainMax();
                        minor = [];

                        for (var i = 1; i < breaks.length; i++) {
                            var incr = breaks[i - 1];

                            for (var j = 2; j < 10; j++) {
                                minor.push(j * incr);
                            }
                        }
                    }
                }

                return minor;
            };

            axisClass.prototype.getActualLabels = function (breakValues) {
                var labels = null;
                var isCategory = (this._scale.scaleType() != 0 /* linear */);

                var formatter = (isCategory) ? vp.formatters.string : vp.formatters.comma;

                if (!labels) {
                    labels = breakValues.map(function (value, index) {
                        return formatter(value);
                    });
                }

                return labels;
            };

            axisClass.prototype.width = function (value) {
                var helper = this._helper;

                if (arguments.length === 0) {
                    return helper.width();
                }

                helper.width(value);
                return this;
            };

            axisClass.prototype.height = function (value) {
                var helper = this._helper;

                if (arguments.length === 0) {
                    return helper.height();
                }

                helper.height(value);
                return this;
            };

            axisClass.prototype.generate = function (isVisible, clearMeasurements, transition) {
                if (typeof isVisible === "undefined") { isVisible = true; }
                if (typeof clearMeasurements === "undefined") { clearMeasurements = false; }
                if (typeof transition === "undefined") { transition = null; }
                if (!isVisible) {
                    this._helper.hide(transition);
                } else {
                    this._helper.show(transition);

                    this.shadeMarks(clearMeasurements, transition, null, 0, true, null);
                }
            };

            axisClass.prototype.getMeasuredWidth = function () {
                var helper = this._helper;

                if (true) {
                    this.generate(true, true);
                }

                return helper.getMeasuredWidth();
            };

            axisClass.prototype.getMeasuredHeight = function () {
                var helper = this._helper;

                if (true) {
                    this.generate(true, true);
                }

                return helper.getMeasuredHeight();
            };

            axisClass.prototype.name = function (value) {
                var helper = this._helper;

                if (arguments.length === 0) {
                    return helper.name();
                }

                helper.name(value);
                return this;
            };

            axisClass.prototype.tickCount = function (value) {
                if (arguments.length === 0) {
                    return this._tickCount;
                }

                this._tickCount = value;
                return this;
            };

            axisClass.prototype.isNameVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isNameVisible;
                }

                this._isNameVisible = value;
                return this;
            };

            axisClass.prototype.isLabelsVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isLabelsVisible;
                }

                this._isLabelsVisible = value;
                return this;
            };

            axisClass.prototype.isTicksVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isTicksVisible;
                }

                this._isTicksVisible = value;
                return this;
            };

            axisClass.prototype.isAxisVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isAxisVisible;
                }

                this._isAxisVisible = value;
                return this;
            };

            axisClass.prototype.hideInteriorLabels = function (value) {
                if (arguments.length === 0) {
                    return this._hideInteriorLabels;
                }

                this._hideInteriorLabels = value;
                return this;
            };

            axisClass.prototype.nameRotation = function (value) {
                if (arguments.length === 0) {
                    return this._helper.nameRotation();
                }

                this._helper.nameRotation(value);
                return this;
            };

            axisClass.prototype.labelRotation = function (value) {
                if (arguments.length === 0) {
                    return this._helper.labelRotation();
                }

                this._helper.labelRotation(value);
                return this;
            };

            axisClass.prototype.maxPerpendicularSize = function (value) {
                if (arguments.length === 0) {
                    return this._helper.maxPerpendicularSize();
                }

                this._helper.maxPerpendicularSize(value);
                return this;
            };

            axisClass.prototype.minLabelSpacing = function (value) {
                if (arguments.length === 0) {
                    return this._helper.minLabelSpacing();
                }

                this._helper.minLabelSpacing(value);
                return this;
            };

            axisClass.prototype.labelOverflow = function (value) {
                if (arguments.length === 0) {
                    return this._helper.labelOverflow();
                }

                this._helper.labelOverflow(value);
                return this;
            };

            axisClass.prototype.labelSizes = function (value) {
                if (arguments.length === 0) {
                    return this._helper.labelSizes();
                }

                this._helper.labelSizes(value);
                return this;
            };

            axisClass.prototype.rootElem = function () {
                return this._helper.rootElem;
            };

            axisClass.prototype.translate = function (x, y, makeCrispAdjustment) {
                this._helper.translate(x, y, makeCrispAdjustment);
                return this;
            };

            axisClass.prototype.onShade = function (value) {
                if (arguments.length === 0) {
                    return this._helper.onShade();
                }

                this._helper.onShade(value);
                return this;
            };

            axisClass.prototype.scale = function (value) {
                if (arguments.length === 0) {
                    return this._scale;
                }

                this._scale = value;
                return this;
            };
            return axisClass;
        })();
        visuals.axisClass = axisClass;

        function createAxis(container, scale, labelLocation, useWebGl, makeCrisp) {
            return new axisClass(container, scale, labelLocation, useWebGl, makeCrisp);
        }
        visuals.createAxis = createAxis;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=axis.js.map

///----------------------------------------------------------------
/// (from axes\bottomAxisHelper.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// bottomAxisHelper.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        /** Helper class for drawing an axis with the labels on the bottom.  */
        var bottomAxisHelperClass = (function (_super) {
            __extends(bottomAxisHelperClass, _super);
            function bottomAxisHelperClass(container, useWebGl, makeCrisp) {
                var _this = this;
                _super.call(this, container, 3 /* bottom */, useWebGl, makeCrisp);
                //---- bottom-specific drawing parameters ----
                this._yOffset = 0;
                this._maxTextHeight = 0;
                this._measuredHeight = 0;
                var root = this._rootElem;

                //---- create AXIS LINE ----
                this._axisLineMark = vp.marks.createLineMark(root, "vpxAxisLine").onShade(function (element, record, index, isNew) {
                    var xStart = 0;
                    var xEnd = _this._axisSize;
                    var y = _this._yOffset;

                    vp.select(element).hLine(xStart - 1, xEnd, y, makeCrisp);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create AXIS TICKS ----
                this._tickMark = vp.marks.createLineMark(root, "vpxAxisTick").onShade(function (element, record, index, isNew) {
                    var x = record;
                    var yStart = _this._yOffset;
                    var yEnd = yStart + _this._tickLength;

                    vp.select(element).vLine(yStart, yEnd, x, makeCrisp);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create MINOR TICKS  ----
                this._minorMark = vp.marks.createLineMark(root, "vpxAxisMinorTick").onShade(function (element, record, index, isNew) {
                    var x = record;
                    var yStart = _this._yOffset;
                    var yEnd = yStart + _this._minorTickLength;

                    vp.select(element).vLine(yStart, yEnd, x, makeCrisp);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create AXIS LABELS ----
                this._labelMark = vp.marks.createTextMark(root, "vpxAxisLabel").onShade(function (element, record, index, isNew) {
                    var cx = record.offset;
                    var cy = _this._yOffset;
                    var availPixelsPerLabel = _this.getAvailablePixelsPerLabelForTruncation(_this._actualLabelRotation);

                    var myHeight = _this.shadeTextLabel(index, element, cx, cy, record.label, "middle", "top", 1 /* top */, false, availPixelsPerLabel);
                    _this._maxTextHeight = Math.max(_this._maxTextHeight, myHeight);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create NAME ----
                this._nameMark = vp.marks.createTextMark(root, "vpxAxisName").onShade(function (element, record, index, isNew) {
                    var cx = _this._axisSize / 2;
                    var cy = _this._yOffset;

                    var wrap = vp.select(element).attr("x", cx + "").attr("y", cy + "").text(_this._name);

                    //---- now that properties are all set, VERT ALIGN at "cy" ----
                    var rc = element.getBBox();
                    var yCorrection = cy - rc.y;
                    wrap.textBaseline("top");
                    rc = new vp.geom.rectLight(rc.x, rc.y + yCorrection, rc.width, rc.height); // update rc

                    _this._maxTextHeight = rc.height;

                    if (_this._nameRotation) {
                        if (_this._nameRotation == 45) {
                            var result = _this.rotateText45(wrap, yCorrection, rc, 1 /* top */);
                            _this._maxTextHeight = result.height;
                        } else if (_this._nameRotation == 90) {
                            var result = _this.rotateText90(wrap, yCorrection, rc, 1 /* top */);
                            _this._maxTextHeight = result.height;
                        }
                    } else {
                        _this._maxTextHeight = rc.height;
                    }

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });
            }
            bottomAxisHelperClass.prototype.shadeMarks = function (transition, record, index, isNew, context) {
                //---- clear shapes out of group ----
                //vp.select(this._rootGroup).clear();
                var _this = this;
                this._maxTextHeight = 0;
                this._yOffset = 0;

                //---- draw axis line ----
                this._axisLineMark.generate(this._drawAxisLine, transition);

                //this._yOffset += 1;
                //---- draw primary ticks ----
                this.hideTicksIfTooMany();
                this._tickMark.generate(this._tickOffsets, transition);

                //---- draw minor ticks ----
                this._minorMark.generate(this._minorTickOffsets, transition);

                //---- update offsets for ticks ----
                this._yOffset += this._tickLength + this._spaceAfterTick;

                //---- measure labels ----
                if (!this._labelSizes) {
                    this._szMaxText = this.measureAllLabels(this._labelStrings);
                }

                //---- join label data and GENERATE (even if not drawing labels) ----
                var labelData = this._labelOffsets.map(function (data, index) {
                    return { offset: data, label: _this._labelStrings[index] };
                });

                //---- draw labels ----
                this._labelMark.generate(labelData, transition);
                this._yOffset += this._maxTextHeight + this._spaceAfterLabel;

                //---- draw axis name ----
                this._maxTextHeight = 0;
                var nameData = (this._drawAxisName && this._name) ? [1] : [];
                this._nameMark.generate(nameData, transition);
                this._yOffset += this._maxTextHeight + this._spaceAfterName;

                this._measuredHeight = this._yOffset;
            };

            bottomAxisHelperClass.prototype.width = function (value) {
                if (arguments.length === 0) {
                    return this._axisSize;
                }

                this._axisSize = value;
                return this;
            };

            bottomAxisHelperClass.prototype.getMeasuredHeight = function () {
                return this._measuredHeight;
            };
            return bottomAxisHelperClass;
        })(visuals.axisHelperBaseClass);
        visuals.bottomAxisHelperClass = bottomAxisHelperClass;

        function createBottomAxisHelper(container, useWebGl, makeCrisp) {
            return new bottomAxisHelperClass(container, useWebGl, makeCrisp);
        }
        visuals.createBottomAxisHelper = createBottomAxisHelper;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=bottomAxisHelper.js.map

///----------------------------------------------------------------
/// (from axes\chartFrameEx.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// chartFrameEx.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlotCore library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        /** A visual object that hosts a title, legend, axes, gridlines, and a plot area.  */
        var chartFrameEx = (function (_super) {
            __extends(chartFrameEx, _super);
            function chartFrameEx(container) {
                var _this = this;
                _super.call(this, container, null);

                this._groupMark = vp.marks.createGroupMark(container, "vpxChartFrame").onShade(function (element, record, index, isNew) {
                    //var group = vp.select(element)
                    //    .addClass("vpxAxis")
                    //this.shadeGroup(element, record, index, isNew);
                    //if (this._onShade)
                    //{
                    //    this._onShade(element, record, index, isNew);
                    //}
                });

                var topGroup = vp.select(this._rootElem);

                topGroup.addClass("vpxChartFrame");

                this._leftAxis = vp.visuals.createAxis(topGroup[0], null, 0 /* left */, null, true);
                this._bottomAxis = vp.visuals.createAxis(topGroup[0], null, 3 /* bottom */, null, true);
                this._topAxis = vp.visuals.createAxis(topGroup[0], null, 1 /* top */, null, true);
                this._rightAxis = vp.visuals.createAxis(topGroup[0], null, 2 /* right */, null, true);

                this._boxMark = vp.marks.createGroupMark(container, "vpxAxisBox").onShade(function (element, record, index, isNew) {
                    var group = vp.select(element).addClass("vpxAxisBox");

                    var rc = _this._rcPlot;

                    var bot = group.append("line").hLine(rc.left, rc.right, rc.bottom, true);

                    var top = group.append("line").hLine(rc.left, rc.right, rc.top, true);

                    var left = group.append("line").vLine(rc.bottom, rc.top, rc.left, true);

                    var right = group.append("line").vLine(rc.bottom, rc.top, rc.right, true);
                });
            }
            chartFrameEx.prototype.buildFrame = function (options) {
                var transition = this._transition;

                //---- here is where the real work happens ----
                vp.select(this._rootElem).clear();

                if (options.showChartFrame) {
                    var container = vp.select(this._container);

                    var width = container.width();
                    var height = container.height();

                    var left = 0;
                    var top = 0;
                    var right = width;
                    var bottom = height;

                    var parentElem = this._rootElem;

                    this.buildAxes(transition, parentElem, options, left, top, right, bottom);
                }
            };

            chartFrameEx.prototype.buildAxes = function (transition, parentElem, options, left, top, right, bottom) {
                //---- start with approx. values ----
                var xHeight = 35;
                var yWidth = 75;

                var width = right - left;
                var height = bottom - top;

                var plotWidth = width;
                var plotHeight = height;

                var leftOpts = options.leftAxis;
                var topOpts = options.topAxis;
                var rightOpts = options.rightAxis;
                var bottomOpts = options.bottomAxis;

                var showLeft = (leftOpts && leftOpts.show);
                var showTop = (topOpts && topOpts.show);
                var showRight = (rightOpts && rightOpts.show);
                var showBottom = (bottomOpts && bottomOpts.show);

                var xScale = options.bottomAxis.scale;
                var yScale = options.leftAxis.scale;

                var leftAxis = this._leftAxis;
                var bottomAxis = this._bottomAxis;
                var topAxis = this._topAxis;
                var rightAxis = this._rightAxis;

                if (showLeft) {
                    plotWidth -= yWidth;

                    leftAxis.scale(yScale).height(plotHeight);
                }

                if (showRight) {
                    plotWidth -= yWidth;

                    rightAxis.scale(yScale).height(plotHeight);
                }

                if (showTop) {
                    plotHeight -= xHeight;

                    topAxis.scale(xScale).width(plotWidth);
                }

                if (showBottom) {
                    plotHeight -= xHeight;

                    bottomAxis.scale(xScale).width(plotWidth);
                }

                //---- get exact values ----
                var topPad = 10;
                var bottomPad = 10;
                var topHeight = 0;
                var bottomHeight = 0;

                var leftPad = 20;
                var rightPad = 20;
                var leftWidth = 0;
                var rightWidth = 0;

                plotWidth = width - (leftPad + rightPad);
                plotHeight = height - (topPad + bottomPad);

                if (showTop) {
                    topHeight = topAxis.getMeasuredHeight();
                    plotHeight -= topHeight;
                }

                if (showBottom) {
                    bottomHeight = bottomAxis.getMeasuredHeight();
                    plotHeight -= bottomHeight;
                }

                if (showLeft) {
                    leftWidth = leftAxis.getMeasuredWidth();
                    plotWidth -= leftWidth;
                }

                if (showRight) {
                    rightWidth = rightAxis.getMeasuredWidth();
                    plotWidth -= rightWidth;
                }

                var topOff = topPad + topHeight;
                var leftOff = leftPad + leftWidth;

                //---- OK, "plotWidth" and "plotHeight" are now finalized; we can start the actual layout ----
                var rc = vp.geom.rect(leftOff, topOff, plotWidth, plotHeight);
                this._rcPlot = rc;

                xScale.palette(0, plotWidth);
                yScale.palette(plotHeight, 0);

                //---- draw 4 lines of frame box (where each axis line would go) ----
                this._boxMark.generate(options.showBox, transition);

                if (showLeft) {
                    leftAxis.height(plotHeight).translate(leftPad, topOff);
                }

                if (showRight) {
                    rightAxis.height(plotHeight).translate(leftOff + plotWidth + 1, topOff);
                }

                if (showBottom) {
                    bottomAxis.width(plotWidth).translate(leftOff, topOff + plotHeight + 1);
                }

                if (topAxis) {
                    topAxis.width(plotWidth).translate(leftOff, topPad);
                }

                //---- we always call generate ----
                leftAxis.generate(showLeft, false, transition);
                bottomAxis.generate(showBottom, false, transition);
                topAxis.generate(showTop, false, transition);
                rightAxis.generate(showRight, false, transition);
            };

            chartFrameEx.prototype.generate = function (data, transition) {
                this._transition = transition;

                this._groupMark.generate(data, transition);
            };

            chartFrameEx.prototype.onShade = function (value) {
                if (arguments.length === 0) {
                    return this._onShade;
                }

                this._onShade = value;
                return this;
            };

            chartFrameEx.prototype.options = function (value) {
                if (arguments.length === 0) {
                    return this._options;
                }

                this._options = value;
                return this;
            };
            return chartFrameEx;
        })(vp.marks.markBase);
        visuals.chartFrameEx = chartFrameEx;

        function createChartFrameEx(container) {
            return new chartFrameEx(container);
        }
        visuals.createChartFrameEx = createChartFrameEx;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=chartFrameEx.js.map

///----------------------------------------------------------------
/// (from axes\leftAxisHelper.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// leftAxisHelper.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        /** Helper class for drawing an axis with the labels on the left.  */
        var leftAxisHelperClass = (function (_super) {
            __extends(leftAxisHelperClass, _super);
            function leftAxisHelperClass(container, useWebGl, makeCrisp) {
                var _this = this;
                _super.call(this, container, 0 /* left */, useWebGl, makeCrisp);
                //---- left-specific drawing parameters ----
                this._xOffset = 0;
                this._maxTextWidth = 0;
                this._measuredWidth = 0;

                this._nameRotation = 90; // the default for a left axis

                var root = this._rootElem;

                //---- create AXIS NAME ----
                this._nameMark = vp.marks.createTextMark(root, "vpxAxisName").onShade(function (element, record, index, isNew) {
                    var wrap = vp.select(element).text(_this._name);

                    //---- measure the label ----
                    var rc = element.getBBox();
                    _this._maxTextWidth = rc.width;

                    var cx = _this._xOffset;
                    var cy = _this._axisSize / 2;

                    wrap = vp.select(element).attr("x", cx + "").attr("y", cy + "").attr("text-anchor", "start");

                    //---- now that properties are all set, VERT ALIGN at "cy" ----
                    var rc = element.getBBox();
                    var yCorrection = cy - rc.y;
                    wrap.textBaseline("middle");
                    rc = new vp.geom.rectLight(rc.x, rc.y + yCorrection, rc.width, rc.height); // update rc

                    if (_this._nameRotation) {
                        if (_this._nameRotation == 45) {
                            var result = _this.rotateText45(wrap, yCorrection, rc, 0 /* left */);
                            _this._maxTextWidth = result.width;
                        } else if (_this._nameRotation == 90) {
                            var result = _this.rotateText90(wrap, yCorrection, rc, 0 /* left */);
                            _this._maxTextWidth = result.width;
                        }
                    } else {
                        _this._maxTextWidth = rc.width;
                    }

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create AXIS LABELS ----
                this._labelMark = vp.marks.createTextMark(root, "vpxAxisLabel").onShade(function (element, record, index, isNew) {
                    //---- szMaxText has been set to the largest measured label width/height ----
                    var textWidth = _this._szMaxText.width;
                    var availPixelsPerLabel = _this.getAvailablePixelsPerLabelForTruncation(_this._actualLabelRotation);

                    //---- will we apply truncation? ----
                    if (_this._labelOverflow == 2 /* ellipses */ || _this._labelOverflow == 1 /* truncate */) {
                        textWidth = Math.min(textWidth, availPixelsPerLabel);
                    }

                    textWidth = _this.rotatedSize(_this._actualLabelRotation, textWidth, _this._szMaxText.height);
                    var xRight = _this._xOffset + textWidth;
                    var cy = record.offset;

                    var myWidth = _this.shadeTextLabel(index, element, xRight, cy, record.label, "end", "middle", 2 /* right */, true, availPixelsPerLabel);
                    _this._maxTextWidth = Math.max(_this._maxTextWidth, myWidth);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create AXIS TICKS  ----
                this._tickMark = vp.marks.createLineMark(root, "vpxAxisTick").onShade(function (element, record, index, isNew) {
                    var xStart = _this._xOffset;
                    var xEnd = xStart + _this._tickLength;
                    var y = record;

                    vp.select(element).hLine(xStart, xEnd, y, makeCrisp);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create MINOR TICKS  ----
                this._minorMark = vp.marks.createLineMark(root, "vpxAxisMinorTick").onShade(function (element, record, index, isNew) {
                    var xStart = _this._xOffset + _this._tickLength;
                    var xEnd = xStart - _this._minorTickLength;
                    var y = record;

                    vp.select(element).hLine(xStart, xEnd, y, makeCrisp);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create AXIS LINE ----
                this._axisLineMark = vp.marks.createLineMark(root, "vpxAxisLine").onShade(function (element, record, index, isNew) {
                    var yStart = 0;
                    var yEnd = _this._axisSize;
                    var x = _this._xOffset;

                    vp.select(element).vLine(yStart, yEnd, x, makeCrisp);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });
            }
            leftAxisHelperClass.prototype.shadeMarks = function (transition, record, index, isNew, context) {
                var _this = this;
                var group = vp.select(this._rootElem).addClass("vpxAxis");

                //---- clear shapes out of group ----
                //vp.select(this._rootGroup).clear();
                this._maxTextWidth = 0;
                this._xOffset = 0;

                //---- draw axis name ----
                var nameData = (this._drawAxisName && this._name) ? [1] : [];
                this._nameMark.generate(nameData, transition);

                if (this._maxTextWidth) {
                    this._xOffset += this._maxTextWidth + this._spaceAfterName;
                }

                //---- measure labels ----
                if (!this._labelSizes) {
                    this._szMaxText = this.measureAllLabels(this._labelStrings);
                }

                //---- join label data and GENERATE (even if not drawing labels) ----
                var labelData = this._labelOffsets.map(function (data, index) {
                    return { offset: data, label: _this._labelStrings[index] };
                });

                //---- draw labels ----
                this._maxTextWidth = 0;
                this._labelMark.generate(labelData, transition);

                if (this._maxTextWidth) {
                    this._xOffset += this._maxTextWidth + this._spaceAfterLabel;
                }

                //---- draw primary ticks ----
                this.hideTicksIfTooMany();
                this._tickMark.generate(this._tickOffsets, transition);

                //---- draw minor ticks ----
                this._minorMark.generate(this._minorTickOffsets, transition);

                //---- update offsets for ticks ----
                if (this._tickOffsets || this._minorTickOffsets) {
                    this._xOffset += this._tickLength + this._spaceAfterTick;
                }

                //---- draw axis line ----
                var lineData = (this._drawAxisLine) ? [1] : [];
                this._axisLineMark.generate(lineData, transition);

                //this._xOffset += 1;
                this._measuredWidth = this._xOffset;
            };

            leftAxisHelperClass.prototype.height = function (value) {
                if (arguments.length === 0) {
                    return this._axisSize;
                }

                this._axisSize = value;
                return this;
            };

            leftAxisHelperClass.prototype.getMeasuredWidth = function () {
                return this._measuredWidth;
            };
            return leftAxisHelperClass;
        })(visuals.axisHelperBaseClass);
        visuals.leftAxisHelperClass = leftAxisHelperClass;

        function createLeftAxisHelper(container, useWebGl, makeCrisp) {
            return new leftAxisHelperClass(container, useWebGl, makeCrisp);
        }
        visuals.createLeftAxisHelper = createLeftAxisHelper;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=leftAxisHelper.js.map

///----------------------------------------------------------------
/// (from axes\rightAxisHelper.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// rightAxisHelper.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        /** Helper class for drawing an axis with the labels on the right.  */
        var rightAxisHelperClass = (function (_super) {
            __extends(rightAxisHelperClass, _super);
            function rightAxisHelperClass(container, useWebGl, makeCrisp) {
                var _this = this;
                _super.call(this, container, 2 /* right */, useWebGl, makeCrisp);
                //---- left-specific drawing parameters ----
                this._xOffset = 0;
                this._maxTextWidth = 0;
                this._measuredWidth = 0;
                var root = this._rootElem;

                this._nameRotation = 90; // the default for a left axis
                this._spaceAfterTick = 4;
                this._spaceAfterLabel = 4;

                //---- create AXIS LINE ----
                this._axisLineMark = vp.marks.createLineMark(root, "vpxAxisLine").onShade(function (element, record, index, isNew) {
                    var yStart = 0;
                    var yEnd = _this._axisSize;
                    var x = _this._xOffset;

                    vp.select(element).vLine(yStart - 1, yEnd, x, makeCrisp);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create AXIS TICKS ----
                this._tickMark = vp.marks.createLineMark(root, "vpxAxisTick").onShade(function (element, record, index, isNew) {
                    var xStart = _this._xOffset;
                    var xEnd = xStart + _this._tickLength;
                    var y = record;

                    vp.select(element).hLine(xStart, xEnd, y, makeCrisp);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create MINOR TICKS  ----
                this._minorMark = vp.marks.createLineMark(root, "vpxAxisMinorTick").onShade(function (element, record, index, isNew) {
                    var xStart = _this._xOffset;
                    var xEnd = xStart + _this._minorTickLength;
                    var y = record;

                    vp.select(element).hLine(xStart, xEnd, y, makeCrisp);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create AXIS LABELS ----
                this._labelMark = vp.marks.createTextMark(root, "vpxAxisLabel").onShade(function (element, record, index, isNew) {
                    //---- szMaxText has been set to the largest measured label width/height ----
                    var xLeft = _this._xOffset;
                    var cy = record.offset - 1;
                    var availPixelsPerLabel = _this.getAvailablePixelsPerLabelForTruncation(_this._actualLabelRotation);

                    var myWidth = _this.shadeTextLabel(index, element, xLeft, cy, record.label, "start", "middle", 0 /* left */, true, availPixelsPerLabel);
                    _this._maxTextWidth = Math.max(_this._maxTextWidth, myWidth);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create AXIS NAME ----
                this._nameMark = vp.marks.createTextMark(root, "vpxAxisName").onShade(function (element, record, index, isNew) {
                    var wrap = vp.select(element).text(_this._name);

                    var cx = _this._xOffset;
                    var cy = _this._axisSize / 2;

                    wrap = vp.select(element).attr("x", cx + "").attr("y", cy + "").attr("text-anchor", "start");

                    //---- now that properties are all set, VERT ALIGN at "cy" ----
                    var rc = element.getBBox();
                    var yCorrection = cy - rc.y;
                    wrap.textBaseline("middle");
                    rc = new vp.geom.rectLight(rc.x, rc.y + yCorrection, rc.width, rc.height); // update rc

                    _this._maxTextWidth = rc.width;

                    if (_this._nameRotation) {
                        if (_this._nameRotation == 45) {
                            var result = _this.rotateText45(wrap, yCorrection, rc, 0 /* left */);
                            _this._maxTextWidth = result.width;
                        } else if (_this._nameRotation == 90) {
                            var result = _this.rotateText90(wrap, yCorrection, rc, 0 /* left */);
                            _this._maxTextWidth = result.width;
                        }
                    } else {
                        _this._maxTextWidth = rc.width;
                    }

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });
            }
            rightAxisHelperClass.prototype.shadeMarks = function (transition, record, index, isNew, context) {
                //---- clear shapes out of group ----
                //vp.select(this._rootGroup).clear();
                var _this = this;
                this._maxTextWidth = 0;
                this._xOffset = 0;

                //---- draw axis line ----
                var lineData = (this._drawAxisLine) ? [1] : [];
                this._axisLineMark.generate(lineData, transition);

                //this._xOffset += 1;
                //---- draw primary ticks ----
                this.hideTicksIfTooMany();
                this._tickMark.generate(this._tickOffsets, transition);

                //---- draw minor ticks ----
                this._minorMark.generate(this._minorTickOffsets, transition);

                //---- update offsets for ticks ----
                if (this._tickOffsets || this._minorTickOffsets) {
                    this._xOffset += this._tickLength + this._spaceAfterTick;
                }

                //---- measure labels ----
                if (!this._labelSizes) {
                    this._szMaxText = this.measureAllLabels(this._labelStrings);
                }

                //---- join label data and GENERATE (even if not drawing labels) ----
                var labelData = this._labelOffsets.map(function (data, index) {
                    return { offset: data, label: _this._labelStrings[index] };
                });

                //---- draw labels ----
                this._maxTextWidth = 0;
                this._labelMark.generate(labelData, transition);

                if (this._maxTextWidth) {
                    this._xOffset += this._maxTextWidth + this._spaceAfterLabel;
                }

                //---- draw axis name ----
                this._maxTextWidth = 0;
                var nameData = (this._drawAxisName && this._name) ? [1] : [];
                this._nameMark.generate(nameData, transition);

                if (this._maxTextWidth) {
                    this._xOffset += this._maxTextWidth + this._spaceAfterName;
                }

                this._measuredWidth = this._xOffset;
            };

            rightAxisHelperClass.prototype.height = function (value) {
                if (arguments.length === 0) {
                    return this._axisSize;
                }

                this._axisSize = value;
                return this;
            };

            rightAxisHelperClass.prototype.getMeasuredWidth = function () {
                return this._measuredWidth;
            };
            return rightAxisHelperClass;
        })(visuals.axisHelperBaseClass);
        visuals.rightAxisHelperClass = rightAxisHelperClass;

        function createRightAxisHelper(container, useWebGl, makeCrisp) {
            return new rightAxisHelperClass(container, useWebGl, makeCrisp);
        }
        visuals.createRightAxisHelper = createRightAxisHelper;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=rightAxisHelper.js.map

///----------------------------------------------------------------
/// (from axes\topAxisHelper.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// bottomAxisHelper.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        /** Helper class for drawing an axis with the labels on the top.  */
        var topAxisHelperClass = (function (_super) {
            __extends(topAxisHelperClass, _super);
            function topAxisHelperClass(container, useWebGl, makeCrisp) {
                var _this = this;
                _super.call(this, container, 1 /* top */, useWebGl, makeCrisp);
                //---- bottom-specific drawing parameters ----
                this._yOffset = 0;
                this._maxTextHeight = 0;
                this._measuredHeight = 0;
                var root = this._rootElem;

                //---- create AXIS NAME ----
                this._nameMark = vp.marks.createTextMark(root, "vpxAxisName").onShade(function (element, record, index, isNew) {
                    var wrap = vp.select(element).text(_this._name);

                    //---- get early "rc" so we can bottom align (rotation vs. top align causing problem here) ----
                    var rc = element.getBBox();

                    var cx = _this._axisSize / 2;
                    var textHeight = _this.rotatedSize(_this._nameRotation, rc.height, rc.width);
                    var cy = _this._yOffset + textHeight;

                    var wrap = vp.select(element).attr("x", cx + "").attr("y", cy + "").attr("text-anchor", "middle");

                    //---- now that properties are all set, VERT ALIGN at "cy" ----
                    var rc = element.getBBox();
                    var yCorrection = cy - rc.y;
                    wrap.textBaseline("bottom");
                    rc = new vp.geom.rectLight(rc.x, rc.y + yCorrection, rc.width, rc.height); // update rc

                    _this._maxTextHeight = rc.height;

                    if (_this._nameRotation) {
                        if (_this._nameRotation == 45) {
                            var result = _this.rotateText45(wrap, yCorrection, rc, 3 /* bottom */);
                            _this._maxTextHeight = result.height;
                        } else if (_this._nameRotation == 90) {
                            var result = _this.rotateText90(wrap, yCorrection, rc, 3 /* bottom */);
                            _this._maxTextHeight = result.height;
                        }
                    } else {
                        _this._maxTextHeight = rc.height;
                    }

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create AXIS LABELS ----
                this._labelMark = vp.marks.createTextMark(root, "vpxAxisLabel").onShade(function (element, record, index, isNew) {
                    var textHeight = _this._szMaxText.height;
                    var availPixelsPerLabel = _this.getAvailablePixelsPerLabelForTruncation(_this._actualLabelRotation);

                    //---- will we apply truncation? ----
                    if (_this._labelOverflow == 2 /* ellipses */ || _this._labelOverflow == 1 /* truncate */) {
                        textHeight = Math.min(textHeight, availPixelsPerLabel);
                    }

                    textHeight = _this.rotatedSize(_this._actualLabelRotation, textHeight, _this._szMaxText.width);
                    var cx = record.offset;
                    var yBottom = _this._yOffset + textHeight;
                    var availPixelsPerLabel = _this.getAvailablePixelsPerLabelForTruncation(_this._actualLabelRotation);

                    var myHeight = _this.shadeTextLabel(index, element, cx, yBottom, record.label, "middle", "bottom", 3 /* bottom */, false, textHeight);
                    _this._maxTextHeight = Math.max(_this._maxTextHeight, myHeight);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create AXIS TICKS ----
                this._tickMark = vp.marks.createLineMark(root, "vpxAxisTick").onShade(function (element, record, index, isNew) {
                    var x = record;
                    var yStart = _this._yOffset;
                    var yEnd = yStart + _this._tickLength;

                    vp.select(element).vLine(yStart, yEnd, x, makeCrisp);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create MINOR TICKS  ----
                this._minorMark = vp.marks.createLineMark(root, "vpxAxisMinorTick").onShade(function (element, record, index, isNew) {
                    var x = record;
                    var yStart = _this._yOffset + _this._tickLength;
                    var yEnd = yStart - _this._minorTickLength;

                    vp.select(element).vLine(yStart, yEnd, x, makeCrisp);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });

                //---- create AXIS LINE ----
                this._axisLineMark = vp.marks.createLineMark(root, "vpxAxisLine").onShade(function (element, record, index, isNew) {
                    var xStart = 0;
                    var xEnd = _this._axisSize;
                    var y = _this._yOffset;

                    vp.select(element).hLine(xStart, xEnd, y, makeCrisp);

                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });
            }
            topAxisHelperClass.prototype.shadeMarks = function (transition, record, index, isNew, context) {
                //---- clear shapes out of group ----
                //vp.select(this._rootGroup).clear();
                var _this = this;
                this._maxTextHeight = 0;
                this._yOffset = 0;

                //---- draw axis name ----
                this._maxTextHeight = 0;
                var nameData = (this._drawAxisName && this._name) ? [1] : [];
                this._nameMark.generate(nameData, transition);
                this._yOffset += this._maxTextHeight + this._spaceAfterName;

                //---- measure labels ----
                if (!this._labelSizes) {
                    this._szMaxText = this.measureAllLabels(this._labelStrings);
                }

                //---- join label data and GENERATE (even if not drawing labels) ----
                var labelData = this._labelOffsets.map(function (data, index) {
                    return { offset: data, label: _this._labelStrings[index] };
                });

                //---- draw labels ----
                this._labelMark.generate(labelData, transition);
                this._yOffset += this._maxTextHeight + this._spaceAfterLabel;

                //---- draw primary ticks ----
                this.hideTicksIfTooMany();
                this._tickMark.generate(this._tickOffsets, transition);

                //---- draw minor ticks ----
                this._minorMark.generate(this._minorTickOffsets, transition);

                //---- update offsets for ticks ----
                this._yOffset += this._tickLength + this._spaceAfterTick;

                //---- draw axis line ----
                var lineData = (this._drawAxisLine) ? [1] : [];
                this._axisLineMark.generate(lineData, transition);
                this._yOffset += 1;

                this._measuredHeight = this._yOffset - 1;
            };

            topAxisHelperClass.prototype.width = function (value) {
                if (arguments.length === 0) {
                    return this._axisSize;
                }

                this._axisSize = value;
                return this;
            };

            topAxisHelperClass.prototype.getMeasuredHeight = function () {
                return this._measuredHeight;
            };
            return topAxisHelperClass;
        })(visuals.axisHelperBaseClass);
        visuals.topAxisHelperClass = topAxisHelperClass;

        function createTopAxisHelper(container, useWebGl, makeCrisp) {
            return new topAxisHelperClass(container, useWebGl, makeCrisp);
        }
        visuals.createTopAxisHelper = createTopAxisHelper;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=topAxisHelper.js.map
///-----------------------------------------------------------------------------------------------------------------
/// canvasElement.ts.  Copyright (c) 201r Microsoft Corporation.
///            Part of the vuePlotCore library - the base class for a canvas container or element.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (canvas) {
        var nextCanvasElementId = 1;

        //---- class: canvasElement ----
        //----    Lightweight class to hold attributes for a canvas shape, and optional children. ----
        var canvasElement = (function () {
            function canvasElement(parent) {
                this.ctr = "vp.canvasElement;";
                this.transform = null;
                this.id = nextCanvasElementId++;
                this.stylesByClass = {};
                this.stroke = "";
                this.fill = "";
                this.parentNode = parent;
                this.rootContainer = this.getRoot(parent);

                this.opacity = 1;
                this["stroke-width"] = 0;
            }
            canvasElement.prototype.clientRectToBoundingBox = function (rc) {
                var bb = { x: rc.left, y: rc.top, width: rc.width, height: rc.height, right: rc.right, bottom: rc.bottom };
                return bb;
            };

            canvasElement.prototype.getRoot = function (elem) {
                while ((elem) && (elem.ctr != "vp.canvasContainerElement") && (elem.tagName != "CANVAS")) {
                    elem = elem.parentNode;
                    ;
                }

                if (elem && elem.tagName == "CANVAS") {
                    elem = elem.canvasContainerElement; // canvasContainerElement associated with the CANVAS
                }

                return elem;
            };

            canvasElement.prototype.drawFrame = function (ctx, container) {
                this.preDraw(ctx);
                this.drawAll(ctx, container);
                this.postDraw(ctx);
            };

            canvasElement.prototype.preDraw = function (ctx) {
                ctx.globalAlpha = this.opacity;

                if (this.transform) {
                    var trans = this.transform;

                    ctx.setTransform(trans.sx, 0, 0, trans.sy, trans.tx, trans.ty);

                    if (trans.angle) {
                        ctx.translate(trans.cx, trans.cy);
                        ctx.rotate(Math.PI / 180 * trans.angle);
                    }
                }
            };

            canvasElement.prototype.drawAll = function (ctx, container) {
            };

            canvasElement.prototype.postDraw = function (ctx) {
                if (this.transform) {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }
            };

            canvasElement.prototype.markDrawNeeded = function () {
                this.rootContainer.markDrawNeeded();
            };

            canvasElement.prototype.setPathData = function (value) {
            };

            canvasElement.prototype.setPathPoints = function (value) {
            };

            /// todo: remove shortcuts (assuming no spaces between func name and "(", limited # of spaces in func args).
            canvasElement.prototype.getInsideOfFuncStr = function (str, funcName) {
                var result = null;
                var index = str.indexOf(funcName + "(");
                if (index > -1) {
                    var index2 = str.indexOf(")", index);
                    if (index2 > -1) {
                        var start = index + funcName.length + 1;
                        var len = index2 - start;
                        result = str.substr(start, len).trim();

                        result = result.replace(/,/g, ' '); // translate commas into spaces
                        result = result.replace(/  /g, ' '); // compress double spaces to single
                        result = result.replace(/  /g, ' '); // compress double spaces to single
                    }
                }

                return result;
            };

            canvasElement.prototype.setTransform = function (value) {
                var transform = null;
                if (value) {
                    var transform = { tx: 0, ty: 0, sx: 1, sy: 1, angle: 0, cx: 0, cy: 0 };

                    var result = this.getInsideOfFuncStr(value, "translate");
                    if (result) {
                        var numbers = result.split(' ');
                        transform.tx = +numbers[0];
                        transform.ty = +numbers[1];
                    }

                    var result = this.getInsideOfFuncStr(value, "scale");
                    if (result) {
                        var numbers = result.split(' ');
                        transform.sx = +numbers[0];
                        transform.sy = +numbers[1];
                    }

                    var result = this.getInsideOfFuncStr(value, "rotate");
                    if (result) {
                        var numbers = result.split(' ');
                        transform.angle = +numbers[0];
                        transform.cx = +numbers[1];
                        transform.cy = +numbers[2];
                    }
                    //vp.utils.debug("setTransform: id=" + this.id + ", tx=" + transform.tx + ", ty=" + transform.ty +
                    //    ", sx=" + transform.sx + ", sy=" + transform.sy + ", value=" + value);
                }

                this.transform = transform;
                this.markDrawNeeded();
            };

            canvasElement.prototype.getTransform = function () {
                var str = "";

                if (this.transform) {
                    var trans = this.transform;
                    var str = "";

                    if (trans.tx != 0 || trans.ty != 0) {
                        str += "translate(" + trans.tx + " " + trans.ty + ") ";
                    }

                    if (trans.sx != 1 || trans.sy != 1) {
                        str += "scale(" + trans.sx + " " + trans.sy + ") ";
                    }

                    if (trans.angle) {
                        str += "rotate(" + trans.angle + " " + trans.cx + " " + trans.cy + ") ";
                    }
                }

                return str;
            };

            canvasElement.prototype.applyStyle = function (style) {
                if (style.opacity !== undefined) {
                    this.opacity = style.opacity;
                }

                if (style.fill !== undefined) {
                    this.fill = style.fill;
                }

                if (style.stroke !== undefined) {
                    this.stroke = style.stroke;
                }

                if (style.strokeWidth !== undefined) {
                    this["stroke-width"] = parseFloat(style.strokeWidth); // ignore "px" units on end, if any
                }
            };

            canvasElement.prototype.setAttribute = function (name, value) {
                if (name == "d") {
                    //---- special handling for path's data property ----
                    this.setPathData(value);
                } else if (name == "points") {
                    //---- special handling for path's data property ----
                    this.setPathPoints(value);
                } else if (name == "transform") {
                    this.setTransform(value);
                } else {
                    this[name] = value;
                }

                this.markDrawNeeded();
            };

            canvasElement.prototype.getAttribute = function (name) {
                return this[name];
            };

            canvasElement.prototype.append = function (strElem) {
                var elem = null;

                if (strElem == "rect") {
                    elem = new canvas.canvasRectElement(this);
                } else if (strElem == "circle") {
                    elem = new canvas.canvasCircleElement(this);
                } else if (strElem == "ellipse") {
                    elem = new canvas.canvasEllipseElement(this);
                } else if (strElem == "text") {
                    elem = new canvas.canvasTextElement(this);
                } else if (strElem == "line") {
                    elem = new canvas.canvasLineElement(this);
                } else if (strElem == "path") {
                    elem = new canvas.canvasPathElement(this);
                } else if (strElem == "image") {
                    elem = new canvas.canvasImageElement(this);
                } else if (strElem == "polygon") {
                    elem = new canvas.canvasPolygonElement(this);
                } else if (strElem == "g") {
                    elem = new canvas.canvasGroupElement(this);
                } else {
                    vp.utils.error("This element type not yet supported for canvas by VuePlot: " + strElem);
                }

                if (elem != null) {
                    this.children.push(elem);
                    this.markDrawNeeded();
                }

                return elem;
            };
            return canvasElement;
        })();
        canvas.canvasElement = canvasElement;
    })(vp.canvas || (vp.canvas = {}));
    var canvas = vp.canvas;
})(vp || (vp = {}));
//# sourceMappingURL=$canvasElement.js.map

///----------------------------------------------------------------
/// (from canvas\canvasCircleElement.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// canvasCircleElement.ts.  Copyright (c) 2014 Microsoft Corporation.
///     Part of the vuePlotore library - represents a lightweight CANVAS CIRCLE element.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (canvas) {
        //---- class: canvasCircleElement ----
        var canvasCircleElement = (function (_super) {
            __extends(canvasCircleElement, _super);
            function canvasCircleElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasCircleElement";
                this.tagName = "circle";

                this.cx = 0;
                this.cy = 0;
                this.r = 0;
            }
            canvasCircleElement.prototype.applyStyle = function (style) {
                _super.prototype.applyStyle.call(this, style);
            };

            canvasCircleElement.prototype.getOffset = function () {
                var x = this.cx - this.r;
                var y = this.cy - this.r;

                return { x: x, y: y };
            };

            /// return elem found at x,y.
            canvasCircleElement.prototype.hitTest = function (x, y) {
                var elem = null;

                //---- for circle, this is easy.  use distance <= r for match ----
                var xdiff = this.cx - x;
                var ydiff = this.cy - y;

                var dist = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
                if (dist <= this.r) {
                    elem = this;
                }

                //vp.utils.debug("circle.hitTest: dist=" + dist);
                return elem;
            };

            canvasCircleElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;

                    ctx.beginPath();
                    ctx.arc(this.cx, this.cy, this.r, 0, Math.PI * 2, true);
                    ctx.closePath();

                    if (container.isHitTesting) {
                        container.hitTestPath(ctx, this);
                    }

                    if (this.fill != null && this.fill != "none" && this.fill != "") {
                        if (container.currentFill != this.fill) {
                            ctx.fillStyle = this.fill;
                            container.currentFill = this.fill;
                        }

                        ctx.fill();
                        //ctx.addHitRegion("circle1");
                    }

                    if (this.stroke != null && this.stroke != "none" && this.stroke != "") {
                        if (container.currentStroke != this.stroke) {
                            ctx.strokeStyle = this.stroke;
                            container.currentStroke = this.stroke;
                        }

                        if (container.currentStrokeWidth != this["stroke-width"]) {
                            ctx.lineWidth = this["stroke-width"];
                            container.currentStrokeWidth = this["stroke-width"];
                        }

                        ctx.stroke();
                    }
                }
            };

            canvasCircleElement.prototype.getWidth = function () {
                return 2 * this.r;
            };

            canvasCircleElement.prototype.getHeight = function () {
                return 2 * this.r;
            };
            return canvasCircleElement;
        })(canvas.canvasElement);
        canvas.canvasCircleElement = canvasCircleElement;
    })(vp.canvas || (vp.canvas = {}));
    var canvas = vp.canvas;
})(vp || (vp = {}));
//# sourceMappingURL=canvasCircleElement.js.map

///----------------------------------------------------------------
/// (from canvas\canvasContainerElement.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// canvasContainerElement.ts.  Copyright (c) 2014 Microsoft Corporation.
///            Part of the vuePlotCore library - holds information associated with a CANVAS DOM element.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (_canvas) {
        //---- class: canvasContainerElement - a helper class for a canvas element that has ----
        //---- lightweight "canvas elements" (our "property bags" for shapes drawn in a canvas).
        var canvasContainerElement = (function (_super) {
            __extends(canvasContainerElement, _super);
            function canvasContainerElement(canvas, ctx, contextRequest) {
                _super.call(this, null);
                //---- keep this instance as property on canvas, so other instances can reuse us ----
                //---- and, as we walk the hierarchy, we know that this is a canvas on which we have ----
                //---- canvas lightweight elements.
                this.ctr = "vp.canvasContainerElement";
                this.frameCount = 0;
                this.lastTime = Date.now();
                this.bufferBuildTime = 0;
                this.frameRate = 0;
                this.frameRateChanged = null;
                this.opacity = 1;
                this.currentFill = "";
                this.currentStroke = "";
                this.currentStrokeWidth = 0;
                this.selectedFill = "orange";
                this.drawCallback = null;
                this.activeAnimations = [];
                this.drawNeeded = false;
                //---- hit test management ----
                this.isHitTesting = false;
                this.hitTestX = 0;
                this.hitTestY = 0;
                this.hitTestResult = null;
                this.drawTimer = null;
                //animTimer = null;
                this.drawCount = 0;

                this.rootContainer = this;
                this.parentNode = canvas;

                canvas.canvasContainerElement = this;
                this.canvas = canvas; // our canvas ELEMENT
                this.ctx = ctx;
                this.children = [];
                this.contextRequest = contextRequest;
                this.initialized = false;

                vp.utils.debug("canvasContainer CTR");

                if (this.contextRequest == "3d") {
                    this.initialized = true;
                }
            }
            /// hit testing for canvas 2D/3D elements (rect, circle, text, line, etc).
            canvasContainerElement.prototype.getCanvasElementAtPoint = function (x, y) {
                var elemFound = null;

                //---- canvas 2d - use pointInPath() during drawing to find elem ----
                this.isHitTesting = true;
                this.hitTestX = x;
                this.hitTestY = y;
                this.hitTestResult = null;

                this.drawFrame();

                elemFound = this.hitTestResult;

                return elemFound;
            };

            canvasContainerElement.prototype.markDrawNeeded = function () {
                //vp.utils.debug("container.markDrawNeeded: drawTimer=" + this.drawTimer);
                var _this = this;
                if (!this.drawTimer) {
                    this.drawTimer = setTimeout(function () {
                        _this.drawFrame(false);
                    }, 10);
                }
            };

            /// remove the specified child element.
            canvasContainerElement.prototype.removeChild = function (element) {
                this.children.remove(element);
                this.markDrawNeeded();
            };

            /// remove all children.
            canvasContainerElement.prototype.clear = function () {
                this.children = [];
                this.markDrawNeeded();
            };

            canvasContainerElement.prototype.hitTestPath = function (ctx, elem) {
                if (ctx.isPointInPath(this.hitTestX, this.hitTestY)) {
                    this.hitTestResult = elem;
                    this.isHitTesting = false;
                }
            };

            canvasContainerElement.prototype.drawAll = function (ctx) {
                ctx.globalAlpha = 1;

                //this.drawSelf(ctx);
                this.currentFill = "none";
                this.currentStroke = "none";
                this.currentStrokeWidth = -999;
                this.selectedFill = "orange";

                for (var i = 0; i < this.children.length; i++) {
                    this.children[i].drawFrame(ctx, this);
                }
            };

            canvasContainerElement.prototype.drawFrame = function (rearmTimer) {
                this.drawCount++;

                //vp.utils.debug("canvasContainerElement: draw(): drawCount=" + this.drawCount);
                this.drawTimer = null;

                //---- frame stats ----
                this.frameCount++;

                var elapsed = Date.now() - this.lastTime;
                if (elapsed >= 1000) {
                    this.frameRate = Math.round(this.frameCount / (elapsed / 1000));

                    if (this.frameRateChanged != null) {
                        var count = this.children.length;
                        this.frameRateChanged(this.frameRate, count, this.bufferBuildTime);
                    }

                    this.frameCount = 0;
                    this.lastTime = Date.now();
                }

                //---- clear the canvas ----
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.drawAll(this.ctx);

                if (this.children.length == 0) {
                    vp.utils.debug("canvas clear, children=" + this.children.length);
                }

                if (this.drawCallback) {
                    this.drawCallback();
                }
            };

            canvasContainerElement.prototype.close = function () {
                if (this.drawTimer) {
                    clearTimeout(this.drawTimer);
                    this.drawTimer = null;
                }

                this.children = [];
            };
            return canvasContainerElement;
        })(_canvas.canvasElement);
        _canvas.canvasContainerElement = canvasContainerElement;
    })(vp.canvas || (vp.canvas = {}));
    var canvas = vp.canvas;
})(vp || (vp = {}));
//# sourceMappingURL=canvasContainerElement.js.map

///----------------------------------------------------------------
/// (from canvas\canvasEllipseElement.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// canvasEllipseElement.ts.  Copyright (c) 2014 Microsoft Corporation.
///     Part of the vuePlotCore library - represents a lightweight CANVAS ELLIPSE element.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (canvas) {
        //---- class: canvasEllipseElement ----
        var canvasEllipseElement = (function (_super) {
            __extends(canvasEllipseElement, _super);
            function canvasEllipseElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasEllipseElement";
                this.tagName = "ellipse";
                this.opacity = 1;
                this.cx = 0;
                this.cy = 0;
                this.rx = 0;
                this.ry = 0;

                this["stroke-width"] = 1;
            }
            canvasEllipseElement.prototype.getOffset = function () {
                var x = this.cx - this.rx;
                var y = this.cy - this.ry;

                return { x: x, y: y };
            };

            /// return elem found at x,y.
            canvasEllipseElement.prototype.hitTest = function (x, y) {
                var elem = null;

                //---- for ellipse, this is easy.  use distance <= r for match ----
                var xdiff = this.cx - x;
                var ydiff = this.cy - y;

                var dist = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
                if (dist <= Math.max(this.rx, this.ry)) {
                    elem = this;
                }

                //vp.utils.debug("ellipse.hitTest: dist=" + dist);
                return elem;
            };

            canvasEllipseElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;

                    var left = this.cx - this.rx;
                    var right = this.cx + this.rx;

                    var top = this.cy - this.ry;
                    var bottom = this.cy + this.ry;

                    //---- canvas has no built-in ellipse support, so we just scale a circle ----
                    var xScale = 1;
                    var yScale = 1;
                    var radius = this.rx;

                    if (this.rx > this.ry) {
                        yScale = this.ry / this.rx;
                        radius = this.rx;
                    } else {
                        xScale = this.rx / this.ry;
                        radius = this.ry;
                    }

                    ctx.beginPath();
                    ctx.save();
                    ctx.translate(this.cx, this.cy);
                    ctx.scale(xScale, yScale);
                    ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
                    ctx.restore();
                    ctx.closePath();

                    if (container.isHitTesting) {
                        container.hitTestPath(ctx, this);
                    }

                    if (this.fill != null && this.fill != "none") {
                        if (container.currentFill != this.fill) {
                            ctx.fillStyle = this.fill;
                            container.currentFill = this.fill;
                        }

                        ctx.fill();
                        //ctx.addHitRegion("ellipse1");
                    }

                    if (this.stroke != null) {
                        if (container.currentStroke != this.stroke) {
                            ctx.strokeStyle = this.stroke;
                            container.currentStroke = this.stroke;
                        }

                        if (container.currentStrokeWidth != this["stroke-width"]) {
                            ctx.lineWidth = this["stroke-width"];
                            container.currentStrokeWidth = this["stroke-width"];
                        }

                        ctx.stroke();
                    }
                }
            };

            canvasEllipseElement.prototype.getWidth = function () {
                return 2 * this.rx;
            };

            canvasEllipseElement.prototype.getHeight = function () {
                return 2 * this.ry;
            };
            return canvasEllipseElement;
        })(canvas.canvasElement);
        canvas.canvasEllipseElement = canvasEllipseElement;
    })(vp.canvas || (vp.canvas = {}));
    var canvas = vp.canvas;
})(vp || (vp = {}));
//# sourceMappingURL=canvasEllipseElement.js.map

///----------------------------------------------------------------
/// (from canvas\canvasGroupElement.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// canvasGroupElement.ts.  Copyright (c) 2014 Microsoft Corporation.
///            Part of the vuePlotCore library - a class for a lightweight canvas GROUP element
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (canvas) {
        //---- class: canvasGroupElement ----
        var canvasGroupElement = (function (_super) {
            __extends(canvasGroupElement, _super);
            function canvasGroupElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasGroupElement";
                this.tagName = "g";
                this.opacity = 1;
                this.children = [];
                this.x = 0;
                this.y = 0;
            }
            canvasGroupElement.prototype.getOffset = function () {
                return { x: this.x, y: this.y };
            };

            /// find 2d/3d element that intersects with x,y at z=0.  return that element.
            canvasGroupElement.prototype.hitTest = function (x, y) {
                var elem = null;

                for (var i = 0; i < this.children.length; i++) {
                    var child = this.children[i];
                    elem = child.hitTest(x, y);

                    if (elem) {
                        break;
                    }
                }

                return elem;
            };

            canvasGroupElement.prototype.appendChild = function (element) {
                this.children.push(element);
                this.markDrawNeeded();
            };

            /// remove the specified child element.
            canvasGroupElement.prototype.removeChild = function (element) {
                this.children.remove(element);
                this.markDrawNeeded();
            };

            /// remove all children.
            canvasGroupElement.prototype.clear = function () {
                this.children = [];
                this.markDrawNeeded();
            };

            canvasGroupElement.prototype.drawAll = function (ctx, container) {
                //---- todo: apply transfrom from each element (group & children) ----
                if (this.visibility != "hidden") {
                    for (var i = 0; i < this.children.length; i++) {
                        var child = this.children[i];

                        child.drawFrame(ctx, container);
                    }
                }
            };
            return canvasGroupElement;
        })(canvas.canvasElement);
        canvas.canvasGroupElement = canvasGroupElement;
    })(vp.canvas || (vp.canvas = {}));
    var canvas = vp.canvas;
})(vp || (vp = {}));
//# sourceMappingURL=canvasGroupElement.js.map

///----------------------------------------------------------------
/// (from canvas\canvasImageElement.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// canvasImageElement.ts.  Copyright (c) 2014 Microsoft Corporation.
///            Part of the vuePlotCore library - represents a lightweight CANVAS IMAGE element.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (canvas) {
        //---- class: canvasImageElement ----
        var canvasImageElement = (function (_super) {
            __extends(canvasImageElement, _super);
            function canvasImageElement(parentElement) {
                var _this = this;
                _super.call(this, parentElement);
                this.ctr = "vp.canvasImageElement";
                this.tagName = "image";
                this.x = 0;
                this.y = 0;
                this.width = 100;
                this.height = 100;
                this.strokePlacement = "straddle";
                this.image = new Image();
                this._href = null;

                this.opacity = 1;
                this["stroke-width"] = 0;

                this.image.onload = function (e) {
                    _this.markDrawNeeded();
                };
            }
            canvasImageElement.prototype.getOffset = function () {
                return { x: this.x, y: this.y };
            };

            canvasImageElement.prototype.getBBox = function () {
                var x = (vp.utils.isDefined(this.layoutX)) ? this.layoutX : this.x;
                var y = (vp.utils.isDefined(this.layoutY)) ? this.layoutY : this.y;

                //---- return bounds as a vuePlot rect ----
                var rc = {
                    left: x, top: y, width: this.width, height: this.height,
                    right: x + this.width, bottom: y + this.height
                };

                return rc;
            };

            canvasImageElement.prototype.hrefOverride = function (src) {
                if (arguments.length == 0) {
                    return this._href;
                }

                this._href = src;
                this.image.setAttribute("src", src);
            };

            /// return elem found at x,y.
            canvasImageElement.prototype.hitTest = function (x, y) {
                //---- for axis aligned rect, this is easy.  see if point is between left/right and top/bottom ----
                var elem = null;

                var myx = (vp.utils.isDefined(this.layoutX)) ? this.layoutX : this.x;
                var myy = (vp.utils.isDefined(this.layoutY)) ? this.layoutY : this.y;

                if ((x >= myx) && (x <= myx + this.width)) {
                    if ((y >= myy) && (y <= myy + this.height)) {
                        elem = this;
                    }
                }

                return elem;
            };

            canvasImageElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;

                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);

                    if (container.isHitTesting) {
                        ctx.save();

                        //---- create a rect path ----
                        ctx.beginPath();
                        ctx.rect(this.x, this.y, this.width, this.height);

                        container.hitTestPath(ctx, this);

                        ctx.restore();
                    }
                }
            };

            canvasImageElement.prototype.getWidth = function () {
                return this.width;
            };

            canvasImageElement.prototype.getHeight = function () {
                return this.height;
            };
            return canvasImageElement;
        })(canvas.canvasElement);
        canvas.canvasImageElement = canvasImageElement;
    })(vp.canvas || (vp.canvas = {}));
    var canvas = vp.canvas;
})(vp || (vp = {}));
//# sourceMappingURL=canvasImageElement.js.map

///----------------------------------------------------------------
/// (from canvas\canvasLineElement.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// canvasLineElement.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - represents a lightweight CANVAS LINE element.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (canvas) {
        //---- class: canvasLineElement ----
        var canvasLineElement = (function (_super) {
            __extends(canvasLineElement, _super);
            function canvasLineElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasLineElement";
                this.tagName = "rect";
                this.opacity = 1;
                this.x1 = 0;
                this.x2 = 0;
                this.y1 = 0;
                this.y2 = 0;

                this["stroke-width"] = 1;
            }
            canvasLineElement.prototype.getOffset = function () {
                var left = Math.min(this.x1, this.x2);
                var top = Math.min(this.y1, this.y2);

                return { x: left, y: top };
            };

            /// return line at x,y, if any.
            canvasLineElement.prototype.hitTest = function (x, y) {
                //---- for NOW, just use axis aligned rect.  later, we will test the non-axis aligned rect that is the line ----
                var elem = null;

                var left = Math.min(this.x1, this.x2);
                var right = Math.max(this.x1, this.x2);

                var top = Math.min(this.y1, this.y2);
                var bottom = Math.max(this.y1, this.y2);

                if ((x >= left) && (x <= right)) {
                    if ((y >= top) && (y <= bottom)) {
                        elem = this;
                    }
                }

                return elem;
            };

            canvasLineElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;

                    if ((this.stroke != null) && (this["stroke-width"] > 0)) {
                        if (container.currentStroke != this.stroke) {
                            ctx.strokeStyle = this.stroke;
                            container.currentStroke = this.stroke;
                        }

                        if (container.currentStrokeWidth != this["stroke-width"]) {
                            ctx.lineWidth = this["stroke-width"];
                            container.currentStrokeWidth = this["stroke-width"];
                        }

                        ctx.beginPath();
                        ctx.moveTo(this.x1, this.y1);
                        ctx.lineTo(this.x2, this.y2);
                        ctx.stroke();

                        if (container.isHitTesting) {
                            container.hitTestPath(ctx, this);
                        }
                    }
                }
            };

            canvasLineElement.prototype.getWidth = function () {
                return Math.abs(this.x1 - this.x2);
            };

            canvasLineElement.prototype.getHeight = function () {
                return Math.abs(this.y1 - this.y2);
            };
            return canvasLineElement;
        })(canvas.canvasElement);
        canvas.canvasLineElement = canvasLineElement;
    })(vp.canvas || (vp.canvas = {}));
    var canvas = vp.canvas;
})(vp || (vp = {}));
//# sourceMappingURL=canvasLineElement.js.map

///----------------------------------------------------------------
/// (from canvas\canvasPathElement.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// canvasPathElement.ts.  Copyright (c) 2014 Microsoft Corporation.
///     Part of the vuePlotCore library - represents a lightweight CANVAS PATH element.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (canvas) {
        //---- class: canvasPathElement ----
        var canvasPathElement = (function (_super) {
            __extends(canvasPathElement, _super);
            function canvasPathElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasPathElement";
                this.tagName = "path";
                this.opacity = 1;
                this.boundingBox = { x: 0, y: 0, width: 0, height: 0, right: 0, bottom: 0 };
                this.createPathFunc = null;
                this.pathDataStr = "";

                this["stroke-width"] = 1;
            }
            canvasPathElement.prototype.getOffset = function () {
                return { x: this.boundingBox.x, y: this.boundingBox.y };
            };

            canvasPathElement.prototype.getBBox = function () {
                return this.boundingBox;
            };

            canvasPathElement.prototype.createPathOnContext = function (ctx) {
                //---- "createPathFunc" is generated when the "d" property is assigned a value ----
                //---- calling "drawPath(ctx)" runs the path commands in the specified ctx context. ----
                if (this.createPathFunc) {
                    this.createPathFunc(ctx);
                }
            };

            /// return elem found at x,y.
            canvasPathElement.prototype.hitTest = function (x, y) {
                //---- for axis aligned rect, this is easy.  see if point is between left/right and top/bottom ----
                var bb = this.boundingBox;
                var elem = null;

                if ((x >= bb.x) && (x <= bb.right)) {
                    if ((y >= bb.y) && (y <= bb.bottom)) {
                        elem = this;
                    }
                }

                return elem;
            };

            canvasPathElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;

                    ctx.beginPath();

                    this.createPathOnContext(ctx); // run the dynamically generatedto draw the path

                    if (this.fill != null && this.fill != "none") {
                        if (container.currentFill != this.fill) {
                            ctx.fillStyle = this.fill;
                            container.currentFill = this.fill;
                        }

                        ctx.fill();
                    }

                    if ((this.stroke != null) && (this["stroke-width"] > 0)) {
                        if (container.currentStroke != this.stroke) {
                            ctx.strokeStyle = this.stroke;
                            container.currentStroke = this.stroke;
                        }

                        if (container.currentStrokeWidth != this["stroke-width"]) {
                            ctx.lineWidth = this["stroke-width"];
                            container.currentStrokeWidth = this["stroke-width"];
                        }

                        ctx.stroke();
                    }

                    if (container.isHitTesting) {
                        container.hitTestPath(ctx, this);
                    }
                    //ctx.closePath();
                }
            };

            //--- this is the "d" attribute (the path string) ----
            canvasPathElement.prototype.setPathData = function (value) {
                this.pathDataStr = value;
                this.parseDataStr();
            };

            /// Canvas path is NOT a string - it a series of cmds executed on the ctx object,
            /// so we generate that a JavaScript function to do those commands here...
            canvasPathElement.prototype.parseDataStr = function () {
                var parser = new vp.internal.parsePathDataAndGenerateDrawFunc(this.pathDataStr);
                var both = parser.parse();

                var funcStr = both[0];
                var rc = both[1];

                this.boundingBox = this.clientRectToBoundingBox(rc);

                //---- generate code for our----
                eval("this.createPathFunc = " + funcStr);
            };

            canvasPathElement.prototype.getWidth = function () {
                return this.boundingBox.width;
            };

            canvasPathElement.prototype.getHeight = function () {
                return this.boundingBox.height;
            };
            return canvasPathElement;
        })(canvas.canvasElement);
        canvas.canvasPathElement = canvasPathElement;
    })(vp.canvas || (vp.canvas = {}));
    var canvas = vp.canvas;
})(vp || (vp = {}));
//# sourceMappingURL=canvasPathElement.js.map

///----------------------------------------------------------------
/// (from canvas\canvasPolygonElement.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// canvasPolygonElement.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - represents a lightweight CANVAS POLYGON element.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (canvas) {
        //---- class: canvasPolygonElement ----
        var canvasPolygonElement = (function (_super) {
            __extends(canvasPolygonElement, _super);
            function canvasPolygonElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasPolygonElement";
                this.tagName = "rect";
                this.opacity = 1;
                this.boundingBox = { x: 0, y: 0, width: 0, height: 0, right: 0, bottom: 0 };
                this.pointStr = "";
                this.fill = "";
                this.stroke = "";

                this["stroke-width"] = 1;
            }
            canvasPolygonElement.prototype.getOffset = function () {
                return { x: this.boundingBox.x, y: this.boundingBox.y };
            };

            canvasPolygonElement.prototype.getBBox = function () {
                return this.boundingBox;
            };

            canvasPolygonElement.prototype.drawPath = function (ctx) {
                //---- this is generated when the "points" property is assigned a value ----
            };

            /// return elem found at x,y.
            canvasPolygonElement.prototype.hitTest = function (x, y) {
                //---- for axis aligned rect, this is easy.  see if point is between left/right and top/bottom ----
                var bb = this.boundingBox;
                var elem = null;

                if ((x >= bb.x) && (x <= bb.right)) {
                    if ((y >= bb.y) && (y <= bb.bottom)) {
                        elem = this;
                    }
                }

                return elem;
            };

            canvasPolygonElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;

                    ctx.beginPath();

                    this.drawPath(ctx); // run the dynamically generatedto draw the path

                    if (this.fill != null && this.fill != "none") {
                        if (container.currentFill != this.fill) {
                            ctx.fillStyle = this.fill;
                            container.currentFill = this.fill;
                        }

                        ctx.fill();
                    }

                    if ((this.stroke != null) && (this["stroke-width"] > 0)) {
                        if (container.currentStroke != this.stroke) {
                            ctx.strokeStyle = this.stroke;
                            container.currentStroke = this.stroke;
                        }

                        if (container.currentStrokeWidth != this["stroke-width"]) {
                            ctx.lineWidth = this["stroke-width"];
                            container.currentStrokeWidth = this["stroke-width"];
                        }

                        ctx.stroke();
                    }

                    if (container.isHitTesting) {
                        container.hitTestPath(ctx, this);
                    }
                    //ctx.closePath();
                }
            };

            canvasPolygonElement.prototype.setPathPoints = function (value) {
                this.points(value);
            };

            canvasPolygonElement.prototype.points = function (value) {
                if (arguments.length == 0) {
                    return this.pointStr;
                }

                this.pointStr = value;
                this.genDrawFromPoints();

                return this;
            };

            canvasPolygonElement.prototype.genDrawFromPoints = function () {
                var funcStr = "function (ctx)\r\n" + "{\r\n";

                var minX = Number.MAX_VALUE;
                var minY = Number.MAX_VALUE;
                var maxX = -Number.MAX_VALUE;
                var maxY = -Number.MAX_VALUE;
                var firstPt = null;

                var points = this.pointStr.split(" ");

                for (var i = 0; i < points.length; i++) {
                    var ptx = points[i];
                    var xy = ptx.split(",");

                    var pt = { x: +xy[0], y: +xy[1] };

                    if (i == 0) {
                        funcStr += "    ctx.moveTo(" + pt.x + "," + pt.y + ");\r\n";
                    } else {
                        funcStr += "    ctx.lineTo(" + pt.x + "," + pt.y + ");\r\n";
                    }

                    if (firstPt == null) {
                        firstPt = pt;
                    }

                    minX = Math.min(minX, pt.x);
                    minY = Math.min(minY, pt.y);

                    maxX = Math.max(maxX, pt.x);
                    maxY = Math.max(maxY, pt.y);
                }

                //---- generate line back to initial point ----
                if (firstPt) {
                    funcStr += "    ctx.lineTo(" + firstPt.x + "," + firstPt.y + ");\r\n";
                }

                funcStr += "}\r\n";
                var rc = vp.geom.rect(minX, minY, maxX - minX, maxY - minY);

                this.boundingBox = this.clientRectToBoundingBox(rc);

                //---- generate code for our----
                eval("this.drawPath = " + funcStr);
            };

            canvasPolygonElement.prototype.getWidth = function () {
                return this.boundingBox.width;
            };

            canvasPolygonElement.prototype.getHeight = function () {
                return this.boundingBox.height;
            };
            return canvasPolygonElement;
        })(canvas.canvasElement);
        canvas.canvasPolygonElement = canvasPolygonElement;
    })(vp.canvas || (vp.canvas = {}));
    var canvas = vp.canvas;
})(vp || (vp = {}));
//# sourceMappingURL=canvasPolygonElement.js.map

///----------------------------------------------------------------
/// (from canvas\canvasRectElement.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// canvasRectElement.ts.  Copyright (c) 2014 Microsoft Corporation.
///            Part of the vuePlotCore library - represents a lightweight CANVAS RECT element.
///-----------------------------------------------------------------------------------------------------------------
//---- class: canvasRectElement ----
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (canvas) {
        var canvasRectElement = (function (_super) {
            __extends(canvasRectElement, _super);
            function canvasRectElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasRectElement";
                this.tagName = "rect";
                this.x = 0;
                this.y = 0;
                this.width = 100;
                this.height = 100;
                this.strokePlacement = "straddle";
                this.fill = "";
                this.stroke = "";
            }
            canvasRectElement.prototype.getOffset = function () {
                return { x: this.x, y: this.y };
            };

            canvasRectElement.prototype.getBBox = function () {
                var x = (vp.utils.isDefined(this.layoutX)) ? this.layoutX : this.x;
                var y = (vp.utils.isDefined(this.layoutY)) ? this.layoutY : this.y;

                //---- return bounds as a vuePlot rect ----
                var rc = {
                    left: x, top: y, width: this.width, height: this.height,
                    right: x + this.width, bottom: y + this.height
                };

                return rc;
            };

            /// return elem found at x,y.
            canvasRectElement.prototype.hitTest = function (x, y) {
                //---- for axis aligned rect, this is easy.  see if point is between left/right and top/bottom ----
                var elem = null;

                var myx = (vp.utils.isDefined(this.layoutX)) ? this.layoutX : this.x;
                var myy = (vp.utils.isDefined(this.layoutY)) ? this.layoutY : this.y;

                if ((x >= myx) && (x <= myx + this.width)) {
                    if ((y >= myy) && (y <= myy + this.height)) {
                        elem = this;
                    }
                }

                return elem;
            };

            canvasRectElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;

                    if (this.fill != null && this.fill != "none") {
                        if (container.currentFill != this.fill) {
                            ctx.fillStyle = this.fill;
                            container.currentFill = this.fill;
                        }

                        ctx.fillRect(this.x, this.y, this.width, this.height);
                    }

                    if ((this.stroke != null) && (this["stroke-width"] > 0)) {
                        if (container.currentStroke != this.stroke) {
                            ctx.strokeStyle = this.stroke;
                            container.currentStroke = this.stroke;
                        }

                        var sw = this["stroke-width"];
                        if (container.currentStrokeWidth != sw) {
                            ctx.lineWidth = sw;
                            container.currentStrokeWidth = sw;
                        }

                        if (this.strokePlacement == "inside") {
                            var sw_div2 = this["stroke-width"] / 2;
                            ctx.strokeRect(this.x + sw_div2, this.y + sw_div2, this.width - sw, this.height - sw);
                        } else if (this.strokePlacement == "outside") {
                            var sw_div2 = this["stroke-width"] / 2;
                            ctx.strokeRect(this.x - sw_div2, this.y - sw_div2, this.width + sw, this.height + sw);
                        } else {
                            ctx.strokeRect(this.x, this.y, this.width, this.height);
                        }
                    }

                    if (container.isHitTesting) {
                        ctx.save();

                        //---- create a rect path ----
                        ctx.beginPath();
                        ctx.rect(this.x, this.y, this.width, this.height);

                        container.hitTestPath(ctx, this);

                        ctx.restore();
                    }
                }
            };

            canvasRectElement.prototype.getWidth = function () {
                return this.width;
            };

            canvasRectElement.prototype.getHeight = function () {
                return this.height;
            };
            return canvasRectElement;
        })(canvas.canvasElement);
        canvas.canvasRectElement = canvasRectElement;
    })(vp.canvas || (vp.canvas = {}));
    var canvas = vp.canvas;
})(vp || (vp = {}));
//# sourceMappingURL=canvasRectElement.js.map

///----------------------------------------------------------------
/// (from canvas\canvasTextElement.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// canvasTextElement.ts.  Copyright (c) 2014 Microsoft Corporation.
///            Part of the vuePlotCore library - represents a lightweight CANVAS TEXT element.
///-----------------------------------------------------------------------------------------------------------------
//---- class: canvasRectElement ----
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (canvas) {
        //---- class: canvasTextElement ----
        var canvasTextElement = (function (_super) {
            __extends(canvasTextElement, _super);
            function canvasTextElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasTextElement";
                this.tagName = "text";
                this.textContent = "";
                this.opacity = 1;
                this.x = 0;
                this.y = 0;
                this.fill = "";
                this.stroke = "";
                this.width = 0;
                this.height = 0;

                this.verticalAlign = "top"; // all measurements rely on this (?)
            }
            canvasTextElement.prototype.applyStyle = function (style) {
                if (style.opacity !== undefined) {
                    this.opacity = style.opacity;
                }

                if (style.fill !== undefined) {
                    this.fill = style.fill;
                }

                if (style.stroke !== undefined) {
                    this.stroke = style.stroke;
                }

                if (style.strokeWidth !== undefined) {
                    this["stroke-width"] = style.strokeWidth;
                }

                if (style.fontSize !== undefined) {
                    this["font-size"] = style.fontSize;
                }

                if (style.fontWeight !== undefined) {
                    this.fontWeight = style.fontWeight;
                }

                if (style.fontStyle !== undefined) {
                    this.fontStyle = style.fontStyle;
                }

                if (style.fontFamily !== undefined) {
                    this["font-family"] = style.fontFamily;
                }

                if (style.textAnchor !== undefined) {
                    this["text-anchor"] = style.textAnchor;
                }
            };

            /// return elem found at x,y.
            canvasTextElement.prototype.hitTest = function (x, y) {
                //---- for text; just treat as rect.  see if point is between left/right and top/bottom ----
                var elem = null;

                if ((x >= this.x) && (x <= this.x + this.width)) {
                    if ((y >= this.y) && (y <= this.y + this.height)) {
                        elem = this;
                    }
                }

                return elem;
            };

            canvasTextElement.prototype.getOffset = function () {
                var left = this.x;
                var top = this.y;

                //---- elem.y specifies the bottom for text elements, so substract the height to get the top ----
                top -= this.getHeight();

                return { x: left, y: top };
            };

            canvasTextElement.prototype.setContextForDrawing = function (ctx) {
                var font = "";

                //---- STYLE ----
                if (this.fontStyle != undefined) {
                    font += this.fontStyle + " ";
                }

                //---- WEIGHT ----
                if (this.fontWeight != undefined) {
                    font += this.fontWeight + " ";
                }

                //---- SIZE ----
                if (this["font-size"] != undefined) {
                    var fs = this["font-size"];
                    if (vp.utils.isNumber(fs)) {
                        //---- SVG uses the "current user coordinate system" for this; we will assume it is pixels ----
                        font += fs + "px ";
                    } else {
                        font += fs + " ";
                    }
                }

                if (this["font-family"]) {
                    font += this["font-family"] + " ";
                } else {
                    font += "tahoma ";
                }

                ctx.font = font;

                if (this.fill != null && this.fill != "none") {
                    ctx.fillStyle = this.fill;
                } else {
                    ctx.fillStyle = "transparent";
                }

                if (this.stroke != null && this.stroke != "none") {
                    ctx.strokeStyle = this.stroke;
                    ctx.lineWidth = this["stroke-width"];
                } else {
                    ctx.strokeStyle = "transparent";
                    ctx.lineWidth = 0;
                }

                var textAlign = this["text-anchor"];
                if (textAlign) {
                    if (textAlign == "middle") {
                        textAlign = "center";
                    }

                    ctx.textAlign = textAlign;
                }

                if (this.verticalAlign) {
                    ctx.textBaseline = this.verticalAlign;
                }
            };

            canvasTextElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;

                    this.setContextForDrawing(ctx);

                    //---- apply alignment ----
                    var x = +this.x;
                    var y = +this.y;

                    if (this.transform && this.transform.angle) {
                        //var height = this.getHeight();
                        //var width = this.getWidth();
                        //---- must offset x, y from the rotation position ----
                        x -= this.transform.cx;
                        y -= this.transform.cy;
                    }

                    if (this.fill && this.fill != "none") {
                        ctx.fillText(this.textContent, x, y);
                    }

                    if (this.stroke && this.stroke != "none") {
                        ctx.strokeText(this.textContent, x, y);
                    }

                    if (container.isHitTesting) {
                        ctx.save();

                        //---- create a rect path to represent the text block (any other way to do this?) ----
                        ctx.beginPath();

                        var width = +ctx.measureText(this.textContent).width;
                        var height = this.getHeight();

                        ctx.rect(this.x, this.y, width, height);

                        container.hitTestPath(ctx, this);

                        ctx.restore();
                    }
                }
            };

            canvasTextElement.prototype.getBBox = function () {
                var x = (vp.utils.isDefined(this.layoutX)) ? this.layoutX : this.x;
                var y = (vp.utils.isDefined(this.layoutY)) ? this.layoutY : this.y;

                var w = this.getWidth();
                var h = this.getHeight();

                //---- return bounds as rect but using "x" and "y" instead of "left" and "top" ----
                var rc = {
                    x: x, y: y, width: w, height: h,
                    right: x + w, bottom: y + h
                };

                return rc;
            };

            canvasTextElement.prototype.getWidth = function () {
                var width = 0;

                var ctx = this.rootContainer.ctx;
                this.setContextForDrawing(ctx);
                width = ctx.measureText(this.textContent).width;

                return width;
            };

            canvasTextElement.prototype.getHeight = function () {
                var height = 0;

                //---- note: ctx.measureText() doesn't support height; parse it from ctx.font ----
                //---- since the font size is the height of characters rendered by that font ----
                var ctx = this.rootContainer.ctx;
                this.setContextForDrawing(ctx);

                var fontStr = ctx.font;
                height = parseFloat(fontStr); // starts with "10px" ...
                if (fontStr.contains("pt ")) {
                    height = height * 98 / 72;
                }

                return height;
            };
            return canvasTextElement;
        })(canvas.canvasElement);
        canvas.canvasTextElement = canvasTextElement;
    })(vp.canvas || (vp.canvas = {}));
    var canvas = vp.canvas;
})(vp || (vp = {}));
//# sourceMappingURL=canvasTextElement.js.map
///-----------------------------------------------------------------------------------------------------------------
/// quadTree.ts.  Copyright (c) 2014 Microsoft Corporation.
///            Part of the vuePlotCore library.
///-----------------------------------------------------------------------------------------------------------------
/// quadTreeClass code adapted from this algorithm:   http://en.wikipedia.org/wiki/Quadtree
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (layouts) {
        /** A structure for accelerating N-body type calculations. */
        var quadTreeClass = (function () {
            function quadTreeClass(points) {
                this.points = points;

                this.buildTree();
            }
            quadTreeClass.prototype.buildTree = function () {
                var points = this.points;

                var xMin = Math.floor(points.min(function (data) {
                    return data.x;
                }));
                var xMax = Math.ceil(points.max(function (data) {
                    return data.x;
                }));

                var yMin = Math.floor(points.min(function (data) {
                    return data.y;
                }));
                var yMax = Math.ceil(points.max(function (data) {
                    return data.y;
                }));

                var root = new quadNodeClass(xMin, yMin, xMax, yMax);
                this.rootNode = root;

                for (var i = 0; i < points.length; i++) {
                    var pt = points[i];
                    root.insert(pt);
                }
            };

            /** Visits each node of the tree in pre-order. */
            quadTreeClass.prototype.visit = function (callback) {
                this.rootNode.visit(callback);
            };

            /** Visits each node of the tree in post-order. */
            quadTreeClass.prototype.visitPostOrder = function (callback, visitEmptyNodes) {
                if (typeof visitEmptyNodes === "undefined") { visitEmptyNodes = false; }
                this.rootNode.postOrder(callback, visitEmptyNodes);
            };
            return quadTreeClass;
        })();
        layouts.quadTreeClass = quadTreeClass;

        var quadNodeClass = (function () {
            function quadNodeClass(left, top, right, bottom) {
                this.left = left;
                this.top = top;

                this.right = right;
                this.bottom = bottom;

                this.isLeaf = true;
            }
            quadNodeClass.prototype.postOrder = function (callback, visitEmptyNodes) {
                if (this.nodes && this.nodes.length) {
                    for (var i = 0; i < this.nodes.length; i++) {
                        var childNode = this.nodes[i];

                        if (childNode.point || visitEmptyNodes) {
                            childNode.postOrder(callback, visitEmptyNodes);
                        }
                    }
                }

                callback(this, this.left, this.top, this.right, this.bottom);
            };

            quadNodeClass.prototype.insert = function (pt) {
                if (!this.containsPoint(pt)) {
                    //---- pt doesn't belong in this node ----
                    return false;
                }

                if (!this.point) {
                    this.point = pt;
                    return true;
                }

                if (!this.nodes) {
                    this.subdivide();
                }

                for (var i = 0; i < this.nodes.length; i++) {
                    var node = this.nodes[i];

                    if (node.insert(pt)) {
                        return true;
                    }
                }

                throw "Error: could not insert point in quadTree: " + pt.x + ", " + pt.y;
            };

            quadNodeClass.prototype.subdivide = function () {
                //---- create 4 subnodes ----
                if (!this.nodes) {
                    var nodes = [];
                    this.nodes = nodes;

                    var xMid = (this.right + this.left) / 2;
                    var yMid = (this.bottom + this.top) / 2;

                    //---- watch out for floating point issues are these get super small in degenerate cases ----
                    //---- where all nodes are in same approximate location ----
                    var nwNode = new quadNodeClass(this.left, this.top, xMid, yMid);
                    nodes.push(nwNode);

                    var neNode = new quadNodeClass(xMid, this.top, this.right, yMid);
                    nodes.push(neNode);

                    var swNode = new quadNodeClass(this.left, yMid, xMid, this.bottom);
                    nodes.push(swNode);

                    var seNode = new quadNodeClass(xMid, yMid, this.right, this.bottom);
                    nodes.push(seNode);

                    this.isLeaf = false;
                }
            };

            quadNodeClass.prototype.visit = function (callback) {
                var skipChildren = callback(this, this.left, this.top, this.right, this.bottom);

                if ((!skipChildren) && (this.nodes)) {
                    for (var i = 0; i < this.nodes.length; i++) {
                        var node = this.nodes[i];
                        node.visit(callback);
                    }
                }
            };

            quadNodeClass.prototype.containsPoint = function (pt) {
                var contains = false;

                if (pt.x >= this.left && pt.x <= this.right) {
                    contains = (pt.y >= this.top && pt.y <= this.bottom);
                }

                return contains;
            };
            return quadNodeClass;
        })();
        layouts.quadNodeClass = quadNodeClass;

        function createQuadTree(points) {
            return new quadTreeClass(points);
        }
        layouts.createQuadTree = createQuadTree;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
//# sourceMappingURL=$quadTree.js.map

///----------------------------------------------------------------
/// (from layouts\dragHelper.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// dragHelper.ts.  Copyright (c) 2014 Microsoft Corporation.
///            Part of the vuePlotCore library.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (layouts) {
        /** Supports dragstart, drag, dragend events. */
        var dragHelperClass = (function () {
            function dragHelperClass(ownerCallback) {
                var _this = this;
                this._onDragStartCallback = null;
                this._onDragCallback = null;
                this._onDragEndCallback = null;
                this._dragElem = null;
                this._ownerCallback = null;
                this._ownerCallback = ownerCallback;

                vp.events.attach(window, "mousemove", function (e) {
                    _this.dragging(e);
                });

                vp.events.attach(window, "mouseup", function (e) {
                    _this.endDragging(e);
                });
            }
            dragHelperClass.prototype.addElements = function (elements) {
                for (var i = 0; i < elements.length; i++) {
                    var elem = elements[i];
                    this.addElement(elem);
                }
            };

            dragHelperClass.prototype.addElement = function (elem) {
                var _this = this;
                vp.select(elem).attach("mousedown", function (e) {
                    _this.startDragging(e);
                });
            };

            dragHelperClass.prototype.startDragging = function (e) {
                this._dragElem = e.target;

                if (this._ownerCallback) {
                    this._ownerCallback("dragstart", this._dragElem, e);
                }

                if (this._onDragStartCallback) {
                    this._onDragStartCallback(e);
                }
            };

            dragHelperClass.prototype.dragging = function (e) {
                if (this._dragElem) {
                    if (this._ownerCallback) {
                        this._ownerCallback("drag", this._dragElem, e);
                    }

                    if (this._onDragCallback) {
                        this._onDragCallback(e);
                    }
                }
            };

            dragHelperClass.prototype.endDragging = function (e) {
                var elem = this._dragElem;
                if (elem) {
                    this._dragElem = null;

                    if (this._ownerCallback) {
                        this._ownerCallback("dragend", elem, e);
                    }

                    if (this._onDragEndCallback) {
                        this._onDragEndCallback(e);
                    }
                }
            };

            dragHelperClass.prototype.onDragStart = function (callback) {
                if (arguments.length == 0) {
                    return this._onDragStartCallback;
                }

                this._onDragStartCallback = callback;
                return this;
            };

            dragHelperClass.prototype.onDrag = function (callback) {
                if (arguments.length == 0) {
                    return this._onDragCallback;
                }

                this._onDragCallback = callback;
                return this;
            };

            dragHelperClass.prototype.onDragEnd = function (callback) {
                if (arguments.length == 0) {
                    return this._onDragEndCallback;
                }

                this._onDragEndCallback = callback;
                return this;
            };
            return dragHelperClass;
        })();
        layouts.dragHelperClass = dragHelperClass;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
//# sourceMappingURL=dragHelper.js.map

///----------------------------------------------------------------
/// (from layouts\forceLayout.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// forceLayout.ts.  Copyright (c) 2014 Microsoft Corporation.
///            Part of the vuePlotCore library.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /// TODO: [in-progress] debug Barnes-Hut technique to speed-up node-to-node charge calculations...
        /** Layout of nodes and optional links using force directed layout. Supports start, tick, and end events. */
        var forceLayoutClass = (function () {
            function forceLayoutClass() {
                this._alpha = 0;
                this._friction = .9;
                this._gravity = .1;
                this._charge = -30;
                this._width = 100;
                this._height = 100;
                this._linkDistance = 20;
                this._linkStrength = 1;
                this._chargeDistance = Infinity;
                this._theta = .8;
                this._tickCount = 0;
                this._onStartCallback = null;
                this._onTickCallback = null;
                this._onEndCallback = null;
                this._lastTickTime = 0;
                this._lastDt = 0;
                this._tickCallbackInProgress = false;
                this._dragHelper = null;
                //---- offset on element where drag started ----
                this._xDelta = 0;
                this._yDelta = 0;
                //---- stats ----
                this._totalUpdateNodesTime = 0;
                this._maxUpdateNodesTime = 0;
                this._lastStatTime = 0;
                this._onStatsCallback = null;
            }
            /** Return a drag helper class, to assist caller in dragging elements associated with "nodes". */
            forceLayoutClass.prototype.getDragHelper = function () {
                var _this = this;
                if (!this._dragHelper) {
                    this._dragHelper = new layouts.dragHelperClass(function (name, dragElem, e) {
                        _this.processDragEvent(name, dragElem, e);
                    });
                }

                return this._dragHelper;
            };

            forceLayoutClass.prototype.processDragEvent = function (name, dragElem, e) {
                var node = dragElem.dataItem.data;

                if (name == "dragstart") {
                    node.dragFixed = true;

                    var pt = vp.events.mousePosition(e);
                    this._xDelta = node.x - pt.x;
                    this._yDelta = node.y - pt.y;

                    node.x = pt.x + this._xDelta;
                    node.y = pt.y + this._yDelta;

                    this.resume();
                } else if (name == "drag") {
                    var pt = vp.events.mousePosition(e);
                    node.x = pt.x + this._xDelta;
                    node.y = pt.y + this._yDelta;

                    this.resume();
                } else if (name == "dragend") {
                    node.dragFixed = false;

                    //---- set prev close to new current position ----
                    node.px = node.x + .1 * Math.random();
                    node.py = node.y + .1 * Math.random();
                }
            };

            forceLayoutClass.prototype.start = function () {
                this.innerStart(.1);
            };

            forceLayoutClass.prototype.innerStart = function (alphaValue) {
                //this.stop();
                var _this = this;
                this._alpha = alphaValue;

                if (this._nodes && this._nodes.length) {
                    if (this._onStartCallback) {
                        this._onStartCallback(null);
                    }

                    this.initNodesAsNeeded();

                    if (this._links) {
                        this.initLinksAsNeeded();
                    }

                    ////---- stats ----
                    //this._totalUpdateNodesTime = 0;
                    //this._maxUpdateNodesTime = 0;
                    //this._tickCount = 0;
                    //this._lastStatTime = +Date.now();
                    if (!this._timer) {
                        if (true) {
                            this.tick(true);
                        } else {
                            //---- calling the first call on a timer keeps us from exceeding TPS limit of 60 ----
                            this._timer = vp.animation.requestAnimationFrame(function (e) {
                                _this.tick(true);
                            });
                        }
                    }
                }
            };

            forceLayoutClass.prototype.initNodesAsNeeded = function () {
                var nodes = this._nodes;
                var charge = this._charge;
                var chargeFunc = vp.utils.isFunction(charge);

                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    if (node.x === undefined) {
                        node.x = Math.round(Math.random() * this._width);
                        node.y = Math.round(Math.random() * this._width);
                    }

                    if (node.px === undefined) {
                        node.px = node.x + .1 * Math.random();
                        node.py = node.y + .1 * Math.random();
                    }

                    node.weight = 1;

                    //---- refresh CHARGE info for each node ----
                    node.charge = (chargeFunc) ? charge(node, i) : charge;
                }
            };

            forceLayoutClass.prototype.initLinksAsNeeded = function () {
                var links = this._links;

                var distance = this._linkDistance;
                var distanceFunc = vp.utils.isFunction(distance);

                var strength = this._linkStrength;
                var strengthFunc = vp.utils.isFunction(strength);

                for (var i = 0; i < links.length; i++) {
                    var link = links[i];

                    link.distance = (distanceFunc) ? distance(link, i) : distance;

                    link.strength = (strengthFunc) ? strength(link, i) : strength;

                    //---- adjust weight of connected nodes ----
                    link.source.weight++;
                    link.target.weight++;
                }
            };

            forceLayoutClass.prototype.stop = function () {
                if (this._timer) {
                    this.onStopped();
                }
            };

            forceLayoutClass.prototype.onStopped = function () {
                if (this._timer) {
                    vp.animation.cancelAnimationFrame(this._timer);
                    this._timer = undefined;
                }

                this._alpha = 0;

                if (this._onEndCallback) {
                    this._onEndCallback(null);
                }
                //vp.utils.debug("forceLayout.stop called");
            };

            forceLayoutClass.prototype.resume = function () {
                this.innerStart(.1);
            };

            forceLayoutClass.prototype.tick = function (startTimer) {
                var _this = this;
                var now = +Date.now();
                var delta = now - this._lastStatTime;

                if (delta > 1000) {
                    var tps = Math.round(this._tickCount / (delta / 1000));

                    if (this._onStatsCallback) {
                        this._onStatsCallback(tps, this._maxUpdateNodesTime, this._totalUpdateNodesTime / tps);
                    }

                    this._lastStatTime = now;
                    this._tickCount = 0;
                    this._maxUpdateNodesTime = 0;
                    this._totalUpdateNodesTime = 0;
                }

                var started = +Date.now();

                this.updateNodes();

                var elapsed = +Date.now() - started;

                this._totalUpdateNodesTime += elapsed;
                this._maxUpdateNodesTime = Math.max(this._maxUpdateNodesTime, elapsed);

                if (this._onTickCallback) {
                    this._tickCallbackInProgress = true;
                    try  {
                        this._onTickCallback(null, this._quadTree);
                    } finally {
                        this._tickCallbackInProgress = false;
                    }
                }

                var alphaDecayFactor = .99;

                this._alpha *= alphaDecayFactor;
                if (this._alpha <= .0005) {
                    this._alpha = 0;
                }

                this._tickCount++;
                this._lastTickTime = +Date.now();

                //vp.utils.debug("forceLayout.tick: alpha=" + this._alpha + ", tickCount=" + this._tickCount);
                if (this._alpha > 0 && startTimer) {
                    this._timer = vp.animation.requestAnimationFrame(function (e) {
                        _this.tick(true);
                    });
                } else {
                    this.onStopped();
                }
            };

            forceLayoutClass.prototype.updateNodes = function () {
                if (this._tickCallbackInProgress) {
                    throw "Error - updateNodes() called while tick callback in progress";
                }

                var nodes = this._nodes;

                var quadTree = null;

                if (this._charge && this._theta) {
                    quadTree = vp.layouts.createQuadTree(nodes);

                    this.addMassToQuadTree(quadTree);
                }

                this._quadTree = quadTree;

                //---- values for "dt" between .2 and .4 work best so far ----
                var dt = .2 + .2 * Math.random();

                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    if (!node.dragFixed && !node.fixed) {
                        var lastDt = (this._lastDt) ? this._lastDt : dt;

                        this.updateNode(node, quadTree, dt, lastDt);
                    }
                }

                this._lastDt = dt;
            };

            forceLayoutClass.prototype.addMassToQuadTree = function (quadTree) {
                //---- visit each node, from children to their parents ----
                quadTree.visitPostOrder(function (origNode, left, top, right, bottom) {
                    //---- note: we only visit non-empty quadNodes, so "point" will be set ----
                    var qtNode = origNode;

                    var totalMass = 0;
                    var xCom = 0;
                    var yCom = 0;

                    //---- first, calculate the total mass for this qtNode ----
                    var node = qtNode.point;
                    totalMass = node.charge;

                    if (qtNode.nodes) {
                        for (var i = 0; i < qtNode.nodes.length; i++) {
                            var qtChild = qtNode.nodes[i];
                            if (qtChild.point) {
                                totalMass += qtChild.totalMass;
                            }
                        }
                    }

                    //---- now, calculate the center of mass ----
                    var factor = (totalMass) ? node.charge / totalMass : 1;
                    xCom += factor * node.x;
                    yCom += factor * node.y;

                    if (qtNode.nodes) {
                        for (var i = 0; i < qtNode.nodes.length; i++) {
                            var qtChild = qtNode.nodes[i];
                            if (qtChild.point) {
                                var factor = (totalMass) ? qtChild.totalMass / totalMass : 1;
                                xCom += factor * qtChild.xCom;
                                yCom += factor * qtChild.yCom;
                            }
                        }
                    }

                    qtNode.totalMass = totalMass;
                    qtNode.xCom = xCom;
                    qtNode.yCom = yCom;
                });
            };

            forceLayoutClass.prototype.updateNode = function (node, quadTree, dt, lastDt) {
                if (isNaN(node.x) || isNaN(node.y)) {
                    throw "Error - nan value found in node";
                }

                var forceTotal = { x: 0, y: 0 };

                //---- compute force from GRAVITY (modified by distance from center) ----
                var cx = this._width / 2;
                var cy = this._height / 2;

                this.addForceWithDistance(node, { x: cx, y: cy, id: -1 }, this._gravity, Infinity, "*", forceTotal);

                //---- compute force from OTHER NODES ----
                if (this._charge) {
                    var result = this.computeNodeForces(node, quadTree);
                    forceTotal.x += result.x;
                    forceTotal.y += result.y;

                    if (node.id == 1) {
                        //vp.utils.debug("force on node[1]: " + forceTotal.x + ", " + forceTotal.y);
                    }
                }

                if (this._linkDistance && this._links) {
                    result = this.computeLinkForces(node);
                    forceTotal.x += result.x;
                    forceTotal.y += result.y;
                }

                //---- apply force using Verlet Integration, with friction ----
                var dt2 = dt * dt;

                var maxTickCount = 300;
                var decayingPercent = (maxTickCount - this._tickCount) / maxTickCount;

                var px = node.px;
                var py = node.py;

                node.px = node.x;
                node.py = node.y;

                var x = node.x;
                var y = node.y;

                //---- verlet formulas from: http://en.wikipedia.org/wiki/Verlet_integration ----
                //---- regular verlet ----
                //node.x = node.x + (node.x - px) + forceX/node.weight * dt2;
                //node.y = node.y + (node.y - py) + forceY/node.weight * dt2;
                //---- time-corrected verlet ----
                //node.x = node.x + (node.x - px)*dt/lastDt + forceX / node.weight * dt2;
                //node.y = node.y + (node.y - py)*dt/lastDt + forceY / node.weight * dt2;
                //---- basic stormer-verlet ----
                //node.x = 2 * node.x - px + forceX/node.weight * dt2;
                //node.y = 2 * node.y - py + forceY/node.weight * dt2;
                //---- basic stormer-verlet with friction ----
                //node.x = (2 - f) * node.x - (1 - f)px + forceX/node.weight * dt2;
                //node.y = (2 - f) * node.y - (1 - f)py + forceY/node.weight * dt2;
                //---- warning: heatFactor exceeding .9 will cause unstable behavior ----
                //var heatFactor = 9.5 * this._alpha;
                var heatFactor = (this._tickCount < 75) ? .85 : (0 + .95 * decayingPercent);
                heatFactor *= this._friction;

                //---- regular verlet with heat on momentum ----
                node.x = x + (x - px) * heatFactor + forceTotal.x / node.weight * dt2;
                node.y = y + (y - py) * heatFactor + forceTotal.y / node.weight * dt2;

                if (isNaN(node.x) || isNaN(node.y)) {
                    throw "Error - nan value found in node";
                }
            };

            forceLayoutClass.prototype.computeLinkForces = function (node) {
                var links = this._links;
                var force = { x: 0, y: 0 };

                for (var i = 0; i < links.length; i++) {
                    var link = links[i];

                    if (link.source == node) {
                        this.computeLinkForce(node, link.target, link, force);
                    } else if (link.target == node) {
                        this.computeLinkForce(node, link.source, link, force);
                    }
                }

                return force;
            };

            forceLayoutClass.prototype.computeLinkForce = function (node, target, link, forceTotal) {
                //---- compute distance between node & target ----
                var dx = node.x - target.x;
                var dy = node.y - target.y;
                var dist = Math.sqrt(dx * dx + dy * dy);

                var delta = link.distance - dist;
                var rawForce = delta * link.strength;

                this.addForceWithDistance(target, node, rawForce, Infinity, null, forceTotal);
            };

            forceLayoutClass.prototype.computeNodeForces = function (fromNode, quadTree) {
                var nodes = this._nodes;
                var forceTotal = { x: 0, y: 0 };

                if (this._theta) {
                    //---- use Barnes-Hut trick for caclulating force faster ----
                    this.computeQuadTreeNodeForce(fromNode, quadTree.rootNode, forceTotal);
                } else {
                    for (var i = 0; i < nodes.length; i++) {
                        var node = nodes[i];
                        if (node != fromNode) {
                            this.addForceWithDistance(fromNode, node, node.charge, this._chargeDistance, "/", forceTotal);
                        }
                    }
                }

                return forceTotal;
            };

            forceLayoutClass.prototype.addForceWithDistance = function (from, to, charge, maxDistance, distOp, forceTotal) {
                if (charge) {
                    var dx = to.x - from.x;
                    var dy = to.y - from.y;
                    var dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < maxDistance) {
                        var rawForce;

                        if (distOp === "*") {
                            rawForce = charge * dist;
                        } else if (distOp === "/") {
                            rawForce = (dist > .000001) ? (charge / dist) : 0;
                        } else {
                            rawForce = charge;
                        }

                        if (rawForce) {
                            //---- separate rawForce into X and Y components ----
                            var radians = Math.atan2(dy, dx);
                            var fx = Math.cos(radians) * rawForce;
                            var fy = Math.sin(radians) * rawForce;

                            forceTotal.x += fx;
                            forceTotal.y += fy;
                        }
                    }
                }
            };

            forceLayoutClass.prototype.computeQuadTreeNodeForce = function (node, qtNode, forceTotal) {
                //---- compute distance between node and center of mass of qtNode ----
                var dx = node.x - qtNode.xCom;
                var dy = node.y - qtNode.yCom;
                var dist = Math.sqrt(dx * dx + dy * dy);

                var regionWidth = qtNode.right - qtNode.left;

                var ratio = regionWidth / dist;

                //vp.utils.debug("ratio: " + ratio + ", regionWidth: " + regionWidth + ", dist: " + dist);
                if (ratio < this._theta) {
                    //---- use shortcut ----
                    this.addForceWithDistance(node, { x: qtNode.xCom, y: qtNode.yCom }, qtNode.totalMass, this._chargeDistance, "/", forceTotal);
                } else {
                    //---- calc with qtNode: point, and 4 child nodes ----
                    if (qtNode.point && qtNode.point != node) {
                        var ptNode = qtNode.point;

                        this.addForceWithDistance(node, ptNode, ptNode.charge, this._chargeDistance, "/", forceTotal);
                    }

                    if (qtNode.nodes) {
                        for (var i = 0; i < qtNode.nodes.length; i++) {
                            var childNode = qtNode.nodes[i];
                            if (childNode.point) {
                                this.computeQuadTreeNodeForce(node, childNode, forceTotal);
                            }
                        }
                    }
                }
            };

            forceLayoutClass.prototype.onStart = function (callback) {
                this._onStartCallback = callback;

                return this;
            };

            forceLayoutClass.prototype.onTick = function (callback) {
                this._onTickCallback = callback;

                return this;
            };

            forceLayoutClass.prototype.onEnd = function (callback) {
                this._onEndCallback = callback;

                return this;
            };

            forceLayoutClass.prototype.onStats = function (callback) {
                this._onStatsCallback = callback;

                return this;
            };

            forceLayoutClass.prototype.nodes = function (value) {
                if (arguments.length === 0) {
                    return this._nodes;
                }

                this._nodes = value;
                return this;
            };

            forceLayoutClass.prototype.links = function (value) {
                if (arguments.length === 0) {
                    return this._links;
                }

                this._links = value;
                return this;
            };

            forceLayoutClass.prototype.gravity = function (value) {
                if (arguments.length === 0) {
                    return this._gravity;
                }

                this._gravity = value;
                return this;
            };

            forceLayoutClass.prototype.charge = function (value) {
                if (arguments.length === 0) {
                    return this._charge;
                }

                this._charge = value;
                return this;
            };

            forceLayoutClass.prototype.width = function (value) {
                if (arguments.length === 0) {
                    return this._width;
                }

                this._width = value;
                return this;
            };

            forceLayoutClass.prototype.height = function (value) {
                if (arguments.length === 0) {
                    return this._height;
                }

                this._height = value;
                return this;
            };

            forceLayoutClass.prototype.alpha = function (value) {
                if (arguments.length === 0) {
                    return this._alpha;
                }

                this._alpha = value;

                if (!this._timer && value > 0) {
                    this.innerStart(this._alpha);
                }

                return this;
            };

            forceLayoutClass.prototype.chargeDistance = function (value) {
                if (arguments.length === 0) {
                    return this._chargeDistance;
                }

                this._chargeDistance = value;
                return this;
            };

            forceLayoutClass.prototype.linkDistance = function (value) {
                if (arguments.length === 0) {
                    return this._linkDistance;
                }

                this._linkDistance = value;
                return this;
            };

            forceLayoutClass.prototype.theta = function (value) {
                if (arguments.length === 0) {
                    return this._theta;
                }

                this._theta = value;
                return this;
            };

            forceLayoutClass.prototype.friction = function (value) {
                if (arguments.length === 0) {
                    return this._friction;
                }

                this._friction = value;
                return this;
            };
            return forceLayoutClass;
        })();
        layouts.forceLayoutClass = forceLayoutClass;

        function createForceLayout() {
            return new forceLayoutClass();
        }
        layouts.createForceLayout = createForceLayout;

        var quadNodeMass = (function (_super) {
            __extends(quadNodeMass, _super);
            function quadNodeMass() {
                _super.apply(this, arguments);
            }
            return quadNodeMass;
        })(layouts.quadNodeClass);
        layouts.quadNodeMass = quadNodeMass;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
//# sourceMappingURL=forceLayout.js.map
//-----------------------------------------------------------------------------------------------------------------
// BasicTypes.ts    Copyright 2014 Microsoft Corporation.
//-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (geom) {
        /// aka "SVGRect".
        var rectLight = (function () {
            function rectLight(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            return rectLight;
        })();
        geom.rectLight = rectLight;
    })(vp.geom || (vp.geom = {}));
    var geom = vp.geom;
})(vp || (vp = {}));
//# sourceMappingURL=basicTypes.js.map

///----------------------------------------------------------------
/// (from geom\matrix4.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// matrix4.ts.  Copyright (c) 2014 Microsoft Corporation.
///            Part of the vuePlotCore library - a 4x4 matrix class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (geom) {
        /// matrix4 class.
        /// formulas in matrix4 adapted from various Microsoft code:
        ///     - DxCodePack project: http://archive.msdn.microsoft.com/WindowsAPICodePack) File: D3DCommonStructs.h
        ///     - Microsoft DirectX docs: http://msdn.microsoft.com/en-us/library/windows/desktop/bb205351%28v=vs.85%29.aspx
        ///     - XnaMathMatrix.inl (Microsoft SDK file)
        ///     - Microsoft WPF (Orcas release): \Core\CSharp\System\Windows\Media3D\Matrix3D.cs\1\Matrix3D.cs (line 1285)
        /// Note: WebGL uses a right-hand coordinate system (with positive z axis coming towards viewer), so shapes should
        /// be placed in the negative z space.
        var matrix4 = (function () {
            function matrix4() {
                //if (typeof Float32Array == 'undefined')
                //{
                //    this.mat = new Array(16);
                //}
                //else
                //{
                //    this.mat = new Float32Array(16);
                //}
                //---- we want calling code to be able to treat this as an array ----
                var self = this;

                //---- add array support ----
                this.length = 16;
                self.push = Array.prototype.push;
                self.splice = Array.prototype.splice;
                self.indexOf = Array.prototype.indexOf;
                self.map = Array.prototype.map;
                self.select = Array.prototype.select;
            }
            matrix4.prototype.toArray = function () {
                var result = [];

                for (var i = 0; i < this.length; i++) {
                    result[i] = this[i];
                }

                return result;
            };

            matrix4.fromFloats = function (m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
                var mat = new matrix4();

                mat[0] = m11;
                mat[1] = m12;
                mat[2] = m13;
                mat[3] = m14;

                mat[4] = m21;
                mat[5] = m22;
                mat[6] = m23;
                mat[7] = m24;

                mat[8] = m31;
                mat[9] = m32;
                mat[10] = m33;
                mat[11] = m34;

                mat[12] = m41;
                mat[13] = m42;
                mat[14] = m43;
                mat[15] = m44;

                return mat;
            };

            matrix4.identity = function () {
                var mat = new matrix4();

                //---- build identity matrix ----
                mat[0] = 1; // M11
                mat[1] = 0; // M12
                mat[2] = 0; // M13
                mat[3] = 0; // M14

                mat[4] = 0; // M21
                mat[5] = 1; // M22
                mat[6] = 0; // M23
                mat[7] = 0; // M24

                mat[8] = 0; // M31
                mat[9] = 0; // M32
                mat[10] = 1; // M33
                mat[11] = 0; // M34

                mat[12] = 0; // M41
                mat[13] = 0; // M42
                mat[14] = 0; // M43
                mat[15] = 1; // M44

                return mat;
            };

            matrix4.invert = function (m) {
                var b = matrix4.identity();

                var _offsetX = m[12];
                var _offsetY = m[13];
                var _offsetZ = m[14];

                // compute all six 2x2 determinants of 2nd two columns
                var y01 = m[2] * m[7] - m[6] * m[3];
                var y02 = m[2] * m[11] - m[10] * m[3];
                var y03 = m[2] * m[15] - _offsetZ * m[3];
                var y12 = m[6] * m[11] - m[10] * m[7];
                var y13 = m[6] * m[15] - _offsetZ * m[7];
                var y23 = m[10] * m[15] - _offsetZ * m[11];

                // Compute 3x3 cofactors for 1st the column
                var z30 = m[5] * y02 - m[9] * y01 - m[1] * y12;
                var z20 = m[1] * y13 - m[5] * y03 + _offsetY * y01;
                var z10 = m[9] * y03 - _offsetY * y02 - m[1] * y23;
                var z00 = m[5] * y23 - m[9] * y13 + _offsetY * y12;

                // Compute 4x4 determinant
                var det = _offsetX * z30 + m[8] * z20 + m[4] * z10 + m[0] * z00;

                // If Determinant is computed using a different method then Inverse can throw
                // NotInvertable when HasInverse is true.  (Windows OS #901174)
                //
                var epsilon = .0000001;
                if (Math.abs(det) > epsilon) {
                    // Compute 3x3 cofactors for the 2nd column
                    var z31 = m[0] * y12 - m[4] * y02 + m[8] * y01;
                    var z21 = m[4] * y03 - _offsetX * y01 - m[0] * y13;
                    var z11 = m[0] * y23 - m[8] * y03 + _offsetX * y02;
                    var z01 = m[8] * y13 - _offsetX * y12 - m[4] * y23;

                    // Compute all six 2x2 determinants of 1st two columns
                    y01 = m[0] * m[5] - m[4] * m[1];
                    y02 = m[0] * m[9] - m[8] * m[1];
                    y03 = m[0] * _offsetY - _offsetX * m[1];
                    y12 = m[4] * m[9] - m[8] * m[5];
                    y13 = m[4] * _offsetY - _offsetX * m[5];
                    y23 = m[8] * _offsetY - _offsetX * m[9];

                    // Compute all 3x3 cofactors for 2nd two columns
                    var z33 = m[2] * y12 - m[6] * y02 + m[10] * y01;
                    var z23 = m[6] * y03 - _offsetZ * y01 - m[2] * y13;
                    var z13 = m[2] * y23 - m[10] * y03 + _offsetZ * y02;
                    var z03 = m[10] * y13 - _offsetZ * y12 - m[6] * y23;
                    var z32 = m[7] * y02 - m[11] * y01 - m[3] * y12;
                    var z22 = m[3] * y13 - m[7] * y03 + m[15] * y01;
                    var z12 = m[11] * y03 - m[15] * y02 - m[3] * y23;
                    var z02 = m[7] * y23 - m[11] * y13 + m[15] * y12;

                    var rcp = 1.0 / det;

                    // Multiply all 3x3 cofactors by reciprocal & transpose
                    b[0] = z00 * rcp;
                    b[1] = z10 * rcp;
                    b[2] = z20 * rcp;
                    b[3] = z30 * rcp;

                    b[4] = z01 * rcp;
                    b[5] = z11 * rcp;
                    b[6] = z21 * rcp;
                    b[7] = z31 * rcp;

                    b[8] = z02 * rcp;
                    b[9] = z12 * rcp;
                    b[10] = z22 * rcp;
                    b[11] = z32 * rcp;

                    b[12] = z03 * rcp;
                    b[13] = z13 * rcp;
                    b[14] = z23 * rcp;
                    b[15] = z33 * rcp;
                }

                return b;
            };

            //---- returns a matrix that does an orthographic projection (RIGHT HAND) ----
            matrix4.createOrthographic = function (width, height, nearPlane, farPlane) {
                var zn = nearPlane;
                var zf = farPlane;

                var m22 = 1 / (zn - zf);
                var m32 = zn * m22;

                var mat = matrix4.fromFloats(2 / width, 0, 0, 0, 0, 2 / height, 0, 0, 0, 0, m22, 0, 0, 0, m32, 1);

                return mat;
            };

            //---- returns a matrix that does an orthographic projection (RIGHT HAND) ----
            //---- note: the directx formula we use has different values in the z-scale and z-translation terms ----
            //---- as compared to results form gl-matrix.js. ----
            matrix4.createOrthographicOffCenter = function (left, right, bottom, top, near, far) {
                var mat = matrix4.fromFloats(2 / (right - left), 0, 0, 0, 0, 2 / (top - bottom), 0, 0, 0, 0, 1 / (near - far), 0, (left + right) / (left - right), (top + bottom) / (bottom - top), near / (near - far), 1);

                return mat;
            };

            /// creates a RIGHT-HANDED view matrix  (the location and direction of the camera)
            /// "eyePos" is the camera location
            /// "lookAt" is the location that the camera is pointed
            /// "up" is a vector from the center to the top of the camera
            ///
            /// note: the directx formula we use has different values in the z-scale and z-translation terms
            /// as compared to results form gl-matrix.js.
            matrix4.createLookAt = function (eyePos, lookAt, up) {
                var zaxis = geom.vector3.normal(geom.vector3.subtract(eyePos, lookAt));
                var xaxis = geom.vector3.normal(geom.vector3.cross(up, zaxis));
                var yaxis = geom.vector3.cross(zaxis, xaxis);

                var mat = matrix4.fromFloats(xaxis.x, yaxis.x, zaxis.x, 0, xaxis.y, yaxis.y, zaxis.y, 0, xaxis.z, yaxis.z, zaxis.z, 0, geom.vector3.dot(xaxis, eyePos), geom.vector3.dot(yaxis, eyePos), geom.vector3.dot(zaxis, eyePos), 1);

                return mat;
            };

            matrix4.createPerspectiveRH = function (width, height, zNear, zFar) {
                var mat = matrix4.fromFloats(2 * zNear / width, 0, 0, 0, 0, 2 * zNear / height, 0, 0, 0, 0, zFar / (zNear - zFar), -1, 0, 0, zNear * zFar / (zNear - zFar), 0);

                return mat;
            };

            /// "fov" is the field of view in the y direction, in radians.
            matrix4.createPerspectiveFovRH = function (fov, aspect, zNear, zFar) {
                var yScale = Math.cos(fov / 2) / Math.sin(fov / 2);
                var xScale = yScale / aspect;

                var mat = matrix4.fromFloats(xScale, 0, 0, 0, 0, yScale, 0, 0, 0, 0, zFar / (zNear - zFar), -1, 0, 0, zNear * zFar / (zNear - zFar), 0);

                return mat;
            };

            matrix4.createPerspectiveOffCenterRH = function (left, right, bottom, top, zNear, zFar) {
                var mat = matrix4.fromFloats(2 * zNear / (right - left), 0, 0, 0, 0, 2 * zNear / (top - bottom), 0, 0, (left + right) / (right - left), (top + bottom) / (top - bottom), zFar / (zNear - zFar), -1, 0, 0, 2 * zNear * zFar / (zNear - zFar), 0);

                return mat;
            };

            //---- multiply matrix and a vector ----
            matrix4.multiplyVector = function (m, v) {
                var x = v.x;
                var y = v.y;
                var z = v.z;
                var w = v.w;

                var x = m[0] * x + m[1] * y + m[2] * z + m[3] * w;
                var y = m[4] * x + m[5] * y + m[6] * z + m[7] * w;
                var z = m[8] * x + m[9] * y + m[10] * z + m[11] * w;
                var w = m[12] * x + m[13] * y + m[14] * z + m[15] * w;

                var result = new geom.vector4(x, y, z, w);
                return result;
            };

            //---- multiply 2 matrices ----
            matrix4.multiply = function (m, m2) {
                var mat = matrix4.fromFloats(m[0] * m2[0] + m[1] * m2[4] + m[2] * m2[8] + m[3] * m2[12], m[0] * m2[1] + m[1] * m2[5] + m[2] * m2[9] + m[3] * m2[13], m[0] * m2[2] + m[1] * m2[6] + m[2] * m2[10] + m[3] * m2[14], m[0] * m2[3] + m[1] * m2[7] + m[2] * m2[11] + m[3] * m2[15], m[4] * m2[0] + m[5] * m2[4] + m[6] * m2[8] + m[7] * m2[12], m[4] * m2[1] + m[5] * m2[5] + m[6] * m2[9] + m[7] * m2[13], m[4] * m2[2] + m[5] * m2[6] + m[6] * m2[10] + m[7] * m2[14], m[4] * m2[3] + m[5] * m2[7] + m[6] * m2[11] + m[7] * m2[15], m[8] * m2[0] + m[9] * m2[4] + m[10] * m2[8] + m[11] * m2[12], m[8] * m2[1] + m[9] * m2[5] + m[10] * m2[9] + m[11] * m2[13], m[8] * m2[2] + m[9] * m2[6] + m[10] * m2[10] + m[11] * m2[14], m[8] * m2[3] + m[9] * m2[7] + m[10] * m2[11] + m[11] * m2[15], m[12] * m2[0] + m[13] * m2[4] + m[14] * m2[8] + m[15] * m2[12], m[12] * m2[1] + m[13] * m2[5] + m[14] * m2[9] + m[15] * m2[13], m[12] * m2[2] + m[13] * m2[6] + m[14] * m2[10] + m[15] * m2[14], m[12] * m2[3] + m[13] * m2[7] + m[14] * m2[11] + m[15] * m2[15]);

                return mat;
            };

            matrix4.transformPoint = function (mat, v) {
                var newX = v.x * mat[0] + v.y * mat[4] + v.z * mat[8] + mat[12];
                var newY = v.x * mat[1] + v.y * mat[5] + v.z * mat[9] + mat[13];
                var newZ = v.x * mat[2] + v.y * mat[6] + v.z * mat[10] + mat[14];

                return new geom.vector3(newX, newY, newZ);
            };

            matrix4.createTranslation = function (x, y, z) {
                var mat = matrix4.identity();
                mat[12] = x;
                mat[13] = y;
                mat[14] = z;

                return mat;
            };

            matrix4.createScale = function (x, y, z) {
                var mat = matrix4.identity();
                mat[0] = x;
                mat[5] = y;
                mat[10] = z;

                return mat;
            };

            /**Returns a matrix that does a rotation about the X axis by the specified angle in radians. */
            matrix4.createRotationX = function (angle) {
                var mat = matrix4.fromFloats(1, 0, 0, 0, 0, Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1);

                return mat;
            };

            /**Returns a matrix that does a rotation about the Y axis by the specified angle in radians. */
            matrix4.createRotationY = function (angle) {
                var mat = matrix4.fromFloats(Math.cos(angle), 0, Math.sin(angle), 0, 0, 1, 0, 0, -Math.sin(angle), 0, Math.cos(angle), 0, 0, 0, 0, 1);

                return mat;
            };

            /**Returns a matrix that does a rotation about the Z axis by the specified angle in radians. */
            matrix4.createRotationZ = function (angle) {
                var mat = matrix4.fromFloats(Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

                return mat;
            };

            /** Returns a matrix that rotates about the z (yaw), y (pitch), and x (roll) axes.  All
            angles are specified in radians. */
            matrix4.createFromYawPitchRoll = function (yaw, pitch, roll) {
                var mz = matrix4.createRotationZ(yaw);
                var my = matrix4.createRotationY(pitch);
                var mx = matrix4.createRotationX(roll);

                var mat = mz;
                mat = matrix4.multiply(mat, my);
                mat = matrix4.multiply(mat, mx);

                return mat;
            };
            return matrix4;
        })();
        geom.matrix4 = matrix4;
    })(vp.geom || (vp.geom = {}));
    var geom = vp.geom;
})(vp || (vp = {}));
//# sourceMappingURL=matrix4.js.map

///----------------------------------------------------------------
/// (from geom\point2.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// point2.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlotCore library - a 2 dim point class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (geom) {
        var point2 = (function () {
            function point2(x, y) {
                this.x = (x === undefined) ? 0 : x;
                this.y = (y === undefined) ? 0 : y;
            }
            return point2;
        })();
        geom.point2 = point2;

        function createPoint2(x, y) {
            return new point2(x, y);
        }
        geom.createPoint2 = createPoint2;
    })(vp.geom || (vp.geom = {}));
    var geom = vp.geom;
})(vp || (vp = {}));
//# sourceMappingURL=point2.js.map

///----------------------------------------------------------------
/// (from geom\point3.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// point3.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlotCore library - a 3 dim point class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (geom) {
        var point3 = (function () {
            function point3(x, y, z) {
                this.x = (x === undefined) ? 0 : x;
                this.y = (y === undefined) ? 0 : y;
                this.z = (y === undefined) ? 0 : y;
            }
            return point3;
        })();
        geom.point3 = point3;

        function createPoint3(x, y, z) {
            return new point3(x, y, z);
        }
        geom.createPoint3 = createPoint3;
    })(vp.geom || (vp.geom = {}));
    var geom = vp.geom;
})(vp || (vp = {}));
//# sourceMappingURL=point3.js.map

///----------------------------------------------------------------
/// (from geom\rect.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// rect.ts.  Copyright (c) 2014 Microsoft Corporation.
///     - part of the vuePlot library
///     - small library of flat rectangle functions   {left, top, right, bottom, width, height}
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    (function (geom) {
        function createRect(left, top, w, h) {
            var rc = { left: left, top: top, width: w, height: h, right: left + w, bottom: top + h };
            return rc;
        }
        geom.createRect = createRect;

        function rect(left, top, w, h) {
            return createRect(left, top, w, h);
        }
        geom.rect = rect;

        function rectFromPoints(pt1, pt2) {
            var x = Math.min(pt1.x, pt2.x);
            var y = Math.min(pt1.y, pt2.y);
            var w = Math.abs(pt1.x - pt2.x);
            var h = Math.abs(pt1.y - pt2.y);

            var rc = { left: x, top: y, width: w, height: h, right: x + w, bottom: y + h };

            return rc;
        }
        geom.rectFromPoints = rectFromPoints;

        function rectContainsPoint(rc, pt) {
            var contains = false;

            if (pt.x >= rc.left) {
                if (pt.x <= rc.right) {
                    if (pt.y >= rc.top) {
                        if (pt.y <= rc.bottom) {
                            contains = true;
                        }
                    }
                }
            }

            return contains;
        }
        geom.rectContainsPoint = rectContainsPoint;

        function rectContainsRect(rcOuter, rcInner) {
            var contains = false;

            if (rcInner.left >= rcOuter.left) {
                if (rcInner.right <= rcOuter.right) {
                    if (rcInner.top >= rcOuter.top) {
                        if (rcInner.bottom <= rcOuter.bottom) {
                            contains = true;
                        }
                    }
                }
            }

            return contains;
        }
        geom.rectContainsRect = rectContainsRect;

        function rectIntersectsRect(rc1, rc2) {
            var overlaps = true;

            if (rc1.right < rc2.left) {
                overlaps = false;
            } else if (rc1.left > rc2.right) {
                overlaps = false;
            } else if (rc1.bottom < rc2.top) {
                overlaps = false;
            } else if (rc1.top > rc2.bottom) {
                overlaps = false;
            }

            return overlaps;
        }
        geom.rectIntersectsRect = rectIntersectsRect;

        function rectIntersectsSvgShape(rc, shape) {
            var tag = shape.tagName;
            var intersects = false;

            if (tag == "line") {
                var x1 = vp.dom.attr(shape, "x1");
                var y1 = vp.dom.attr(shape, "y1");

                var x2 = vp.dom.attr(shape, "x2");
                var y2 = vp.dom.attr(shape, "y2");

                intersects = rectIntersectsLine(rc, x1, y1, x2, y2);
            } else if (tag == "polygon") {
                var pts = vp.dom.attr(shape, "points");
                intersects = rectIntersectsAreaPolygon(rc, pts);
            } else {
                //---- use bounding box test for all other shapes ----
                var rc2 = vp.dom.getBounds(shape, true);

                intersects = vp.geom.rectIntersectsRect(rc, rc2);
            }

            return intersects;
        }
        geom.rectIntersectsSvgShape = rectIntersectsSvgShape;

        function rectIntersectsAreaPolygon(rc, pointStr) {
            var overlaps = true;
            var pts = parsePoints(pointStr);

            var x1 = pts[0].x;
            var x2 = pts[2].x;

            var y1 = pts[0].y;
            var y2 = pts[1].y;
            var y3 = pts[2].y;
            var y4 = pts[3].y;

            //---- try to reject based on x bounds of area ----
            var maxX = Math.max(x1, x2);
            var minX = Math.min(x1, x2);

            if (maxX < rc.left) {
                overlaps = false;
            } else if (minX > rc.right) {
                overlaps = false;
            } else {
                //--- reject based on y bounds of area ----
                var maxY = Math.max(y1, y4);
                var minY = Math.min(y2, y3);

                if (maxY < rc.top) {
                    //--- bottom of area is above top of rect ----
                    overlaps = false;
                } else if (minY > rc.bottom) {
                    //---- top of area is below bottom of rect ----
                    overlaps = false;
                } else if (x1 != x2) {
                    //---- find where TOP diagonal line (x1,y2)..(x2,y3) intersects left & right of rect ----
                    var m = (y3 - y2) / (x2 - x1);
                    var b = y3 - m * x2;

                    var yLeft = m * rc.left + b;
                    var yRight = m * rc.right + b;

                    //---- if both are below the rect, they do not intercept ----
                    if ((yLeft > rc.bottom) && (yRight > rc.bottom)) {
                        overlaps = false;
                    } else {
                        //---- find where BOTTOM diagonal line (x1,y1)..(x2,y4) intersects left & right of rect ----
                        var m = (y4 - y1) / (x2 - x1);
                        var b = y4 - m * x2;

                        var yLeft = m * rc.left + b;
                        var yRight = m * rc.right + b;

                        //---- if both are above the rect, they do not intercept ----
                        if ((yLeft < rc.top) && (yRight < rc.top)) {
                            overlaps = false;
                        }
                    }
                }
            }

            return overlaps;
        }
        geom.rectIntersectsAreaPolygon = rectIntersectsAreaPolygon;

        function parsePoints(str) {
            var pts = [];

            str = str.replace(/, /g, ","); // replace all ", " chars with just comma
            str = str.replace(/  /g, " "); // replace all double spaces with a single space

            var parts = str.split(" ");
            for (var i = 0; i < parts.length; i++) {
                var pps = parts[i].split(",");
                if (pps.length != 2) {
                    vp.utils.error("unsupported point format in shape");
                }

                var pt = { x: pps[0], y: pps[1] };
                pts.push(pt);
            }

            return pts;
        }

        function rectIntersectsLine(rc, x1, y1, x2, y2) {
            var overlaps = true;

            //---- try to reject based on x bounds of line ----
            var maxX = Math.max(x1, x2);
            var minX = Math.min(x1, x2);

            if (maxX < rc.left) {
                overlaps = false;
            } else if (minX > rc.right) {
                overlaps = false;
            } else {
                //--- reject based on y bounds of line ----
                var maxY = Math.max(y1, y2);
                var minY = Math.min(y1, y2);

                if (maxY < rc.top) {
                    overlaps = false;
                } else if (minY > rc.bottom) {
                    overlaps = false;
                } else {
                    //---- find where line intersects left & right of rect ----
                    var m = (y2 - y1) / (x2 - x1);
                    var b = y2 - m * x2;

                    var yLeft = m * rc.left + b;
                    var yRight = m * rc.right + b;

                    //---- if both are ABOVE the rect, they do not intercept ----
                    if ((yLeft < rc.top) && (yRight < rc.top)) {
                        overlaps = false;
                    }

                    //---- if both are BELOW the rect, they do not intercept ----
                    if ((yLeft > rc.bottom) && (yRight > rc.bottom)) {
                        overlaps = false;
                    }
                }
            }

            return overlaps;
        }
        geom.rectIntersectsLine = rectIntersectsLine;

        function offsetRect(rc, xoff, yoff) {
            var x = rc.left + xoff;
            var y = rc.top + yoff;
            var w = rc.width;
            var h = rc.height;

            return { left: x, top: y, width: w, height: h, right: x + w, bottom: y + h };
        }
        geom.offsetRect = offsetRect;
    })(vp.geom || (vp.geom = {}));
    var geom = vp.geom;
})(vp || (vp = {}));
//# sourceMappingURL=rect.js.map

///----------------------------------------------------------------
/// (from geom\vector2.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// vector2.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlotCore library - a 2 dim vector class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (geom) {
        var vector2 = (function () {
            function vector2(x, y) {
                this.x = (x === undefined) ? 0 : x;
                this.y = (y === undefined) ? 0 : y;
            }
            vector2.add = function (v, v2) {
                var vNew = new vector2(v.x + v2.x, v.y + v2.y);
                return vNew;
            };

            vector2.subtract = function (v, v2) {
                var vNew = new vector2(v.x - v2.x, v.y - v2.y);
                return vNew;
            };

            vector2.multiply = function (v, s) {
                var vNew = new vector2(v.x * s, v.y * s);
                return vNew;
            };

            vector2.dot = function (v, v2) {
                var sum = v.x * v2.x + v.y * v2.y;
                return sum;
            };

            /// return the normalized vector.
            vector2.normal = function (v) {
                var magnitude = Math.sqrt((v.x * v.x) + (v.y * v.y));
                var vNew = new vector2(v.x / magnitude, v.y / magnitude);

                return vNew;
            };
            return vector2;
        })();
        geom.vector2 = vector2;

        function createVector2(x, y) {
            return new vector2(x, y);
        }
        geom.createVector2 = createVector2;
    })(vp.geom || (vp.geom = {}));
    var geom = vp.geom;
})(vp || (vp = {}));
//# sourceMappingURL=vector2.js.map

///----------------------------------------------------------------
/// (from geom\vector3.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// vector3.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlotCore library - a 3 dim vector class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (geom) {
        var vector3 = (function () {
            function vector3(x, y, z) {
                this.x = (x === undefined) ? 0 : x;
                this.y = (y === undefined) ? 0 : y;
                this.z = (z === undefined) ? 0 : z;
            }
            vector3.add = function (v, v2) {
                var vNew = new vector3(v.x + v2.x, v.y + v2.y, v.z + v2.z);
                return vNew;
            };

            vector3.subtract = function (v, v2) {
                var vNew = new vector3(v.x - v2.x, v.y - v2.y, v.z - v2.z);
                return vNew;
            };

            vector3.multiply = function (v, s) {
                var vNew = new vector3(v.x * s, v.y * s, v.z * s);
                return vNew;
            };

            vector3.cross = function (v, v2) {
                var vNew = new vector3();

                vNew.x = v.y * v2.z - v.z * v2.y;
                vNew.y = v.z * v2.x - v.x * v2.z;
                vNew.z = v.x * v2.y - v.y * v2.x;

                return vNew;
            };

            vector3.dot = function (v, v2) {
                var sum = v.x * v2.x + v.y * v2.y + v.z * v2.z;
                return sum;
            };

            /// return the normalized vector.
            vector3.normal = function (v) {
                var magnitude = Math.sqrt((v.x * v.x) + (v.y * v.y) + (v.z * v.z));
                var vNew = new vector3(v.x / magnitude, v.y / magnitude, v.z / magnitude);

                return vNew;
            };

            /// return the vector normal to 3 points.
            vector3.normalToPoints = function (pt1, pt2, pt3) {
                var v1 = new vector3(pt2.x - pt1.x, pt2.y - pt1.y, pt2.z - pt1.z);
                var v2 = new vector3(pt3.x - pt2.x, pt3.y - pt2.y, pt3.z - pt1.z);

                var vNew = vector3.cross(v1, v2);

                return vNew;
            };

            vector3.zero = function () {
                return new vector3(0, 0, 0);
            };

            vector3.up = function () {
                return new vector3(0, 1, 0);
            };
            return vector3;
        })();
        geom.vector3 = vector3;

        function createVector3(x, y, z) {
            return new vector3(x, y, z);
        }
        geom.createVector3 = createVector3;
    })(vp.geom || (vp.geom = {}));
    var geom = vp.geom;
})(vp || (vp = {}));
//# sourceMappingURL=vector3.js.map

///----------------------------------------------------------------
/// (from geom\vector4.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// vector4.ts.  Copyright (c) 2013 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - a set of flat functions for 3d vector support.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (geom) {
        var vector4 = (function () {
            function vector4(x, y, z, w) {
                this.x = (x === undefined) ? 0 : x;
                this.y = (y === undefined) ? 0 : y;
                this.z = (z === undefined) ? 0 : z;
                this.w = (w === undefined) ? 0 : w;
            }
            vector4.add = function (v, v2) {
                var vNew = new vector4(v.x + v2.x, v.y + v2.y, v.z + v2.z, v.w + v2.w);
                return vNew;
            };

            vector4.subtract = function (v, v2) {
                var vNew = new vector4(v.x - v2.x, v.y - v2.y, v.z - v2.z, v.w - v2.w);
                return vNew;
            };

            vector4.multiply = function (v, s) {
                var vNew = new vector4(v.x * s, v.y * s, v.z * s, v.w * s);
                return vNew;
            };

            /////
            //static cross(v, v2): vector4
            //{
            //    var x = v.y * v2.z - v.z * v2.y;
            //    var y = v.z * v2.x - v.x * v2.z;
            //    var z = v.x * v2.y - v.y * v2.x;
            //    var w = 1;          // ??
            //    return new vector4(x, y, z, w);
            //}
            vector4.dot = function (v, v2) {
                var sum = v.x * v2.x + v.y * v2.y + v.z * v2.z + v.w * v2.w;
                return sum;
            };

            /// return the normalized vector.
            vector4.normal = function (v) {
                var magnitude = Math.sqrt((v.x * v.x) + (v.y * v.y) + (v.z * v.z) + (v.w * v.w));
                var vNew = new vector4(v.x / magnitude, v.y / magnitude, v.z / magnitude, v.w / magnitude);

                return vNew;
            };

            vector4.zero = function () {
                return new vector4(0, 0, 0, 0);
            };
            return vector4;
        })();
        geom.vector4 = vector4;
    })(vp.geom || (vp.geom = {}));
    var geom = vp.geom;
})(vp || (vp = {}));
//# sourceMappingURL=vector4.js.map
///-----------------------------------------------------------------------------------------------------------------
/// buildPie.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (_paths) {
        function buildPie(data, cx, cy, innerRadius, outerRadius, createCanvasPath, callback) {
            var paths = [];
            var lastX = null;
            var lastYMin = null;
            var lastYMax = null;
            var yValues = [];

            for (var i = 0; i < data.length; i++) {
                var record = data[i];

                var info = { y: 100 };
                callback(record, i, info);

                yValues.push(info.y);
            }

            var abc = "hi there";
            if (abc.startsWith("dkdk")) {
            }

            //---- second pass - normalize the data ----
            var sum = yValues.sum(function (d) {
                return Math.abs(d);
            });

            var rotation = 0;

            for (var i = 0; i < data.length; i++) {
                var angle = 360 * (yValues[i] / sum);

                var path = getPieSlicePath(cx, cy, innerRadius, outerRadius, angle, rotation, createCanvasPath);

                paths.push(path);

                rotation += angle;
            }

            return paths;
        }
        _paths.buildPie = buildPie;

        function placeOnCircle(ptCenter, radius, rotationDegrees) {
            rotationDegrees -= 90; // make 0 degrees start "12:00" position

            var radians = rotationDegrees * (Math.PI / 180);

            var xEnd = ptCenter.x + Math.cos(radians) * radius;
            var yEnd = ptCenter.y + Math.sin(radians) * radius;

            return { x: xEnd, y: yEnd };
        }

        //---- draw ARC from current point to ptEnd ----
        function makeArc(arcDegrees, sweepClockwise, radius, ptEnd) {
            var isLarge = (arcDegrees >= 180) ? 1 : 0;
            var sweepFlag = (sweepClockwise) ? 1 : 0;

            var path = "A" + radius + "," + radius + ",0," + isLarge + "," + sweepFlag + "," + ptEnd.x + "," + ptEnd.y + " ";

            return path;
        }

        function pointAlongLine(ptStart, ptEnd, dist) {
            var x = ptStart.x + dist * (ptEnd.x - ptStart.x);
            var y = ptStart.y + dist * (ptEnd.y - ptStart.y);

            var pt = { x: x, y: y };
            return pt;
        }

        function getPieSlicePath(xCenter, yCenter, innerRadius, outerRadius, angleDegrees, rotation, createCanvasPath) {
            var path = null;

            if (createCanvasPath) {
                path = getPieSlicePathCanvas(xCenter, yCenter, innerRadius, outerRadius, angleDegrees, rotation);
            } else {
                path = getPieSlicePathSvg(xCenter, yCenter, innerRadius, outerRadius, angleDegrees, rotation);
            }

            return path;
        }
        _paths.getPieSlicePath = getPieSlicePath;

        function getPieSlicePathSvg(xCenter, yCenter, innerRadius, outerRadius, angleDegrees, rotation) {
            var ptCenter = { x: xCenter, y: yCenter };
            var ptStart = { x: xCenter, y: yCenter };

            if (innerRadius > 0) {
                //ptStart.x += innerRadius;
                ptStart = placeOnCircle(ptCenter, innerRadius, rotation);
            }

            var path = "M" + ptStart.x + "," + ptStart.y + " ";

            var fullPie = false;
            if (angleDegrees >= 360) {
                fullPie = true;

                //---- the ARC cmd cannot draw a full circle, but this value seems to work well ----
                angleDegrees = 359.999;
            }

            var ptArc = placeOnCircle(ptCenter, outerRadius, rotation);

            if (!fullPie) {
                //---- first line (extends to the start of the arc) ----
                path += "L" + ptArc.x + "," + ptArc.y + " ";
            } else {
                path += "M" + ptArc.x + "," + ptArc.y + " ";
            }

            //---- the arc ----
            var ptArcEnd = placeOnCircle(ptCenter, outerRadius, rotation + angleDegrees);

            var arc = makeArc(angleDegrees, true, outerRadius, ptArcEnd);
            path += arc;

            if (innerRadius > 0) {
                var ptEnd = placeOnCircle(ptCenter, innerRadius, rotation + angleDegrees);

                if (fullPie) {
                    //---- need to move to ptEnd ---
                    path += "M" + ptEnd.x + "," + ptEnd.y + " ";
                } else {
                    //---- draw a line to ptEnd ----
                    path += "L" + ptEnd.x + "," + ptEnd.y + " ";
                }

                //---- reverse, innner arc ----
                var arc2 = makeArc(angleDegrees, false, innerRadius, ptStart);
                path += arc2;
            }

            path += "Z"; // close path

            //---- test ----
            //path = "M 100 100 L 300 100 L 200 300 z";
            return path;
        }
        _paths.getPieSlicePathSvg = getPieSlicePathSvg;

        function getPieSlicePathCanvas(xCenter, yCenter, innerRadius, outerRadius, angleDegrees, rotation) {
            var ptCenter = { x: xCenter, y: yCenter };
            var ptStart = { x: xCenter, y: yCenter };

            if (innerRadius > 0) {
                //ptStart.x += innerRadius;
                ptStart = placeOnCircle(ptCenter, innerRadius, rotation);
            }

            var path = "M" + ptStart.x + "," + ptStart.y + " ";

            var fullPie = false;
            if (angleDegrees >= 360) {
                fullPie = true;

                //---- the ARC cmd cannot draw a full circle, but this value seems to work well ----
                angleDegrees = 359.999;
            }

            var ptArc = placeOnCircle(ptCenter, outerRadius, rotation);

            if (!fullPie) {
                //---- first line (extends to the start of the arc) ----
                path += "L" + ptArc.x + "," + ptArc.y + " ";
            } else {
                path += "M" + ptArc.x + "," + ptArc.y + " ";
            }

            var startAngle = (rotation - 90) * Math.PI / 180;
            var endAngle = (rotation - 90 + angleDegrees) * Math.PI / 180;

            //---- the arc ----
            var ptArcEnd = placeOnCircle(ptCenter, outerRadius, rotation + angleDegrees);

            //var arc = makeArc(angleDegrees, true, outerRadius, ptArcEnd);
            var arc = "X" + xCenter + "," + yCenter + "," + outerRadius + "," + startAngle + "," + endAngle + ",0 ";
            arc += "M" + ptArcEnd.x + "," + ptArcEnd.y + " "; // move current point to end of arc
            path += arc;

            if (innerRadius > 0) {
                var ptEnd = placeOnCircle(ptCenter, innerRadius, rotation + angleDegrees);

                if (fullPie) {
                    //---- need to move to ptEnd ---
                    path += "M" + ptEnd.x + "," + ptEnd.y + " ";
                } else {
                    //---- draw a line to ptEnd ----
                    path += "L" + ptEnd.x + "," + ptEnd.y + " ";
                }

                //---- reverse, innner arc ----
                //var arc2 = makeArc(angleDegrees, false, innerRadius, ptStart);
                var arc2 = "X" + xCenter + "," + yCenter + "," + innerRadius + "," + endAngle + "," + startAngle + ",1 ";
                arc2 += "M" + ptStart.x + "," + ptStart.y + " "; // move current point to end of arc
                path += arc2;
            }

            path += "Z"; // close path

            //---- test ----
            //path = "M 100 100 L 300 100 L 200 300 z";
            return path;
        }
        _paths.getPieSlicePathCanvas = getPieSlicePathCanvas;
    })(vp.paths || (vp.paths = {}));
    var paths = vp.paths;
})(vp || (vp = {}));
//# sourceMappingURL=buildPie.js.map

///----------------------------------------------------------------
/// (from paths\curveFitting.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// curveFitting.ts.  Copyright (c) 2014 Microsoft Corporation.
///            Part of the vuePlotCore library - curve fitting functions.
///-----------------------------------------------------------------------------------------------------------------
/// all of these functions in this file, unless specified otherwise,
/// were adapted from book "practical WPF Charts and Graphics"
/// http://www.amazon.com/Practical-Charts-Graphics-Experts-Voice/dp/1430224819, Chapter 11 Curve Fitting.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (curveFitting) {
        function line(xa, ya) {
            var values = {};

            if ((!xa) || (!xa.length) || (!ya) || (!ya.length)) {
                vp.utils.error("error - polyfit() requires X and Y number arrays");
            }

            if (xa.length != ya.length) {
                vp.utils.error("error - polyfit() requires that X and Y be the same size");
            }

            var count = xa.length;

            //---- model: y = slope*x + intercept ----
            var xm = average(xa);
            var ym = average(ya);

            var btop = 0;
            var bbot = 0;

            for (var i = 0; i < count; i++) {
                btop += (ya[i] * (xa[i] - xm));
                bbot += (xa[i] * (xa[i] - xm));
            }

            var slope = btop / bbot;
            var intercept = ym - xm * slope;

            var sigma = 0;

            for (var i = 0; i < count; i++) {
                var t = ya[i] - intercept - (slope * xa[i]);
                sigma += t * t;
            }

            sigma = Math.sqrt(sigma / (count - 2));

            var ptFrom = { x: xa[0], y: slope * xa[0] + intercept };
            var ptTo = { x: xa[count - 1], y: slope * xa[count - 1] + intercept };

            values = { slope: slope, intercept: intercept, sigma: sigma, ptFrom: ptFrom, ptTo: ptTo };

            return values;
        }
        curveFitting.line = line;

        function average(nums) {
            var total = 0;
            var count = nums.length;

            for (var i = 0; i < nums.length; i++) {
                total += nums[i];
            }

            var avg = (count > 0) ? total / count : 0;
            return avg;
        }

        function matrix2d(rows, cols) {
            var m = [];

            for (var i = 0; i < rows; i++) {
                var row = [];

                for (var j = 0; j < cols; j++) {
                    row.push(0);
                }

                m.push(row);
            }

            return m;
        }

        function vector(cols) {
            var row = [];

            for (var j = 0; j < cols; j++) {
                row.push(0);
            }

            return row;
        }

        //export function linRegressPoly(xa, ya, degree)
        //{
        //    var f0 = function(x) {return 1;}
        //    var f1 = function(x) {return x;}
        //    var f2 = function(x) {return x*x;}
        //    var f3 = function(x) {return x*x*x;}
        //    var f = null;
        //    if (degree == 1)
        //    {
        //        f = [f0, f1];
        //    }
        //    else if (degree == 2)
        //    {
        //        f = [f0, f1, f2];
        //    }
        //    else if (degree == 3)
        //    {
        //        f = [f0, f1, f2, f3];
        //    }
        //    var result = export function linearRegression(xa, ya, f);
        //    return result;
        //}
        /// "xa" are the x data values, "ya" are the y data values, "degree" is the polynomial degress (1, 2, ...)
        function polyFit(xa, ya, degree) {
            var m = degree + 1;
            var a = matrix2d(m, m);
            var b = vector(m);
            var n = xa.length;

            for (var k = 0; k < m; k++) {
                b[k] = 0;
                for (var i = 0; i < n; i++) {
                    b[k] += Math.pow(xa[i], k) * ya[i];
                }
            }

            for (var j = 0; j < m; j++) {
                for (var k = 0; k < m; k++) {
                    a[j][k] = 0;
                    for (var i = 0; i < n; i++) {
                        a[j][k] += Math.pow(xa[i], j + k);
                    }
                }
            }

            var coef = gaussJordan(a, b);

            //---- calculate the std deviation ----
            var s = 0;
            for (var i = 0; i < n; i++) {
                var s1 = 0;

                for (var j = 0; j < m; j++) {
                    s1 += coef[j] * Math.pow(xa[i], j);
                }

                s += (ya[i] - s1) * (ya[i] - s1);
            }

            var sigma = Math.sqrt(s / (n - m));

            return { coef: coef, sigma: sigma };
        }
        curveFitting.polyFit = polyFit;

        /// "xa" are the x data values, "ya" are the y data values, "wa" are the weight values.
        function weightedLinearRegression(xa, ya, wa) {
            var n = xa.length;
            var xw = 0;
            var yw = 0;
            var b1 = 0;
            var b2 = 0;
            var a = 0;
            var b = 0;

            for (var i = 0; i < n; i++) {
                xw += xa[i] / n;
                yw = ya[i] / n;
            }

            for (var i = 0; i < n; i++) {
                b1 += wa[i] * wa[i] * ya[i] * (xa[i] - xw);

                //b2 += wa[i] * wa[i] * xa[i] * (xa[i] - xw);
                b2 += wa[i] * wa[i] * xa[i] * (ya[i] - yw);
            }

            b = b1 / b2;
            a = yw - xw * b;

            return { coef: [a, b] };
        }
        curveFitting.weightedLinearRegression = weightedLinearRegression;

        /// "xa" are the x data values, "ya" are the y data values, "degree" is the polynomial degress (1, 2, ...)
        function exponentialFit(xa, ya) {
            var logy = [];

            for (var i = 0; i < ya.length; i++) {
                logy[i] = Math.log(ya[i]);
            }

            var result = weightedLinearRegression(xa, logy, ya);
            return result;
        }
        curveFitting.exponentialFit = exponentialFit;

        /// "xa" are the x data values, "ya" are the y data values, "f" is an array of model func (usually returns x**N).
        function linearRegression(xa, ya, f) {
            var m = f.length;
            var a = matrix2d(m, m);
            var b = vector(m);
            var n = xa.length;

            for (var k = 0; k < m; k++) {
                b[k] = 0;

                for (var i = 0; i < n; i++) {
                    var result = f[k](xa[i]);
                    var term = result * ya[i];
                    b[k] += term;
                }
            }

            for (var j = 0; j < m; j++) {
                for (var k = 0; k < m; k++) {
                    a[j][k] = 0;

                    for (var i = 0; i < n; i++) {
                        var result = f[j](xa[i]);
                        var result2 = f[k](xa[i]);
                        var term = result * result2;
                        a[j][k] += term;
                    }
                }
            }

            var coef = gaussJordan(a, b);

            //---- calculate the std deviation ----
            var s = 0;
            for (var i = 0; i < n; i++) {
                var s1 = 0;

                for (var j = 0; j < m; j++) {
                    s1 += coef[j] * f[j](xa[i]);
                }

                s += (ya[i] - s1) * (ya[i] - s1);
            }

            var sigma = Math.sqrt(s / (n - m));

            return { coef: coef, sigma: sigma };
        }
        curveFitting.linearRegression = linearRegression;

        /// "a" is Matrix, "b" is array.
        function gaussJordan(a, b) {
            triangulate(a, b);

            var n = b.length;
            var x = vector(n);

            for (var i = n - 1; i >= 0; i--) {
                var d = a[i][i];

                if (Math.abs(d) < 1.0e-500) {
                    vp.utils.error("error: diagnoal element is too small for GaussJordan");
                }

                x[i] = (b[i] - dotProduct(a[i], x)) / d;
            }

            return x;
        }

        /// "a" is array, "b" is array.
        function dotProduct(a, b) {
            var sum = 0;

            for (var i = 0; i < a.length; i++) {
                sum += a[i] * b[i];
            }

            return sum;
        }

        /// "a" is Matrix, "b" is array.
        function triangulate(a, b) {
            var n = a.length;
            var v = vector(n);

            for (var i = 0; i < n - 1; i++) {
                var d = pivot(a, b, i);

                if (Math.abs(d) < 1.0e-500) {
                    vp.utils.error("error: diagnoal element is too small for triangulate");
                }

                for (var j = i + 1; j < n; j++) {
                    var dd = a[j][i] / d;
                    for (var k = i + 1; k < n; k++) {
                        a[j][k] -= dd * a[i][k];
                    }

                    b[j] -= dd * b[i];
                }
            }
        }

        /// "a" is Matrix, "b" is array, "q" in number.
        function pivot(a, b, q) {
            var n = b.length;
            var i = q;
            var d = 0;

            for (var j = q; j < n; j++) {
                var dd = Math.abs(a[j][q]);
                if (dd > d) {
                    d = dd;
                    i = j;
                }
            }

            if (i > q) {
                //---- swap rows "q" and "i" in a ----
                var temp = a[q];
                a[q] = a[i];
                a[i] = temp;

                //---- swap elements "q" and "i" in b ----
                temp = b[q];
                b[q] = b[i];
                b[i] = temp;
            }

            return a[q][q];
        }

        function spline(xx, yy) {
            //---- convert xx,yy into points ----
            var points = xx.map(function (data, index) {
                return { x: xx[index], y: yy[index] };
            });

            var tension = .5;
            var tensions = null;
            var segments = [];

            if (points.length == 2) {
                if (tensions) {
                    tension = tensions[0];
                }

                addSplineSegment(segments, points[0], points[0], points[1], points[1], tension, tension);
            } else {
                for (var i = 0; i < points.length; i++) {
                    var t1 = (tensions) ? tensions[i % tensions.length] : tension;
                    var t2 = (tensions) ? tensions[(i + 1) % tensions.length] : tension;

                    if (i == 0) {
                        addSplineSegment(segments, points[0], points[0], points[1], points[2], t1, t2);
                    } else if (i == points.length - 2) {
                        addSplineSegment(segments, points[i - 1], points[i], points[i + 1], points[i + 1], t1, t2);
                    } else if (i != points.length - 1) {
                        addSplineSegment(segments, points[i - 1], points[i], points[i + 1], points[i + 2], t1, t2);
                    }
                }
            }

            return segments;
        }
        curveFitting.spline = spline;

        function addSplineSegment(segments, pt0, pt1, pt2, pt3, t1, t2) {
            // adapted from Charles Petzold book:
            // See Petzold, "Programming Microsoft Windows with C#", pages 645-646 or
            //     Petzold, "Programming Microsoft Windows with Microsoft Visual Basic .NET", pages 638-639
            // for derivation of the following formulas:
            var SX1 = t1 * (pt2.x - pt0.x);
            var SY1 = t1 * (pt2.y - pt0.y);
            var SX2 = t2 * (pt3.x - pt1.x);
            var SY2 = t2 * (pt3.y - pt1.y);

            var AX = SX1 + SX2 + 2 * pt1.x - 2 * pt2.x;
            var AY = SY1 + SY2 + 2 * pt1.y - 2 * pt2.y;
            var BX = -2 * SX1 - SX2 - 3 * pt1.x + 3 * pt2.x;
            var BY = -2 * SY1 - SY2 - 3 * pt1.y + 3 * pt2.y;

            var CX = SX1;
            var CY = SY1;
            var DX = pt1.x;
            var DY = pt1.y;

            var tolerance = .25;
            var num = Math.floor((Math.abs(pt1.x - pt2.x) + Math.abs(pt1.y - pt2.y)) / tolerance);

            var points = [];
            segments.push(points);

            for (var i = 1; i < num; i++) {
                var t = i / (num - 1);

                var pt = {
                    x: AX * t * t * t + BX * t * t + CX * t + DX,
                    y: AY * t * t * t + BY * t * t + CY * t + DY
                };

                points.push(pt);
            }
        }
    })(vp.curveFitting || (vp.curveFitting = {}));
    var curveFitting = vp.curveFitting;
})(vp || (vp = {}));
//# sourceMappingURL=curveFitting.js.map

///----------------------------------------------------------------
/// (from paths\paths.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// paths.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (_paths) {
        function buildShape(shapeName, x, y, size, createCanvasPath) {
            var index = vp.paths.ShapeTypeNames.indexOf(shapeName);
            if (index == -1) {
                throw "Error: unknown shape name=" + shapeName;
            }

            var shapeType = index;

            var path = _paths.getPathDataForShape(shapeType, x, y, size, size, createCanvasPath);
            return path;
        }
        _paths.buildShape = buildShape;

        function buildLine(data, buildSinglePath, callback) {
            var paths = [];
            var lastX = null;
            var lastY = null;
            var path = "";

            for (var i = 0; i < data.length; i++) {
                var record = data[i];

                var info = { x: 0, y: 100 };
                callback(record, i, info);

                if (i == 0) {
                    lastX = info.x;
                    lastY = info.y;
                }

                if (buildSinglePath) {
                    if (i == 0) {
                        path = "M" + lastX + "," + lastY;
                    }

                    path += " L" + info.x + "," + info.y;
                } else {
                    path = "M" + lastX + "," + lastY;
                    path += " L" + info.x + "," + info.y;
                }

                lastX = info.x;
                lastY = info.y;

                if (!buildSinglePath) {
                    paths.push(path);
                }
            }

            if (buildSinglePath) {
                paths.push(path);
            }

            return paths;
        }
        _paths.buildLine = buildLine;

        function buildArea(data, callback) {
            var paths = [];
            var lastX = null;
            var lastYMin = null;
            var lastYMax = null;

            for (var i = 0; i < data.length; i++) {
                var record = data[i];

                var info = { x: 0, yMin: 0, yMax: 100 };
                callback(record, i, info);

                if (i == 0) {
                    lastX = info.x;
                    lastYMin = info.yMin;
                    lastYMax = info.yMax;
                }

                var path = "M" + lastX + "," + lastYMin;
                path += " L" + lastX + "," + lastYMax; // LINE to upper left
                path += " L" + info.x + "," + info.yMax; // LINE to upper right
                path += " L" + info.x + "," + info.yMin; // LINE to lower right
                path += " Z";

                lastX = info.x;
                lastYMin = info.yMin;
                lastYMax = info.yMax;

                paths.push(path);
            }

            return paths;
        }
        _paths.buildArea = buildArea;

        function buildSpline(data, callback) {
            var paths = [];
            var lastX = null;
            var lastY = null;
            var path = "";
            var xa = [];
            var ya = [];

            for (var i = 0; i < data.length; i++) {
                var record = data[i];

                var info = { x: 0, y: 100 };
                callback(record, i, info);

                xa.push(info.x);
                ya.push(info.y);
            }

            //---- calc the spline path for this rect ----
            var segments = vp.curveFitting.spline(xa, ya);

            //---- create dummy path for first pt ----
            var path = "M0,0 ";
            paths.push(path);

            for (var s = 0; s < segments.length; s++) {
                var segment = segments[s];
                var path = "M";

                for (var i = 0; i < segment.length; i++) {
                    var pt = segment[i];

                    if (i > 0) {
                        path += "L";
                    }

                    path += pt.x + "," + pt.y + " ";
                }

                paths.push(path);
            }

            return paths;
        }
        _paths.buildSpline = buildSpline;
    })(vp.paths || (vp.paths = {}));
    var paths = vp.paths;
})(vp || (vp = {}));
//# sourceMappingURL=paths.js.map

///----------------------------------------------------------------
/// (from paths\shapeData.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// shapeData.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - uses to create paths for our set of shapeTypes.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (paths) {
        function getPathDataForShape(shapeType, x, y, w, h, createCanvasPath) {
            var move = function (str, x, y) {
                str += " M " + x + " " + y;
                return str;
            };

            var line = function (str, x, y) {
                str += " L " + x + " " + y;
                return str;
            };

            var circle = function (str, cx, cy, r) {
                if (createCanvasPath) {
                    str += " X " + cx + "," + cy + "," + r + ",0," + 2 * Math.PI + ",0";
                } else {
                    str += " M " + (cx - r) + " " + cy + " a " + r + " " + r + " 0 1 0 " + (2 * r) + " 0" + " a " + r + " " + r + " 0 1 0 " + (-2 * r) + " 0";
                }

                return str;
            };

            var close = function (str) {
                str += " z";
                return str;
            };

            var d = "";

            //---- scale our 0..1 vars as per the desired bounds ----
            var x0 = x - w / 2;
            var x1 = x + w / 2;
            var x5 = x;

            var y0 = y - h / 2;
            var y1 = y + h / 2;
            var y5 = y;

            switch (shapeType) {
                case 5 /* triangleUp */: {
                    //---- triangle ----
                    d = move(d, x0, y1);
                    d = line(d, x5, y0);
                    d = line(d, x1, y1);
                    d = close(d);
                    break;
                }

                case 11 /* plus */: {
                    //---- plus sign ----
                    d = move(d, x0, y5);
                    d = line(d, x1, y5);
                    d = move(d, x5, y1);
                    d = line(d, x5, y0);
                    break;
                }

                case 10 /* x */: {
                    //---- big X ----
                    d = move(d, x0, y0);
                    d = line(d, x1, y1);
                    d = move(d, x1, y0);
                    d = line(d, x0, y1);
                    break;
                }

                case 1 /* diamond */: {
                    //---- diamond ----
                    d = move(d, x5, y0);
                    d = line(d, x0, y5);
                    d = line(d, x5, y1);
                    d = line(d, x1, y5);
                    d = line(d, x5, y0);
                    d = close(d);
                    break;
                }

                case 6 /* triangleDown */: {
                    //---- upside down triangle ----
                    d = move(d, x0, y0);
                    d = line(d, x5, y1);
                    d = line(d, x1, y0);
                    d = close(d);
                    break;
                }

                case 7 /* triangleLeft */: {
                    //---- left pointing triangle ----
                    d = move(d, x1, y0);
                    d = line(d, x1, y1);
                    d = line(d, x0, y5);
                    d = close(d);
                    break;
                }

                case 8 /* triangleRight */: {
                    //---- right pointing triangle ----
                    d = move(d, x0, y0);
                    d = line(d, x0, y1);
                    d = line(d, x1, y5);
                    d = close(d);
                    break;
                }

                case 3 /* pentagram */: {
                    //---- for pentagram ----
                    var y3 = y0 + .36 * h;
                    var y6 = y0 + .62 * h;
                    var y7 = y0 + .76 * h;

                    var x2 = x0 + .19 * w;
                    var x3 = x0 + .31 * w;
                    var x4 = x0 + .37 * w;
                    var x6 = x0 + .63 * w;
                    var x7 = x0 + .69 * w;
                    var x8 = x0 + .85 * w;

                    //---- 5 point star ----
                    d = move(d, x5, y0);
                    d = line(d, x6, y3);
                    d = line(d, x1, y3);
                    d = line(d, x7, y6);
                    d = line(d, x8, y1);
                    d = line(d, x5, y7);
                    d = line(d, x2, y1);
                    d = line(d, x3, y6);
                    d = line(d, x0, y3);
                    d = line(d, x4, y3);
                    d = close(d);
                    break;
                }

                case 2 /* hexagram */: {
                    //---- for hexagram ----
                    var y2 = y0 + .25 * h;
                    var y7 = y0 + .75 * h;

                    var x2 = x0 + .21 * w;
                    var x3 = x0 + .36 * w;
                    var x6 = x0 + .64 * w;
                    var x8 = x0 + .80 * w;

                    //---- 5 point star ----
                    d = move(d, x5, y0);
                    d = line(d, x6, y2);
                    d = line(d, x1, y2);
                    d = line(d, x8, y5);
                    d = line(d, x1, y7);
                    d = line(d, x6, y7);
                    d = line(d, x5, y1);
                    d = line(d, x3, y7);
                    d = line(d, x0, y7);
                    d = line(d, x2, y5);
                    d = line(d, x0, y2);
                    d = line(d, x3, y2);
                    d = close(d);
                    break;
                }

                case 18 /* xInSquare */: {
                    //---- X in square ----
                    //---- X-part ----
                    d = move(d, x0, y0);
                    d = line(d, x1, y1);
                    d = move(d, x1, y0);
                    d = line(d, x0, y1);

                    //---- square-part ----
                    d = move(d, x0, y0);
                    d = line(d, x0, y1);
                    d = line(d, x1, y1);
                    d = line(d, x1, y0);
                    d = close(d);
                    break;
                }

                case 9 /* asterisk */: {
                    //---- asterisk ----
                    //---- make diagonals a bit smaller ----
                    var diagFactor = .14;

                    var x2 = x0 + diagFactor * w;
                    var x8 = x1 - diagFactor * w;

                    var y2 = y0 + diagFactor * h;
                    var y8 = y1 - diagFactor * h;

                    d = move(d, x5, y0);
                    d = line(d, x5, y1);

                    d = move(d, x8, y2);
                    d = line(d, x2, y8);

                    d = move(d, x1, y5);
                    d = line(d, x0, y5);

                    d = move(d, x8, y8);
                    d = line(d, x2, y2);
                    break;
                }

                case 12 /* plusInDiamond */: {
                    //---- diamond with a plus inside ----
                    //---- diamond-part ----
                    d = move(d, x5, y0);
                    d = line(d, x0, y5);
                    d = line(d, x5, y1);
                    d = line(d, x1, y5);
                    d = line(d, x5, y0);
                    d = close(d);

                    //---- plus-part ----
                    d = move(d, x0, y5);
                    d = line(d, x1, y5);
                    d = move(d, x5, y1);
                    d = line(d, x5, y0);
                    break;
                }

                case 13 /* plusInCircle */: {
                    //---- plus in a circle ----
                    //---- circle-part ----
                    d = circle(d, x5, y5, w / 2);

                    //---- plus-part ----
                    d = move(d, x0, y5);
                    d = line(d, x1, y5);
                    d = move(d, x5, y1);
                    d = line(d, x5, y0);
                    break;
                }

                case 15 /* triangleUpDown */: {
                    //---- 2 triangles ----
                    //---- triangle-part ----
                    d = move(d, x0, y1);
                    d = line(d, x5, y0);
                    d = line(d, x1, y1);
                    d = close(d);

                    //---- down-triangle-part ----
                    d = move(d, x0, y0);
                    d = line(d, x5, y1);
                    d = line(d, x1, y0);
                    d = close(d);
                    break;
                }

                case 4 /* square */: {
                    //---- square with plus ----
                    //---- square-part ----
                    d = move(d, x0, y0);
                    d = line(d, x0, y1);
                    d = line(d, x1, y1);
                    d = line(d, x1, y0);
                    d = close(d);
                    break;
                }

                case 14 /* plusInSquare */: {
                    //---- square with plus ----
                    //---- square-part ----
                    d = move(d, x0, y0);
                    d = line(d, x0, y1);
                    d = line(d, x1, y1);
                    d = line(d, x1, y0);
                    d = close(d);

                    //---- plus-part ----
                    d = move(d, x0, y5);
                    d = line(d, x1, y5);
                    d = move(d, x5, y1);
                    d = line(d, x5, y0);
                    break;
                }

                case 0 /* circle */: {
                    //---- circle-part ----
                    d = circle(d, x5, y5, w / 2);
                    break;
                }

                case 17 /* xInCircle */: {
                    //---- X in a circle ----
                    //---- circle-part ----
                    d = circle(d, x5, y5, w / 2);

                    //---- X-part ----
                    d = move(d, x0, y0);
                    d = line(d, x1, y1);
                    d = move(d, x1, y0);
                    d = line(d, x0, y1);
                    break;
                }

                case 16 /* triangleInSquare */: {
                    //---- triangle in a square ----
                    //---- triangle-part ----
                    //---- triangle-part ----
                    d = move(d, x0, y1);
                    d = line(d, x5, y0);
                    d = line(d, x1, y1);
                    d = close(d);

                    //---- square-part ----
                    d = move(d, x0, y0);
                    d = line(d, x0, y1);
                    d = line(d, x1, y1);
                    d = line(d, x1, y0);
                    d = close(d);
                    break;
                }
            }

            return d;
        }
        paths.getPathDataForShape = getPathDataForShape;

        (function (ShapeType) {
            //---- simple shapes that can be filled ----
            ShapeType[ShapeType["circle"] = 0] = "circle";
            ShapeType[ShapeType["diamond"] = 1] = "diamond";
            ShapeType[ShapeType["hexagram"] = 2] = "hexagram";
            ShapeType[ShapeType["pentagram"] = 3] = "pentagram";
            ShapeType[ShapeType["square"] = 4] = "square";
            ShapeType[ShapeType["triangleUp"] = 5] = "triangleUp";
            ShapeType[ShapeType["triangleDown"] = 6] = "triangleDown";
            ShapeType[ShapeType["triangleLeft"] = 7] = "triangleLeft";
            ShapeType[ShapeType["triangleRight"] = 8] = "triangleRight";

            ShapeType[ShapeType["asterisk"] = 9] = "asterisk";
            ShapeType[ShapeType["x"] = 10] = "x";
            ShapeType[ShapeType["plus"] = 11] = "plus";
            ShapeType[ShapeType["plusInDiamond"] = 12] = "plusInDiamond";
            ShapeType[ShapeType["plusInCircle"] = 13] = "plusInCircle";
            ShapeType[ShapeType["plusInSquare"] = 14] = "plusInSquare";
            ShapeType[ShapeType["triangleUpDown"] = 15] = "triangleUpDown";
            ShapeType[ShapeType["triangleInSquare"] = 16] = "triangleInSquare";
            ShapeType[ShapeType["xInCircle"] = 17] = "xInCircle";
            ShapeType[ShapeType["xInSquare"] = 18] = "xInSquare";
        })(paths.ShapeType || (paths.ShapeType = {}));
        var ShapeType = paths.ShapeType;

        paths.ShapeTypeNames = [
            "circle",
            "diamond",
            "hexagram",
            "pentagram",
            "square",
            "triangleUp",
            "triangleDown",
            "triangleLeft",
            "triangleRight",
            "asterisk",
            "x",
            "plus",
            "plusInDiamond",
            "plusInCircle",
            "plusInSquare",
            "triangleUpDown",
            "triangleInSquare",
            "xInCircle",
            "xInSquare"
        ];
    })(vp.paths || (vp.paths = {}));
    var paths = vp.paths;
})(vp || (vp = {}));
//# sourceMappingURL=shapeData.js.map
///-----------------------------------------------------------------------------------------------------------------
/// plotBox.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - a conceptual 3D box that holds the 2D/3D axes for a chart and provides pan/zoom/rotate functions.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
//# sourceMappingURL=axisOptions.js.map

///----------------------------------------------------------------
/// (from plotBox\plotBox.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// plotBox.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - a conceptual 3D box that holds the 2D/3D axes for a chart and provides pan/zoom/rotate functions.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (plotBox) {
        var plotBoxClass = (function () {
            function plotBoxClass() {
                //---- private state ----
                this._transform3d = null;
                this._canvas = null;
                this._ctx = null;
                this._width = 0;
                this._height = 0;
                var canvas = document.createElement("canvas");
                this._canvas = canvas;

                var ctx = canvas.getContext("2d");
                this._ctx = ctx;

                var transform3d = plotBox.createTransform3d();
                this._transform3d = transform3d;
            }
            plotBoxClass.prototype.width = function (value) {
                if (arguments.length == 0) {
                    return this._width;
                }

                this._width = value;
                this._canvas.setAttribute("width", value + "");

                return this;
            };

            plotBoxClass.prototype.height = function (value) {
                if (arguments.length == 0) {
                    return this._height;
                }

                this._height = value;
                this._canvas.setAttribute("height", value + "");

                return this;
            };

            plotBoxClass.prototype.draw = function (xOptions, yOptions, zOptions) {
                var rect = vp.geom.createRect(0, 0, 100, 100);

                return rect;
            };
            return plotBoxClass;
        })();
        plotBox.plotBoxClass = plotBoxClass;

        function createPlotBox() {
            return new plotBoxClass();
        }
        plotBox.createPlotBox = createPlotBox;
    })(vp.plotBox || (vp.plotBox = {}));
    var plotBox = vp.plotBox;
})(vp || (vp = {}));
//# sourceMappingURL=plotBox.js.map

///----------------------------------------------------------------
/// (from plotBox\transform3d.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// transform3d.js.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlotCore library - class for translating 3D point3s to 2D (3D scaling using azimuth and elevation).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (plotBox) {
        /** This class uses azimuth and elevation to project point3s from 3D space to 2D space. */
        var transform3dClass = (function () {
            /** builds a 3D matrix that can be used to translate point3s from 3D to 2D.  The projection
            is specified by an azimuth and an elevation (both in degrees of rotation).  The
            standard MATLAB setting for a 3D view is azimuth=-37.5, elevation=30.  For a direct overhead (2D)
            view, use azimuth=0, elevation=90. */
            function transform3dClass(screenWidth, screenHeight, azimuth, elevation, xMin, xMax, yMin, yMax, zMin, zMax, isScreenOutput) {
                //---- private adjustments ----
                this._xFact = 2;
                this._yFact = 2;
                this._xShift = 1;
                this._yShift = 1;
                //---- getter/setter fields ----
                this._azimuth = 0;
                this._elevation = 0;
                this._screenWidth = 0;
                this._screenHeight = 0;
                //---- public properties ----
                this._xOffset = 0;
                this._yOffset = 0;
                this._xScale = 0;
                this._yScale = 0;
                this._xMin = 0;
                this._xMax = 0;
                this._yMin = 0;
                this._yMax = 0;
                this._zMin = 0;
                this._zMax = 0;
                //---- internal state fields ----
                this._mat = null;
                this._mainMat = null;
                this._matScreen = null;
                this._origWidth = 0;
                this._xRange = 0;
                this._yRange = 0;
                this._zRange = 0;
                this._isScreenOutput = true;
                this._azimuth = azimuth;
                this._elevation = elevation;

                this._xMin = xMin;
                this._xMax = xMax;
                this._yMin = yMin;
                this._yMax = yMax;
                this._zMin = zMin;
                this._zMax = zMax;

                this._screenWidth = screenWidth;
                this._screenHeight = screenHeight;

                this._origWidth = screenWidth;
                this._isScreenOutput = isScreenOutput;

                //---- constants that effect how 3D image is contained in screen frame ----
                this.resetCamera();
            }
            transform3dClass.prototype.getZoom = function () {
                var zoom = this._xScale / this._xFact;
                return zoom;
            };

            transform3dClass.prototype.getX = function () {
                return this._xOffset;
            };

            transform3dClass.prototype.getY = function () {
                return this._yOffset;
            };

            transform3dClass.prototype.getElevation = function () {
                return this._elevation;
            };

            transform3dClass.prototype.getRotation = function () {
                return this._azimuth;
            };

            transform3dClass.prototype.setZoom = function (value) {
                var zoom = value * this._xFact;

                this._xScale = zoom;
                this._yScale = zoom;
            };

            transform3dClass.prototype.setX = function (value) {
                this._xOffset = value;
            };

            transform3dClass.prototype.setY = function (value) {
                this._yOffset = value;
            };

            transform3dClass.prototype.setElevation = function (value) {
                this._elevation = value;
            };

            transform3dClass.prototype.setRotation = function (value) {
                this._azimuth = value;
            };

            transform3dClass.prototype.resetCamera = function () {
                this._xOffset = 0;
                this._yOffset = 0;

                this._xScale = this._xFact;
                this._yScale = this._yFact;

                this.rebuild();
            };

            transform3dClass.prototype.getMatrix = function () {
                return this._mat;
            };

            transform3dClass.prototype.getScreenMatrix = function () {
                return this._matScreen;
            };

            transform3dClass.prototype.rebuild = function () {
                var elevation = this._elevation;
                var azimuth = this._azimuth;

                //elevation = vp.lamp(elevation, -90, 90);
                //azimuth = vp.lamp(azimuth, -180, 180);
                //---- convert to radians ----
                elevation = elevation * Math.PI / 180;
                azimuth = azimuth * Math.PI / 180;

                this._xRange = this.safeRange(this._xMax, this._xMin);
                this._yRange = this.safeRange(this._yMax, this._yMin);
                this._zRange = this.safeRange(this._zMax, this._zMin);

                //---- pre-compute 4 values ----
                var se = Math.sin(elevation);
                var ce = Math.cos(elevation);
                var sa = Math.sin(azimuth);
                var ca = Math.cos(azimuth);

                //---- NORMALIZE point3s in 3D space (to [-.5..+5]) ----
                //var x = (x - this._xMin) / this._xRange - .5;
                //var y = (y - this._yMin) / this._yRange - .5;
                //var z = (z - this._zMin) / this._zRange - .5;
                var preMat1 = vp.geom.matrix4.createTranslation(-this._xMin, -this._yMin, -this._zMin);
                var preMat2 = vp.geom.matrix4.createScale(1 / this._xRange, 1 / this._yRange, 1 / this._zRange);
                var preMat3 = vp.geom.matrix4.createTranslation(-.5, -.5, -.5);

                //---- MAP from 3D to 2D (to [-1..+1]) ----
                var mainMat = vp.geom.matrix4.fromFloats(ca, -se * sa, ce * sa, 0, sa, se * ca, -ce * ca, 0, 0, ce, se, 0, 0, 0, 0, 1);

                //---- MAP from ([-1..+1] to screen pixels ----
                //v.x = (this._xShift + this._xScale * v.x) * (this._screenWidth / 2) + this._xOffset;
                //v.y = (this._yShift - this._yScale * v.y) * (this._screenHeight / 2) + this._yOffset;
                var postMat1 = vp.geom.matrix4.createScale(this._xScale, -this._yScale, 1);
                var postMat2 = vp.geom.matrix4.createTranslation(this._xShift, this._yShift, 0);
                var postMat3 = vp.geom.matrix4.createScale(this._screenWidth / 2, this._screenHeight / 2, 1);
                var postMat4 = vp.geom.matrix4.createTranslation(this._xOffset, this._yOffset, 0);

                //---- now, multiple all matricies into a single transform matrix ----
                var mat = preMat1;
                mat = vp.geom.matrix4.multiply(mat, preMat2);
                mat = vp.geom.matrix4.multiply(mat, preMat3);
                mat = vp.geom.matrix4.multiply(mat, mainMat);
                mat = vp.geom.matrix4.multiply(mat, postMat1);
                mat = vp.geom.matrix4.multiply(mat, postMat2);
                mat = vp.geom.matrix4.multiply(mat, postMat3);
                mat = vp.geom.matrix4.multiply(mat, postMat4);

                this._matScreen = mat;

                if (!this._isScreenOutput) {
                    //---- transform from screen pixels back to -1, +1 range (for input to WebGL) ----
                    var postMat5 = vp.geom.matrix4.createScale(2 * 1 / this._screenWidth, 2 * 1 / this._screenHeight, 1);
                    var postMat6 = vp.geom.matrix4.createTranslation(-1, -1, 0);

                    mat = vp.geom.matrix4.multiply(mat, postMat5);
                    mat = vp.geom.matrix4.multiply(mat, postMat6);
                }

                this._mat = mat;
                this._mainMat = mainMat;

                return this;
            };

            transform3dClass.prototype.transformPointEx = function (x, y, z) {
                //---- NORMALIZE point3s in 3D space (to [-.5..+5]) ----
                var nx = (x - this._xMin) / this._xRange - .5;
                var ny = (y - this._yMin) / this._yRange - .5;
                var nz = (z - this._zMin) / this._zRange - .5;

                var v = vp.geom.matrix4.transformPoint(this._mainMat, new vp.geom.vector3(nx, ny, nz));

                //---- MAP from ([-1..+1] to screen pixels ----
                var xx = (this._xShift + this._xScale * v.x) * (this._screenWidth / 2) + this._xOffset;
                var yy = (this._yShift - this._yScale * v.y) * (this._screenHeight / 2) + this._yOffset;

                if (!this._isScreenOutput) {
                    //---- map back to -1, +1 ----
                    xx = (2 * xx / this._screenWidth) - 1;
                    yy = (2 * yy / this._screenHeight) - 1;
                }

                var vv = new vp.geom.vector3(xx, yy, v.z);

                return vv;
            };

            transform3dClass.prototype.adjustZoom = function (scaleFactor, x, y) {
                //---- concept: we want to set the xScale and yScale numbers to a new value, and then adjust the ----
                //---- xOffset and yOffset values such that ptOver is over the same point3 in data space.   ----
                //---- FOR REFERENCE: formula for mapping from ([-1..+1] to screen pixels ----
                //v.x = (this._xShift + this._xScale * v.x) * (this._screenWidth / 2) + this._xOffset;
                //v.y = (this._yShift - this._yScale * v.y) * (this._screenHeight / 2) + this._yOffset;
                if (!this._isScreenOutput) {
                    //---- from WebGL output to our system, the Y must be flipped ----
                    y = this._screenHeight - y;
                }

                //---- MAP ptOver from SCREEN to NORMALIZED 2D space ----
                var xNorm = (x - this._xOffset) / (this._screenWidth / 2);

                //var xNorm = (x - this._xOffset) / (this._screenWidth / 2);
                xNorm = (xNorm - this._xShift) / this._xScale;

                var yNorm = (y - this._yOffset) / (this._screenHeight / 2);

                //var yNorm = (y - this._yOffset) / (this._screenHeight / 2);
                //var yNorm = y / ((this._screenHeight / 2) - this._yOffset);
                yNorm = (yNorm - this._yShift) / (-this._yScale);

                //---- now, apply the new scaling factors ----
                if (scaleFactor < 0) {
                    //---- treat as absolute sclae ----
                    var zoom = -scaleFactor * this._xFact;

                    this._xScale = zoom;
                    this._yScale = zoom;
                } else {
                    this._xScale *= scaleFactor;
                    this._yScale *= scaleFactor;
                }

                //---- now, MAP (xNorm, yNorm) back to SCREEN space ----
                var xScreen = (this._xShift + this._xScale * xNorm) * (this._screenWidth / 2) + this._xOffset;
                var yScreen = (this._yShift - this._yScale * yNorm) * (this._screenHeight / 2) + this._yOffset;

                //---- now, compute difference between ptOver and (xScreen, yScreen) and add to xOffset, yOffset ----
                var xDiff = xScreen - x;
                var yDiff = yScreen - y;

                this._xOffset -= xDiff;
                this._yOffset -= yDiff;
                //---- test ----
                //this.rebuild();
            };

            transform3dClass.prototype.safeRange = function (max, min) {
                var range = max - min;
                if (range == 0) {
                    range = 1;
                }

                return range;
            };

            transform3dClass.prototype.testTheMatrix = function () {
                //---- test out mat ----
                var pt = this.transformPoint(0, 0, 0);
                vp.utils.assert(vp.utils.floatEq(pt.x, this._screenWidth / 2));
                vp.utils.assert(vp.utils.floatEq(pt.y, this._screenHeight / 2));
            };

            transform3dClass.prototype.xMin = function (value) {
                if (arguments.length == 0) {
                    return this._xMin;
                }

                this._xMin = value;

                //this.rebuild();
                return this;
            };

            transform3dClass.prototype.xMax = function (value) {
                if (arguments.length == 0) {
                    return this._xMax;
                }

                this._xMax = value;

                //this.rebuild();
                return this;
            };

            transform3dClass.prototype.yMin = function (value) {
                if (arguments.length == 0) {
                    return this._yMin;
                }

                this._yMin = value;

                //this.rebuild();
                return this;
            };

            transform3dClass.prototype.yMax = function (value) {
                if (arguments.length == 0) {
                    return this._yMax;
                }

                this._yMax = value;

                //this.rebuild();
                return this;
            };

            transform3dClass.prototype.screenWidth = function (value) {
                if (arguments.length == 0) {
                    return this._screenWidth;
                }

                this._screenWidth = value;
                this._origWidth = value;

                //this.rebuild();
                return this;
            };

            transform3dClass.prototype.screenHeight = function (value) {
                if (arguments.length == 0) {
                    return this._screenHeight;
                }

                this._screenHeight = value;

                //this.rebuild();
                return this;
            };

            //azimuth(): number;
            //azimuth(value: number): transform3dClass;
            //azimuth(value?: number): any
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._azimuth;
            //    }
            //    this._azimuth = value;
            //    //this.rebuild();
            //    return this;
            //}
            //elevation(): number;
            //elevation(value: number): transform3dClass;
            //elevation(value?: number): any
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._elevation;
            //    }
            //    this._elevation = value;
            //    //this.rebuild();
            //    return this;
            //}
            /** transform a point3 from 3D to 2D */
            transform3dClass.prototype.transformPoint = function (x, y, z) {
                var v = vp.geom.matrix4.transformPoint(this._mat, new vp.geom.vector3(x, y, z));
                return v;
            };
            return transform3dClass;
        })();
        plotBox.transform3dClass = transform3dClass;

        function createTransform3d(screenWidth, screenHeight, azimuth, elevation, xMin, xMax, yMin, yMax, zMin, zMax, isScreenOutput) {
            return new transform3dClass(screenWidth, screenHeight, azimuth, elevation, xMin, xMax, yMin, yMax, zMin, zMax, isScreenOutput);
        }
        plotBox.createTransform3d = createTransform3d;
    })(vp.plotBox || (vp.plotBox = {}));
    var plotBox = vp.plotBox;
})(vp || (vp = {}));
//# sourceMappingURL=transform3d.js.map
///-----------------------------------------------------------------------------------------------------------------
/// baseScale.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - base class for scales.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        

        var baseScaleClass = (function () {
            function baseScaleClass() {
                this.ctr = "vp.scales.baseScaleClass";
                this.scaleName = "baseScale";
                this._expandSpace = 0;
                this._isRangeClipping = false;
                this._domainMin = 0;
                this._domainMax = 1;
                this._isPaletteDiscrete = undefined;
                this._mappingCallback = undefined;
                this._scaleType = 0 /* linear */;
                //---- other fields ----
                this._categoryKeys = {};
                this._nextKeyIndex = 0;
                this._domainDelta = 1;
                this._userSetCategoryKeys = false;
                /** this gets replaced by one of the 3 scale routines internally. */
                this.scale = function (value, seriesIndex) {
                    return 0;
                };
                this.onMapTypeChanged();
            }
            baseScaleClass.prototype.expandSpace = function (value) {
                if (arguments.length === 0) {
                    return this._expandSpace;
                }

                this._expandSpace = value;
                this.onRangeChanged();
                return this;
            };

            baseScaleClass.prototype.mappingCallback = function (value) {
                if (arguments.length === 0) {
                    return this._mappingCallback;
                }

                this._mappingCallback = value;
                return this;
            };

            baseScaleClass.prototype.isPaletteDiscrete = function (value) {
                if (arguments.length === 0) {
                    return this._isPaletteDiscrete;
                }

                this._isPaletteDiscrete = value;
                return this;
            };

            baseScaleClass.prototype.isRangeClipping = function (value) {
                if (arguments.length == 0) {
                    return this._isRangeClipping;
                }

                this._isRangeClipping = value;
                return this;
            };

            baseScaleClass.prototype.scaleType = function (value) {
                if (arguments.length == 0) {
                    return this._scaleType;
                }

                if (value != this._scaleType) {
                    this._scaleType = value;
                    this.onMapTypeChanged();
                }

                return this;
            };

            baseScaleClass.prototype.palette = function (value) {
                if (arguments.length == 0) {
                    return this._palette;
                }

                this._palette = (arguments.length == 1) ? value : vp.utils.argumentsAsArray(arguments);
                this.onPaletteChanged();
                return this;
            };

            baseScaleClass.prototype.rangeMin = function (value) {
                if (!this._palette) {
                    //---- JIT, convert to 2 dimensional array ----
                    this._palette = [0, 100];
                }

                if (arguments.length == 0) {
                    return this._palette[0];
                }

                this._palette[0] = value;
                this.onRangeChanged();

                return this;
            };

            baseScaleClass.prototype.rangeMax = function (value) {
                if (!this._palette) {
                    //---- JIT, convert to 2 dimensional array ----
                    this._palette = [0, 100];
                }

                if (arguments.length == 0) {
                    return this._palette[1];
                }

                this._palette[1] = value;
                this.onRangeChanged();

                return this;
            };

            baseScaleClass.prototype.onRangeChanged = function () {
            };

            baseScaleClass.prototype.onPaletteChanged = function () {
            };

            baseScaleClass.prototype.stops = function (value) {
                if (arguments.length == 0) {
                    return this._stops;
                }

                this._stops = (arguments.length == 1) ? value : vp.utils.argumentsAsArray(arguments);
                return this;
            };

            baseScaleClass.prototype.domainMin = function (value) {
                if (arguments.length == 0) {
                    return this._domainMin;
                }

                this._domainMin = value;
                this.onDomainChanged();
                return this;
            };

            baseScaleClass.prototype.domainMax = function (value) {
                if (arguments.length == 0) {
                    return this._domainMax;
                }

                this._domainMax = value;
                this.onDomainChanged();
                return this;
            };

            baseScaleClass.prototype.onDomainChanged = function () {
                this._domainDelta = this._domainMax - this._domainMin;
                if (this._domainDelta == 0) {
                    this._domainDelta = 1;
                }
            };

            baseScaleClass.prototype.resetKeys = function () {
                if (!this._userSetCategoryKeys) {
                    this._categoryKeys = {}; // reset the keys seen
                    this._nextKeyIndex = 0;
                }
            };

            baseScaleClass.prototype.categoryKeys = function (value) {
                if (arguments.length == 0) {
                    return this._categoryKeys;
                }

                this.setCategoryKeys(value);
                return this;
            };

            baseScaleClass.prototype.setCategoryKeys = function (keys) {
                this._categoryKeys = {};

                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];

                    this._categoryKeys[key] = i;
                }

                this._nextKeyIndex = keys.length;
                ;
                this._userSetCategoryKeys = true;
            };

            baseScaleClass.prototype.onMapTypeChanged = function () {
                var scaleType = this._scaleType;

                if (scaleType == 3 /* category */) {
                    this.scale = this.categoryScale;
                } else if (scaleType == 4 /* categoryKey */) {
                    this.scale = this.categoryKeyScale;
                } else if (scaleType == 0 /* linear */) {
                    this.scale = this.lerpScale;
                }

                this.resetKeys();
            };

            baseScaleClass.prototype.categoryScale = function (recordIndex) {
                var result = undefined;
                var palette = this._palette;

                if (palette && palette.length > 0) {
                    /// TODO: use _isPaletteDiscrete to switch between interpolation / enumeration
                    /// of the palette values.
                    //---- use "index" to get a value from palette ----
                    if (this._isRangeClipping) {
                        recordIndex = this.clip(recordIndex, 0, palette.length - 1);
                    } else {
                        recordIndex = recordIndex % palette.length;
                    }

                    result = palette[recordIndex];
                }

                return result;
            };

            baseScaleClass.prototype.getIndexOfKey = function (value) {
                var index = this._categoryKeys[value];

                if (index === undefined) {
                    index = this._nextKeyIndex++;
                    this._categoryKeys[value] = index;
                }

                return index;
            };

            baseScaleClass.prototype.categoryKeyScale = function (value) {
                var index = this.getIndexOfKey(value);

                //---- pass all original arguments (subclass may have extra params) ----
                arguments[0] = index; // update "value" param
                var result = this.categoryScale.apply(this, arguments);

                return result;
            };

            baseScaleClass.prototype.clip = function (value, min, max) {
                //---- it turns out we DON'T WANT clipping for our plots ----
                //---- so we disable this by default ----
                if (value < min) {
                    value = min;
                } else if (value > max) {
                    value = max;
                }

                return value;
            };

            baseScaleClass.prototype.calcPercent = function (value) {
                var t = (value - this._domainMin) / this._domainDelta;

                if (this._isRangeClipping) {
                    t = this.clip(t, 0, 1);
                }

                //if (this._isWrappingEnabled)
                //{
                //    if (t > 1)
                //    {
                //        t = t - Math.floor(t);      // get fractional part of value
                //    }
                //}
                return t;
            };

            baseScaleClass.prototype.lerpPalette = function (t, palette) {
                var result = null;
                var pcount = palette.length;
                var lastIndex = pcount - 1;

                //---- allow for t outside of bounds [0..1], but don't apply clipping ----
                if (t < 0) {
                    //---- always use first 2 palettes for this out of bounds case ----
                    result = this.interpolateValues(palette[0], palette[1], t);
                } else if (t > 1) {
                    //---- always use last 2 palettes for this out of bounds case ----
                    result = this.interpolateValues(palette[pcount - 2], palette[pcount - 1], t);
                } else if (t == 0) {
                    //---- take care of easy cases first ----
                    result = palette[0];
                } else if (t == 1) {
                    //---- take care of easy cases first ----
                    result = palette[lastIndex];
                } else {
                    var stops = this._stops;
                    if ((stops) && (stops.length != pcount)) {
                        stops = null;
                    }

                    var index = -1;

                    if (!stops) {
                        //---- common case, & faster path ----
                        var dindex = lastIndex * t;
                        var index = Math.min(lastIndex - 1, Math.floor(dindex));

                        //---- re-normalize t ----
                        t = dindex - index;
                    } else {
                        //---- walk stops[] to find pair of values "t" is between ----
                        var index = -1;

                        for (var i = 0; i < pcount; i++) {
                            if (stops[i] >= t) {
                                index = i;
                                break;
                            }
                        }

                        if (index == -1) {
                            //---- never found - use last entry ----
                            result = palette[lastIndex];
                        } else if (index == 0) {
                            //---- use first entry ----
                            result = palette[0];
                        } else {
                            index--; // start with our previous entry
                            var interval = stops[index + 1] - stops[index];

                            //---- re-normalize "t" ----
                            t = (interval == 0) ? 0 : ((t - stops[index]) / interval);
                        }
                    }

                    ////---- now we can apply the ease ----
                    //if (easeFunc != null)
                    //{
                    //    t = easeFunc(t);
                    //}
                    if (t == 0) {
                        result = palette[index];
                    } else if (t == 1) {
                        result = palette[index + 1];
                    } else {
                        result = this.interpolateValues(palette[index], palette[index + 1], t);
                    }
                }

                return result;
            };

            baseScaleClass.prototype.lerpScale = function (value, rangePalette) {
                var result = undefined;
                var palette = (rangePalette) ? rangePalette : this._palette;
                if ((this._expandSpace) && (palette && palette.length == 2)) {
                    var p0 = palette[0];
                    var p1 = palette[1];

                    if (p0 > p1) {
                        //---- flipped scale ----
                        p0 = p0 - this._expandSpace;
                        p1 = p1 + this._expandSpace;
                    } else {
                        p0 = p0 + this._expandSpace;
                        p1 = p1 - this._expandSpace;
                    }

                    //---- create new copy of palette (don't touch the class property ----
                    palette = [p0, p1];
                }

                value = +value;

                if (this._mappingCallback) {
                    var t = this.calcPercent(value);
                    result = this._mappingCallback(value, t);
                } else {
                    if ((palette && palette.length > 0) && (!isNaN(value))) {
                        if (palette.length == 1) {
                            //---- take care of odd case first ----
                            result = palette[0];
                        } else {
                            ///
                            /// Note: "t" wiil be [0..1] and will be used to find pair of entries in palette[])
                            ///
                            var t = this.calcPercent(value);
                            result = this.lerpPalette(t, palette);
                        }
                    }
                }

                return result;
            };

            baseScaleClass.prototype.lerp = function (num, num2, t) {
                var result = num + t * (num2 - num);
                return result;
            };

            baseScaleClass.prototype.interpolateValues = function (min, max, t) {
                var result = this.lerp(min, max, t);
                return result;
            };
            return baseScaleClass;
        })();
        scales.baseScaleClass = baseScaleClass;

        var baseScale = (function (_super) {
            __extends(baseScale, _super);
            function baseScale() {
                _super.apply(this, arguments);
            }
            return baseScale;
        })(baseScaleClass);
        scales.baseScale = baseScale;

        //---- NEW VuePlot Wide Policy - make the first letter of enum name CAPITAL, to avoid accidental ambiguous reference to property of same name ----
        //---- that is usually not caught by TypeScript. ----
        /** type of mapping used in scales to extract values from a range palette. */
        (function (ScaleType) {
            /** use normalized input value to interplate between palette entries. */
            ScaleType[ScaleType["linear"] = 0] = "linear";

            /** take log of input values before doing linear scale to range. */
            ScaleType[ScaleType["log"] = 1] = "log";

            /** take exp of input values before doing linear scale to range. */
            ScaleType[ScaleType["exp"] = 2] = "exp";

            /** use itemIndex as index into palette. */
            ScaleType[ScaleType["category"] = 3] = "category";

            /** use a map to track unique values and use key index as index into palette. */
            ScaleType[ScaleType["categoryKey"] = 4] = "categoryKey";

            /** simliar to linear, but with support for nice date breaks and formatting on axis/legend. */
            ScaleType[ScaleType["dateTime"] = 5] = "dateTime";
        })(scales.ScaleType || (scales.ScaleType = {}));
        var ScaleType = scales.ScaleType;

        
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=baseScale.js.map

///----------------------------------------------------------------
/// (from scales\categoryScale.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// categoryScale.ts.  Copyright (c) 2014 Microsoft Corporation.
///     Part of the vuePlotCore library - category scale.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var categoryScaleClass = (function (_super) {
            __extends(categoryScaleClass, _super);
            function categoryScaleClass() {
                _super.call(this);
                this._rangeBounds = null;
                this._stepSize = 1;

                this.ctr = "vp.scales.categoryScaleClass";
                this.scaleName = "category";

                this.scaleType(4 /* categoryKey */);
            }
            categoryScaleClass.prototype.stepSize = function () {
                return this._stepSize;
            };

            categoryScaleClass.prototype.domain = function () {
                var args = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    args[_i] = arguments[_i + 0];
                }
                if (arguments.length == 0) {
                    return this._categoryKeys;
                }

                if (args.length == 1) {
                    this.setCategoryKeys(args[0]);
                } else {
                    this.setCategoryKeys(args);
                }

                if (this._rangeBounds) {
                    this.computeRangeFromBounds();
                }

                return this;
            };

            categoryScaleClass.prototype.range = function () {
                var args = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    args[_i] = arguments[_i + 0];
                }
                if (arguments.length == 0) {
                    return this._palette;
                }

                if (args.length == 1) {
                    //---- values passed as single array ----
                    this.palette(args[0]);
                } else {
                    //---- values passed as function arguments ----
                    this.palette(args);
                }

                this._rangeBounds = null;

                return this;
            };

            categoryScaleClass.prototype.rangeFromBounds = function () {
                var args = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    args[_i] = arguments[_i + 0];
                }
                var values = arguments;

                if (args.length == 1) {
                    //---- values passed as single array ----
                    values = arguments[0];
                }

                if (values.length != 2) {
                    throw "Error - must pass 2 values to rangeFromBounds()";
                }

                this._rangeBounds = values;

                this.computeRangeFromBounds();

                return this;
            };

            categoryScaleClass.prototype.onRangeChanged = function () {
                _super.prototype.onRangeChanged.call(this);

                if (this._rangeBounds) {
                    this.computeRangeFromBounds();
                }
            };

            categoryScaleClass.prototype.computeRangeFromBounds = function () {
                var keys = vp.utils.keys(this._categoryKeys);

                var steps = keys.length;

                var min = this._rangeBounds[0];
                var max = this._rangeBounds[1];

                if (min < max) {
                    min += this._expandSpace;
                    max -= this._expandSpace;
                } else {
                    max += this._expandSpace;
                    min -= this._expandSpace;
                }

                var delta = max - min;
                this._stepSize = (steps >= 1) ? (delta / steps) : 1;
                var halfStep = this._stepSize / 2;

                //---- generate points in middle of each step ----
                var stopper = max - halfStep;
                this._palette = vp.utils.range(min, stopper, this._stepSize).map(function (value, index) {
                    return value + halfStep;
                });
            };

            categoryScaleClass.prototype.map = function (value) {
                return this.scale(value);
            };
            return categoryScaleClass;
        })(scales.baseScale);
        scales.categoryScaleClass = categoryScaleClass;

        function createCategory() {
            return new categoryScaleClass();
        }
        scales.createCategory = createCategory;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=categoryScale.js.map

///----------------------------------------------------------------
/// (from scales\expScale.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// expScale.ts.  Copyright (c) 2014 Microsoft Corporation.
///     Part of the vuePlotCore library - exp scale.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var expScaleClass = (function (_super) {
            __extends(expScaleClass, _super);
            function expScaleClass() {
                _super.call(this);

                this.ctr = "vp.scales.expScaleClass";
                this.scaleName = "exp";

                this._scaleType = 2 /* exp */;
            }
            expScaleClass.prototype.domain = function (min, max) {
                if (arguments.length == 0) {
                    return [this._domainMin, this._domainMax];
                }

                this.domainMin(min);
                this.domainMax(max);

                return this;
            };

            expScaleClass.prototype.range = function (min, max) {
                if (arguments.length == 0) {
                    if (arguments.length == 0) {
                        return this._palette;
                    }
                }

                this.palette([min, max]);

                return this;
            };

            expScaleClass.prototype.map = function (value) {
                return this.scale(value);
            };

            expScaleClass.prototype.calcPercent = function (value) {
                //---- TODO: precompute these when domain changes ----
                var expMin = Math.exp(this._domainMin);
                var expMax = Math.exp(this._domainMax);
                var expDelta = (expMax == expMin) ? 1 : (expMax - expMin);

                var expValue = Math.exp(value);
                var t = (expValue - expMin) / expDelta;

                if (this._isRangeClipping) {
                    t = this.clip(t, 0, 1);
                }

                return t;
            };
            return expScaleClass;
        })(scales.baseScale);
        scales.expScaleClass = expScaleClass;

        function createExp() {
            return new expScaleClass();
        }
        scales.createExp = createExp;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=expScale.js.map

///----------------------------------------------------------------
/// (from scales\formatters.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// formatters.ts.  Copyright (c) 2014 Microsoft Corporation.
///   - part of the vuePlot library
///   - defines a set of chart label formatting functions
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (formatters) {
        /// format a number nicely (shortest decimal possible, add commas for thousands).
        function comma(value, numDecimalPlaces, forceDecimalPlaces, removeLeadingSingleZero) {
            if (numDecimalPlaces === undefined) {
                numDecimalPlaces = 2;
            }

            //---- convert to a number, if possible ----
            var num = parseFloat(value);

            if ((vp.utils.isNumber(num)) && (!isNaN(num))) {
                value = num;

                var isWholeNum = (Math.abs(value - Math.round(value)) == 0);

                if ((!forceDecimalPlaces) && (isWholeNum)) {
                    value = Math.round(value).toString();
                } else {
                    //---- ensure "numDecimalPlaces" is a legal value ----
                    numDecimalPlaces = Math.round(numDecimalPlaces);
                    numDecimalPlaces = Math.max(0, Math.min(20, numDecimalPlaces));

                    var isLessThanOne = (Math.abs(value) < 1);

                    if (false) {
                        value = num + ""; // default formatting

                        var index = value.indexOf(".");
                        if (index > 0) {
                            var signifCount = 0;
                            var excessIndex = -1;
                            var firstSignifIndex = -1;
                            var excessCount = 0;

                            for (var i = index + 1; i < value.length; i++) {
                                if (value[i] >= "0" && value[i] <= "9") {
                                    //---- its a DIGIT (vs. +E..) ----
                                    if ((value[i] > "0") && (firstSignifIndex == -1)) {
                                        firstSignifIndex = i;
                                    }

                                    if (firstSignifIndex > -1) {
                                        signifCount++;
                                    }

                                    if ((signifCount > numDecimalPlaces) && (excessIndex == -1)) {
                                        excessIndex = i;
                                    }

                                    if (excessIndex > -1) {
                                        excessCount++;
                                    }
                                } else {
                                    break;
                                }
                            }

                            //---- reached end of digits after the "." ----
                            if (excessIndex > -1) {
                                //---- delete digits at "excessIndex" ----
                                value = value.substr(0, excessIndex) + value.substr(excessIndex + excessCount);
                            }
                        }
                    } else {
                        value = value.toFixed(numDecimalPlaces);

                        if ((isLessThanOne) && (removeLeadingSingleZero) && (forceDecimalPlaces)) {
                            value = value.substr(1);
                        }

                        //---- remove extra zeros ----
                        if ((!forceDecimalPlaces) && (value.contains("."))) {
                            var allZeros = (0).toFixed(numDecimalPlaces).substr(1);
                            if (value.endsWith(allZeros)) {
                                var len = value.length - allZeros.length;
                                value = value.substr(0, len);
                            }
                        }
                    }
                }

                //---- add commas, as needed ----
                var parts = value.split('.');
                var left = parts[0];
                var right = (parts.length > 1) ? "." + parts[1] : "";

                var len = left.length;

                //---- don't add commas to 4 digit numbers ----
                if ((len > 4) || (len > 5 && len[0] == "-")) {
                    var startLen = (len % 3) == 0 ? 3 : len % 3;
                    var newLeft = left.substring(0, startLen);

                    for (var i = startLen; i < len; i += 3) {
                        newLeft += "," + left.substring(i, i + 3);
                    }

                    value = newLeft + right;
                }

                //---- look for exception to rule ----
                if (value.startsWith("-,")) {
                    value = "-" + value.substr(2);
                }
            }

            return value;
        }
        formatters.comma = comma;

        //---- format a number as a percentage ----
        function percent(value, numDecimalPlaces) {
            //---- convert to a number, if possible ----
            var num = parseFloat(value);

            if (vp.utils.isNumber(num)) {
                value = 100 * num;
                value = comma(value, numDecimalPlaces) + "%";
            }

            return value;
        }
        formatters.percent = percent;

        //---- format a number as a dollar amount (US only for now) ----
        function dollar(value, numDecimalPlaces) {
            if (numDecimalPlaces === undefined) {
                numDecimalPlaces = 2;
            }

            //---- convert to a number, if possible ----
            var num = parseFloat(value);

            if (vp.utils.isNumber(num)) {
                value = "$" + comma(value, numDecimalPlaces, true);
            }

            return value;
        }
        formatters.dollar = dollar;

        //---- format a number in scientific notation ----
        function scientific(value, numDecimalPlaces) {
            //---- convert to a number, if possible ----
            var num = parseFloat(value);

            if (vp.utils.isNumber(num)) {
                if (numDecimalPlaces === undefined) {
                    value = num.toExponential(2);
                } else {
                    value = num.toExponential(numDecimalPlaces);
                }
            }

            return value;
        }
        formatters.scientific = scientific;

        function date(value) {
            return value;
        }
        formatters.date = date;

        function string(value) {
            return value + "";
        }
        formatters.string = string;

        /// format a number nicely (shortest decimal possible, add commas for thousands).
        function format(value) {
            if (vp.utils.isNumber(value)) {
                value = comma(value);
            }

            return value;
        }
        formatters.format = format;
    })(vp.formatters || (vp.formatters = {}));
    var formatters = vp.formatters;
})(vp || (vp = {}));
//# sourceMappingURL=formatters.js.map

///----------------------------------------------------------------
/// (from scales\linearScale.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// linearScale.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - linear scale.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var linearScaleClass = (function (_super) {
            __extends(linearScaleClass, _super);
            function linearScaleClass() {
                _super.call(this);

                this.ctr = "vp.scales.linearScaleClass";
                this.scaleName = "linear";

                this._scaleType = 0 /* linear */;
            }
            linearScaleClass.prototype.domain = function (min, max) {
                if (arguments.length == 0) {
                    return [this._domainMin, this._domainMax];
                }

                this.domainMin(min);
                this.domainMax(max);

                return this;
            };

            linearScaleClass.prototype.range = function (min, max) {
                if (arguments.length == 0) {
                    if (arguments.length == 0) {
                        return this._palette;
                    }
                }

                this.palette([min, max]);

                return this;
            };

            linearScaleClass.prototype.map = function (value) {
                return this.scale(value);
            };
            return linearScaleClass;
        })(scales.baseScale);
        scales.linearScaleClass = linearScaleClass;

        function createLinear() {
            return new linearScaleClass();
        }
        scales.createLinear = createLinear;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=linearScale.js.map

///----------------------------------------------------------------
/// (from scales\logScale.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// logScale.ts.  Copyright (c) 2014 Microsoft Corporation.
///     Part of the vuePlotCore library - log scale.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var logScaleClass = (function (_super) {
            __extends(logScaleClass, _super);
            function logScaleClass() {
                _super.call(this);

                this.ctr = "vp.scales.logScaleClass";
                this.scaleName = "log";

                this._scaleType = 1 /* log */;
            }
            logScaleClass.prototype.domain = function (min, max) {
                if (arguments.length == 0) {
                    return [this._domainMin, this._domainMax];
                }

                this.domainMin(min);
                this.domainMax(max);

                return this;
            };

            logScaleClass.prototype.range = function (min, max) {
                if (arguments.length == 0) {
                    if (arguments.length == 0) {
                        return this._palette;
                    }
                }

                this.palette([min, max]);

                return this;
            };

            logScaleClass.prototype.map = function (value) {
                return this.scale(value);
            };

            logScaleClass.prototype.calcPercent = function (value) {
                //---- TODO: precompute these when domain changes ----
                var logMin = Math.log(this._domainMin);
                var logMax = Math.log(this._domainMax);
                var logDelta = (logMax == logMin) ? 1 : (logMax - logMin);

                var logValue = Math.log(value);
                var t = (logValue - logMin) / logDelta;

                if (this._isRangeClipping) {
                    t = this.clip(t, 0, 1);
                }

                return t;
            };
            return logScaleClass;
        })(scales.baseScale);
        scales.logScaleClass = logScaleClass;

        function createLog() {
            return new logScaleClass();
        }
        scales.createLog = createLog;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=logScale.js.map

///----------------------------------------------------------------
/// (from scales\niceNumbers.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// niceNumbers.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - used to caculate nice numbers for an axis, for histograms, etc.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (scales) {
        /** settings for an attribute (value, scaling, and legend data). */
        var niceNumbers = (function () {
            function niceNumbers() {
            }
            niceNumbers.calculate = function (dataMin, dataMax, extendDomainToZero, useOnlyIntBreaks, callerMin, callerMax, callerTickCount, addmaxHeadroom) {
                //---- designed for "measure" data (see seperate algorithm for date values) ----
                var min = dataMin;
                var max = dataMax;
                var adjustMin = true;
                var adjustMax = true;

                if (callerMin != undefined) {
                    min = callerMin;
                    adjustMin = false;
                }

                if (callerMax != undefined) {
                    max = callerMax;
                    adjustMax = false;
                }

                if (addmaxHeadroom === undefined) {
                    addmaxHeadroom = true;
                }

                var incr = 0;

                if ((adjustMin) || (adjustMax)) {
                    var minMax = this.calcMinMax(min, max, adjustMin, adjustMax, extendDomainToZero, addmaxHeadroom, useOnlyIntBreaks);

                    min = minMax.min;
                    max = minMax.max;
                    incr = minMax.incr;
                } else {
                    var result2 = this.calcIncr(min, max, useOnlyIntBreaks);
                    incr = result2.incr;
                }

                //---- calc TICKS ----
                var ticks = 0;

                if (callerTickCount === undefined) {
                    var incrCount = (max - min) / incr;
                    ticks = 1 + Math.floor(incrCount + .00001);
                } else {
                    ticks = callerTickCount;
                }

                //---- assign final values ----
                var result = { min: min, max: max, tickCount: ticks };
                return result;
            };

            niceNumbers.calcIncr = function (min, max, useOnlyIntBreaks) {
                var incr = 1;

                var range = max - min;
                if (range > 0) {
                    var exp = Math.floor(Math.log10(range));
                    var r = range / Math.pow(10, exp);

                    if (r > 9.523) {
                        range *= 1.05;

                        max = min + range;
                        exp = Math.floor(Math.log10(range));
                        r = range / Math.pow(10, exp);
                    }

                    if (r < 2) {
                        incr = .2;
                    } else if (r < 5) {
                        incr = .5;
                    }

                    incr = incr * Math.pow(10, exp);

                    if (useOnlyIntBreaks) {
                        incr = Math.max(1, Math.round(incr));
                    }
                }

                return { incr: incr, max: max };
            };

            niceNumbers.calcMinMax = function (dataMin, dataMax, adjustMin, adjustMax, extendDomainToZero, addmaxHeadroom, useOnlyIntBreaks) {
                var min = dataMin;
                var max = dataMax;

                if (extendDomainToZero) {
                    if ((min > 0) && (adjustMin)) {
                        min = 0;
                    }

                    if ((max < 0) && (adjustMax)) {
                        max = 0;
                    }
                }

                if ((min == max) && (adjustMax)) {
                    incr = (useOnlyIntBreaks) ? 1 : .1 * dataMin;
                    max = dataMin + incr;
                } else {
                    var range = max - min;
                    if (range > 0) {
                        if (useOnlyIntBreaks) {
                            min = Math.floor(min);
                            max = Math.ceil(max);
                        }

                        var result = niceNumbers.calcIncr(min, max, useOnlyIntBreaks);
                        var incr = result.incr;
                        max = result.max;

                        //---- set domainMin to max INCR increment that is < minValue (or <= if 0) ----
                        //---- set domainMax to min INCR increment that is > maxValue ----
                        if (min >= 0) {
                            min = incr * Math.floor(min / incr);
                        } else {
                            min = incr * Math.floor(min * 1.001 / incr);
                        }

                        if (addmaxHeadroom) {
                            if ((max / incr) == Math.round(max / incr)) {
                                //---- if max is a multiple of "incr", add one increment ----
                                max = max + incr;
                            } else {
                                //---- round UP to the next increment ----
                                //max = incr * Math.ceil(max / incr);
                                //---- try always adding one incr ----
                                max = incr * Math.round((max + incr) / incr);
                            }
                        } else {
                            //---- try always adding part of one incr ----
                            max = incr * Math.floor((max + .9 * incr) / incr);
                        }
                    }
                }

                return { min: min, max: max, incr: incr };
            };
            return niceNumbers;
        })();
        scales.niceNumbers = niceNumbers;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=niceNumbers.js.map
///-----------------------------------------------------------------------------------------------------------------
/// basicTypes.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - Part of the vuePlot library
///    - Defines some basic types for use by our TypeScript classes.
///    - Some of the types are from the remaining VuePlot.js files.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="scripts/allfiles.ts" />

var vp;
(function (vp) {
    (function (session) {
        
    })(vp.session || (vp.session = {}));
    var session = vp.session;
})(vp || (vp = {}));

var vp;
(function (vp) {
    (function (utils) {
        
    })(vp.utils || (vp.utils = {}));
    var utils = vp.utils;
})(vp || (vp = {}));

var vp;
(function (vp) {
    (function (stats) {
        
    })(vp.stats || (vp.stats = {}));
    var stats = vp.stats;
})(vp || (vp = {}));

var vp;
(function (vp) {
    (function (file) {
        
    })(vp.file || (vp.file = {}));
    var file = vp.file;
})(vp || (vp = {}));

var vp;
(function (vp) {
    (function (visuals) {
        

        (function (LabelFit) {
            /** Just draw all labels and let any overlaps happen */
            LabelFit[LabelFit["drawAll"] = 0] = "drawAll";

            /** Skip 0-N labels, as needed, to make the others fit without overlap */
            LabelFit[LabelFit["skip"] = 1] = "skip";

            /** Truncate labels, as needed, so that they don't exceed their available space. */
            LabelFit[LabelFit["truncate"] = 2] = "truncate";

            /** If all labels cannot be drawn without overlap, rotate the labels 45 degrees to allow them to fit better. */
            LabelFit[LabelFit["rotate45"] = 3] = "rotate45";

            /** If all labels cannot be drawn without overlap, rotate the labels 90 degrees to allow them to fit better. */
            LabelFit[LabelFit["rotate90"] = 4] = "rotate90";

            /** If all labels cannot be drawn without overlap, rotate the labels 45 or 90 degrees to allow them to fit better. */
            LabelFit[LabelFit["rotateAuto"] = 5] = "rotateAuto";

            /** If all labels cannot be drawn without overlap, hide them all. */
            LabelFit[LabelFit["hideAll"] = 6] = "hideAll";
        })(visuals.LabelFit || (visuals.LabelFit = {}));
        var LabelFit = visuals.LabelFit;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=basicTypes.js.map
///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/buildBottomAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///     - flat helper functions for building a bottom axis.
///-----------------------------------------------------------------------------------------------------------------
vp.buildBottomAxis = function (group, width, tickOffsets, labels, szText, isCategory, name,
    isNameRotated, daBlock, autoHideLabels, autoHideTicks, labelFit, drawTicksOnInside)
{
    group.clear();

    var yoff = 0;
    var tickLabelSpace = daBlock.tick.spaceToLabel;
    var tickLength = daBlock.tick.length;
    var xMax = width - 1;
    var labelRotation = 0;
    var showLabels = true;
    var showTicks = true;
    var halign = "center";
    var xtweak = 0;

    var labelCount = labels.length;
    var adjWidth = .9 * width;
    var maxLabelWidth = szText.width;
    var perGroupCount = 1;         // # of labels in a group (1 label per group is visible)
    var truncateLabels = false;
    var rotate = null;

    if (labelCount * maxLabelWidth > adjWidth)
    {
        //---- all labels don't fit the space ----
        if (labelFit == vp.visuals.LabelFit.skip)          
        {
            //---- SKIP labelFit ----
            var groupCount = adjWidth / maxLabelWidth;
            perGroupCount = Math.ceil(labelCount / groupCount);
        }
        else if (labelFit == vp.visuals.LabelFit.truncate)
        {
            //---- TRUNCATE labelFit ----
            truncateLabels = true;
        }
        else if (labelFit == vp.visuals.LabelFit.rotate45)
        {
            //---- ROTATE 45 ----
            rotate = 45;
        }
        else if (labelFit == vp.visuals.LabelFit.rotate90)
        {
            //---- ROTATE 90 ----
            rotate = 90;
        }
        else if (labelFit == vp.visuals.LabelFit.rotateAuto)
        {
            //---- AUTO ROTATE ----
            rotate = "auto";
        }
        else if (labelFit == vp.visuals.LabelFit.hideAll)
        {
            //---- HIDE ALL ----
            showLabels = false;

            if ((autoHideTicks) && (labelCount > .15 * width))
            {
                showTicks = false;
            }
        }
    }

    if (group.firstPassResults)
    {
        showLabels = group.firstPassResults.showLabels;
        showTicks = group.firstPassResults.showTicks;
        rotate = group.firstPassResults.labelRotation;
    }

    if (rotate)
    {
        //---- try to make room for labels, if needed ----
        var labelCount = labels.length;
        if (labelCount * szText.height > width)
        {
            showLabels = false;
        }
        else if ((rotate == 90) || ((rotate == "auto") && (labelCount * szText.height * 1.3 > width)))
        {
            labelRotation = 90;
            halign = "left";
        }
        else if ((rotate == 45) || ((rotate == "auto") && (labelCount * szText.width > width)))
        {
            labelRotation = 45;
            halign = "left";
            xtweak = szText.height / 2;
        }
    }

    //---- axis line ----
    vp.internal.drawHLine(group, daBlock.axis, 0, xMax, yoff, "vpAxisLine");

    if (showTicks)
    {
        var skipCount = 0;

        //---- tick marks ----
        for (var i = 0; i < tickOffsets.length; i++)
        {
            var x = Math.round(tickOffsets[i]);

            var daTick = daBlock.tick;

            if ((skipCount > 1) || ((skipCount == 1) && (!isCategory)))
            {
                if (daBlock.skipTick)
                {
                    daTick = daBlock.skipTick;
                }
            }

            var myTickLength = daTick.length + 1;

            if (drawTicksOnInside)
            {
                myTickLength = -myTickLength;
            }

            vp.internal.drawVLine(group, daTick, yoff, yoff + myTickLength + 1, x, "vpTickMark");

            skipCount++;
            if (skipCount == perGroupCount)
            {
                skipCount = 0;
            }
        }
    }

    if (showTicks && (!drawTicksOnInside))
    {
        yoff += (tickLength + tickLabelSpace);
    }
    else
    {
        yoff += tickLabelSpace + 2;
    }

    //---- tick labels ----
    var lastOffset = null;
    var labelIndex = 0;

    if (showLabels)
    {
        var skipCount = 0;

        for (var i = 0; i < tickOffsets.length; i++)
        {
            var x = Math.round(tickOffsets[i]);

            if (isCategory)
            {
                var offset = x;

                if (lastOffset == null)
                {
                    lastOffset = offset;
                    continue;
                }

                x = (offset + lastOffset) / 2;      // draw centered on middle of last & current tick
                lastOffset = offset;
            }

            //var textWidth = szText.width;
            //var textHeight = szText.height;

            //var actualX = x - (textWidth / 2) + xtweak;
            var label = labels[labelIndex++];

            if (skipCount == 0)
            {
                if (label != "")
                {
                    daBlock.label.textLabel = (label.label) ? label.label : label;

                    var yStart = yoff + 5;
                    var xStart = x + xtweak;

                    if (labelRotation == 90)
                    {
                        xStart += 2;
                        yStart -= 8;
                    }
                    else if (labelRotation == 45)
                    {
                        xStart -= 10;
                        yStart -= 7;
                    }

                    vp.internal.drawText(group, daBlock.label, xStart, yStart, null, null, halign, "center", labelRotation,
                        0, .5);

                    if (truncateLabels)
                    {
                        //---- add tooltip for full label name ----
                        var fullLabel = (label.fullLabel) ? label.fullLabel : label;
                        vp.internal.textElemJustDrawn.title(fullLabel);
                    }
                }
            }

            skipCount++;
            if (skipCount == perGroupCount)
            {
                skipCount = 0;
            }
        }
    }

    if (showLabels)
    {
        if (labelRotation == 90)
        {
            yoff += (szText.width - 1);
        }
        else if (labelRotation == 45)
        {
            var rotateHeight = szText.width * Math.sin(45 * Math.PI / 180);
            yoff += (rotateHeight + 4);
        }
        else
        {
            yoff += (5 + szText.height / 2);      // height/2 since we draw text with vertical centering
        }
    }

    //---- axis title ----
    if (name)
    {
        var aoff = (labelRotation) ? 30 : 15;
        daBlock.title.textLabel = name;

        var left = daBlock.title.left;
        var top = daBlock.title.top;
        var right = daBlock.title.right;
        var bottom = daBlock.title.bottom;

        //var sz = vp.internal.drawText(group, daBlock.title, 0, yoff + aoff, width, null, "center", "center", 0);
        //yoff += (sz.height + aoff);
        var sz = vp.internal.drawText(group, daBlock.title, left, yoff + top, width, null, "center", "center", 0);
        yoff += (sz.height + top + bottom);

        //---- add standard tooltip ----
        var ge = group[0];
        var elem = ge.childNodes[ge.childNodes.length - 1];
        vp.dom.title(elem, "The X-axis represents the data column: " + name);
        elem.id = "xAxis";

        yoff -= 20;         // tighten up the white space
    }
    else
    {
        //---- add some white space so its not too crowded ----
        yoff -= 10;         // tighten up the white space
    }

    group.desiredWidth = width;
    group.desiredHeight = yoff;
    group.firstPassResults = { showLabels: showLabels, showTicks: showTicks, labelRotation: labelRotation };

    return group;
};


///----------------------------------------------------------------
/// (from chartFrame\buildLeftAxis.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/buildLeftAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///     - flat helper functions for building a left axis.
///-----------------------------------------------------------------------------------------------------------------
vp.buildLeftAxis = function (group, height, tickOffsets, labels, szText, isCategory, name,
    isNameRotated, daBlock, autoHideLabels, autoHideTicks, drawTicksOnInside)
{
    group.clear();

    var xoff = 0;
    var yoff = 0;
    var tickLength = daBlock.tick.length;
    var tickLabelSpace = daBlock.tick.spaceToLabel;
    var yMax = height - 1;
    var showLabels = true;
    var showTicks = true;
    var perGroupCount = 1;         // # of labels in a group (1 label per group is visible)

    var labelCount = labels.length;
    var adjHeight = .9 * height;
    var maxLabelHeight = szText.height;

    if (maxLabelHeight > adjHeight)
    {
        //---- not room for even a single label - always hide ----
        showLabels = false;
    }
    else if (labelCount * maxLabelHeight > adjHeight)
    {
        //---- all labels don't fit the space ----
        if (autoHideLabels)
        {
            showLabels = false;

            if ((autoHideTicks) && (labelCount > .15 * height))
            {
                showTicks = false;
            }
        }
        else
        {
            var groupCount = adjHeight / maxLabelHeight;
            perGroupCount = Math.ceil(labelCount / groupCount);
        }
    }

    //---- axis title ----
    if (name)
    {
        daBlock.title.textLabel = name;

        var left = daBlock.title.left;
        var top = daBlock.title.top;
        var right = daBlock.title.right;
        var bottom = daBlock.title.bottom;

        var sz = vp.internal.drawText(group, daBlock.title, xoff + left, yoff + top, null, height, "center", "center", 270);

        //---- add standard tooltip ----
        var ge = group[0];
        var elem = ge.childNodes[ge.childNodes.length - 1];
        vp.dom.title(elem, "The Y-axis represents the data column: " + name);
        elem.id = "yAxis";

        xoff += (left + right + sz.height);       // sz.height is the width of the text after rotation
    }

    if (showLabels)
    {
        //---- tick labels ----
        var lastOffset = null;
        var textWidth = szText.width;
        var textHeight = szText.height;
        var labelIndex = 0;
        var skipCount = 0;

        for (var i = 0; i < tickOffsets.length; i++)
    {
            var y = Math.round(tickOffsets[i]);

            if (isCategory)
            {
                var offset = y;

                if (lastOffset == null)
                {
                    lastOffset = offset;
                    continue;
                }

                y = (offset + lastOffset) / 2;      // draw centered on middle of last & current tick
                lastOffset = offset;
            }

            if (skipCount == 0)
            {
                var label = labels[labelIndex];
                daBlock.label.textLabel = label;

                var yy = yoff + (height - y) + 3;
                vp.internal.drawText(group, daBlock.label, xoff, yy, textWidth, null, "right", "center");
            }

            labelIndex++;

            skipCount++;
            if (skipCount == perGroupCount)
            {
                skipCount = 0;
            }
        }
    }

    xoff += (szText.width + tickLabelSpace);
    xoff += tickLength;

    if (showTicks)
    {
        //---- tick marks ----
        for (var i = 0; i < tickOffsets.length; i++)
        {
            var y = Math.round(tickOffsets[i]);

            var daTick = daBlock.tick;      // (skipCount > 0 && daBlock.skipTick) ? daBlock.skipTick : daBlock.tick;
            var myTickLength = daTick.length;
            var yy = yoff + (height - y);

            if (! drawTicksOnInside)
            {
                myTickLength = -myTickLength;
            }

            //---- don't draw ticks very near top/bottom on inside (hard to align correctly due to antialiasing) ----
            var nearTop = (Math.abs(yy - 0) < 2);
            var nearBottom = (Math.abs(yy - height) < 2);

            if ((drawTicksOnInside) && (nearTop || nearBottom))
            {
                //---- don't draw this tick ----
            }
            else
            {
                vp.internal.drawHLine(group, daTick, xoff, xoff + myTickLength, yy);
            }
        }
    }

    //---- axis line ----
    vp.internal.drawVLine(group, daBlock.axis, yoff, yoff + yMax, xoff);

    group.desiredWidth = xoff;
    group.desiredHeight = height;

    return group;
};


///----------------------------------------------------------------
/// (from chartFrame\buildLegend.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/buildLegend.js.  Copyright (c) 2012 Microsoft Corporation.
///     - a set of flat helper functions for building a set of legends.
///-----------------------------------------------------------------------------------------------------------------
vp.buildLegend = function (parentGroup, attributes, daBlock, layers, seriesCount, isLegendBoxVisible, useLayersForLegend, legendLabels)
{
    var primaryLayer = layers[0];
    var group = parentGroup.append("g");
    var dw = 0;
    var dh = 0;

    var left = daBlock.box.left;
    var top = daBlock.box.top;
    var right = daBlock.box.right;
    var bottom = daBlock.box.bottom;

    if (useLayersForLegend)
    {
        singleGroup = vp.buildDiscreteLegendFromLayers(group, layers, left, top, daBlock, name, isLegendBoxVisible, legendLabels);

        dw = Math.max(dw, (singleGroup.desiredWidth + left + right));
        dh += singleGroup.desiredHeight + top + bottom;
    }
    else
        {
        for (var i = 0; i < attributes.length; i++)
        {
            var attribute = attributes[i];
            var scale = attribute.scale();

            //---- ensure this attribute is mapped to a column ----
            if ((!attribute.isMapped()) || (!attribute.isLegendVisible()))
            {
                continue;
            }

            if (scale.scaleName == "size")
            {
                continue;       // not yet supported
            }

            var scaleOrPalette = (scale.scaleName == "color") ? scale : null;
            var name = attribute.title();
            var breaks = attribute.getActualBreaks();
            var labels = attribute.getActualLabels(breaks);
            var singleGroup = null;
            var isContinuousPalette = (!attribute.isDiscrete());

            if (scaleOrPalette)
            {
                if (isContinuousPalette)
                {
                    singleGroup = vp.buildContinuousLegend(group, primaryLayer, left, top, daBlock, attribute, scaleOrPalette, name, breaks, labels,
                        isLegendBoxVisible);
                }
                else
                {
                    singleGroup = vp.buildDiscreteLegend(group, primaryLayer, left, top, daBlock, attribute, scaleOrPalette, name, breaks, labels,
                        isLegendBoxVisible);
                }

                dw = Math.max(dw, (singleGroup.desiredWidth + left + right));
                dh += singleGroup.desiredHeight + top + bottom;
            }
        }
    }

    group.desiredWidth = dw;
    group.desiredHeight = dh;

    return group;

};

//---- build svg RECT with gradient matching "palette" (with last color in palette at top) ----
vp.buildSvgGradient = function (svgParent, defName, palette, drawBorder, flipColors, x, y, width, height)
{
    var defs = svgParent.append("defs");

    var gradient = defs.append("linearGradient")
        .attr("id", defName)
        .from("0%", "0%")
        .to("0%", "100%")

    var len = palette.length;

    //---- add a stop for each color in the palette ----
    for (var i = 0; i < len; i++)
    {
        var cr = (flipColors) ? palette[i] : palette[len - (i+1)];
        var color = vp.color.toColor(cr);

        var percent = (len == 1) ? 0 : (100 * i / (len - 1));

        gradient
            .addStop(percent + "%", color)
    }

    var rect = svgParent.append("rect")
        .bounds(x, y, width, height)
        .attr("fill", "url(#" + defName + ")");

    if (drawBorder)
    {
        rect
            .attr("stroke", "#333")
            .attr("stroke-width", "1")
    }

    return rect;
}

vp.addNameToLegend = function(group, daBlock, leftBase, dw, dh, name)
{
    daBlock.title.textLabel = name;

    var left = daBlock.title.left;
    var top = daBlock.title.top;
    var right = daBlock.title.right;
    var bottom = daBlock.title.bottom;

    var sz = vp.internal.drawText(group, daBlock.title, leftBase + left, dh + top, null, null, "left", "center");

    dh += sz.height + (top + bottom);
    dw = Math.max(dw, (left + right + sz.width));

    return { dh: dh, dw: dw };
}

vp.buildDiscreteLegend = function (parentGroup, primaryLayer, xLoc, yLoc, daBlock, colorAttr, colorScale, name, breaks, labels, 
    isLegendBoxVisible)
{
    var group = parentGroup.append("g");

    var cr = "black";          // default color
    var dw = 0;
    var dh = yLoc;
    var xoff = xLoc;

    var daBox = daBlock.box;
    var box = null;

    if (isLegendBoxVisible)
    {

        if ((daBox.fill != "transparent") || ((daBox.lineSize) && (daBox.stroke != "transparent")))
        {
            box = vp.internal.drawBox(group, daBox, 0, 0, 100, 100);       // we will resize at end of this function
            dh += 10;
            xoff += 10;
        }
    }

    if (name)
    {
        var leftBase = dw;

        if ((!vp.utils.isString(name)) && vp.utils.isArray(name))
        {
            //---- do each name in array ----
            for (var i = 0; i < name.length; i++)
            {
                if (i > 0)
                {
                    dh += 4;        // a little extra spacing between multiple legend names
                }

                var thisName = name[i];
                var dd = vp.addNameToLegend(group, daBlock, leftBase, dw, dh, thisName);

                dh = dd.dh;
                dw = dd.dw;
            }
        }
        else
        {
            var dd = vp.addNameToLegend(group, daBlock, leftBase, dw, dh, name);

            dh = dd.dh;
            dw = dd.dw;
        }
    }

    var colorBoxesHeight = 0;
    var colorBoxesTop = dh;

    var flipIt = colorAttr.flipInLegend();

    //---- draw color boxes ----
    var lastBreak = breaks.length - 1;      // extra tick 

    for (var i = 0; i < lastBreak; i++)
    {
        var index = (flipIt) ? ((lastBreak - 1) - i) : i;

        var breakValue = index;     // discrete scale wants index

        if (colorScale)
        {
            if (vp.utils.isArray(colorScale))
            {
                //var index = (flipIt) ? (breaks.length - 1) - i : 0;
                cr = vp.color.colorFromPalette(colorScale, index);
            }
            else
            {
                var categoryKeys = colorScale.categoryKeys();
                if (vp.utils.hasKeys(categoryKeys))
                {
                    var key = labels[index];
                    cr = colorScale.categoryKeyScale(key);
                }
                else
                {
                    cr = colorScale.scale(breakValue);
                }
            }
        }

        //---- shape ----
        var sw = daBlock.key.shapeWidth;
        var sh = daBlock.key.shapeHeight;

        var rect = group.append("rect")
            .bounds(xoff, dh + .5, sw, sh)

        daBlock.key.fill = cr;
        vp.internal.applyShapeAttributes(rect, daBlock.key);

        dh += sh;   //(sh + daBlock.key.lineSize);       //Math.max(sh, sz.height);
        colorBoxesHeight += sh;
    }

    var boxPlusWidth = daBlock.key.shapeWidth;

    //---- draw ticks and labels to right of color boxes ----
    var rightAxis = vp.createRightAxisForLegend(primaryLayer, colorAttr, colorScale, colorBoxesHeight - 1, flipIt);

    var rightAxisWidth = rightAxis.getWidth(group, 100, colorBoxesHeight);
    rightAxis.draw(group, boxPlusWidth, colorBoxesTop + .5, rightAxisWidth, colorBoxesHeight - 1, true);

    dw = Math.max(dw, boxPlusWidth + rightAxisWidth);

    var boxWidth = dw + 8;
    var boxHeight = dh + sh;

    group.desiredWidth = (box) ? dw : (dw - 10);
    group.desiredHeight = (box) ? boxHeight : (dh + sh - 16);

    if (box)
    {
        box
            .attr("width", boxWidth)
            .attr("height", boxHeight);
    }

    return group;
};

vp.buildDiscreteLegendFromLayers = function (parentGroup, layers, xLoc, yLoc, daBlock, name, isLegendBoxVisible, legendLabels)
{
    var group = parentGroup.append("g");
    var primaryLayer = layers[0];

    var cr = "black";          // default color
    var dw = 0;
    var dh = yLoc;
    var xoff = xLoc;

    var daBox = daBlock.box;
    var box = null;

    if (isLegendBoxVisible)
    {
        if ((daBox.fill != "transparent") || ((daBox.lineSize) && (daBox.stroke != "transparent")))
        {
            box = vp.internal.drawBox(group, daBox, 0, 0, 100, 100);       // we will resize at end of this function
            dh += 10;
            xoff += 10;
        }
    }

    if (name)
    {
        var leftBase = dw;

        if ((!vp.utils.isString(name)) && vp.utils.isArray(name))
        {
            //---- do each name in array ----
            for (var i = 0; i < name.length; i++)
            {
                if (i > 0)
                {
                    dh += 4;        // a little extra spacing between multiple legend names
                }

                var thisName = name[i];
                var dd = vp.addNameToLegend(group, daBlock, leftBase, dw, dh, thisName);

                dh = dd.dh;
                dw = dd.dw;
            }
        }
        else
        {
            var dd = vp.addNameToLegend(group, daBlock, leftBase, dw, dh, name);

            dh = dd.dh;
            dw = dd.dw;
        }
    }

    var colorBoxesHeight = 0;
    var colorBoxesTop = dh;

    //---- vmPlot generates line/point layer pairs, with the point layer being optional ----
    //---- we will be 1 legend entry per line layer ----
    var entryCount = 0;
    for (var i = 0; i < layers.length; i++)
    {
        var layer = layers[i];
        if (layer.layerType() == "line")
        {
            entryCount++;
        }
    }

    //---- draw color LINES ----
    var lastBreak = entryCount - 1;      // extra tick 
    var useLayerLabels = (legendLabels == null || legendLabels.length == 0);
    var flipIt = false;

    if (useLayerLabels)
    {
        legendLabels = [];
    }

    var dak = daBlock.key;

    for (var i = 0; i < layers.length; i++)
    {
        var index = (flipIt) ? ((lastBreak - 1) - i) : i;

        var breakValue = index;     // discrete scale wants index

        var layer = layers[i];

        //var graphic = layer.getLegendGraphic();
        var cr = layer.stroke().value();          // use simple line color for now

        if (useLayerLabels)
        {
            var label = "line" + (1 + i);         // layer.getLegendLabel();
            legendLabels[i] = label;
        }

        var sw = dak.shapeWidth;
        var sh = dak.shapeHeight;
        var lineType = layer.lineType().value();
        var lineSize = layer.lineSize().value();
        var shapeType = null;

        if (i < layers.length - 1)
        {
            var nextLayer = layers[i + 1];
            if (nextLayer.layerType() == "point")
            {
                shapeType = nextLayer.shapeType().value();
            }
        }

        if (lineSize > 0)
        {
            lineSize = 2;           // for readability in the legend
        }

        var y = dh + sh/2 - .5;

        //var rect = group.append("rect")
        //    .bounds(xoff, y, sw, lineSize)

        //---- draw line ----
        var line = group.append("line")
            .from(xoff, y)
            .to(xoff + sw, y)

        dak.stroke = cr;
        dak.lineSize = lineSize;
        dak.lineType = lineType;

        vp.internal.applyShapeAttributes(line, dak);

        //--- draw marker ----
        if (shapeType != null)
        {
            //---- create and set shape element attributes (could be rect, path, ellipse, ...) ----
            var uelem = nextLayer.elementFromShapeType(shapeType);
            nextLayer.setShapeElemAttrs(uelem, dak, xoff + sw/2, y);

            var shape = group.append(uelem)

            dak.shapeSize = dak.shapeHeight;
            dak.fill = "transparent";
            dak.lineSize = 1;
            dak.lineType = nextLayer.lineType().value();
            dak.stroke = nextLayer.stroke().value();

            vp.internal.applyShapeAttributes(shape, dak);
        }

        dh += sh

        if (shapeType != null)
        {
            i++;
        }

        colorBoxesHeight += sh;
    }

    var boxPlusWidth = daBlock.key.shapeWidth;

    //---- draw ticks and labels to right of color boxes ----
    var rightAxis = vp.internal.drawRightAxisForLayersLegend(legendLabels, colorBoxesHeight, primaryLayer);

    var rightAxisWidth = rightAxis.getWidth(group, 100, colorBoxesHeight);
    rightAxis.draw(group, boxPlusWidth, colorBoxesTop + .5, rightAxisWidth, colorBoxesHeight - 1, true);

    dw = Math.max(dw, boxPlusWidth + rightAxisWidth);

    var boxWidth = dw + 8;
    var boxHeight = dh + sh;

    group.desiredWidth = (box) ? dw : (dw - 10);
    group.desiredHeight = (box) ? boxHeight : (dh + sh - 16);

    if (box)
    {
        box
            .attr("width", boxWidth)
            .attr("height", boxHeight);
    }

    return group;
};

vp.internal.drawRightAxisForLayersLegend = function (labels, gradientHeight, primaryLayer)
{
    //---- create an attribute/scale pair to draw color axis with ----
    var tickCount = labels.length + 1;
    var min = 0;
    var max = labels.length - 1;

    var useNiceNums = false;
    var palette = null;
    var flipIt = false;

    if (flipIt)
    {
        palette = [0, gradientHeight];
    }
    else
    {
        palette = [gradientHeight, 0];
    }

    var data = vp.utils.range(min, max, 1);

    //---- setup scale ----
    var axisScale = vp.scales.createSpace()
        .autoRange(false)

    var attrName = "legendFill";

    var axisAttr = vp.scales.createAttribute(attrName, axisScale)
        .tickCount(tickCount)
        .useNiceNumbers(useNiceNums)
        .isDiscrete(true)
        .colData(data)
        .domainMin(min)
        .domainMax(max)
        .tickCount(tickCount)
        .labels(labels)
        .palette(palette)

    ////primaryLayer.prepAttrScaleIfNeeded(axisAttr, primaryLayer.info.seriesNames);
    //var daAttr = vp.session.currentTheme().getDrawingAttributes("legend.keyText", 0);
    ////var daPropName = "legend.keyText";      // (attrName == "fill" || attrName == "stroke") ? (attrName + "Palette") : attrName;
    ////var daAttr = da[daPropName];

    //daAttr.lineSize = 0;            // don't draw tick marks
    //daAttr.stroke = "transparent";
    var daAttr = {};

    axisAttr.setupScale(data, null, daAttr, "dodge", attrName);

    //---- create the RIGHT AXIS ----
    var rightAxis = vp.visuals.svgAxis()
        .attribute(axisAttr)
        .axisLocation("right")
        .isLabelVisible(false)
        .daName("legendAxis")
        .showTicks(false)


    return rightAxis;
}

vp.createRightAxisForLegend = function (primaryLayer, colorAttr, colorScale, gradientHeight, flipIt)
{
    //---- create an attribute/scale pair to draw color axis with ----
    var tickCount = 4;
    var min = colorScale.domainMin();
    var max = colorScale.domainMax();

    var useNiceNums = ((!colorAttr.isDiscrete()) && (colorAttr.colName() != "_seriesIndex"));
    var palette = null;

    if (flipIt)
    {
        palette = [0, gradientHeight];
    }
    else
    {
        palette = [gradientHeight, 0];
    }

    //---- setup scale ----
    var axisScale = vp.scales.createSpace()
        .autoRange(false)

    var axisAttr = vp.scales.createAttribute("legendFill", axisScale)
        .tickCount(tickCount)
        .useNiceNumbers(useNiceNums)
        .colName(colorAttr.colName())
        .colData(colorAttr.colData())
        .isDiscrete(colorAttr.isDiscrete())
        .domainMin(min)
        .domainMax(max)
        .tickCount(tickCount)
        .labels(colorAttr.breaks())
        .labels(colorAttr.labels())
        .palette(palette)

    primaryLayer.prepAttrScaleIfNeeded(axisAttr, primaryLayer.info.seriesNames);

    //---- create the RIGHT AXIS ----
    var rightAxis = vp.visuals.svgAxis()
        .attribute(axisAttr)
        .axisLocation("right")
        .isLabelVisible(false)
        .daName("legendAxis")

    return rightAxis;
}

vp.legendId = 1;

vp.buildContinuousLegend = function (parentGroup, primaryLayer, xLoc, yLoc, daBlock, colorAttr, colorScale, name, breaks,
    labels, isLegendBoxVisible)
{
    var group = parentGroup.append("g");

    var cr = "black";          // default color
    var xoff = xLoc;
    var yoff = yLoc;
    var daBox = daBlock.box;
    var box = null;
    var titleWidth = 0;

    if (isLegendBoxVisible)
    {
        if ((daBox.fill != "transparent") || ((daBox.lineSize) && (daBox.stroke != "transparent")))
        {
            box = vp.internal.drawBox(group, daBox, xoff, yoff, 100, 100);       // we will resize at end of this function
            yoff += 10;
            xoff += 10;
        }
    }

    if (name)
    {
        daBlock.title.textLabel = name;

        var sz = vp.internal.drawText(group, daBlock.title, xoff, yoff, null, null, "left", "center");
        titleWidth = sz.width;

        yoff += sz.height + 0;
    }

    //---- draw gradient for colors ----
    var gradientWidth = 20;
    var gradientHeight = 120;

    var palette = colorScale.palette();
    var uniqueName = "legendGradient_" + vp.legendId++;
    var flipColors = (!colorAttr.flipInLegend());      // logic is backwards

    vp.buildSvgGradient(group, uniqueName, palette, true, flipColors, xoff, yoff + .5, gradientWidth, gradientHeight);
    xoff += (gradientWidth + 1);

    //---- draw ticks and labels to right of gradient ----
    var rightAxis = vp.createRightAxisForLegend(primaryLayer, colorAttr, colorScale, gradientHeight);

    var rightAxisWidth = rightAxis.getWidth(group, 100, gradientHeight);
    rightAxis.draw(group, xoff, yoff, rightAxisWidth, gradientHeight, true);

    var groupWidth = gradientWidth + rightAxisWidth - 10;       // 10 is fudgeFactor
    groupWidth = Math.max(groupWidth, titleWidth);

    var groupHeight = yoff + gradientHeight;

    if (box)
    {
        groupWidth += 10;
        groupHeight += 10;

        var boxWidth = groupWidth + 8;
        var boxHeight = groupHeight + 8;

        box
            .attr("width", boxWidth)
            .attr("height", boxHeight);
    }

    group.desiredWidth = groupWidth;
    group.desiredHeight = groupHeight;

    return group;
};

///----------------------------------------------------------------
/// (from chartFrame\buildRightAxis.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/buildRightAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///     - flat helper functions for building a left axis.
///-----------------------------------------------------------------------------------------------------------------
vp.buildRightAxis = function (group, height, tickOffsets, labels, szText, isCategory, name,
    isNameRotated, daBlock, autoHideLabels, autoHideTicks, boxOnly, drawTicksOnInside, showTicks)
{
    group.clear();

    var xoff = 0;
    var yoff = 0;
    var tickLength = daBlock.tick.length;
    var tickLabelSpace = daBlock.tick.spaceToLabel;
    var yMax = height - 1;
    var showLabels = true;
    var perGroupCount = 1;         // # of labels in a group (1 label per group is visible)

    var labelCount = labels.length;
    var adjHeight = .9 * height;
    var maxLabelHeight = szText.height;

    if (boxOnly)
    {
        showLabels = false;
        name = null;
    }
    else
    {
        if (labelCount * maxLabelHeight > adjHeight)
        {
            //---- all labels don't fit the space ----
            if (autoHideLabels)
            {
                showLabels = false;

                if ((autoHideTicks) && (labelCount > .15 * height))
                {
                    showTicks = false;
                }
            }
            else
            {
                var groupCount = adjHeight / maxLabelHeight;
                perGroupCount = Math.ceil(labelCount / groupCount);
            }
        }
    }

    //---- axis line ----
    vp.internal.drawVLine(group, daBlock.axis, yoff, yoff + yMax, xoff);

    if (showTicks)
    {
        //---- tick marks ----
        var skipCount = 0;

        if (myTickLength)
        {
            xoff += 2;
        }

        for (var i = 0; i < tickOffsets.length; i++)
        {
            var y = Math.round(tickOffsets[i]);

            var daTick = (skipCount > 0 && daBlock.skipTick) ? daBlock.skipTick : daBlock.tick;
            var myTickLength = daTick.length;

            if (drawTicksOnInside)
            {
                myTickLength = -myTickLength;
            }

            //---- don't draw ticks very near top/bottom on inside (hard to align correctly due to antialiasing) ----
            var yy = yoff + (height - y);

            var nearTop = (Math.abs(yy - 0) < 2);
            var nearBottom = (Math.abs(yy - height) < 2);

            if ((drawTicksOnInside) && (nearTop || nearBottom))
            {
                //---- don't draw this tick ----
            }
            else
            {
                vp.internal.drawHLine(group, daTick, xoff, xoff + myTickLength, yy);
            }

            skipCount++;
            if (skipCount == perGroupCount)
            {
                skipCount = 0;
            }
        }
    }

    xoff += tickLength + tickLabelSpace;

    if (showLabels)
    {
        //---- tick labels ----
        var lastOffset = null;
        var textWidth = szText.width;
        var textHeight = szText.height;
        var labelIndex = 0;
        var skipCount = 0;
        var maxTextWidth = 0;

        for (var i = 0; i < tickOffsets.length; i++)
        {
            if (skipCount == 0)
            {
                var y = Math.round(tickOffsets[i]);

                if (isCategory)
                {
                    var offset = y;

                    if (lastOffset == null)
                    {
                        lastOffset = offset;
                        continue;
                    }

                    y = (offset + lastOffset) / 2;      // draw centered on middle of last & current tick
                    lastOffset = offset;
                }

                var label = labels[labelIndex];
                daBlock.label.textLabel = label;

                var sz = vp.internal.drawText(group, daBlock.label, xoff, yoff + (height - y) + 3,
                    textWidth, null, "left", "center");

                var tw = sz.width;      // width of text just drawn
                if (tw > maxTextWidth)
                {
                    maxTextWidth = tw;
                }
            }

            labelIndex++;

            skipCount++;
            if (skipCount == perGroupCount)
            {
                skipCount = 0;
            }
        }

        //xoff += (szText.width + tickLabelSpace);
        xoff += maxTextWidth;
    }

    //---- axis title ----
    if (name)
    {
        daBlock.title.textLabel = name;

        var left = daBlock.title.left;
        var top = daBlock.title.top;
        var right = daBlock.title.right;
        var bottom = daBlock.title.bottom;

        xoff += tickLabelSpace + 6;

        //---- uses a coulple of fudge factors ----
        //sz = vp.internal.drawText(group, daBlock.title, xoff - 5, yoff + 3, null, height, "left", "center", 90);
        var sz = vp.internal.drawText(group, daBlock.title, xoff + left, yoff + 3 + top, null,
            height, "center", "center", 270);

        //---- add standard tooltip ----
        var ge = group[0];
        var elem = ge.childNodes[ge.childNodes.length - 1];
        vp.dom.title(elem, "The Y-axis represents the data column: " + name);
        elem.id = "yAxis";

        xoff += (left + right + sz.height);       // sz.height is width of rotated text
    }

    group.desiredWidth = xoff;
    group.desiredHeight = height;

    return group;
};


///----------------------------------------------------------------
/// (from chartFrame\buildTopAxis.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/buildTopAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///     - flat helper functions for building a bottom axis.
///-----------------------------------------------------------------------------------------------------------------
vp.buildTopAxis = function (group, width, tickOffsets, labels, szText, isCategory, name, isNameRotated, daBlock, ticksOnly, drawTicksOnInside)
{
    group.clear();

    var yoff = 0;
    var tickLength = daBlock.tick.length;
    var tickLabelSpace = daBlock.tick.spaceToLabel;
    var xMax = width - 1;
    var showLabels = true;
    var showTicks = true;

    if (ticksOnly)
    {
        showLabels = false;
        name = null;
    }
    else
    {
        var labelCount = labels.length;
        if (labelCount * szText.width > 1.3 * width)
        {
            showLabels = false;

            if (labelCount > .15 * width)
            {
                showTicks = false;
            }
        }
    }

    //---- axis title ----
    if (name)
    {
        var sz = vp.internal.drawText(group, daBlock.title, 0, yoff, width, null, name, "vpAxisLabel", "center", "center", 0);
        yoff += sz.width + 10;
    }

    if (showLabels)
    {
        //---- tick labels ----
        var lastOffset = null;
        var labelIndex = 0;

        for (var i = 0; i < tickOffsets.length; i++)
        {
            var x = Math.round(tickOffsets[i]);      

            if (isCategory)
            {
                var offset = x;

                if (lastOffset == null)
                {
                    lastOffset = offset;
                    continue;
                }

                x = (offset + lastOffset) / 2;      // draw centered on middle of last & current tick
                lastOffset = offset;
            }

            var textWidth = szText.width;
            var textHeight = szText.height;

            var actualX = x - textWidth / 2;
            var label = labels[labelIndex++];

            vp.internal.drawText(group, daBlock.label, actualX, yoff, textWidth, textHeight, label, "vpTickLabel", "center", "center");
        }

        yoff += (szText.height + tickLabelSpace);
    }

    yoff += tickLength;

    if (showTicks)
    {
        //---- tick marks ----
        for (var i = 0; i < tickOffsets.length; i++)
        {
            var x = Math.round(tickOffsets[i]);
            var myTickLength = tickLength + 1;

            if (!drawTicksOnInside)
            {
                myTickLength = -myTickLength;
            }

            vp.internal.drawVLine(group, daBlock.tick, yoff, yoff + myTickLength, x, "vpTickMark");
        }
    }


    //---- axis line ----
    vp.internal.drawHLine(group, daBlock.axis, 0, xMax, yoff, "vpAxisLine");

    group.desiredWidth = width;
    group.desiredHeight = yoff;

    return group;
};


///----------------------------------------------------------------
/// (from chartFrame\chartFrame.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/chartFrame.js.  Copyright (c) 2012 Microsoft Corporation.
///     - draws the chart frame (title, axes, legend, grid).
///-----------------------------------------------------------------------------------------------------------------
vp.chartFrameClass = function ()
{
    //---- state variables ----
    var cfGroup;        // the root "g" for the chart frame
    var bgGroup;        // the plotarea background group
    var glGroup;        // the gridlines group
    var title;          // the text of the chart title
    var titleSize;      // the font size of the title (in points)
    var showXGridLines;
    var showYGridLines;
    var gridLineType = undefined;
    var showLeftAxis;
    var showTopAxis;
    var showRightAxis;
    var showBottomAxis;
    var showLeftLabel;
    var showTopLabel;
    var showRightLabel;
    var showBottomLabel;
    var showBoxTicks;       // show ticks only for upper and right axes
    var xAttribute; 
    var yAttribute;
    var fillScale;
    var xData;
    var yData;
    var fillData;
    var plotAreaRect = null;
    var attributes = null;
    var xLabelFit = null;
    var drawTicksOnInside = false;

    var isLegendVisible = undefined;
    var isLegendBoxVisible;
    var useLayersForLegend;
    var legendLabels;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.chartFrame";

    var init = function ()
    {
    }

    closure.gridLinesGroup = function ()
    {
        return glGroup;
    }

    closure.plotAreaBounds = function ()
    {
        return plotAreaRect;
    };

    closure.build = function (root, frameMargins, borderSize, layers, seriesCount)
    {
        //buildScales();

        var x = 0;
        var y = 0;

        var w = root.width();
        var h = root.height();

        var primaryLayer = layers[0];
        var info = primaryLayer.info;

        //---- why is this needed to get margins equal? ----
        x -= 1;
    
        //if (showBoxTicks)
        //{
        //    showRightAxis = true;
        //    showTopAxis = true;
        //}

        var showRight = (showRightAxis || showBoxTicks);
        var showTop = (showTopAxis || showBoxTicks);

        cfGroup = root.append("g")
            .id("chartFrame")

        //---- create now so that bg & grid lines are drawn first, even though we compute their positions last ----
        bgGroup = cfGroup.append("g")
        glGroup = cfGroup.append("g")

        //---- first, apply frame margins ----
        if (frameMargins)
        {
            x += frameMargins.left;
            y += frameMargins.top;

            w -= (frameMargins.left + frameMargins.right);
            h -= (frameMargins.top + frameMargins.bottom);
        }

        var szText = null;

        //---- draw title at top ----
        if (title)
        {
            //---- get THEME drawing attributes for TITLE ----
            var da = vp.session.currentTheme().getDrawingAttributes("chartFrame.title");
            da.textLabel = title;
            da.id = "title";

            if (titleSize !== undefined)
            {
                da.textSize = titleSize;
            }

            //---- use left/top/right/bottom margins from "da" ----
            var tw = w - (da.left + da.right);
            var xoff = x + da.left;

            //---- DRAW TITLE ----
            szText = vp.internal.drawText(cfGroup, da, xoff, y + da.top, tw, null, "center", "bottom");

            var yoff = szText.height + da.top + da.bottom;
            h -= yoff;
            y += yoff;
        }

        //---- draw legend on right ----
        var legendHeight = 0;
        var legendLeft = 0;
        var legendGroup = null;

        var showLegend = isLegendVisible;
        if (showLegend === undefined)
        {
            showLegend = (seriesCount > 1) || ((attributes) && (attributes.length));
        }

        if (showLegend)
        {
            //---- get THEME drawing attributes for LEGEND ----
            var legendTitle = vp.session.currentTheme().getDrawingAttributes("legend.title");
            var key = vp.session.currentTheme().getDrawingAttributes("legend.key");
            var keyText = vp.session.currentTheme().getDrawingAttributes("legend.keyText");
            var box = vp.session.currentTheme().getDrawingAttributes("legend.box");
            var tick = vp.session.currentTheme().getDrawingAttributes("legend.tick");

            var daBlock = { title: legendTitle, key: key, keyText: keyText, box: box, tick: tick };

            legendGroup = vp.buildLegend(cfGroup, attributes, daBlock, layers, seriesCount, isLegendBoxVisible, useLayersForLegend, legendLabels);

            legendLeft = (x + w + 16) - legendGroup.desiredWidth;
            legendHeight = legendGroup.desiredHeight;

            w -= (legendGroup.desiredWidth - 4);
        }

        //---- figure out width/height of plot area, based on presence of 4 axes ----
        var leftWidth = 0;          // width of left axis
        var rightWidth = 0;
        var topHeight = 0;
        var bottomHeight = 0;

        //---- FIRST CALC WIDTHS ----

        //--- always create LEFT axis (but don't always show it) ----
        var leftAxis = vp.visuals.svgAxis()
            .attribute(yAttribute)
            .isLabelVisible(showLeftLabel)
            .daName("yaxis")

        leftWidth = leftAxis.getWidth(cfGroup, w, h, info, showLeftAxis, false, drawTicksOnInside);

        if (!showLeftAxis)
        {
            leftAxis.isAxisVisible(false);
            leftWidth = 0;
        }

        if (showRight)
        {
            var rightAxis = vp.visuals.svgAxis()
                .attribute(yAttribute)
                .axisLocation("right")
                .isLabelVisible(showRightLabel)
                .daName("yaxis")

            rightWidth = rightAxis.getWidth(cfGroup, w, h, info, showRight, showBoxTicks, drawTicksOnInside);
        }

        //---- hide non-plot stuff if plot is too small ----
        var minPlotSize = 10;
        var ww = w - (leftWidth + rightWidth);

        if ((ww < minPlotSize) && (legendGroup))
        {
            //---- hide legend ----
            w += (legendGroup.desiredWidth - 4);
            ww += (legendGroup.desiredWidth - 4);

            legendGroup.remove();           // remove from parent
            legendGroup = null;
        }

        if ((ww < minPlotSize) && (rightAxis))
        {
            //---- hide right axis ----
            rightAxis.isAxisVisible(false);
            ww += rightWidth;
            rightWidth = 0;
        }

        if ((ww < minPlotSize) && (leftAxis.isAxisVisible()))
        {
            //---- hide left axis ----
            leftAxis.isAxisVisible(false);
            ww += leftWidth;
            leftWidth = 0;
        }

        //---- now cacl final width ----
        w -= (leftWidth + rightWidth);

        //---- NOW CALC HEIGHTS ----

        //--- always create BOTTOM axis (but don't always show it) ----
        var bottomAxis = vp.visuals.svgAxis()
           .attribute(xAttribute)
           .axisLocation("bottom")
           .isLabelVisible(showBottomLabel)
           .daName("xaxis")
           .labelFit(xLabelFit)

        bottomHeight = bottomAxis.getHeight(cfGroup, w, h, info, showBottomAxis, false, drawTicksOnInside);

        if (!showBottomAxis)
        {
            bottomAxis.isAxisVisible(false);
            bottomHeight = 0;
        }

        if (showTop)
        {
            var topAxis = vp.visuals.svgAxis()
               .attribute(xAttribute)
               .axisLocation("top")
               .isLabelVisible(showTopLabel)
               .daName("xaxis")

            topHeight = topAxis.getHeight(cfGroup, w, h, info, showTop, showBoxTicks, drawTicksOnInside);
        }

        var hh = h - (topHeight + bottomHeight);
        if ((hh < minPlotSize) && (topAxis))
        {
            //---- hide top axis ----
            topAxis.isAxisVisible(false);
            hh += topHeight;
            topHeight = 0;
        }

        if ((hh < minPlotSize) && (bottomAxis))
        {
            //---- hide bottom axis ----
            bottomAxis.isAxisVisible(false);
            hh += bottomHeight;
            bottomHeight = 0;
        }

        //---- now we can draw all axes ----
        var sideHeight = h - topHeight - bottomHeight;
        //var topBotWidth = w;        // - leftWidth - rightWidth;

        if (topAxis)
        {
            topAxis.draw(cfGroup, x + leftWidth, y, w, topHeight, info, showTop, showBoxTicks, drawTicksOnInside);
        }

        if (bottomAxis)
        {
            bottomAxis.draw(cfGroup, x + leftWidth, y + h - bottomHeight, w, bottomHeight, info, showBottomAxis, false, drawTicksOnInside);
        }

        // w -= (leftWidth + rightWidth);
        h -= (topHeight + bottomHeight);

        //---- now actually draw axes ----
        if (leftAxis)
        {
            leftAxis.draw(cfGroup, x, y + topHeight - .5, leftWidth, sideHeight, info, showLeftAxis, false, drawTicksOnInside);
        }

        if (rightAxis)
        {
            rightAxis.draw(cfGroup, x + leftWidth + w, y + topHeight - .5, rightWidth, sideHeight, info, showRight, showBoxTicks, drawTicksOnInside);
        }

        x += leftWidth;
        y += topHeight;

        if ((w > 0) && (h > 0))
        {
            closure.drawPlotArea(x, y, w, h, leftAxis, bottomAxis, borderSize);
        }

        plotAreaRect = vp.geom.rect(x, y, w, h);

        //---- center legend vertically relative to plot area, but no higher than top of plot area ----
        if (legendGroup)
        {
            var legendTop = y;
            if (legendHeight < h)
            {
                legendTop += (h - legendHeight) / 2;
            }

            legendGroup
                .translate(legendLeft + .5, legendTop - .25)
        }

        //---- move TITLE so that it is centered over plot area (white rect) ----
        if (szText)
        {
            var titleElem = vp.select(cfGroup, "#title");
            if (titleElem)
            {
                var xCenter = x + w / 2 - szText.width/2;
                titleElem.attr("x", xCenter);
            }
        }
    }

    closure.plotAreaRect = function ()
    {
        return plotAreaRect;
    };

    closure.drawPlotArea = function (x, y, w, h, leftAxis, bottomAxis, borderSize)
    {
        bgGroup
            .clear()
            .translate(x, y)
            .id("plotAreaBg")

        glGroup
            .clear()
            .translate(x, y - .5)
            .id("gridLines")

        //---- get THEME drawing attributes for PLOT BG ----
        var da = vp.session.currentTheme().getDrawingAttributes("chartFrame.plotBg");

        if (borderSize !== undefined)
        {
            da.lineSize = borderSize;
        }

        //---- add white rectangle ----
        var rect = bgGroup.append("rect")
            .id("plotBg")
            .attr("x", .5)
            .attr("y", +.5)
            .attr("width", w)
            .attr("height", h)

        vp.internal.applyShapeAttributes(rect, da);

        //---- get THEME drawing attributes for GRID LINES ----
        da = vp.session.currentTheme().getDrawingAttributes("chartFrame.gridLines");
        da.id = "gridLine";

        if (gridLineType != undefined)
        {
            da.lineType = gridLineType;
        }

        if (showYGridLines)
        {
            var hTickOffsets = null;
            if (leftAxis)
            {
                hTickOffsets = leftAxis.tickOffsets();

                if (hTickOffsets.length > .15 * h)
                {
                    hTickOffsets = null;        // hide horizontal gridlines  (too busy)
                }
            }

            if (hTickOffsets)
            {
                //vp.utils.debug("drawing gridlines with width=" + w);

                //---- draw horizontal gridlines ----
                for (var t = 0; t < hTickOffsets.length; t++)
                {
                    var yy = Math.round(hTickOffsets[t]);

                    //---- draw horizontal grid line ----
                    vp.internal.drawHLine(glGroup, da, 0, w, (h - yy), da);
                }
            }
        }

        if (showXGridLines)
        {
            var vTickOffsets = null;
            if (bottomAxis)
            {
                vTickOffsets = bottomAxis.tickOffsets();

                if (vTickOffsets.length > .15 * w)
                {
                    vTickOffsets = null;        // hide vertical gridlines  (too busy)
                }

            }

            if (vTickOffsets)
            {
                //---- draw vertical gridlines ----
                for (var v = 0; v < vTickOffsets.length; v++)
                {
                    var xx = Math.round(vTickOffsets[v]);

                    //---- draw vertical grid line ----
                    vp.internal.drawVLine(glGroup, da, 0, h, xx, da);
                }
            }
        }

        da.id = "plotBorder";

        //---- draw frame around grid ----
        //vp.internal.drawHLine(glGroup, da, 0, w, 0, da);
        //vp.internal.drawHLine(glGroup, da, 0, w, h, da);
        //vp.internal.drawVLine(glGroup, da, 0, h, 0, da);
        //vp.internal.drawVLine(glGroup, da, 0, h, w-1, da);
    }

    //---- public property: title ----
    closure.title = function (value)
    {
        if (arguments.length == 0)
        {
            return title;
        }

        title = value;
        return closure;
    };


    //---- public property: titleSize ----
    closure.titleSize = function (value)
    {
        if (arguments.length == 0)
        {
            return titleSize;
        }

        titleSize = value;
        return closure;
    };

    //---- public property: xLabelFit ---- 
    closure.xLabelFit = function (value)
    {
        if (arguments.length == 0)
        {
            return xLabelFit;
        }

        xLabelFit = value;
        return closure;
    };

    //---- public property: showXGridLines ---- 
    closure.showXGridLines = function (value)
    {
        if (arguments.length == 0)
        {
            return showXGridLines;
        }

        showXGridLines = value;
        return closure;
    };

    //---- public property: gridLineType ---- 
    closure.gridLineType = function (value)
    {
        if (arguments.length == 0)
        {
            return gridLineType;
        }

        gridLineType = value;
        return closure;
    };

    //---- public property: showYGridLines ---- 
    closure.showYGridLines = function (value)
    {
        if (arguments.length == 0)
        {
            return showYGridLines;
        }

        showYGridLines = value;
        return closure;
    };

    //---- public property: isLegendVisible ----
    closure.isLegendVisible = function (value)
    {
        if (arguments.length == 0)
        {
            return isLegendVisible;
        }

        isLegendVisible = value;
        return closure;
    };

    //---- public property: isLegendBoxVisible ----
    closure.isLegendBoxVisible = function (value)
    {
        if (arguments.length == 0)
        {
            return isLegendBoxVisible;
        }

        isLegendBoxVisible = value;
        return closure;
    };

    //---- public property: useLayersForLegend ----
    closure.useLayersForLegend = function (value)
    {
        if (arguments.length == 0)
        {
            return useLayersForLegend;
        }

        useLayersForLegend = value;
        return closure;
    };

    //---- public property: legendLabels ----
    closure.legendLabels = function (value)
    {
        if (arguments.length == 0)
        {
            return legendLabels;
        }

        legendLabels = value;
        return closure;
    };

    //---- public property: showLeftAxis ----
    closure.showLeftAxis = function (value)
    {
        if (arguments.length == 0)
        {
            return showLeftAxis;
        }

        showLeftAxis = value;
        return closure;
    };

    //---- public property: showTopAxis ----
    closure.showTopAxis = function (value)
    {
        if (arguments.length == 0)
        {
            return showTopAxis;
        }

        showTopAxis = value;
        return closure;
    };

    //---- public property: showBoxTicks ----
    closure.showBoxTicks = function (value)
    {
        if (arguments.length == 0)
        {
            return showBoxTicks;
        }

        showBoxTicks = value;
        return closure;
    };

    //---- public property: showRightAxis ----
    closure.showRightAxis = function (value)
    {
        if (arguments.length == 0)
        {
            return showRightAxis;
        }

        showRightAxis = value;
        return closure;
    };

    //---- public property: showBottomAxis ----
    closure.showBottomAxis = function (value)
    {
        if (arguments.length == 0)
        {
            return showBottomAxis;
        }

        showBottomAxis = value;
        return closure;
    };

    //---- public property: dataFrame ----
    //closure.dataFrame = function (value)
    //{
    //    if (arguments.length == 0)
    //    {
    //        return dataFrame;
    //    }

    //    dataFrame = value;
    //    return closure;
    //};

    ////---- public property: mappings ----
    //closure.mappings = function (value)
    //{
    //    if (arguments.length == 0)
    //    {
    //        return mappings;
    //    }

    //    mappings = value;
    //    return closure;
    //};

    //---- public property: showLeftLabel ----
    closure.showLeftLabel = function (value)
    {
        if (arguments.length == 0)
        {
            return showLeftLabel;
        }

        showLeftLabel = value;
        return closure;
    };

    //---- public property: showRightLabel ----
    closure.showRightLabel = function (value)
    {
        if (arguments.length == 0)
        {
            return showRightLabel;
        }

        showRightLabel = value;
        return closure;
    };
    //---- public property: showTopLabel ----
    closure.showTopLabel = function (value)
    {
        if (arguments.length == 0)
        {
            return showTopLabel;
        }

        showTopLabel = value;
        return closure;
    };

    //---- public property: showBottomLabel ----
    closure.showBottomLabel = function (value)
    {
        if (arguments.length == 0)
        {
            return showBottomLabel;
        }

        showBottomLabel = value;
        return closure;
    };

    //---- public property: drawTicksOnInside ----
    closure.drawTicksOnInside = function (value)
    {
        if (arguments.length == 0)
        {
            return drawTicksOnInside;
        }

        drawTicksOnInside = value;
        return closure;
    };

    //---- public property: xAttribute ----
    closure.xAttribute = function (value)
    {
        if (arguments.length == 0)
        {
            return xAttribute;
        }

        xAttribute = value;
        return closure;
    };

    //---- public property: yAttribute ----
    closure.yAttribute = function (value)
    {
        if (arguments.length == 0)
        {
            return yAttribute;
        }

        yAttribute = value;
        return closure;
    };

    //---- public property: attributes ----
    closure.attributes = function (value)
    {
        if (arguments.length == 0)
        {
            return attributes;
        }

        attributes = value;
        return closure;
    };

    //---- init code ----
    init();

    return closure;
};

vp.visuals.createChartFrame = function ()
{
    return new vp.chartFrameClass();
};

///----------------------------------------------------------------
/// (from chartFrame\svgAxis.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// svgAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///     - implements a continuous (linear) OR discrete (category) axis for left/top/right/bottom positions.
///-----------------------------------------------------------------------------------------------------------------
/// create an SVG-based numeric axis control and return a closure object for it.
///
/// This represents a axis:
///     - axis line
///     - tick marks
///     - tick labels
///
/// Requirements:
///     - stretch to specified height
///     - output a minimum width
///     - base tickmarks & labels on its member scale
///     - hide tick marks if they exceed a maximum
///     - hide labels if not enough room
///     - provide optional label rotation
///
/// Css style-able elements:
///     - label: font, color
///     - tick mark: tickWidth, strokeWidth, stroke, strokeStyle
///     - axis line: strokeWidth, stroke, strokeStyle
///-----------------------------------------------------------------------------------------------------------------
/// testing: see svgAxis.html
///-----------------------------------------------------------------------------------------------------------------
vp.visuals.svgAxis = function ()
{
    //---- private state ----
    var tickLength = 4;     // length of a tick mark
    var labelSpace = 3;     // space between tick and label

    var labelStrings = [];
    var labelWidths = [];
    var axisLocation = vp.axisLocation.left;
    var totalLabelWidths = 0;
    var totalLabelHeights = 0;
    var dataCount = 0;
    var isAxisVisible = true;
    var isLabelVisible = true;
    var showTicks = true;

    var maxStringWidth = 0;
    var maxStringHeight = 0;
    var timer = null;
    var changingSize = false;
    var daName;             // name used to retreive theme information
    var daBlock;            // holds da's for all axis parts 

    var group = undefined;
    var breaks = undefined;
    var tickOffsets = undefined;
    var autoHideLabels = false;
    var autoHideTicks = false;
    var labelFit = undefined;

    //---- myAttribute is the attribute object associated with this axis (MUST be set by caller) ----
    var myAttribute = null;
    var myScale = null;

    /// closure
    var closure = function ()
    {
    };

    closure.ctr = "vp.visuals.svgAxis";

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "scale");
        vp.makeControlProperty(wrapper, "axisLocation");
        vp.makeControlProperty(wrapper, "isAxisVisible");
    };

    /// private: onDataChanged().
    var onDataChanged = function ()
    {
        onTextChanged();
    }

    /// private: onTextChanged().
    var onTextChanged = function ()
    {
        //buildLabelStringsAndSizes();
        markRebuildNeeded();
    }

    /// private.
    var markRebuildNeeded = function ()
    {
        //if (timer == null)
        //{
        //    timer = setTimeout(build, 1);
        //}
    };

    /// private.
    var pixelAlign = function (value)
    {
        return Math.round(value);
    };

    //---- public property: labelFit ---- 
    closure.labelFit = function (value)
    {
        if (arguments.length == 0)
        {
            return labelFit;
        }

        labelFit = value;
        return closure;
    };

    closure.getDaBlock = function()
    {
        return daBlock;
    }

    /// private.
    var buildLabelStringsAndSizes = function (breakValues, showAxis, width, truncateIfNeeded)
    {
        labelStrings = [];
        labelWidths = [];

        maxStringWidth = 0;
        maxStringHeight = 0;
        totalLabelWidths = 0;
        totalLabelHeights = 0;
        dataCount = 0;
        
        if (showAxis)
        {
            var scaleLabels = myAttribute.getActualLabels(breakValues);

            //---- create a single SVG TEXT element for measuring all of our strings ----
            var fakeLabel = group.append("text")

            var da = daBlock.label;
            vp.internal.applyTextAttributes(fakeLabel, da);

            var maxLabelWidth = (truncateIfNeeded && scaleLabels.length) ? (width / scaleLabels.length) : 0;

            scaleLabels.map(function (value, index)
            {
                //var formatFunc = myAttribute.getActualFormatter();
                //var labelStr = null;

                //if (scaleLabels)
                //{
                //    labelStr = scaleLabels[index];
                //}
                //else
                //{
                //    labelStr = formatFunc(value);
                //}

                var labelStr = value;

                //---- set up for measuring "labelStr" ----
                fakeLabel.text(labelStr);

                var width = Math.ceil(fakeLabel.width());
                var height = Math.ceil(fakeLabel.height());

                if ((maxLabelWidth) && (width > maxLabelWidth))
                {
                    //---- label is too big - truncate it ----
                    var ret = truncateLabelToFit(labelStr, maxLabelWidth, fakeLabel);

                    width = ret.width;
                    labelStr = { label: ret.labelStr, fullLabel: value };
                }

                labelStrings.push(labelStr);

                if (width > maxStringWidth)
                {
                    maxStringWidth = width;
                }

                if (height > maxStringHeight)
                {
                    maxStringHeight = height;
                }

                labelWidths.push(width);
                dataCount++;
            });

            totalLabelWidths = maxStringWidth * dataCount;
            totalLabelHeights = maxStringHeight * dataCount;

            //---- remove temp label created above ----
            fakeLabel.remove();
        }
    }

    var truncateLabelToFit = function(labelStr, maxLabelWidth, fakeLabel)
    {
        var text = labelStr;
        var width = 0;

        while (text.length)
        {
            //---- remove last char ----
            text = text.substr(0, text.length - 1);

            labelStr = text + "...";

            //---- measure ----
            fakeLabel.text(labelStr);
            width = Math.ceil(fakeLabel.width());
            if (width <= maxLabelWidth)
            {
                break;
            }
        }

        return { width: width, labelStr: labelStr};
    }

    closure.buildPrep = function (parentGroup, width, height, info, showAxis, truncateIfNeeded, ticksOnly)
    {
        if (!group)
        {
            group = parentGroup.append("g"); 
        }

        closure.updateAutoRangeScale(width, height);

        //---- build "breaks" ----
        breaks = myAttribute.getActualBreaks();

        //---- build "tickOffsets" ----
        tickOffsets = [];           // list of normalized offsets of each tick mark

        var range = myScale.palette();
        var rangeMin = range[0];
        var rangeMax = range[1];
        
        var rangeRange = rangeMax - rangeMin;
        rangeRange = (rangeRange == 0) ? 1 : rangeRange;

        //---- this code allows for just putting ticks around breaks ----
        if (myAttribute.getActualIsDiscrete())           // && (! myAttribute.mergeDuplicateCategories()))
        {
            //---- discrete axis has 1 extra tick at end but this is included in "breaks" ----
            for (var i = 0; i < breaks.length; i++)
            {
                var breakValue = breaks[i];
                var tickOff = myScale.scale(breakValue, -1, true);       // supress bar offset
                tickOffsets.push(tickOff);
            }
        }
        else
        {
            for (var i = 0; i < breaks.length; i++)
            {
                var breakValue = breaks[i];
                var offset = myScale.scale(breakValue);
                tickOffsets.push(offset);
            }
        }

        //---- build "labels" and "szText" ----
        buildLabelStringsAndSizes(breaks, showAxis, width, truncateIfNeeded);
    }

    closure.drawCore = function (parentGroup, width, height, info, showAxis, ticksOnly, drawTicksOnInside)
    {
        //---- always call buildPrep (performs some needed side effects) ----
        var drawOnBottom = ((axisLocation == vp.axisLocation.bottom) || (axisLocation == "bottom"));
        if (labelFit === undefined)
        {
            //---- figure out best default ----
            labelFit = vp.visuals.LabelFit.skip;

            if (drawOnBottom)
            {
                var isCategory = myAttribute.getActualIsDiscrete();   
                if (isCategory)
                {
                    labelFit = vp.visuals.LabelFit.rotateAuto;
                }
            }
        }

        var truncateIfNeeded = ((drawOnBottom) && (labelFit == 2));     // truncate

        closure.buildPrep(parentGroup, width, height, info, showAxis, truncateIfNeeded, ticksOnly);

        if (showAxis)
        {
            var szText = { width: maxStringWidth, height: maxStringHeight };
            var name = (isLabelVisible) ? myAttribute.title() : null;

            var isCategory = myAttribute.getActualIsDiscrete();     // && (!myAttribute.mergeDuplicateCategories()));

            if ((width <= 0) || (height <= 0))
            {
                group.clear();
                group.desiredWidth = 0;
                group.desiredHeight = 0;
            }
            else if ((axisLocation == vp.axisLocation.left) || (axisLocation == "left"))
            {
                vp.buildLeftAxis(group, height, tickOffsets, labelStrings, szText, isCategory, name,
                    true, daBlock, autoHideLabels, autoHideTicks, drawTicksOnInside);
                group.id("leftAxis");
            }
            else if ((axisLocation == vp.axisLocation.right) || (axisLocation == "right"))
            {
                vp.buildRightAxis(group, height, tickOffsets, labelStrings, szText, isCategory, name, true, daBlock, autoHideLabels, autoHideTicks,
                    ticksOnly, drawTicksOnInside, showTicks);
                group.id("rightAxis");
            }
            else if ((axisLocation == vp.axisLocation.top) || (axisLocation == "top"))
            {
                vp.buildTopAxis(group, width, tickOffsets, labelStrings, szText, isCategory, name, false, daBlock, ticksOnly, drawTicksOnInside);
                group.id("topAxis");
            }
            else if (drawOnBottom)
            {
                vp.buildBottomAxis(group, width, tickOffsets, labelStrings, szText, isCategory, name,
                    false, daBlock, autoHideLabels, autoHideTicks, labelFit, drawTicksOnInside);
                group.id("bottomAxis");
            }
        }
    };

    closure.getWidth = function (parentGroup, width, height, info, showAxis, ticksOnly, drawTicksOnInside)
    {
        if (showAxis === undefined)
        {
            showAxis = true;
        }

        closure.drawCore(parentGroup, width, height, info, showAxis, ticksOnly, drawTicksOnInside);

        return (showAxis) ? group.desiredWidth : 0;
    }

    closure.getHeight = function (parentGroup, width, height, info, showAxis, ticksOnly, drawTicksOnInside)
    {
        if (showAxis === undefined)
        {
            showAxis = true;
        }

        closure.drawCore(parentGroup, width, height, info, showAxis, ticksOnly, drawTicksOnInside);

        return (showAxis) ? group.desiredHeight : 0;
    }

    closure.draw = function (parentGroup, x, y, width, height, info, showAxis, ticksOnly, drawTicksOnInside)
    {
        if (showAxis === undefined)
        {
            showAxis = true;
        }

        closure.drawCore(parentGroup, width, height, info, showAxis, ticksOnly, drawTicksOnInside);

        group
            //.transform("translate(" + x + "," + y + ")");
            .translate(x, y)
    }

    var elementResized = function (e)
    {
        if (!changingSize)
        {
            //---- update auto range scale so dependent parts get correct scaling ----
            //updateAutoRangeScale();       // need to get width, height ...
        }
    };

    closure.updateAutoRangeScale = function (width, height)
    {
        if (myScale.autoRange && myScale.autoRange())
        {
            var isVertical = ((axisLocation == vp.axisLocation.left) || (axisLocation == "left")
                || (axisLocation == vp.axisLocation.right) || (axisLocation == "right"));

            var size = (isVertical) ? height : width;

            myScale
                .rangeMin(0)
                .rangeMax(size)
        }
    };

    closure.element = function ()
    {
        return rootElem;
    };

    //---- property: attribute ----
    closure.attribute = function (value)
    {
        if (value === undefined)
        {
            return myAttribute;
        }

        myAttribute = value;
        myScale = value.scale();
        //updateAutoRangeScale();

        return closure;
    };

    //---- property: axisLocation ----
    closure.axisLocation = function (value)
    {
        if (value === undefined)
        {
            return axisLocation;
        }

        axisLocation = value;
        markRebuildNeeded();

        return closure;
    };

    //---- property: isAxisVisible ----
    closure.isAxisVisible = function (value)
    {
        if (value === undefined)
        {
            return isAxisVisible;
        }

        isAxisVisible = value;
        if (group)
        {
            group.remove();     // remove from parent
        }

        markRebuildNeeded();

        return closure;
    };

    //---- READONLY property: tickOffsets ----
    closure.tickOffsets = function (value)
    {
        return tickOffsets;
    };

    //---- property: isLabelVisible ----
    closure.isLabelVisible = function (value)
    {
        if (arguments.length === 0)
        {
            return isLabelVisible;
        }

        isLabelVisible = value;
        return closure;
    };

    //---- property: showTicks ----
    closure.showTicks = function (value)
    {
        if (arguments.length === 0)
        {
            return showTicks;
        }

        showTicks = value;
        return closure;
    };

    //---- property: daName ----
    closure.daName = function (value)
    {
        if (arguments.length === 0)
        {
            return daName;
        }

        daName = value;
        onDaNameChanged();

        return closure;
    };

    var onDaNameChanged = function()
    {
        var theme = vp.session.currentTheme();

        var daTick = theme.getDrawingAttributes(daName + ".tick");
        var daSkipTick = theme.getDrawingAttributes(daName + ".skipTick");
        var daLabel = theme.getDrawingAttributes(daName + ".label");
        var daTitle = theme.getDrawingAttributes(daName + ".title");
        var daAxis = theme.getDrawingAttributes(daName + ".axisLine");

        daBlock = { tick: daTick, skipTick: daSkipTick, label: daLabel, title: daTitle, axis: daAxis };
    }

    return closure;
};

//---- enum: axisLocation ----
vp.axisLocation = { left: 0, top: 1, right: 2, bottom: 3 };

///----------------------------------------------------------------
/// (from chartFrame\svgDraw.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// /vuePlot/vvPlot/svgDraw.ts.  Copyright (c) 2014 Microsoft Corporation.
///     - flat helper functions for drawing lines and text.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (internal) {
        internal.textElemJustDrawn = null;

        function validateDa(da) {
            if ((!da) || (da.isThemeAttr === undefined)) {
                vp.utils.error("Invalid 'da' ('isThemeAttr' property not set): " + da);
            }
        }

        function drawText(group, da, x, y, width, height, halign, valign, rotation, cxRot, cyRot) {
            validateDa(da);

            cxRot = (cxRot === undefined) ? .5 : cxRot;
            cyRot = (cyRot === undefined) ? .5 : cyRot;

            var elem = group.append("text");

            applyTextAttributes(elem, da, false);

            //---- get UNROTATED size ----
            var rect = vp.dom.getBounds(elem[0]);
            var sz = { width: rect.width, height: rect.height };

            var origSz = sz;
            var origX = x;
            var origY = y;

            if (rotation) {
                elem.transform("rotate(" + rotation + ")");

                //---- get ROTATED size ----
                rect = vp.dom.getBounds(elem[0]);
                sz = { width: rect.width, height: rect.height };
            }

            halign = (halign === undefined) ? "left" : halign;
            valign = (valign === undefined) ? "center" : valign;

            if (!width) {
                //---- align to (x,y) ----
                if (halign === "center") {
                    x -= origSz.width / 2;
                } else if (halign == "right") {
                    x -= origSz.width;
                } else if (halign == "left") {
                    //---- this is the SVG default ----
                }
            } else {
                //---- align within (x, y, width, height) ----
                if (halign === "center") {
                    var xoff = Math.max(0, (width - origSz.width) / 2);
                    x += xoff;
                } else if (halign == "right") {
                    var xoff = Math.max(0, (width - origSz.width));
                    x += xoff;
                } else if (halign == "left") {
                    //---- this is the SVG default ----
                }
            }

            /// for vertical alignment, SVG defaults to writing the text on top of the
            /// line at "y" with descenders hanging down.
            /// this adjusts the text is vertically centered on the y line --
            if (true) {
                //if (Math.abs(rotation) > 0)
                //{
                //    x += (.30 * sz.width);       // adjust text to be just under middle line
                //}
                //else
                //{
                //    y += (.30 * sz.height);       // adjust text to be just under middle line
                //}
            }

            if (!height) {
                //---- align to (x,y) ----
                if (valign === "bottom") {
                    y += origSz.height / 2;
                } else if (valign == "top") {
                    y -= origSz.height / 2;
                } else if (valign == "center") {
                    //---- this is the SVG default ----
                }
            } else {
                //---- align within (x, y, width, height) ----
                if (valign == "top") {
                    y += origSz.height / 2;
                } else if (valign == "center") {
                    y += height / 2;
                } else if (valign === "bottom") {
                    y += (height - origSz.height / 2);
                }
            }

            y += .15 * origSz.height; // asthetic adjustment

            elem.attr("x", x).attr("y", y);

            if (rotation) {
                //---- set the actual transform ----
                //---- rotation point ----
                var cx = x + (cxRot * origSz.width);
                var cy = y + ((cyRot - 1) * origSz.height);

                cy += .15 * origSz.height; // asthetic adjustment

                elem.transform("rotate(" + rotation + "," + cx + "," + cy + ")");
                //---- debug - create small rect at rotation center ----
                //group.append("rect")
                //    .bounds(origX+1, y+1, 2, 2)
                //    .colors("blue")
                //group.append("rect")
                //    //.bounds(x + 1 + origSz.width / 2, y + 1 - origSz.height / 2, 2, 2)
                //    .bounds(cx + 1, cy + 1, 2, 2)
                //    .colors("red")
                //elem.transform("")
            }

            internal.textElemJustDrawn = elem;

            return sz;
        }
        internal.drawText = drawText;

        function drawHLine(group, da, x1, x2, y) {
            validateDa(da);

            x1 = Math.round(x1);
            x2 = Math.round(x2);
            y = Math.round(y);

            var line = group.append("line").attr("x1", x1).attr("x2", x2).attr("y1", y + .5).attr("y2", y + .5).attr("shape-rendering", "crispEdges");

            applyLineAttributes(line, da);
            //var rect = group.append("rect")
            //   .attr("x", x1)
            //   .attr("y", y + .5)
            //   .attr("width", x2-x1)
            //   .attr("height", da.lineSize)
            //   .attr("shape-rendering", "crispEdges")
            //   .attr("fill", da.fill)
        }
        internal.drawHLine = drawHLine;

        function drawVLine(group, da, y1, y2, x) {
            validateDa(da);

            y1 = Math.round(y1);
            y2 = Math.round(y2);
            x = Math.round(x);

            var line = group.append("line").attr("x1", x + .5).attr("x2", x + .5).attr("y1", y1).attr("y2", y2).attr("shape-rendering", "crispEdges");

            applyLineAttributes(line, da);
            //var rect = group.append("rect")
            // .attr("x", x)
            // .attr("y", y1 + .5)
            // .attr("width", da.lineSize)
            // .attr("height", y2-y1)
            // .attr("shape-rendering", "crispEdges")
            // .attr("fill", da.fill)
        }
        internal.drawVLine = drawVLine;

        function getFirstItem(value, isColor) {
            //---- this block no longer needed since theme "fill" and "stroke" values are now single colors only ----
            //if (vp.utils.isString(value))
            //{
            //}
            //else if (vp.utils.isArray(value))
            //{
            //    var item0 = value[0];
            //    if ((! isColor) || (!vp.utils.isNumber(item0)))
            //    {
            //        value = item0;
            //    }
            //}
            if ((isColor) && (!vp.utils.isString(value)) && (vp.utils.isArray(value))) {
                value = vp.color.toColor(value);
            }

            return value;
        }

        /// apply constant/mapped attributes specifed in "da" to a text element.
        /// we check for "undefined" to keep things fast & lightweight (in terms on resulting elements).
        function applyTextAttributes(elem, da, alignText, hAdjust, vAdjust) {
            if (typeof alignText === "undefined") { alignText = true; }
            validateDa(da);

            //---- FILL ----
            if (da.textFill !== undefined) {
                var fillValue = getFirstItem(da.textFill, true);

                elem.attr("fill", fillValue);

                /// Note: using elem.setAttribute() for custom props sometimes results in NaN values, so we set directly as prop on elem.
                elem[0].origFill = fillValue;
            }

            //---- OPACITY ----
            if (da.opacity !== undefined) {
                elem.attr("opacity", da.opacity);

                elem[0].origOpacity = da.opacity;
            }

            //---- TEXT SIZE ----
            if (da.textSize !== undefined) {
                elem.attr("font-size", da.textSize);
            }

            //---- FONT FAMILY ----
            if (da.fontFamily !== undefined) {
                elem.attr("font-family", da.fontFamily);
            }

            if (da.fontWeight !== undefined) {
                elem.attr("font-weight", da.fontWeight);
            }

            //---- TEXT LABEL ----
            if (da.textLabel !== undefined) {
                elem.text(da.textLabel);
            }

            if (alignText) {
                //---- HALIGN, VALIGN ----
                var hAlign = da.hAlign;
                if (hAdjust) {
                    hAlign = hAdjust.value + (hAdjust.sign * hAlign);
                }

                var vAlign = da.vAlign;
                if (vAdjust) {
                    vAlign = vAdjust.value + (vAdjust.sign * vAlign);
                }

                var adjust = calculateTextAdjust(elem, hAlign, vAlign);
                elem.attr("dx", adjust.x);
                elem.attr("dy", adjust.y);
                //---- the below code is for reference - a method for adjust text without us doing the measurement ----
                //.attr("text-anchor", "middle")
                //.attr("dy", ".5ex")       // "ex" unit is height of "e" char
            }

            if (da.id) {
                elem.id(da.id);
            }
        }
        internal.applyTextAttributes = applyTextAttributes;

        /// use the "hAlign" and "vAlign" property values to calculate the x/y adjustment
        /// needed for the text. requires the text element with the final text applied to it
        /// (and it should be attached to the document) so that it can be correctly measured.
        ///
        /// return the adjustment as a {x, y} object.
        function calculateTextAdjust(textElem, hAlign, vAlign) {
            var hvals = { left: 0, middle: .5, right: 1 };
            var vvals = { top: 1, middle: .5, bottom: 0 };
            var adjust = { x: 0, y: 0 };

            if (textElem) {
                //---- HALIGN ----
                if (hvals[hAlign]) {
                    hAlign = hvals[hAlign];
                }

                //---- VALIGN ----
                if (vvals[vAlign]) {
                    vAlign = vvals[vAlign];
                }

                var uelem = (textElem.length) ? textElem[0] : textElem;
                var bb = vp.dom.getBounds(uelem);

                //---- horizontal alignment defaults to: text starts at "x" ----
                adjust.x = -(bb.width * hAlign);

                //---- UNROATED TEXT: vertical alignment defaults to: CENTER LINE of text is at "y" ----
                adjust.y = (1 - .25 - vAlign) * bb.height; // the ".25" is an asthetic adjustment for vertical alignment
            }

            return adjust;
        }
        internal.calculateTextAdjust = calculateTextAdjust;

        function applyShapeAttributes(elem, da) {
            applyShapeAttributesU(elem[0], da);
            //vp.validateDa(da);
            ////---- SHAPE and SHAPE SIZE are not handled here since they requires special processing.  ----
            ////---- see layerPoint.js for example ----
        }
        internal.applyShapeAttributes = applyShapeAttributes;

        function applyShapeAttributesU(uelem, da) {
            validateDa(da);

            //---- SHAPE and SHAPE SIZE are not handled here since they requires special processing.  ----
            //---- see layerPoint.js for example ----
            //---- FILL ----
            if (da.fill !== undefined) {
                var fillValue = getFirstItem(da.fill, true);

                vp.dom.attr(uelem, "fill", fillValue);

                uelem.origFill = fillValue;
            }

            //---- STROKE ----
            if (da.stroke !== undefined) {
                var strokeValue = getFirstItem(da.stroke, true);

                vp.dom.attr(uelem, "stroke", strokeValue);

                uelem.origStroke = strokeValue;
            }

            //---- OPACITY ----
            if (da.opacity !== undefined) {
                vp.dom.attr(uelem, "opacity", da.opacity);
                uelem.origOpacity = da.opacity;
            }

            //---- LINE TYPE ----
            if (da.lineType !== undefined) {
                var lineType = lineTypeToDashArray(da.lineType);
                vp.dom.attr(uelem, "stroke-dasharray", lineType);
            }

            if (da.lineSize !== undefined) {
                vp.dom.attr(uelem, "stroke-width", da.lineSize);
            }

            if (da.id) {
                vp.dom.id(uelem, da.id);
            }

            if (uelem.tagName == "rect") {
                //---- check for rx/ry attributes ----
                if ((da.rx) || (da.ry)) {
                    vp.dom.attr(uelem, "rx", da.rx);
                    vp.dom.attr(uelem, "ry", da.ry);
                }
                //---- causing severe problems during animation; turn OFF for now ----
                ////---- adjust bounds of RECT to SNAP TO PIXELS ----
                //var noBorder = (!da.lineSize);
                //var x = Math.round(elem.attr("x"));
                //var y = Math.round(elem.attr("y"));
                //var w = Math.round(elem.attr("width"));
                //var h = Math.round(elem.attr("height"));
                //if (noBorder)
                //{
                //    h -= .25;
                //}
                //else
                //{
                //    x += .5;
                //    y += .5;
                //    w -= 1;
                //    h -= 1.25;
                //}
                //elem.attr("x", x);
                //elem.attr("y", y);
                //elem.attr("width", w);
                //elem.attr("height", h);
            }
        }
        internal.applyShapeAttributesU = applyShapeAttributesU;

        function applyLineAttributes(elem, da) {
            applyLineAttributesU(elem[0], da);
        }
        internal.applyLineAttributes = applyLineAttributes;

        /// apply constant/mapped attributes specifed in "da" to line element.
        /// we check for "undefined" to keep things fast & lightweight (in terms on resulting elements).
        function applyLineAttributesU(uelem, da) {
            validateDa(da);

            //---- STROKE ----
            if (da.stroke !== undefined) {
                var strokeValue = getFirstItem(da.stroke, true);

                vp.dom.attr(uelem, "stroke", strokeValue);
                uelem.origStroke = strokeValue;
            }

            //---- OPACITY ----
            if (da.opacity !== undefined) {
                vp.dom.attr(uelem, "opacity", da.opacity);
                uelem.origOpacity = da.opacity;
            }

            //---- LINE TYPE ----
            if (da.lineType !== undefined) {
                var lineType = lineTypeToDashArray(da.lineType);
                vp.dom.attr(uelem, "stroke-dasharray", lineType);
            }

            if (da.lineSize === undefined) {
                da.lineSize = 1;
            }

            vp.dom.attr(uelem, "stroke-width", da.lineSize);
            uelem.origStrokeWidth = da.lineSize;

            if (da.id) {
                vp.dom.id(uelem, da.id);
            }
        }
        internal.applyLineAttributesU = applyLineAttributesU;

        function drawBox(group, da, x, y, w, h) {
            validateDa(da);

            var rect = group.append("rect").position(x, y).width(w).height(h);

            applyShapeAttributes(rect, da);

            return rect;
        }
        internal.drawBox = drawBox;

        function lineTypeToDashArray(lineType) {
            ///
            /// TODO: merge with definition of lineType in vuePlotTypes.ts
            ///
            var lt = (vp.utils.isString(lineType)) ? lineType.toLowerCase() : lineType;
            var value = "";

            if ((lt === "blank") || (lt === 0)) {
                value = "0, 10";
            } else if ((lt === "solid") || (lt === 1)) {
                value = "";
            } else if ((lt === "dashed") || (lt === 2)) {
                value = "4, 4";
            } else if ((lt === "dotted") || (lt === 3)) {
                value = "1, 3";
            } else if ((lt === "dotdash") || (lt === 4)) {
                value = "1, 3, 4, 4";
            } else if ((lt === "longdash") || (lt === 5)) {
                value = "7, 3";
            } else if ((lt === "twodash") || (lt === 6)) {
                value = "2, 2, 6, 2";
            } else {
                //---- leave alone (let call specify on/off pattern in a string) ----
                value = lt;
            }

            return value;
        }
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));
//# sourceMappingURL=svgDraw.js.map
///-----------------------------------------------------------------------------------------------------------------
/// adaptStatFuncs.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - statistic functions.
///-----------------------------------------------------------------------------------------------------------------

/// adapted from: http://en.wikipedia.org/wiki/Normal_distribution
vp.normalPDF = function (mean, varSq, xFrom, xTo, xIncr)
    /// vp.normalPDF(mean, varSq, xFrom, xTo, xIncr)
    /// - generates data for a gaussian (normal) probability distribution function.
{
    if (xFrom === undefined)
    {
        xFrom = -5;
    }

    if (xTo === undefined)
    {
        xTo = -xFrom;
    }

    if (xIncr === undefined)
    {
        xIncr = .05;
    }

    var variance = Math.sqrt(varSq);
    var dd = variance * Math.sqrt(2 * Math.PI)
    var records = [];

    for (var x = xFrom; x <= xTo; x += xIncr)
    {
        var xx = (x - mean) / variance;
        var y = (1 / dd) * Math.exp(xx * xx * -.5);

        var rec = { x: x, y: y };
        records.push(rec);
    }

    return records;
};

/// the error function, adapted from: http://en.wikipedia.org/wiki/Error_function
vp.erf = function (x)
{
    var p = .3275911;
    var a1 = .254829592;
    var a2 = -.284496736
    var a3 = 1.421413741;
    var a4 = -1.453152027;
    var a5 = 1.061405429;

    var xAbs = (x >= 0) ? x : -x;

    var t = 1 / (1 + p * xAbs);
    var t2 = t * t;
    var t3 = t2 * t;
    var t4 = t2 * t2;
    var t5 = t4 * t;

    var value = 1 - (a1 * t + a2 * t2 + a3 * t3 + a4 * t4 + a5 * t5) * Math.exp(-(xAbs * xAbs));

    if (x < 0)
    {
        value = -value;
    }

    return value;
};


/// adapted from: http://en.wikipedia.org/wiki/Normal_distribution
vp.normalCDF = function (mean, varSq, xFrom, xTo, xIncr)
{
    if (xFrom === undefined)
    {
        xFrom = -5;
    }

    if (xTo === undefined)
    {
        xTo = -xFrom;
    }

    if (xIncr === undefined)
    {
        xIncr = .05;
    }

    var variance = Math.sqrt(varSq);
    var dd = variance * Math.sqrt(2 * Math.PI)
    var records = [];

    for (var x = xFrom; x <= xTo; x += xIncr)
    {
        var ep = (x - mean) / Math.sqrt(2 * varSq);
        var value = (1 + vp.erf(ep)) / 2;

        var rec = { x: x, y: value };
        records.push(rec);
    }

    return records;
};

/// adapted from http://en.wikipedia.org/wiki/Normal_distribution.
vp.randn = function (count, method)
{
    var meth = (method) ? method.toLowerCase() : "central-limit";
    var values = [];

    var loopCount = (count === undefined) ? 1 : count;

    if (meth === "box-muller")
    {
        //----- generate 2 numbers at a time ----
        for (var i = 0; i < loopCount; i += 2)
        {
            var u = Math.random();
            var v = Math.random();

            var term1 = Math.sqrt(-2 * Math.log(u)/Math.LOG10E);

            var value = term1 * Math.cos(2 * Math.PI * v);
            values.push(value);

            if (i < loopCount - 1)
            {
                //---- room for quick 2nd number ----
                value = term1 * Math.sin(2 * Math.PI * v);
                values.push(value);
            }
        }
    }
    else if (meth == "central-limit")
    {
        //--- generate 1 number at a time ----
        for (var i = 0; i < loopCount; i++)
        {
            //---- total next 12 random numbers ----
            var sum = Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() +
                Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random();

            var value = sum / 6;
            values.push(value);
        }
    }

    /// return scaler or array, depending on value of 'count' 
    return (count === undefined) ? values[0] : values;
};


///----------------------------------------------------------------
/// (from data\csv.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// csv.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library
///     - converts a CSV (comma seperated file) into an array of json objects
///-----------------------------------------------------------------------------------------------------------------


/// converts a csv string (read from a csv file) into a json object.
vp.file.csvToJson = function (csv, hasHeader, sepChar, findTypes)
{
    var loader = vp.csvLoader(hasHeader, sepChar, findTypes);
    return loader.load(csv);
};

vp.csvLoader = function (hasHeader, sepChar, findTypes)
{
    //---- private state ----
    var colNames = [];
    var processedHdr = false;
    var lastLoadRemainder = "";
    var colCount = 0;

    //---- closure ----
    var closure = function ()
    {
    };

    /// public: load(csv)
    closure.load = function (csv, incrementalLoading)
    {
        var rows = [];
        var i = 0;      // char index into csv

        if (!processedHdr)
        {
            if (hasHeader)
            {
                //---- read first line containing column headers ----
                var colNum = 0;

                //---- process first line ----
                while ((i < csv.length) && (csv[i] != "\n"))
                {
                    var iStart = i;
                    //---- get next column name ----
                    while ((i < csv.length) && (csv[i] != sepChar) && (csv[i] != "\n"))
                    {
                        i++;
                    }

                    var colName = csv.substring(iStart, i);

                    //---- remove quotes around col names ----
                    if ((colName.startsWith("\"")) && (colName.endsWith("\"")))
                    {
                        colName = colName.substr(1, colName.length - 2);
                    }

                    colName = colName.trim();

                    colNames.push(colName);

                    if (csv[i] == sepChar)
                    {
                        i++;
                        colNum++;
                    }
                    else
                    {
                        if ((i < csv.length) && (csv[i] == "\n"))
                        {
                            i++;            // skip over newline at end of line
                        }
                        break;
                    }
                }
            }

            processedHdr = true;
        }

        if (incrementalLoading)
        {
            //---- append left over chars from last load ----
            csv = lastLoadRemainder + csv;
        }

        var lastRowOffset = 0;

        while (i < csv.length)
        {
            var row = null;

            var aray = csvLineToJsonRow(csv, i, sepChar, colNames);
            row = aray[0];
            i = aray[1];

            var isLastRowShort = false;
            var colsFound = vp.utils.keys(row).length;

            if (colCount == 0)
            {
                colCount = colsFound;
            }
            else if (colsFound < colCount)
            {
                //---- short row - is it the last? ----
                if (i >= csv.length)
                {
                    isLastRowShort = true;
                }
            }

            if ((isLastRowShort) && (incrementalLoading))
            {
                lastLoadRemainder = csv.substr(lastRowOffset);
                break;
            }
            else
            {
                rows.push(row);
                lastRowOffset = i;
            }
        }

        //---- test each column to see if all numeric; if so, convert to numbers ----
        if ((findTypes) && (rows.length > 0))
        {
            var firstRow = rows[0];
            var keys = vp.utils.keys(firstRow);

            //---- test each column ----
            for (var i = 0; i < keys.length; i++)
            {
                tryToConvertColToNativeType(rows, keys[i]);
            }
        }

        return rows;
    };

    var tryToConvertColToNativeType = function (rows, colName)
    {
        if (!tryToConvertColToBool(rows, colName))
        {
            /// since JavaScript cannot tell the difference between a DATE and a number reliably, don't auto convert to date.
            if (true)       // ! tryToConvertColToDate(rows, colName))
            {
                tryToConvertColToNumeric(rows, colName);
            }
        }
    };

    var tryToConvertColToNumeric = function (rows, colName)
    {
        var isNumeric = true;
        var values = [];

        for (var i = 0; i < rows.length; i++)
        {
            var row = rows[i];
            var str = row[colName];

            var value = Number(str);
            if (isNaN(value))
            {
                isNumeric = false;
                break;
            }

            values.push(value);
        }

        if (isNumeric)
        {
            for (var i = 0; i < rows.length; i++)
            {
                var row = rows[i];
                row[colName] = values[i];
            }
        }

        return isNumeric;
    };

    var tryToConvertColToBool = function (rows, colName)
    {
        var isBool = true;
        var values = [];

        for (var i = 0; i < rows.length; i++)
        {
            var row = rows[i];
            var str = row[colName].toLowerCase();

            if (str == "true")
            {
                values.push(true);
            }
            else if (str == "false")
            {
                values.push(false);
            }
            else
            {
                isBool = false;
                break;
            }

            values.push(value);
        }

        if (isBool)
        {
            for (var i = 0; i < rows.length; i++)
            {
                var row = rows[i];
                row[colName] = values[i];
            }
        }

        return isBool;
    };

    var tryToConvertColToDate = function (rows, colName)
    {
        var isDate = true;
        var values = [];

        for (var i = 0; i < rows.length; i++)
        {
            var row = rows[i];
            var str = row[colName];

            var value = Date.parse(str);
            if (isNaN(value))
            {
                isDate = false;
                break;
            }

            values.push(value);
        }

        if (isDate)
        {
            for (var i = 0; i < rows.length; i++)
            {
                var row = rows[i];
                row[colName] = values[i];
            }
        }

        return isDate;
    };

    var csvLineToJsonRow = function (csv, i, sepChar, colNames)
    {
        //---- process next line (row) of data ----
        var colNum = 0;
        var row = {};

        while ((i < csv.length) && (csv[i] != "\n"))
        {
            //---- get next value ----
            var iStart = i;
            while ((i < csv.length) && (csv[i] != sepChar) && (csv[i] != "\n"))
            {
                i++;
            }

            var value = csv.substring(iStart, i);
            var colName = (colNum < colNames.length) ? colNames[colNum] : "col" + colNum;

            //---- remove quotes around values ----
            if ((value.startsWith("\"")) && (value.endsWith("\"")))
            {
                value = value.substr(1, value.length - 2);
            }

            row[colName] = value;


            if (csv[i] == sepChar)
            {
                i++;
                colNum++;
            }
            else
            {
                break;
            }
        }

        if ((i < csv.length) && (csv[i] == "\n"))
        {
            i++;            // skip over newline at end of line
        }

        return [row, i];
    };

    //---- init code ----
    if (hasHeader == null)
    {
        hasHeader = false;
    }

    if (sepChar == null)
    {
        sepChar = "\t";
    }

    var colNames = [];


    return closure;
};

///----------------------------------------------------------------
/// (from data\curveFitting.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// curveFitting.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - curve fitting functions.
///-----------------------------------------------------------------------------------------------------------------
/// all of these functions in this file, unless specified otherwise, 
/// were adapted from book "practical WPF Charts and Graphics"
/// http://www.amazon.com/Practical-Charts-Graphics-Experts-Voice/dp/1430224819, Chapter 11 Curve Fitting.  
///-----------------------------------------------------------------------------------------------------------------
vp.curveFitting = {};       // namespace object

vp.curveFitting.line = function (xa, ya)
{
    var values = [];

    if ((!xa) || (!xa.length) || (!ya) || (!ya.length))
    {
        vp.utils.error("error - polyfit() requires X and Y number arrays");
    }

    if (xa.length != ya.length)
    {
        vp.utils.error("error - polyfit() requires that X and Y be the same size");
    }

    var count = xa.length;
   
    //---- model: y = slope*x + intercept ----
    var xm = vp.average(xa);
    var ym = vp.average(ya);

    var btop = 0;
    var bbot = 0;

    for (var i = 0; i < count; i++)
    {
        btop += (ya[i] * (xa[i] - xm));
        bbot += (xa[i] * (xa[i] - xm));
    }

    var slope = btop / bbot;
    var intercept = ym - xm * slope;

    var sigma = 0;

    for (var i = 0; i < count; i++)
    {
        var t = ya[i] - intercept - (slope * xa[i]);
        sigma += t * t;
    }

    sigma = Math.sqrt(sigma / (count - 2));

    var ptFrom = { x: xa[0], y: slope * xa[0] + intercept };
    var ptTo = { x: xa[count - 1], y: slope * xa[count - 1] + intercept };

    values = { slope: slope, intercept: intercept, sigma: sigma, ptFrom: ptFrom, ptTo: ptTo };

    return values;
};

vp.geom.matrix2d = function (rows, cols)
{
    var m = [];

    for (var i = 0; i < rows; i++)
    {
        var row = [];

        for (var j = 0; j < cols; j++)
        {
            row.push(0);
        }

        m.push(row);
    }

    return m;
};

vp.geom.vector = function (cols)
{
    var row = [];

    for (var j = 0; j < cols; j++)
    {
        row.push(0);
    }

    return row;
};

//vp.curveFitting.linRegressPoly = function (xa, ya, degree)
//{
//    var f0 = function(x) {return 1;};
//    var f1 = function(x) {return x;};
//    var f2 = function(x) {return x*x;};
//    var f3 = function(x) {return x*x*x;};

//    var f = null;

//    if (degree == 1)
//    {
//        f = [f0, f1];
//    }
//    else if (degree == 2)
//    {
//        f = [f0, f1, f2];
//    }
//    else if (degree == 3)
//    {
//        f = [f0, f1, f2, f3];
//    }

//    var result = vp.curveFitting.linearRegression(xa, ya, f);
//    return result;
//};

/// "xa" are the x data values, "ya" are the y data values, "degree" is the polynomial degress (1, 2, ...)
vp.curveFitting.polyFit = function (xa, ya, degree)
{
    var m = degree + 1;
    var a = vp.geom.matrix2d(m, m);
    var b = vp.geom.vector(m);
    var n = xa.length;

    for (var k = 0; k < m; k++)
    {
        b[k] = 0;
        for (var i = 0; i < n; i++)
        {
            b[k] += Math.pow(xa[i], k) * ya[i];
        }
    }

    for (var j = 0; j < m; j++)
    {
        for (var k = 0; k < m; k++)
        {
            a[j][k] = 0;
            for (var i = 0; i < n; i++)
            {
                a[j][k] += Math.pow(xa[i], j + k);
            }
        }
    }

    var coef = vp.gaussJordan(a, b);

    //---- calculate the std deviation ----
    var s = 0;
    for (var i = 0; i < n; i++)
    {
        var s1 = 0;

        for (var j = 0; j < m; j++)
        {
            s1 += coef[j] * Math.pow(xa[i], j);
        }

        s += (ya[i] - s1) * (ya[i] - s1);
    }

    var sigma = Math.sqrt(s / (n - m));

    return { coef: coef, sigma: sigma };
};

/// "xa" are the x data values, "ya" are the y data values, "wa" are the weight values.
vp.curveFitting.weightedLinearRegression = function (xa, ya, wa)
{
    var n = xa.length;
    var xw = 0;
    var yw = 0;
    var b1 = 0;
    var b2 = 0;
    var a = 0;
    var b = 0;

    for (var i = 0; i < n; i++)
    {
        xw += xa[i] / n;
        yw = ya[i] / n;
    }

    for (var i = 0; i < n; i++)
    {
        b1 += wa[i] * wa[i] * ya[i] * (xa[i] - xw);
        //b2 += wa[i] * wa[i] * xa[i] * (xa[i] - xw);
        b2 += wa[i] * wa[i] * xa[i] * (ya[i] - yw);
    }

    b = b1 / b2;
    a = yw - xw * b;

    return {coef: [a, b] };
};

/// "xa" are the x data values, "ya" are the y data values, "degree" is the polynomial degress (1, 2, ...)
vp.curveFitting.exponentialFit = function (xa, ya)
{
    var logy = [];

    for (var i = 0; i < ya.length; i++)
    {
        logy[i] = Math.log(ya[i]);
    }

    var result = vp.curveFitting.weightedLinearRegression(xa, logy, ya);
    return result;
};

/// "xa" are the x data values, "ya" are the y data values, "f" is an array of model func (usually returns x**N).
vp.curveFitting.linearRegression = function (xa, ya, f)
{
    var m = f.length
    var a = vp.geom.matrix2d(m, m);
    var b = vp.geom.vector(m);
    var n = xa.length;

    for(var k=0; k < m; k++)
    {
        b[k] = 0;

        for(var i=0; i < n; i++)
        {
            var result = f[k](xa[i]);
            var term = result * ya[i];
            b[k] += term;
        }
    }

    for(var j=0; j < m; j++)
    {
        for(var k=0; k < m; k++)
        {
            a[j][k] = 0;

            for(var i=0; i < n; i++)
            {
                var result = f[j](xa[i]);
                var result2 = f[k](xa[i]);
                var term = result * result2;
                a[j][k] += term;
            }
        }
    }

    var coef = vp.gaussJordan(a, b);

    //---- calculate the std deviation ----
    var s = 0;
    for(var i =0; i < n; i++)
    {
        var s1 = 0;

        for(var j=0; j < m; j++)
        {
            s1 += coef[j] * f[j](xa[i]);
        }

        s+= (ya[i] - s1) * (ya[i] - s1);
    }

    var sigma = Math.sqrt(s / (n-m));

    return {coef: coef, sigma: sigma};
}

/// "a" is Matrix, "b" is array.
vp.gaussJordan = function (a, b)
{
    vp.triangulate(a, b);

    var n = b.length;
    var x = vp.geom.vector(n);
     
    for (var i = n - 1; i >= 0; i--)
    {
        var d = a[i][i];

        if (Math.abs(d) < 1.0e-500)
        {
            vp.utils.error("error: diagnoal element is too small for GaussJordan");
        }

        x[i] = (b[i] - vp.dotProduct(a[i], x)) / d;
    }

    return x;

};

/// "a" is array, "b" is array.
vp.dotProduct = function (a, b)
{
    var sum = 0;

    for (var i = 0; i < a.length; i++)
    {
        sum += a[i] * b[i];
    }

    return sum;
};

/// "a" is Matrix, "b" is array.
vp.triangulate = function (a, b)
{
    var n = a.length;
    var v = vp.geom.vector(n);

    for (var i = 0; i < n - 1; i++)
    {
        var d = vp.pivot(a, b, i);

        if (Math.abs(d) < 1.0e-500)
        {
            vp.utils.error("error: diagnoal element is too small for triangulate");
        }

        for (var j = i + 1; j < n; j++)
        {
            var dd = a[j][i] / d;
            for (var k = i + 1; k < n; k++)
            {
                a[j][k] -= dd * a[i][k];
            }

            b[j] -= dd * b[i];
        }
    }
};

/// "a" is Matrix, "b" is array, "q" in number.
vp.pivot = function (a, b, q)
{
    var n = b.length;
    var i = q;
    var d = 0;

    for(var j=q; j < n; j++)
    {
        var dd = Math.abs(a[j][q]);
        if (dd > d)
        {
            d = dd;
            i = j;
        }
    }

    if (i > q)
    {
        //---- swap rows "q" and "i" in a ----
        var temp = a[q];
        a[q] = a[i];
        a[i] = temp;

        //---- swap elements "q" and "i" in b ----
        temp = b[q];
        b[q] = b[i];
        b[i] = temp;
    }

    return a[q][q];
};

vp.curveFitting.spline = function (xx, yy)
{
    //---- convert xx,yy into points ----
    var points = xx.map(function (data, index)
    {
        return { x: xx[index], y: yy[index] };
    });

    var tension = .5;       // controls how smooth/sharp changes are at each point
    var tensions = null;
    var segments = [];

    if (points.length == 2)
    {
        if (tensions)
        {
            tension = tensions[0];
        }

        vp.addSplineSegment(segments, points[0], points[0], points[1], points[1], tension, tension);
    }
    else
    {
        for (var i = 0; i < points.length; i++)
        {
            var t1 = (tensions) ? tensions[i % tensions.length] : tension;
            var t2 = (tensions) ? tensions[(i + 1) % tensions.length] : tension;

            if (i == 0)
            {
                vp.addSplineSegment(segments, points[0], points[0], points[1], points[2], t1, t2);
            }
            else if (i == points.length - 2)
            {
                vp.addSplineSegment(segments, points[i - 1], points[i], points[i + 1], points[i + 1], t1, t2);
            }
            else if (i != points.length - 1)
            {
                vp.addSplineSegment(segments, points[i - 1], points[i], points[i + 1], points[i + 2], t1, t2);
            }
        }

    }

    return segments;
};

vp.addSplineSegment = function (segments, pt0, pt1, pt2, pt3, t1, t2)
{
    // adapted from Charles Petzold book:
    // See Petzold, "Programming Microsoft Windows with C#", pages 645-646 or 
    //     Petzold, "Programming Microsoft Windows with Microsoft Visual Basic .NET", pages 638-639
    // for derivation of the following formulas:

    var SX1 = t1 * (pt2.x - pt0.x);
    var SY1 = t1 * (pt2.y - pt0.y);
    var SX2 = t2 * (pt3.x - pt1.x);
    var SY2 = t2 * (pt3.y - pt1.y);

    var AX = SX1 + SX2 + 2 * pt1.x - 2 * pt2.x;
    var AY = SY1 + SY2 + 2 * pt1.y - 2 * pt2.y;
    var BX = -2 * SX1 - SX2 - 3 * pt1.x + 3 * pt2.x;
    var BY = -2 * SY1 - SY2 - 3 * pt1.y + 3 * pt2.y;

    var CX = SX1;
    var CY = SY1;
    var DX = pt1.x;
    var DY = pt1.y;

    var tolerance = .25;        // .25 is the standard tolerance for curve flattening (curve to lines)
    var num = Math.floor((Math.abs(pt1.x - pt2.x) + Math.abs(pt1.y - pt2.y)) / tolerance);

    var points = [];
    segments.push(points);

    // Notice begins at 1 so excludes the first point (which is just pt1)
    for (var i = 1; i < num; i++)
    {
        var t = i / (num - 1);

        var pt = {
            x: AX * t * t * t + BX * t * t + CX * t + DX,
            y: AY * t * t * t + BY * t * t + CY * t + DY
        };

        points.push(pt);
    }
};


///----------------------------------------------------------------
/// (from data\dataBinder.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// dataBinder.js.  Copyright (c) 2012 Microsoft Corporation.
///            part of the vuePlot library - data binding and related functions.
///-----------------------------------------------------------------------------------------------------------------
//
//---- warning: "dataBinder()" is now obsolete.   use "dataAnimMgr" instead. ----
//
vp.dataBinder = function (container, data, pkFunc, isNewData)
{
    //alert("container=" + container);
    var wrappedElements = vp.select();      // conbination of elements from ENTER and UPDATE
    var exitWrappedElements = vp.select();
    var enterDataPairs = [];                // consists of dataPairHolder records
    var keys = {};

    //---- closure ----
    var closure = function () 
    {
    };
    closure.ctr = "vp.dataBinder";

    /// READONLY public: container
    closure.container = container;

    /// public: enter()
    closure.enter = function ()
    {
        var dws = vp.dataWrapperSet(closure, enterDataPairs);
        return dws;
    };

    /// public: update()
    closure.update = function ()
    {
        wrappedElements.id = "wrappedElements";
        return wrappedElements;
    };

    /// public: exit()
    closure.exit = function ()
    {
        return exitWrappedElements;
    };

    /// public: each()
    //---- each function signature: callBack(action, dataPairHolder, element) ----
    closure.each = function (callBack)
    {
        var enterElems = [];

        //---- ENTER items ----
        for (var i = 0; i < enterDataPairs.length; i++)
        {
            var dataPairHolder = enterDataPairs[i];
            var enterElem = callBack(vp.bindAction.enter, dataPairHolder, null);
            if (enterElem != null)
            {
                enterElem.dataItem = dataPairHolder.dataItem;
                enterElem.dataIndex = dataPairHolder.dataIndex;

                enterElems.push(enterElem);
            }
        }

        //---- update "wrappedElements" with newly created elements ----
        if (enterElems.length > 0)
        {
            closure.mergeEnterSet(enterElems);
        }

        //---- UPDATE items ----
        for (var i = 0; i < wrappedElements.length; i++)
        {
            var elem = wrappedElements[i];
            var dataPairHolder = new vp.dataPairHolder(elem.dataItem, elem.dataIndex);

            callBack(vp.bindAction.update, dataPairHolder, elem);
        }

        //---- EXIT items ----
        for (var i = 0; i < exitWrappedElements.length; i++)
        {
            var elem = exitWrappedElements[i];
            var dataPairHolder = new vp.dataPairHolder(elem.dataItem, elem.dataIndex);

            callBack(vp.bindAction.exit, dataPairHolder, exitWrappedElements[i]);
        }
    };

    /// private: getKey()
    var getKey = function (dataItem, dataIndex)
    {
        var pk = dataIndex;     // row index

        if (vp.utils.isFunction(pkFunc))
        {
            pk = pkFunc(dataItem);
        }

        return pk;
    }

    /// public: setData()
    closure.setData = function (data, pkFunc, isNewData)
    {
        enterDataPairs = [];
        pkFunc = pkFunc;

        if (isNewData)
        {
            //---- get rid of all old items ----
            exitWrappedElements = wrappedElements;
            wrappedElements = vp.select();
            keys = {};

            //---- put all new items on "enter" ----
            for (var i = 0; i < data.length; i++)
            {
                var dataPairHolder = new vp.dataPairHolder(data[i], i);
                enterDataPairs.push(dataPairHolder);
            }
        }
        else
        {
            //---- mark all existing elements as "not yet found" ----
            for (var i = 0; i < wrappedElements.length; i++)
            {
                wrappedElements[i].notYetFound = true;
            }

            //---- figure out split of new data into: enter, update groups ----
            var updateElements = [];
            var exitElements = [];

            for (var i = 0; i < data.length; i++)
            {
                var pk = getKey(data[i], i);

                var element = keys[pk];
                if (element == undefined)
                {
                    var dataPairHolder = new vp.dataPairHolder(data[i], i);
                    enterDataPairs.push(dataPairHolder);
                }
                else
                {
                    element.notYetFound = false;

                    //---- update data/dataIndex fields to reflect data change ----
                    element.dataItem = data[i];
                    element.dataIndex = i;

                    updateElements.push(element);
                }
            }

            //---- move any elements that we didn't find in the new data into the "exit" elements ----
            for (var i = 0; i < wrappedElements.length; i++)
            {
                var elem = wrappedElements[i];

                if (elem.notYetFound == true)
                {
                    //---- remove key from keys ----
                    var pk = getKey(elem.dataItem, elem.dataIndex);
                    delete keys[pk];

                    //---- update dataIndex to reflect that data is not in current data[] ----
                    elem.dataIndex = -(elem.dataIndex + 1);

                    exitElements.push(elem);
                }
            }

            //---- now, wrap our 2 main arrays ----
            wrappedElements = vp.select(updateElements);
            exitWrappedElements = vp.select(exitElements);
        }
    };

    /// public: mergeEnterSet()
    closure.mergeEnterSet = function (enterSet)
    {
        //---- first, merge in the keys from enterSet ----
        for (var i = 0; i < enterSet.length; i++)
        {
            var element = enterSet[i];

            var pk = getKey(element.dataItem, element.dataIndex);
            keys[pk] = enterSet[i];
        }

        //---- now, merge the wrapped elements ----
        wrappedElements = wrappedElements.merge(enterSet);
    };

    //---- init code ----
    closure.setData(data, pkFunc, isNewData);

    return closure;

};


///** Warning: "dataBind()" is now obsolete.   use "dataAnimMgr" instead. */
vp.dataBind = function(elem, ss, bindingName, data, pkFunc, isNewData)
{
    var binder = null;

    //---- make sure name doesn't step on another property name ----
    bindingName = "binder_" + bindingName;

    //--- the binder object is stored on the associated HTML/SVG element as a named property ----
    if (!elem.hasOwnProperty(bindingName))
    {
        binder = vp.dataBinder(ss, data, pkFunc, isNewData);
        elem[bindingName] = binder;
    }
    else
    {
        binder = elem[bindingName];
        binder.setData(data, pkFunc, isNewData);
    }

    return binder;
}

/* enum */ vp.bindAction = 
{
    enter: 0,
    update: 1,
    exit: 2,
}


//---- small closure object ----
vp.dataPairHolder = function (dataItem, dataIndex)
{
    this.dataItem = dataItem;
    this.dataIndex = dataIndex;

    return this;
}


///----------------------------------------------------------------
/// (from data\dataFuncs.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// dataFuncs.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - data-related functions.
///-----------------------------------------------------------------------------------------------------------------

/// test each value in data - if at least one can be converted to a valid number, 
/// return true; otherwise return false;
vp.utils.isDataNumeric = function (data)
{
    var numberCount = 0;

    if (data.length)
    {
        for (var i = 0; i < data.length; i++)
        {
            var value = data[i];

            if (vp.utils.isString(value))
            {
                value = value.trim();
                if (value == "")
                {
                    continue;
                }

                value = +value;
            }

            if (!isNaN(value))
            {
                numberCount++;
            }

            if (numberCount > 0)
            {
                break;
            }
        }
    }

    return (numberCount > 0);
};

vp.utils.isNanOrBlank = function (value)
{
    var isNob = false;

    if (vp.utils.isString(value))
    {
        value = value.trim();
        if (value == "")
        {
            isNob = true;
        }
    }

    if ((! isNob) && (isNaN(+value)))
    {
        isNob = true;
    }

    return isNob;
};

vp.nanCount = function (origData)
{
    var count = 0;

    for (var i=0; i < origData.length; i++)
    {
        var value = origData[i];

        if (vp.utils.isNanOrBlank(value))
        {
            count++;
        }
    }

    return count;
};

vp.cleanData = function (origData, cleanValue)
{
    var newData = origData.map(function (data, index)
    {
        var value = +data;
        if (isNaN(value))
        {
            value = cleanValue;
        }

        return value;
    });

    return newData;
};

///----------------------------------------------------------------
/// (from data\dataTransfer.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// dataTransfer.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - functions to read and write data from URL's.
///-----------------------------------------------------------------------------------------------------------------

/// starts a async download of text from the specified url.  if "isJson" is true,
/// the data is requested in json format.  when the download is finished, either
/// successFunc or failFunc is called, with the param "xmlhttp".
///
/// if this is a file on a server, the true text is returned in xmlhttp.responseText.  if text is XML,
/// the XML document object is available in xmlhttp.responseXML.


vp.file.httpRead = function (url, isJson, successFunc, failFunc, callAsync)
{
    callAsync = (callAsync === undefined) ? true : callAsync;

    var xmlhttp = vp.createXMLHttpRequest();
    xmlhttp.open("GET", url, callAsync);

    if (isJson)
    {
        xmlhttp.setRequestHeader("accept", "application/json");
    }

    xmlhttp.onreadystatechange = function ()
    {
        if ((xmlhttp.readyState == 4) && (xmlhttp.status != 0))
        {
            if (xmlhttp.status == 200)
            {
                if (successFunc != null)
                {
                    successFunc(xmlhttp);
                }
            }
            else
            {
                if (failFunc != null)
                {
                    failFunc(xmlhttp);
                }
            }
        }
    };

    xmlhttp.send();
};


vp.pagePath = function (getServicePrefix)
{
    var pagePath = window.location.href;

    //---- first, remove any parameters ----
    var index = pagePath.indexOf("?");
    if (index > -1)
    {
        pagePath = pagePath.substr(0, index);
    }

    //---- now, remove the page name ----
    index = pagePath.lastIndexOf("/");
    if (index > 0)
    {
        pagePath = pagePath.substr(0, index);

        if (getServicePrefix)
        {
            //---- remove next path near top (todo: remove all paths until top) ----
            index = pagePath.lastIndexOf("/");
            if (index > 0)
            {
                pagePath = pagePath.substr(0, index);
            }
        }
    }

    return pagePath;
};

vp.httpReadIncremental = function (url, isJson, offset, maxSize, successFunc, failFunc, callAsync)
{
    var pagePath = vp.pagePath(false);
    var servicePath = vp.pagePath(true);

    if (url.startsWith(".."))
    {
        url = pagePath + "/" + url;
    }

    //var serviceUrl = "http://" + window.location.host + "/VuePlotWeb/Service/Service1.asmx/DownloadText";
    var serviceUrl = servicePath + "/Service/Service1.asmx/IncrementalDownload";

    if (window.alertShown === undefined)
    {
        //alert("read via url: " + serviceUrl);
        window.alertShown = 1;
    }

    vp.file.httpRead(serviceUrl + "?url=" + url + "&offset=" + offset + "&maxSize=" + maxSize, false, function (xmlhttp)
    {
        if (successFunc)
        {
            var data = vp.getJsonFromResponseXml(xmlhttp.responseXML);

            successFunc(data);
        }
    },
        failFunc);
};


vp.writeFileText = function(fn, text, successCallback, failureCallback)
{
    var serverPath = vp.pagePath(true);
    var serviceUrl = serverPath + "/Service/Service1.asmx/writeFileText";

    var fullUrl = serviceUrl;
    var finalUrl = encodeURI(fullUrl);

    //alert("posting to url: " + finalUrl);

    var body = "fn=" + fn + "&text=" + text;
    body += "&timestamp=" + Date.now();         // add time to disable caching

    vp.httpPost(finalUrl, body, function (xmlhttp)
    {
        if (successCallback)
        {
            successCallback(xmlhttp);
        }
    },
    function (e)
    {
        if (failureCallback)
        {
            failureCallback(e);
        }
    }, false);
}

/// <summary>
/// Write an HTML file and its associated JavaScript/TypeScript file to the server's
/// "GeneratedPages" directory. 
/// </summary>
vp.writeFilePair = function (html, script, isTypeScript, successCallback, failureCallback)
{
    var serverPath = vp.pagePath(true);
    var serviceUrl = serverPath + "/Service/Service1.asmx/writeFilePair";

    var fullUrl = serviceUrl; 
    var finalUrl = encodeURI(fullUrl);

    var safeHtml = encodeURIComponent(html);
    var safeScript = encodeURIComponent(script);

    //alert("posting to url: " + finalUrl);

    var body = "?html=" + safeHtml + "&script=" + safeScript + "&isTypeScript=" + isTypeScript;
    body += "&timestamp=" + Date.now();         // add time to disable caching

    vp.httpPost(finalUrl, body, function (xmlhttp)
    {
        if (successCallback)
        {
            successCallback(xmlhttp);
        }
    },
    function (e)
    {
        if (failureCallback)
        {
            failureCallback(e);
        }
    }, false);

}


/// starts a async upload of text to the specified url.
vp.httpPost = function (url, stringToSend, successFunc, failFunc)
{
    var xmlhttp = vp.createXMLHttpRequest();
    xmlhttp.open("POST", url, true);

    xmlhttp.setRequestHeader("contentType", "application/x-www-form-urlencoded");

    xmlhttp.onreadystatechange = function ()
    {
        if ((xmlhttp.readyState == 4) && (xmlhttp.status != 0))
        {
            if (xmlhttp.status == 200)
            {
                if (successFunc != null)
                {
                    successFunc(xmlhttp);
                }
            }
            else
            {
                if (failFunc != null)
                {
                    failFunc(xmlhttp);
                }
            }
        }
    };

    xmlhttp.send(stringToSend);
};

/// convert a XmlHttp responseXML to a json object.
vp.getJsonFromResponseXml = function (responseXML)
{
    var data = null;

    var node = responseXML.lastChild;
    if (node)
    {
        var str = (node.text) ? node.text : node.textContent;
        var data = null;

        try
        {
            data = JSON.parse(str);        // eval('(' + str + ')');
        }
        catch (ex)
        {
            //---- for debugging, try 1 record at a time, so we can see where the problem is ----
            if (str[0] == '[')
            {
                var index = 1;
                var recNum = 0;

                while (true)
                {
                    var start = str.indexOf('{', index);
                    if (start > -1)
                    {
                        var stop = str.indexOf('},', start + 1);
                        if (stop > -1)
                        {
                            var recStr = str.substr(start, stop - start + 1);
                            var jd = JSON.parse(recStr);
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }

                    recNum++;
                    index = stop + 1;
                }

                var a = 9;
            }
        }

        if ((data) && (data.d))
        {
            data = data.d;      // for json data
        }
    }

    return data;
};

/// convert an XmlHttp responseText to a json object.
vp.file.getJsonFromResponse = function (txt)
{
    var data = null;

    //var data = eval('(' + responseText + ')');

    var xmlStringPrefix = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<string xmlns=\"http://tempuri.org/\">";

    if (txt.startsWith(xmlStringPrefix))
    {
        txt = txt.substr(xmlStringPrefix.length);
        txt = txt.substr(0, txt.length - 9);        // remove "</string>" at end
    }
    else if (txt.startsWith("d:"))      // prefix appended by AspNetService (asp.net page)
    {
        txt = txt.substr(2);
    }

    var data = JSON.parse(txt);
    if (data.d)
    {
        data = data.d;      // for json data
    }

    return data;
};


///
/// download text data from a URL, using a specific service that is expected to
/// be on the same host as the current host:  http://samehostname/VuePlotWeb/Service/Service1.asmx/DownloadText
///
/// This is to get around problem "cross origin resource sharing".
///
vp.httpReadViaService = function (url, isJson, successFunc, failFunc)
{
    var pagePath = vp.pagePath(true);

    //var serviceUrl = "http://" + window.location.host + "/VuePlotWeb/Service/Service1.asmx/DownloadText";
    var serviceUrl = pagePath + "/Service/Service1.asmx/DownloadText";

    if (window.alertShown === undefined)
    {
        //alert("read via url: " + serviceUrl);
        window.alertShown = 1;
    }

    vp.file.httpRead(serviceUrl + "?url=" + url + "&isJson=" + isJson, isJson, function (xmlhttp)
    {
        if (successFunc)
        {
            var data = vp.getJsonFromResponseXml(xmlhttp.responseXML);

            successFunc(data);
        }
    },
        failFunc);
};

///
/// download JSON data from a SQL database.  
///
vp.httpReadSqlData = function (server, dbName, tableName, successFunc, failFunc)
{
    var pagePath = vp.pagePath(true);

    var serviceUrl = pagePath + "/Service/Service1.asmx/GetSqlData";
    //var serviceUrl = "/Service/Service1.asmx/GetSqlData";
    serviceUrl += "?server=" + server + "&dbName=" + dbName + "&tableName=" + tableName;

    if (window.alertShown === undefined)
    {
        //alert("read via url: " + serviceUrl);
        window.alertShown = 1;
    }

    vp.file.httpRead(serviceUrl, true,
        function (xmlhttp)
        {
            if (successFunc)
            {
                var data = vp.getJsonFromResponseXml(xmlhttp.responseXML);

                successFunc(data);
            }
        },
        function (xmlhttp)
        {
            if (failFunc)
            {
                failFunc(xmlhttp);
            }
        });
};

///
/// download names of tables in specified SQL database.  
///
vp.httpReadSqlTableNames = function (server, dbName, successFunc, failFunc)
{
    var pagePath = vp.pagePath(true);

    var serviceUrl = pagePath + "/Service/Service1.asmx/GetSqlTables";
    serviceUrl += "?server=" + server + "&dbName=" + dbName;

    if (window.alertShown === undefined)
    {
        //alert("read via url: " + serviceUrl);
        window.alertShown = 1;
    }

    vp.file.httpRead(serviceUrl, true,
        function (xmlhttp)
        {
            if (successFunc)
            {
                var data = vp.getJsonFromResponseXml(xmlhttp.responseXML);

                successFunc(data);
            }
        },
        function (xmlhttp)
        {
            if (failFunc)
            {
                failFunc(xmlhttp);
            }
        });
};

/// starts a async download of text from the specified url, using the "XDomainRequest" object which
/// is designed to work across domains.  To use this, the hosting service that supplys the data
/// must explictly support cross domain reads (by reading & writing certain headers).
///
/// if "isJson" is true, the data is requested in json format.  when the download is finished, either
/// successFunc or failFunc is called, with the param "xmlhttp".
vp.httpCrossDomainRead = function (url, isJson, successFunc, failFunc)
{
    if (window.XDomainRequest)
    {
        var xdr = new XDomainRequest();

        if (isJson)
        {
            xdr.setRequestHeader("accept", "application/json");
        }

        xdr.onload = function (xdr)
        {
            if (successFunc != null)
            {
                var data = null;

                //if (isJson)
                //{
                //    data = vp.getJsonFromResponseXml(xdr.responseXML);
                //}
                //else
                //{
                //    data = xdr.responseText;        // xmlhttp.xmlText;
                //}

                successFunc(xdr);
            }
        };

        xdr.ontimeout = function (ep)
        {
            alert("xdr.timeout");
        };

        xdr.onprogress = function (ep)
        {
            alert("xdr.timeout");
        };

        xdr.onerror = function (ep, ex)
        {
            if (failFunc != null)
            {
                failFunc(xdr);
            }
        };

        xdr.timeout = 99000;

        xdr.open("GET", url);
        xdr.send();
    }
    else
    {
        vp.utils.error("XDomainRequest API not supported by this browser");
    }
};

/// reads OData data from the specified url.
vp.oDataRead = function (url, isJson, successFunc, failFunc)
{
    vp.httpReadViaService(url, isJson, function (data)
    {
        if (successFunc)
        {
            if ((data) && (data.results))
            {
                data = data.results;
            }

            successFunc(data);
        }
    }, failFunc);
};

/// reads all of the OData data from the specified url (adding parameters to the URL to
/// read each block of data).
vp.oDataReadAll = function (url, byCount, isJson, successFunc, failFunc)
{
    if (byCount == null)
    {
        byCount = 1000;
    }

    this.error = false;
    this.data = [];
    this.total = 0;
    this.byCount = byCount;
    var self = this;

    this.readMore = function ()
    {
        vp.oDataRead(url + "?$skip=" + self.total + "&$top=" + self.byCount, true,

            function (dataChunk)     // success func
            {
                var chunkSize = dataChunk.length;
                if (chunkSize > 0)
                {
                    self.byCount = chunkSize;

                    self.data = self.data.concat(dataChunk);
                    self.total = self.data.length;

                    self.readMore();
                }
                else
                {
                    if (successFunc != null)
                    {
                        successFunc(self.data);
                    }
                }
            },

            function (xmlhttp)      // failure func
            {
                if (failFunc != null)
                {
                    failFunc(xmlhttp);
                }

                self.error = true;
            }
        );
    };

    this.readMore();
};

/// create a instance of the XMLHttpRequest object.
vp.createXMLHttpRequest = function ()
{
    var req = null;

    if (XMLHttpRequest != null)
    {
        req = new XMLHttpRequest();
    }
    else
    {
        req = new ActiveXObject("Microsoft.XMLHTTP");
    }

    return req;
}

vp.pathHelper = function(nodeName)
{
    var getServicePrefix = true;
    var serverPath = window.location.href;

    //---- try easy one first ----
    if (serverPath.startsWith("http://localhost"))
    {
        serverPath = "http://localhost/" + nodeName;
    }
    else
    {
        //---- first, remove any parameters ----
        var index = serverPath.indexOf("?");
        if (index > -1)
        {
            serverPath = serverPath.substr(0, index);
        }

        //---- now, remove the page name ----
        index = serverPath.lastIndexOf("/");
        if (index > 0)
        {
            serverPath = serverPath.substr(0, index);

            if (getServicePrefix)
            {
                //---- remove LAST NODE ----
                index = serverPath.lastIndexOf("/");
                if (index > 0)
                {
                    serverPath = serverPath.substr(0, index);
                }

                //---- remove 2nd LAST NODE ----
                index = serverPath.lastIndexOf("/");
                if (index > 0)
                {
                    serverPath = serverPath.substr(0, index);
                }

                //---- both DEV and RELEASE machines now use nodeName ----
                serverPath += "/" + nodeName;
            }
        }
    }

    return serverPath;
}

vp.file.bigDataPath = function (fn)
{
    var dummy = 5;

    //var path = vp.pathHelper("VueBigData");
    var hostName = (window.location.hostname) ? window.location.hostname : "localhost";

    fn = "http://" + hostName + "/VueBigData/" + fn;

    return fn;
}

///----------------------------------------------------------------
/// (from data\dataWrapperSet.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// dataWrapperSet.js.  Copyright (c) 2012 Microsoft Corporation.
///            part of the vuePlot library - data binding and related functions.
///-----------------------------------------------------------------------------------------------------------------
//---- class: dataWrapperSet ----
//----      "dataPairs" is an array of dataPair objects ----
vp.dataWrapperSet = function (dataBinder, dataPairs)
{
    //---- private state ----
    var container = dataBinder.container;

    /// closure
    var closure = function ()
    {
    };
    closure.ctr = "vp.dataWrapperSet";

    ///
    /// timing: append(10,000) took 553ms on roland's home machine (3/23/2012):
    ///     - createElementNS("rect")   - 3ms
    ///     - wrappedElement()          - 4ms
    ///     - container.append()        - 143ms

    /// these very expensive calls have been replaced by simple attribute settings:
    ///     - wrappedElement.data(first)     - 140ms
    ///     - wrappedElement.data(second)    - 110ms

    /// this very expensive call in-loop call has been replaced by building an array
    /// of elements and then wrapping them at the end:
    ///     - wrappedSet = wrappedSet.add(wrappedElement)     - 10 secs!
    ///

    /// public: append(stringOrFunc)
    closure.append = function (stringOrFunc)
    {
        //var startTime = new Date().getTime();
        var elementArray = [];
        elementArray[dataPairs.length - 1] = null;        // create array the size we need it

        for (var i = 0; i < dataPairs.length; i++)
        {
            var dataPairHolder = dataPairs[i];
            var element = null;

            if (vp.utils.isFunction(stringOrFunc))
            {
                element = stringOrFunc(dataPairHolder.dataItem, dataPairHolder.dataIndex);
            }
            else
            {
                element = document.createElementNS('http://www.w3.org/2000/svg', stringOrFunc);
            }

            if (element != null)
            {
                elementArray[i] = element;

                element.dataItem = dataPairHolder.dataItem;
                element.dataIndex = dataPairHolder.dataIndex;
            }
        }

        var wrappedSet = vp.select(elementArray);
        container.append(wrappedSet);

        dataBinder.mergeEnterSet(wrappedSet);

        //var elapsedMs = new Date().getTime() - startTime;
        return wrappedSet;
    };

    /// public: each(eachFunc)
    //---- each function signature: eachFunc(dataItem, index) ----
    closure.each = function (eachFunc)
    {
        var elementArray = [];
        elementArray[dataPairs.length - 1] = null;        // create array the size we need it

        for (var i = 0; i < dataPairs.length; i++)
        {
            var dataPairHolder = dataPairs[i];

            var element = eachFunc(dataPairHolder.dataItem, dataPairHolder.dataIndex);

            if (element != null)
            {
                elementArray[i] = element;

                element.dataItem = dataPairHolder.dataItem;
                element.dataIndex = dataPairHolder.dataIndex;
            }

        }

        var wrappedSet = vp.select(elementArray);

        dataBinder.mergeEnterSet(wrappedSet);

        //var elapsedMs = new Date().getTime() - startTime;
        return wrappedSet;
    };

    //---- init code ----
    return closure;
};


///----------------------------------------------------------------
/// (from data\incrementalCsvLoader.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// incrementalCsvLoader.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library
///     - downloads a large CSV file in chunks, returning the records from each chunk so that visualization can 
///       can be built incrementally.
///-----------------------------------------------------------------------------------------------------------------

vp.incrementalCsvLoader = function (url, hasHeader, sepChar, findTypes, recordsCallback)
{
    //---- private state ----
    var offset = 0;
    var csvLoader = null;

    //---- closure ----
    var closure = function ()
    {
    };

    //---- public readNextChunk(size) ----
    closure.readNextChunk = function (size)
    {
        vp.httpReadIncremental(url, false, offset, size,
        function (jsonResult)
        {
            //---- success: got next chunk ----
            var chunk = jsonResult.data;
            var isMore = jsonResult.isMore;

            offset += chunk.length;

            var records = csvLoader.load(chunk, true);
            recordsCallback(records, isMore);
        },
        function (xmlhttp)
        {
            //---- read failed ----
            vp.utils.error("Error reading CSV file: " + url);
        });
    };

    //---- init code ----
    csvLoader = vp.csvLoader(hasHeader, sepChar, findTypes);

    return closure;
};


///----------------------------------------------------------------
/// (from data\interpolation.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// interpolation.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - smooth interpolation between points.
///-----------------------------------------------------------------------------------------------------------------
/// all of these functions were adapted from book "practical WPF Charts and Graphics"
/// http://www.amazon.com/Practical-Charts-Graphics-Experts-Voice/dp/1430224819, Chapter 10 Data Interpolations.  
///-----------------------------------------------------------------------------------------------------------------
vp.interpolation = {};       // namespace object

vp.interpolation.lagrangePoint = function (xa, ya, x)
{
    var y = 0;
    var product = ya[0];

    for (var i = 0; i < xa.length; i++)
    {
        product = ya[i];

        for (var j = 0; j < xa.length; j++)
        {
            if (i != j)
            {
                product *= (x - xa[j]) / (xa[i] - xa[j]);
            }
        }

        y += product;
    }

    return y;
};

vp.interpolation.lagrange = function (xa, ya, x)
{
    var y = [];

    for (var i = 0; i < x.length; i++)
    {
        y[i] = vp.interpolation.lagrangePoint(xa, ya, x[i]);
    }

    return y;
};

vp.interpolation.barycentricPoint = function (xa, ya, x)
{
    var c1 = 0;
    var c2 = 0;
    var n = xa.length;
    var wt = [];

    for (var i = 0; i < n; i++)
    {
        var product = 1;

        for (var j = 0; j < n; j++)
        {
            if (i != j)
            {
                product *= (xa[i] - xa[j]);
                wt[i] = 1 / product;
            }
        }
    }

    for (var i = 0; i < n; i++)
    {
        var dx = wt[i] / (x - xa[i]);
        c1 += ya[i] * dx;
        c2 += dx;
    }

    return c1/c2;
};

vp.interpolation.barycentric = function (xa, ya, x)
{
    var y = [];

    for (var i = 0; i < x.length; i++)
    {
        y[i] = vp.interpolation.barycentricPoint(xa, ya, x[i]);
    }

    return y;
};

vp.interpolation.newtonDividedDiffPoint = function (xa, ya, x)
{
    var n = xa.length;
    var temp = [];

    for (var i = 0; i < n; i++)
    {
        temp[i] = ya[i];
    }

    for (var i = 0; i < n - 1; i++)
    {
        for (var j = n - 1; j > i; j--)
        {
            temp[j] = (temp[j-1] - temp[j]) / (xa[j-1-i] - xa[j]);
        }
    }

    var y = temp[n - 1];

    for (var i = n - 2; i >= 0; i--)
    {
        y = temp[i] + (x - xa[i]) * y;
    }

    return y;
};

vp.interpolation.newtonDividedDiff = function (xa, ya, x)
{
    var y = [];

    for (var i = 0; i < x.length; i++)
    {
        y[i] = vp.interpolation.newtonDividedDiffPoint(xa, ya, x[i]);
    }

    return y;
};

vp.interpolation.secondDerrivatives = function (xa, ya)
{
    var n = xa.length;
    var c1 = [];
    var c2 = [];
    var c3 = [];
    var dx = [];
    var derivative = [];

    for (var i = 1; i < n; i++)
    {
        dx[i] = xa[i] - xa[i - 1];
        derivative[i] = (ya[i] - ya[i - 1]) / dx[i];
    }

    for (var i=1; i < n-1; i++)
    {
        c2[i - 1] = 2;
        c3[i - 1] = dx[i + 1] / (dx[i] + dx[i + 1]);
        c1[i - 1] = 1 - c3[i - 1];
        derivative[i-1] = 6*(derivative[i+1] - derivative[i])/(dx[i] + dx[i+1]);
    }

    derivative = vp.interpolation.tridiagonal(n - 2, c1, c2, c3, derivative);
    return derivative;
};

vp.interpolation.tridiagonal = function (n, c1, c2, c3, derivative)
{
    var tol = 1.0e-12;
    var isSingular = (c2[0] < tol);

    for (var i = 1; i < n && !isSingular; i++)
    {
        c1[i] = c1[i] / c2[i - 1];
        c2[i] = c2[i] - c1[i] * c3[i - 1];
        isSingular = (c2[i] < tol);
        derivative[i] = derivative[i] - c1[i] * derivative[i - 1];
    }

    if (!isSingular)
    {
        derivative[n - 1] = derivative[n - 1] / c2[n - 1];

        for (var i = n - 2; i >= 0; i--)
        {
            derivative[i] = (derivative[i] - c3[i] * derivative[i + 1]) / c2[i];
        }

        return derivative;
    }

    return null;
};

vp.interpolation.splinePoint = function (xarray, yarray, x)
{
    var xa = [];
    var ya = [];

    //---- workaround for not handling "zero" values in xarray ----
    var xFirst = (xarray[0] == 0) ? -1.0e-5 : xarray[0];

    xa[0] = (1.0 - 1.0e-6) * xFirst;
    ya[0] = (1.0 - 1.0e-6) * yarray[0];

    for (var i = 0; i < xarray.length; i++)
    {
        xa[i + 1] = xarray[i];
        ya[i + 1] = yarray[i];
    }

    xarray = xa;
    yarray = ya;

    var y = NaN;
    var n = xarray.length;
    var dx = [];
    var derivative = vp.interpolation.secondDerrivatives(xarray, yarray);

    for (var i = 1; i < n; i++)
    {
        dx[i] = xarray[i] - xarray[i - 1];
    }

    for(var i=1; i < n-1; i++)
    {
        if (x >= xarray[i] && x < xarray[i+1])
        {
            var d1 = x - xarray[i];
            var d2 = xarray[i+1] - x;

            y = derivative[i-1] * d2 * d2 * d2 / (6.0 * dx[i+1]) + 
                derivative[i] * d1 * d1 * d1 / (6.0 * dx[i+1]) + 
                (yarray[i+1] / dx[i+1] - derivative[i] * dx[i+1] / 6.0) * d1 + 
                (yarray[i] / dx[i+1] - derivative[i-1] * dx[i+1] / 6.0) * d2;
        }
    }

    return y;
};

/// returns a set of Y coordinates that fit the xa/ya line.  The X coordinates of the fit are specified by
/// by caller.
vp.interpolation.spline = function (xa, ya, x)
{
    var y = [];

    for (var i = 0; i < x.length; i++)
    {
        y[i] = vp.interpolation.splinePoint(xa, ya, x[i]);
    }

    return y;
};

vp.interpolation.linear = function (xa, ya, x)
{
    var y = [];
    var firstx = x[0];

    for (var i = 0; i < x.length; i++)
    {
        var xx = x[i];

        //---- find index of "xa" values that surround "x" ----
        for (var j = 0; j < xa.length; j++)
        {
            if (xa[j] > firstx)
            {
                break;
            }
        }

        if ((j == 0) || (j == xa.length))
        {
            throw "error - bad x values in linear interpolation";
        }

        var xbefore = xa[j - 1];
        var xafter = xa[j];
        var xdelta = xafter - xbefore;
        var percent = (xx - xbefore) / xdelta;

        var ybefore = ya[j - 1];
        var yafter = ya[j];
        var ydelta = yafter - ybefore;
        var yy = ybefore + percent*ydelta;

        y[i] = yy;
    }

    return y;
};

vp.interpolation.lerpArray = function (ya, yb, percent)
{
    var yNew = [];

    for (var i = 0; i < ya.length; i++)
    {
        var aa = ya[i];
        var bb = yb[i];

        var yy = aa + percent * (bb - aa);
        yNew[i] = yy;
    }

    return yNew;
};

///----------------------------------------------------------------
/// (from data\statFucs.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// statFuncs.js.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - statistic functions.
///-----------------------------------------------------------------------------------------------------------------

/// "meshGrid" produces a set of records representing all combinations of specified "x", "y" fields, along with a 
/// callback-specified and "value" fields.
/// Note - this is a different behavior than the MATLAB meshgrid function, which produces a matrix of height values.
/// "dx" is a vector of x values to use.
/// "dy" is a vector of y values to use.  if not specified, the values in "vx" will be used here also.
/// "valueOrFunc" is used to set the "value" field of each record.
vp.meshGrid = function (dx, dy, valueOrFunc)
{
    var rows = [];

    if (!vp.utils.isArray(dy))
    {
        valueOrFunc = dy;
        dy = dx;
    }

    var hasValue = (vp.utils.isDefined(valueOrFunc));
    var valueIsFunc = vp.utils.isFunction(valueOrFunc);

    //---- must specify functions here to get a numeric sort ----
    dx = dx.sort(function (a, b) { return a - b });
    dy = dy.sort(function (a, b) { return a - b });

    var ycount = dy.length;
    var xcount = dx.length;

    for (var r = 0; r < ycount; r++)
    {
        var y = dy[r];
        for (var c = 0; c < xcount; c++)
        {
            var x = dx[c];
            var record = { x: x, y: y };

            if (hasValue)
            {
                record.value = (valueIsFunc) ? valueOrFunc(x, y) : valueOrFunc;
            }

            rows.push(record);
        }
    }

    return rows;
};

vp.average = function (nums)
{
    var total = 0;
    var count = nums.length;

    for (var i = 0; i < nums.length; i++)
    {
        total += nums[i];
    }

    var avg = (count > 0) ? total / count : 0;
    return avg;
};


///-----------------------------------------------------------------------------------------------------------------
/// panAndZoom.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library - supports panning and zooming.
///-----------------------------------------------------------------------------------------------------------------
//---- class: zoomBoxHelper ----
vp.utils.zoomBoxHelper = function (wrappedElem)
{
    /// local state
    var origWidth = wrappedElem.width();
    var origHeight = wrappedElem.height();
    var isSvg = vp.utils.isSvgDocOrElement(wrappedElem[0]);
    var left = 0;
    var top = 0;
    var width = 0;
    var height = 0;
    var transformName = "";

    /// closure.
    var closure = function ()
    {
    };

    var init = function ()
    {
        if (!isSvg)
        {
            if (vp.utils.isIE)
            {
                transformName = "msTransform";
            }
            else if (vp.utils.isFireFox)
            {
                transformName = "MozTransform";
            }
            else
            {
                transformName = "-webkit-transform";
            }

        }

        left = 0;
        top = 0;
        width = origWidth;
        height = origHeight;

        vp.utils.debug("zoomBoxHelper: origWidth=" + origWidth + ", origHeight=" + origHeight);
    };

    /// private: updateViewBox().
    var updateViewBox = function ()
    {
        var box = left + ", " + top + ", " + width + ", " + height;
        vp.utils.debug(".updateViewBox: box=" + box);

        if (isSvg)
        {
            wrappedElem.attr("viewBox", box);
        }
        else
        {
            //---- use transform with translate/scale operations ----
            var name = transformName + "Origin";
            var transValue = left + "px " + top + "px";
            wrappedElem.css(name, transValue);

            var xScale = origWidth / width;
            var yScale = origHeight / height;

            var xoff = -left;  //x - xScale * x;
            var yoff = -top;   // y - yScale * y;

            var translate = "translate(" + xoff + "px, " + yoff + "px)";
            var scale = "scale(" + xScale + ", " + yScale + ")";

            //---- transform must come BEFORE scale in this model ----
            var value = translate + " " + scale;

            wrappedElem.css(transformName, value);

        }
    }

    /// public: zoom(factor, cx, cy).
    closure.zoom = function (factor, cx, cy)
    {
        vp.utils.debug(".zoom: cx=" + cx + ", cy=" + cy);

        var oldFactor = width / origWidth;

        //---- adjust zoom factor ----
        width *= factor;
        height *= factor;

        var newFactor = width / origWidth;

        left += cx * (oldFactor - newFactor);
        top += cy * (oldFactor - newFactor);

        updateViewBox();

    }

    /// public pan(dx, dy).
    closure.pan = function (dx, dy)
    {
        //vp.utils.debug(".pan: dx=" + dx + ", dy=" + dy);

        var factor = width / origWidth;

        left += factor * dx;
        top += factor * dy;

        updateViewBox();

    }

    /// public: reset().
    closure.reset = function ()
    {
        left = 0;
        top = 0;
        width = origWidth;
        height = origHeight;

        updateViewBox();
    }

    //---- init code ----
    init();

    return closure;
};

////---- scriptLoader class ----
//vp.onScriptLoaded = function (url)
//{
//    //vp.utils.debug("script loaded: " + url);

//    scripts[url] = 1;
//    checkReady();
//}

///----------------------------------------------------------------
/// (from events\rubberBandSelector.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// rubberBandSelector.ts.  Copyright (c) 2014 Microsoft Corporation.
///     - part of the vuePlot library
///     - allows user to drag-select elements using a rectangle outline.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (visuals) {
        /** Creates a helper for doing rectangular drag selections on HTML, SVG< and Canvas elements.
        canvasUW - SVG or HTML element that will be used to drag out and draw the selection rectangle
        selectCallback - the function that will be called when the user completes the selection action. */
        var rubberBandSelector = (function () {
            function rubberBandSelector(canvasUW, selectCallback) {
                //---- private state ----
                this._isEnabled = true;
                this.isBanding = false;
                this.ptMouseDown = null;
                this.rubberBand = null;
                this.canvas = vp.dom.unwrap(canvasUW);
                this.isSvgCanvas = vp.utils.isSvgDocOrElement(this.canvas);
                this.selectCallback = selectCallback;

                this.initBuild();
            }
            rubberBandSelector.prototype.initBuild = function () {
                var _this = this;
                if (!this.isSvgCanvas) {
                    //---- change canvas so that we can put an absolutely positioned span onto it ----
                    vp.dom.css(this.canvas, "position", "relative");
                }

                vp.events.attach(this.canvas, "mousedown", function (e) {
                    _this.onDown(e);
                });

                //vp.events.attach(window, "mousedown", closure.onDown);
                vp.events.attach(this.canvas, "keydown", function (e) {
                    if (e.keyCode == vp.events.keyCodes.escape) {
                        _this.cancelBanding(true, e);
                    }
                });
            };

            rubberBandSelector.prototype.setRubberBand = function (rc) {
                if (!this.rubberBand) {
                    if (this.isSvgCanvas) {
                        this.rubberBand = vp.dom.append(this.canvas, "rect");

                        //---- get THEME drawing attributes for each of the parts we will draw ----
                        var da = vp.session.currentTheme().getDrawingAttributes("dragRect");

                        vp.internal.applyShapeAttributes(this.rubberBand, da);
                    } else {
                        this.rubberBand = vp.dom.append(this.canvas, "div").setClass("rubberBand").css("z-index", "99999");
                    }
                }

                if (this.isSvgCanvas) {
                    this.rubberBand.bounds(rc.left, rc.top, rc.width, rc.height);
                } else {
                    this.rubberBand.absPosition(rc.left, rc.top).width(rc.width).height(rc.height);
                }
            };

            rubberBandSelector.prototype.clearRubberBand = function () {
                if (this.rubberBand) {
                    this.rubberBand.remove();
                    this.rubberBand = null;
                }
            };

            rubberBandSelector.prototype.cancelBanding = function (clearBanding, evt) {
                this.clearRubberBand();
                vp.events.releaseCapture(this.canvas, evt);

                if (clearBanding) {
                    this.isBanding = false;
                }
            };

            rubberBandSelector.prototype.isToggleKey = function (evt) {
                return (evt.ctrlKey);
            };

            rubberBandSelector.prototype.onUp = function (evt) {
                this.cancelBanding(false, evt);
                var cancelEvent = false;

                vp.utils.debug("got MOUSE UP on RUBBER BAND canvas");

                try  {
                    if (this.isBanding) {
                        var toggle = this.isToggleKey(evt);

                        var ptCurrent = vp.events.mousePosition(evt, this.canvas);
                        var rcBand = vp.geom.rectFromPoints(ptCurrent, this.ptMouseDown);

                        vp.utils.debug("rcBand: width=" + rcBand.width + ", height=" + rcBand.height);

                        //---- allow for a direct click (no movement) ----
                        if (true) {
                            vp.utils.debug("calling selectCallback from RUBBER BAND...");

                            if (this.selectCallback) {
                                this.selectCallback(rcBand, toggle);
                            }

                            cancelEvent = true;
                        }
                    }
                } catch (ex) {
                    vp.utils.debug("Exception in rubber banding: " + ex);
                    //throw ex;
                } finally {
                    //---- re-enable text selection by browser (for Chrome, FireFox) ----
                    vp.dom.enableElementSelection(document.body, true);

                    this.cancelBanding(true, null);
                }
                //if (cancelEvent)
                //{
                //    vp.utils.debug("trying to cancel UP event on RUBBER BAND canvas");
                //    //---- what's the minimum needed here?  this doesn't work in preventing subsequent click event ----
                //    //---- in this particular case ----
                //    evt.preventDefault();
                //    evt.cancelBubble = true;
                //    evt.stopPropagation();
                //    window.event.returnValue = false;
                //    return false;
                //}
            };

            rubberBandSelector.prototype.onMove = function (evt) {
                 {
                    if (this.isBanding) {
                        var ptCurrent = vp.events.mousePosition(evt, this.canvas);
                        var rc = vp.geom.rectFromPoints(ptCurrent, this.ptMouseDown);

                        this.setRubberBand(rc);
                    }
                }
                //catch (ex)
                //{
                //    vp.utils.debug("MouseMove Exception: " + ex);
                //}
            };

            rubberBandSelector.prototype.onDown = function (evt) {
                var _this = this;
                if (this.isBanding) {
                    this.cancelBanding(true, evt);
                } else if (this._isEnabled) {
                    var toggle = this.isToggleKey(evt);

                    //---- prevent text selection by browser during our drag operation (for Chrome, FireFox) ----
                    vp.dom.enableElementSelection(document.body, false);

                    //---- use chart-relative point & then add chart-relative offset of each series ----
                    this.ptMouseDown = vp.events.mousePosition(evt, this.canvas);
                    this.isBanding = true;

                    vp.events.setCapture(this.canvas, evt, function (e) {
                        _this.onMove(e);
                    }, function (e) {
                        _this.onUp(e);
                    });
                }
            };

            rubberBandSelector.prototype.isEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isEnabled;
                }

                this._isEnabled = value;
                return this;
            };
            return rubberBandSelector;
        })();
        visuals.rubberBandSelector = rubberBandSelector;

        function createRubberBandSelector(canvasUW, selectCallback) {
            return new rubberBandSelector(canvasUW, selectCallback);
        }
        visuals.createRubberBandSelector = createRubberBandSelector;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=rubberBandSelector.js.map

///----------------------------------------------------------------
/// (from events\startup.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// startup.js.  Copyright (c) 2012 Microsoft Corporation.
///              part of the vuePlot library - startup & document/script loading functions.
///-----------------------------------------------------------------------------------------------------------------
/// internal: initialize the vuePlot function and global object.
vp.init = function ()
{
    this.readyFuncs = [];
    this.readyTriggered = false;
//    this.keyboardKeys = {};
    this.scripts = {};          // {url, isLoaded} for scripts being downloaded

    //alert(navigator.userAgent.toLowerCase());

    var self = this;

    if (document.addEventListener != null)
    {
        document.addEventListener("DOMContentLoaded", function ()
        {
            self.checkReady();
        });
    }
    else if (document.attachEvent != null)
    {
        //---- IE8 and earlier ----
        document.attachEvent("onreadystatechange", function ()
        {
            self.checkReady();
        });
    }

}

/// internal: check to see if document and all requested scripts are fully loaded.
vp.checkReady = function ()
{
    //vp.utils.debug("checkReady...");
    if (!allLoaded)            // ignore these calls once we are all loaded
    {
        //---- ensure document is fully loaded ----
        var state = document.readyState;
        if ((state === "complete") || (state == "interactive"))
        {
            //---- watch for IE timing isssue; might need another tick ----
            if (!document.body)
            {
                setTimeout(vp.utils.cb(this.checkReady, this));
                return;
            }

            var allLoaded = true;

            //---- ensure all requested scripts have loaded ----
            for (var url in this.scripts)
            {
                if (this.scripts[url] === null)
                {
                    allLoaded = false;
                    break;
                }
            }

            if (allLoaded)
            {
                //---- now, execute each script in declared order ----
                for (var url in this.scripts)
                {
                    var js = this.scripts[url];
                    vp.globalEval(js);
                }

                this.scripts = {};      // so we don't run them again

                //---- now, everything has been loaded ----
                this.onReady();
            }
        }
    }
};

/// internal: called when document and all requested scripts are fully loaded.
vp.onReady = function ()
{
    //vp.utils.debug("onReady called");

    if (!this.readyTriggered)
    {
        for (var i = 0; i < this.readyFuncs.length; i++)
        {
            this.readyFuncs[i]();
        }

        this.readyFuncs = [];       // only call these once

        this.readyTriggered = true;
    }
};

//---- intialize are global function/object now ----
vp.init();

vp.utils.ready = function (readyFunc)
    /// signature: vp.utils.ready(func)
    ///     summary: adds the specified function to a list of functions that will be called when the document and all requested scripts are fully loaded.
    ///     paramType(func): the function to be called when the document/scripts are loaded.
    ///     snippet: $.ready(function()  { buildItems(); });     // call buildItems() when doc is loaded
    ///     returns: null.
{
    vp.readyFuncs.push(readyFunc);
};

/// internal - don't expose
vp.httpReadText = function (url, successFunc, failFunc)
{
    var xmlhttp = null;

    if (XMLHttpRequest != null)
    {
        xmlhttp = new XMLHttpRequest();
    }
    else
    {
        xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    }

    xmlhttp.open("GET", url, true);

    xmlhttp.onreadystatechange = function ()
    {
        if ((xmlhttp.readyState == 4) && (xmlhttp.status != 0))
        {
            if (xmlhttp.status == 200)
            {
                if (successFunc != null)
                {
                    successFunc(xmlhttp);
                }
            }
            else
            {
                if (failFunc != null)
                {
                    failFunc(xmlhttp);
                }
            }
        }
    };

    xmlhttp.send();
}

vp.startScriptLoad = function (url)
{
    //---- don't load the same script twice ----
    if (vp.utils.isUndefined(vp.scripts[url]))
    {
        var head = document.getElementsByTagName("head")[0];
        if (head)
        {
            vp.scripts[url] = null;        // mark it as being loaded

            vp.httpReadText(url, function (xhr)
            {
                var text = xhr.responseText;
                vp.scripts[url] = text;
                vp.checkReady();
            });
        }
    }
}

///----------------------------------------------------------------
/// (from events\tooltip.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// tooltip.js.  Copyright (c) 2012 Microsoft Corporation.
///              part of the vuePlot library - class for supporting rich tooltips.
///-----------------------------------------------------------------------------------------------------------------
//---- class: tooltip ----
vp.visuals.toolTip = function (ttDiv, ttShowingFunc, swapCtrlKey)
{
    //---- private state ----
    var ttElem = null;          // the element we are showing a tooltip for
    var mousePos = null;        // the current position of the mouse
    var showDelay = 1000;       // how long to wait before making the tooltip visible
    var showDuration = 5000;    // how long to display the tooltip before starting to hide it
    var hideDelay = 500;        // if tooltip is no longer over a tooltip-able item, how long to wait before hiding tooltip
    var timer = null;           // controls timing of showing/hiding tooltip
    var isTooltipEnabled = true;

    /// closure
    var closure = function ()
    {
    };

    closure.ctr = "vp.visuals.toolTip";

    /// public property: isEanbled
    closure.isEnabled = function (value)
    {
        if (arguments.length == 0)
        {
            return isTooltipEnabled;
        }

        isTooltipEnabled = value;
    };

    /// public property: showDelay
    closure.showDelay = function (value)
    {
        if (arguments.length == 0)
        {
            return showDelay;
        }

        showDelay = value;
    };

    /// private: mouseMove()
    var mouseMove = function (e)
    {
        var isCtrlKey = (swapCtrlKey) ? (!e.ctrlKey) : e.ctrlKey;

        //---- hold ctrl key down for debugging (move cursor without triggering event) ----
        if ((isTooltipEnabled) && (!isCtrlKey))
        {
            var pos = vp.events.mousePosition(e);
            mousePos = pos;

            //---- elementFromPoint() doesn't work for nested SVG documents in some browsers ----
            //---- it turns out "e.target" is very reliable and easy to use. ----
            var elem = vp.events.elementFromPoint(pos.x, pos.y);
            //var elem = e.target;

            var found = false;

            //vp.utils.debug("tooltip.mouseMove: x=" + pos.x + ", y=" + pos.y + ", elem=" + elem);

            if (elem != null)
            {
                //vp.utils.debug("elem.ctr=" + elem.ctr);
            }

            //---- find the interesting parent of closure child ----
            var parent = elem;
            while ((parent != null) && (parent != ttDiv) && (parent.toolTipContext === undefined))
            {
                parent = parent.parentNode;
            }

            //var isShowing = ((timer != null) || (ttDiv.style.visibility == "visible"));

            if (parent != null)
            {
                found = true;           // found a tooltip element or the tooltip itself

                if (parent == ttDiv)
                {
                    //---- on the tooltip (or one of its children); give it some more time ----
                    //closure.hide(showDuration);
                }
                else if (parent != ttElem)
                {
                    //---- active tooltip elem has changed ----
                    if ((ttElem == null) || (ttDiv.style.visibility == "hidden"))
                    {
                        ttElem = parent;
                        closure.show(showDelay);
                    }
                    else
                    {
                        //---- if an elem was active, make it an instant switch ----
                        ttElem = parent;
                        closure.showNow();
                    }
                }
            }

            if (!found)
            {
                closure.hide(hideDelay);
            }
        }
    };

    /// private: setPositionFromMouse()
    closure.setPositionFromMouse = function ()
    {
        var pos = mousePos;
        pos.y += 20;            // move below mouse cursor bottom

        var tt = ttDiv;

        var tw = vp.dom.width(window);
        var th = vp.dom.height(window);

        var w = vp.dom.width(tt);
        var h = vp.dom.height(tt);

        var scroll = vp.dom.getBodyScroll();

        var ttTop = vp.dom.docOffset(ttElem).top;

        //---- slide left, if needed ----
        var shadowPlus = 10;        // leave some space for shadow & asthetics
        var xover = (pos.x + w + shadowPlus) - tw;
        if ((xover > 0) && (xover <= pos.x))
        {
            //vp.utils.debug("tw=" + tw + ", w=" + w + ", xover=" + xover + ", pos.x=" + pos.x);

            pos.x -= xover;
        }
        else
        {
            //vp.utils.debug("w=" + w + ", h=" + h);
        }

        //---- move above item, if needed ----
        var yover = (pos.y + h + shadowPlus) - th;
        if ((yover > 0) && (h < ttTop))
        {
            pos.y = ttTop - (h + shadowPlus);
        }

        tt.style.left = pos.x + "px";
        tt.style.top = pos.y + "px";
    };

    /// private: cancelTimers()
    closure.cancelTimers = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }
    };

    /// public: show()
    /// show the tooltip in delay ms (or now, if delay is undefined.
    closure.show = function (delay)
    {
        closure.cancelTimers();

        if (isTooltipEnabled)
        {
            if (delay)
            {
                timer = setTimeout(closure.showNow, delay);
            }
            else
            {
                closure.showNow();
            }
        }
    }

    /// public: showNow()
    /// show the tooltip immediately and set a timer for when to start hiding it.
    closure.showNow = function ()
    {
        if ((ttElem != null) && (isTooltipEnabled))
        {
            var showIt = true;

            if (ttShowingFunc)
            {
                showIt = ttShowingFunc(ttElem);
            }

            if (showIt)
            {
                //---- make visible first, so "setPositionFromMouse" can correctly measure size of tooltip ----
                vp.dom.left(ttDiv, -100000);        // move offscreen while we calculate its desired position
                ttDiv.style.visibility = "visible";

                setTimeout(closure.onTooltipReadyToMeasure, 1);
                //closure.setPositionFromMouse();
                //closure.hide(showDuration);
            }
        }
    };

    closure.onTooltipReadyToMeasure = function (e)
    {
        closure.setPositionFromMouse();
        //closure.hide(showDuration);
    };

    /// public: hide()
    closure.hide = function (delay)
    {
        //vp.utils.debug("tt.hide called");

        closure.cancelTimers();

        if (delay)
        {
            timer = setTimeout(closure.hideNow, delay);
        }
        else
        {
            closure.hideNow();
        }
    };

    closure.hideNow = function ()
    {
        //---- experiment ----
        var w = vp.dom.width(ttDiv);

        closure.cancelTimers();
        ttElem = null;

        ttDiv.style.visibility = "hidden";
    };

    //---- init code ----
    document.addEventListener("mousemove", mouseMove);

    return closure;
};


///----------------------------------------------------------------
/// (from events\touch.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// touch.js.  Copyright (c) 2012 Microsoft Corporation.
///            part of the vuePlot library - handles touch events.
///-----------------------------------------------------------------------------------------------------------------
///
/// touchEventHandler class
///
///     this class adapted from microsoft blog code:
///         adapted from: http://blogs.msdn.com/b/ie/archive/2011/10/19/handling-multi-touch-and-mouse-input-in-all-browsers.aspx
///
///     target - the HTML element object which is the target of the touch event
///
///     touchDownFunc - called when one of a TOUCH DOWN (or mouse/stylus down) event occurs.
///          5 params: target, pointerId, x, y, evt.        x and y are guaranteed to be within target's rectange.
///
///     touchMoveFunc - called when one of a TOUCH MOVE (or mouse/stylus move) event occurs.  same params.
///
///     touchUpFunc - called when one of a TOUCH UP (or mouse/stylus up) event occurs.  same params.
///
///     - The "touchXXXFunc" params are all optional.
///     - The target element cannot move within the document during drawing.
///
vp.touchEventHandlerFactory = function (target, touchDownFunc, touchMoveFunc, touchUpFunc)
{
    //---- lastXYById is an object to keep track of the last x/y positions of the mouse/pointer/touch point ----
    //---- used to reject redundant moves and as a flag to determine if we're in the "down" state ----
    this.lastXYById = {};

    //--- opera doesn't have Object.keys so we use this wrapper ----
    this.numberOfKeys = function (theObject)
    {
        if (Object.keys)
            return Object.keys(theObject).length;

        var n = 0;
        for (var key in theObject)
            ++n;

        return n;
    };

    //  IE10's implementation in the Windows Developer Preview requires doing all of this
    //  Not all of these methods remain in the Windows Consumer Preview, hence the tests for method existence.
    this.preventDefaultManipulationAndMouseEvent = function (evtObj)
    {
        if (evtObj.preventDefault)
            evtObj.preventDefault();

        if (evtObj.preventManipulation)
            evtObj.preventManipulation();

        if (evtObj.preventMouseEvent)
            evtObj.preventMouseEvent();
    };

    //  we send target-relative coordinates to the draw functions
    //  this calculates the delta needed to convert pageX/Y to offsetX/Y because offsetX/Y don't exist in the TouchEvent object or in Firefox's MouseEvent object
    this.computeDocumentToElementDelta = function (theElement)
    {
        var off = vp.dom.docOffset(theElement);
        var elementLeft = off.left;
        var elementTop = off.top;

        //        for (var offsetElement = theElement; offsetElement != null; offsetElement = offsetElement.offsetParent)
        //        {
        //            //  the following is a major hack for versions of IE less than 8 to avoid an apparent problem on the IEBlog with double-counting the offsets
        //            //  this may not be a general solution to IE7's problem with offsetLeft/offsetParent
        //            if (navigator.userAgent.match(/\bMSIE\b/) && (!document.documentMode || document.documentMode < 8) && offsetElement.currentStyle.position == "relative" && offsetElement.offsetParent && offsetElement.offsetParent.currentStyle.position == "relative" && offsetElement.offsetLeft == offsetElement.offsetParent.offsetLeft)
        //            {
        //                // add only the top
        //                elementTop += offsetElement.offsetTop;
        //            }
        //            else
        //            {
        //                elementLeft += offsetElement.offsetLeft;
        //                elementTop += offsetElement.offsetTop;
        //            }
        //        }

        return { x: elementLeft, y: elementTop };
    };

    //  function needed because IE versions before 9 did not define pageX/Y in the MouseEvent object
    this.ensurePageXY = function (eventObj)
    {
        if (typeof eventObj.pageX == 'undefined')
        {
            //  initialize assuming our source element is our target
            eventObj.pageX = eventObj.offsetX + documentToTargetDelta.x;
            eventObj.pageY = eventObj.offsetY + documentToTargetDelta.y;

            if (eventObj.srcElement.offsetParent == target && document.documentMode && document.documentMode == 8 && eventObj.type == "mousedown")
            {
                //  source element is a child piece of VML, we're in IE8, and we've not called setCapture yet - add the origin of the source element
                eventObj.pageX += eventObj.srcElement.offsetLeft;
                eventObj.pageY += eventObj.srcElement.offsetTop;
            }
            else if (eventObj.srcElement != target && !document.documentMode || document.documentMode < 8)
            {
                //  source element isn't the target (most likely it's a child piece of VML) and we're in a version of IE before IE8 -
                //  the offsetX/Y values are unpredictable so use the clientX/Y values and adjust by the scroll offsets of its parents
                //  to get the document-relative coordinates (the same as pageX/Y)
                var sx = -2, sy = -2;   // adjust for old IE's 2-pixel border
                for (var scrollElement = eventObj.srcElement; scrollElement != null; scrollElement = scrollElement.parentNode)
                {
                    sx += scrollElement.scrollLeft ? scrollElement.scrollLeft : 0;
                    sy += scrollElement.scrollTop ? scrollElement.scrollTop : 0;
                }

                eventObj.pageX = eventObj.clientX + sx;
                eventObj.pageY = eventObj.clientY + sy;
            }
        }
    };

    //  functions to convert document-relative coordinates to target-relative and constrain them to be within the target
    this.targetRelativeX = function (px)
    {
        return Math.max(0, Math.min(px - documentToTargetDelta.x, vp.dom.width(target)));
    };

    this.targetRelativeY = function (py)
    {
        return Math.max(0, Math.min(py - documentToTargetDelta.y, vp.dom.height(target)));
    };

    var self = this;

    //  common event handler for the mouse/pointer/touch models and their down/start, move, up/end, and cancel events
    this.doEvent = function (theEvtObj)
    {
        //vp.utils.debug("touchEventHandler.doEvent: BEFORE FILTER: theEvtObj.type=" + theEvtObj.type);

        //  optimize rejecting mouse moves when mouse is up
        if ((theEvtObj.type == "mousemove") && (vp.utils.numberOfKeys(self.lastXYById) == 0))
        {
            return;
        }

        //vp.utils.debug("touchEventHandler.doEvent: theEvtObj.type=" + theEvtObj.type);

        self.preventDefaultManipulationAndMouseEvent(theEvtObj);

        var pointerList = theEvtObj.changedTouches ? theEvtObj.changedTouches : [theEvtObj];

        for (var i = 0; i < pointerList.length; ++i)
        {
            var pointerObj = pointerList[i];
            var pointerId = (typeof pointerObj.identifier != 'undefined') ? pointerObj.identifier : (typeof pointerObj.pointerId != 'undefined') ? pointerObj.pointerId : 1;

            //  use the pageX/Y coordinates to compute target-relative coordinates when we have them (in ie < 9, we need to do a little work to put them there)
            self.ensurePageXY(pointerObj);

            var pageX = pointerObj.pageX;
            var pageY = pointerObj.pageY;

            if (theEvtObj.type.match(/(start|down)$/i))
            {
                //  clause for processing MSPointerDown, touchstart, and mousedown

                //  refresh the document-to-target delta on start in case the target has moved relative to document
                documentToTargetDelta = self.computeDocumentToElementDelta(target);

                //  protect against failing to get an up or end on this pointerId
                if (self.lastXYById[pointerId])
                {
                    if (touchUpFunc)
                    {
                        touchUpFunc(target, pointerId, self.targetRelativeX(pageX), self.targetRelativeY(pageY), theEvtObj);
                    }

                    delete self.lastXYById[pointerId];
                }

                if (touchDownFunc)
                {
                    var result = touchDownFunc(target, pointerId, self.targetRelativeX(pageX), self.targetRelativeY(pageY), theEvtObj);
                    if (result !== undefined)
                    {
                        self.useCapture = result;
                    }
                }

                //  init last page positions for this pointer
                self.lastXYById[pointerId] = { x: pageX, y: pageY };

                //  in the Microsoft pointer model, set the capture for this pointer
                //  in the mouse model, set the capture or add a document-level event handlers if this is our first down point
                //  nothing is required for the iOS touch model because capture is implied on touchstart
                if (target.msSetPointerCapture)
                {
                    target.msSetPointerCapture(pointerId);
                }
                else if (theEvtObj.type == "mousedown" && self.numberOfKeys(self.lastXYById) == 1)
                {
                    if ((self.useCapture) && (target.setCapture))
                    {
                        target.setCapture(true);
                        vp.utils.debug("mouse captured on TARGET: " + target);
                    }
                    else
                    {
                        //---- if we cannot capture the mouse, we must listen to all document move/up events ----
                        //---- to simulate a mouse capture.  In particular, it is CRITICAL that we listen to ----
                        //---- document mouseup so we know when to terminate the caller's drag operation ----
                        document.body.addEventListener("mousemove", this.doEvent, false);
                        document.body.addEventListener("mouseup", this.doEvent, false);

                        if ((self.useCapture) && (document.body.setCapture))
                        {
                            document.body.setCapture(true);
                            vp.utils.debug("mouse captured on DOCUMENT.BODY");
                        }
                    }
                }
            }
            else if (theEvtObj.type.match(/move$/i))
            {
                //  clause handles mousemove, MSPointerMove, and touchmove

                if (self.lastXYById[pointerId] && !(self.lastXYById[pointerId].x == pageX && self.lastXYById[pointerId].y == pageY))
                {
                    documentToTargetDelta = self.computeDocumentToElementDelta(target);

                    //  only extend if the pointer is down and it's not the same as the last point
                    if (touchMoveFunc)
                    {
                        touchMoveFunc(target, pointerId, self.targetRelativeX(pageX), self.targetRelativeY(pageY), theEvtObj);
                    }

                    //  update last page positions for this pointer
                    self.lastXYById[pointerId].x = pageX;
                    self.lastXYById[pointerId].y = pageY;
                }
            }
            else if (self.lastXYById[pointerId] && theEvtObj.type.match(/(up|end|cancel)$/i))
            {
                //  clause handles up/end/cancel

                if (touchUpFunc)
                {
                    touchUpFunc(target, pointerId, self.targetRelativeX(pageX), self.targetRelativeY(pageY), theEvtObj);
                }

                //  delete last page positions for this pointer
                delete self.lastXYById[pointerId];

                //  in the Microsoft pointer model, release the capture for this pointer
                //  in the mouse model, release the capture or remove document-level event handlers if there are no down points
                //  nothing is required for the iOS touch model because capture is implied on touchstart
                if (target.msReleasePointerCapture)
                {
                    target.msReleasePointerCapture(pointerId);
                }
                else if (theEvtObj.type == "mouseup" && self.numberOfKeys(self.lastXYById) == 0)
                {
                    if ((self.useCapture) && (target.releaseCapture))
                    {
                        target.releaseCapture();
                    }
                    else
                    {
                        document.removeEventListener("mousemove", this.doEvent, false);
                        document.removeEventListener("mouseup", this.doEvent, false);
                    }
                }
            }
        }
    };

    //---- start up code ----
    self.useCapture = false;

    //---- cache the delta from the document to our event target ----
    var documentToTargetDelta = this.computeDocumentToElementDelta(target);

    if (window.navigator.msPointerEnabled)
    {
        //---- hook Microsoft "pointer model" events ----
        target.addEventListener("MSPointerDown", this.doEvent, false);
        target.addEventListener("MSPointerMove", this.doEvent, false);
        target.addEventListener("MSPointerUp", this.doEvent, false);
        target.addEventListener("MSPointerCancel", this.doEvent, false);

        //---- prevent panning when we touch our target area ----
        if (typeof target.style.msContentZooming != 'undefined')
        {
            target.style.msContentZooming = "none";
        }

        //---- don't let IE steal our touch events ----
        if (typeof target.style.msTouchAction != 'undefined')
        {
            target.style.msTouchAction = "none";
        }
    }
    else if (target.addEventListener)
    {
        //---- hook IOS touch model events ----
        target.addEventListener("touchstart", this.doEvent, false);
        target.addEventListener("touchmove", this.doEvent, false);
        target.addEventListener("touchend", this.doEvent, false);
        target.addEventListener("touchcancel", this.doEvent, false);

        //---- hook mouse events ----
        target.addEventListener("mousedown", this.doEvent, false);

        //---- does this browser support capturing the mouse? ----
        if (true)      
        {
            //---- don't hook for Gecko browsers since they don't send events when the mouse is outside target ----
            if (true)   // set to true to fix for Chrome     //!window.navigator.userAgent.match(/\bGecko\b/))
            {
                self.useCapture = true;

                target.addEventListener("mousemove", this.doEvent, false);
                target.addEventListener("mouseup", this.doEvent, false);
            }
        }
    }
    else if ((target.attachEvent) && (target.setCapture))
    {
        //---- legacy IE mode - hook mouse events and use mouse capture ----
        self.useCapture = true;

        target.attachEvent("onmousedown", function ()
        {
            this.doEvent(window.event);

            //---- cancel the event to stop system from selecting text, etc. on non-IE browsers ----
            theEvtObj.cancelBubble = true;
            theEvtObj.stopPropagation();

            //---- mark the event as handled ----
            window.event.returnValue = false;
            return false;
        });

        target.attachEvent("onmousemove", function ()
        {
            this.doEvent(window.event);

            //---- cancel the event to stop system from selecting text, etc. on non-IE browsers ----
            theEvtObj.cancelBubble = true;
            theEvtObj.stopPropagation();

            //---- mark the event as handled ----
            window.event.returnValue = false;
            return false;
        });

        target.attachEvent("onmouseup", function ()
        { 
            this.doEvent(window.event);

            //---- cancel the event to stop system from selecting text, etc. on non-IE browsers ----
            theEvtObj.cancelBubble = true;
            theEvtObj.stopPropagation();

            //---- mark the event as handled ----
            window.event.returnValue = false;
            return false;
        });
    }
};

vp.touchEventHandler = function (target, touchDownFunc, touchMoveFunc, touchUpFunc)
{
    return new vp.touchEventHandlerFactory(target, touchDownFunc, touchMoveFunc, touchUpFunc);
};
///-----------------------------------------------------------------------------------------------------------------
/// mappings.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a mappings object to hold our plot/layer property/data mappings.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (layers) {
        var mappingsClass = (function () {
            //xEnd = null;
            //yEnd = null;
            function mappingsClass() {
                //---- public ----
                this.ctr = "vp.visuals.vvMappings";
                //---- private state ----
                this._data = undefined;
                //---- property variables ----
                this._x = undefined;
                this._y = undefined;
                this._yMin = undefined;
                this._yMax = undefined;
                this._yOpen = undefined;
                this._yClose = undefined;
                this._xEnd = undefined;
                this._yEnd = undefined;
                //---- mapped drawing attributes ----
                this._stroke = undefined;
                this._fill = undefined;
                this._opacity = undefined;
                this._lineType = undefined;
                this._shapeType = undefined;
                this._lineSize = undefined;
                this._shapeSize = undefined;
                this._textSize = undefined;
                this._textFill = undefined;
                this._label = undefined;
                //---- constant-only (non-mapped) attributes ----
                this._hAlign = undefined;
                this._vAlign = undefined;
                this._fontFamily = undefined;
                this._stackType = "";
                this._key = undefined;
                this._key2 = undefined;
                this._showOutliers = false;
                this._direction = "";
                this._fillRule = "";
                //---- aliases ----
                this.yIntercept = null;
                this.xIntercept = null;
                this.slope = null;
                //---- pre-create X and Y attributes ----
                this.generalProp("_x", "space");
                this.generalProp("_y", "space");

                //---- assign all aliases ----
                this.yIntercept = this.y;
                this.xIntercept = this.x;
                this.slope = this.x;
            }
            mappingsClass.prototype.pop = function () {
                return this;
            };

            //parentMappings(propName)
            //{
            //    var value = undefined;
            //    if (this._vvParent)
            //    {
            //        var layerOrPlot = this._vvParent;
            //        if (layerOrPlot.vvParent)
            //        {
            //            var plot = this._vvParent.vvParent();
            //            if (plot)
            //            {
            //                var pm = plot.mappings();
            //                value = pm[propName]();
            //            }
            //        }
            //    }
            //    return this;
            //}
            mappingsClass.prototype.markRebuildNeeded = function () {
                ////---- mapping checks its parent (vvLayer or vvPlot) ----
                //if (this._vvParent != null)
                //{
                //    this._vvParent.markRebuildNeeded();
                //}
            };

            ////---- property: setterReturnValue ----
            //setterReturnValue(value)
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this;
            //    }
            //    this = value;
            //    //---- this setter is special and returns the "vvMapping" object (closure) ----
            //    return this;
            //}
            mappingsClass.prototype.capitalize = function (str) {
                return str[0].toUpperCase() + str.substr(1);
            };

            mappingsClass.prototype.generalProp = function (propName, scaleName, args) {
                var firstArg = (args && args.length) ? args[0] : undefined;

                if (firstArg && firstArg.ctr === "vp.scales.attributeClass") {
                    this[propName] = firstArg;

                    this.markRebuildNeeded();
                    return this;
                }

                //---- ensure we have a attrbute object (JIT create) ----
                var attribute = this[propName];
                if (!attribute) {
                    var scale = null;

                    if (scaleName) {
                        scale = eval("vp.scales.create" + this.capitalize(scaleName) + "()");
                    }

                    attribute = vp.scales.createAttribute(propName, scale).owner(this);

                    var isXOrY = ((propName == "_x") || (propName == "_y"));
                    attribute.layerDefaults.useNiceNumbers = true;
                    attribute.layerDefaults.zeroAxis = isXOrY;
                    attribute.layerDefaults.addMaxHeadroom = false; // let the user adjust this when needed, but default to exact data values as nice numbers     isXOrY;

                    this[propName] = attribute;
                }

                if ((!args) || (args.length === 0)) {
                    return attribute;
                }

                if (true) {
                    args = firstArg;
                }

                attribute.quickSet(args);

                this.markRebuildNeeded();
                return this;
            };

            mappingsClass.prototype.x = function (firstValue) {
                return this.generalProp("_x", "space", arguments);
            };

            mappingsClass.prototype.y = function (firstValue) {
                return this.generalProp("_y", "space", arguments);
            };

            mappingsClass.prototype.stroke = function (firstValue) {
                return this.generalProp("_stroke", "color", arguments);
            };

            mappingsClass.prototype.fill = function (firstValue) {
                return this.generalProp("_fill", "color", arguments);
            };

            mappingsClass.prototype.lineSize = function (firstValue) {
                return this.generalProp("_lineSize", "size", arguments);
            };

            mappingsClass.prototype.shapeSize = function (firstValue) {
                return this.generalProp("_shapeSize", "size", arguments);
            };

            mappingsClass.prototype.textSize = function (firstValue) {
                return this.generalProp("_textSize", "textSize", arguments);
            };

            mappingsClass.prototype.textFill = function (firstValue) {
                return this.generalProp("_textFill", "color", arguments);
            };

            mappingsClass.prototype.lineType = function (firstValue) {
                return this.generalProp("_lineType", "lineType", arguments);
            };

            mappingsClass.prototype.label = function (value) {
                return this.generalProp("_label", null, arguments);
            };

            mappingsClass.prototype.hAlign = function (value) {
                if (arguments.length == 0) {
                    return this._hAlign;
                }

                this._hAlign = value;
                this.markRebuildNeeded();

                return this;
            };

            mappingsClass.prototype.vAlign = function (value) {
                if (arguments.length == 0) {
                    return this._vAlign;
                }

                this._vAlign = value;
                this.markRebuildNeeded();

                return this;
            };

            mappingsClass.prototype.yMin = function (value) {
                return this.generalProp("_yMin", "space", arguments);
            };

            mappingsClass.prototype.yMax = function (value) {
                return this.generalProp("_yMax", "space", arguments);
            };

            mappingsClass.prototype.xEnd = function (value) {
                return this.generalProp("_xEnd", "space", arguments);
            };

            mappingsClass.prototype.yEnd = function (value) {
                return this.generalProp("_yEnd", "space", arguments);
            };

            mappingsClass.prototype.yOpen = function (value) {
                return this.generalProp("_yOpen", "space", arguments);
            };

            mappingsClass.prototype.yClose = function (value) {
                return this.generalProp("_yClose", "space", arguments);
            };

            mappingsClass.prototype.opacity = function (firstValue) {
                return this.generalProp("_opacity", "opacity", arguments);
            };

            mappingsClass.prototype.shapeType = function (value) {
                return this.generalProp("_shapeType", "shape", arguments);
            };

            mappingsClass.prototype.fillRule = function (value) {
                if (arguments.length == 0) {
                    return this._fillRule;
                }

                this._fillRule = value;
                this.markRebuildNeeded();

                return this;
            };

            mappingsClass.prototype.fontFamily = function (value) {
                if (arguments.length == 0) {
                    return this._fontFamily;
                }

                this._fontFamily = value;
                this.markRebuildNeeded();

                return this;
            };

            mappingsClass.prototype.stackType = function (value) {
                if (arguments.length == 0) {
                    return this._stackType;
                }

                this._stackType = value;
                this.markRebuildNeeded();

                return this;
            };

            mappingsClass.prototype.key = function (value) {
                if (arguments.length == 0) {
                    return this._key;
                }

                this._key = value;

                this.onKeyChanged();

                //if (this._vvParent)
                //{
                //    this._vvParent.onKeyChanged();
                //}
                this.markRebuildNeeded();

                return this;
            };

            mappingsClass.prototype.key2 = function (value) {
                if (arguments.length == 0) {
                    return this._key2;
                }

                this._key2 = value;

                this.onKey2Changed();

                this.markRebuildNeeded();

                return this;
            };

            mappingsClass.prototype.showOutliers = function (value) {
                if (arguments.length == 0) {
                    return this._showOutliers;
                }

                this._showOutliers = value;
                this.markRebuildNeeded();

                return this;
            };

            mappingsClass.prototype.direction = function (value) {
                if (arguments.length == 0) {
                    return this._direction;
                }

                this._direction = value;
                this.markRebuildNeeded();

                return this;
            };

            mappingsClass.prototype.onKeyChanged = function () {
            };

            mappingsClass.prototype.onKey2Changed = function () {
            };
            return mappingsClass;
        })();
        layers.mappingsClass = mappingsClass;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=--mappings.js.map

///----------------------------------------------------------------
/// (from layers\-baseLayer.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// baseLayer.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - the base class for a plotLayer object.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (_layers) {
        var nextLayerId = 1;

        /**  the base class for a plotLayer object. "T" is the outer layer class. */
        var baseLayerClass = (function (_super) {
            __extends(baseLayerClass, _super);
            function baseLayerClass() {
                _super.call(this);
                /** public field that gives the name of the class */
                this.ctr = "vp.layers.baseLayerClass";
                /** public field that provides information about drawShapes caller */
                this.info = {};
                //---- private state ----
                /** True if this layer supports 0-N series of data (used by dataAnimMgr). */
                this._isSeriesLayer = false;
                //---- todo: combine these 3 properties + KEY so we don't have so much duplication ----
                this._dataAnimMgr = undefined;
                this._newTagOrFunc = undefined;
                this._data2 = undefined;
                this._dataAnimMgr2 = undefined;
                this._newTagOrFunc2 = undefined;
                //---- for ease of access ----
                this._xAttr = null;
                this._yAttr = null;
                this._xDefaults = null;
                this._yDefaults = null;
                this._plotDefaults = new vp.layers.plotDefaults();
                this._filter = undefined;
                /* should be a function of the form: formatValue(value, colName, seriesIndex). **/
                this._toolTipFormatter = null;
                this._container = undefined;
                this._defaultStackType = "identity";
                this._vvParent = undefined;
                this._stat = undefined;
                this._layerType = undefined;
                //_seriesPalette = undefined;
                this._postCreateFunc = null;
                this._postUpdateShapes = null;
                this._seriesAxis = "y";
                //_isSeriesVisible: boolean[] = null;                 // allows series to be toggled on/off while legend shows all series
                //---- should these properties be in vvMappings instead? ----
                this._toolTipCols = true;
                this._isAnimEnabled = true;
                this._animDuration = 700;
                this._key = undefined;
                this._key2 = undefined;
                this._chartName = undefined;
                this._xColAfterStat = undefined;
                this._yColsAfterStat = undefined;
                this._xCol2AfterStat = undefined;
                this._yCols2AfterStat = undefined;
                this._layerId = nextLayerId++;
                //---- are drawing attributes currently mapped? ----
                this._isStrokeMapped = false;
                this._isFillMapped = false;
                this._isOpacityMapped = false;
                this._isLineTypeMapped = false;
                this._isShapeTypeMapped = false;
                this._isShapeSizeMapped = false;
                this._isLineSizeMapped = false;
                this._isTextSizeMapped = false;
                this._isTextFillMapped = false;
                this._isTextLabelMapped = false;

                //---- set up ease-of-access variables ----
                this._xAttr = this._x;
                this._yAttr = this._y;
                this._xDefaults = this._xAttr.layerDefaults;
                this._yDefaults = this._yAttr.layerDefaults;
            }
            baseLayerClass.prototype.error = function (msg) {
                throw msg;
            };

            //---- protected ----
            baseLayerClass.prototype.getPrimaryLayer = function (plot) {
                var primLayer = null;

                var layers = plot.layers();
                if (layers && layers.length) {
                    primLayer = layers[0];
                }

                return primLayer;
            };

            //---- define in base class for consistent signature among subclasses ----
            baseLayerClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var shapes = [];
                return shapes;
            };

            baseLayerClass.prototype.prepScaleIfNeeded = function (attrs, seriesNames, attrName) {
                var attr = this["_" + attrName];
                if (attr) {
                    //---- always do X and Y (for implicit category charts); only do other attributes if user has mapped a column to them ----
                    if ((attrName == "x") || (attrName == "y") || (attr.isMapped())) {
                        this.prepAttrScaleIfNeeded(attr, seriesNames);
                        attrs.push(attr);
                    }
                }
            };

            baseLayerClass.prototype.prepAttrScaleIfNeeded = function (attr, seriesNames) {
                if (attr.needsSetUp()) {
                    var attrName = attr._attrName;
                    if (attrName.startsWith("_")) {
                        attrName = attrName.substr(1);
                    }

                    layerName = this._layerType;
                    var layerName = "layer" + layerName.substr(0, 1).toUpperCase() + layerName.substr(1);

                    var da = vp.session.currentTheme().getDrawingAttributes(layerName, 0);
                    var daPropName = (attrName == "fill" || attrName == "stroke") ? (attrName + "Palette") : attrName;
                    var daAttr = da[daPropName];

                    var afterPropName = null;

                    if ((attrName == "x") && (this.info.xRecords.length)) {
                        afterPropName = this.info.xRecords[0].name;
                    } else if ((attrName == "y") && (this.info.yRecords.length)) {
                        afterPropName = this.info.yRecords[0].name;
                    }

                    attr.setupScale(this.info.filteredData, seriesNames, daAttr, this.info.stackType, afterPropName);
                }
            };

            baseLayerClass.prototype.getActiveAttributes = function () {
                var attrs = [];
                var myData = this.data();

                if ((myData) && (myData.length > 0)) {
                    var seriesNames = this.info.seriesNames;

                    this.prepScaleIfNeeded(attrs, seriesNames, "x");
                    this.prepScaleIfNeeded(attrs, seriesNames, "y");
                    this.prepScaleIfNeeded(attrs, seriesNames, "stroke");
                    this.prepScaleIfNeeded(attrs, seriesNames, "fill");
                    this.prepScaleIfNeeded(attrs, seriesNames, "opacity");
                    this.prepScaleIfNeeded(attrs, seriesNames, "lineSize");
                    this.prepScaleIfNeeded(attrs, seriesNames, "lineType");
                    this.prepScaleIfNeeded(attrs, seriesNames, "shapeType");
                    this.prepScaleIfNeeded(attrs, seriesNames, "text");
                }

                return attrs;
            };

            /// chart is being rebuilt, so scales will have to be re-setup.
            baseLayerClass.prototype.onChartRebuild = function () {
                //---- don't trigger a JIT create, if not yet defined ----
                var attr = this;

                if (attr._x) {
                    attr._x.needsSetUp(true);
                }

                if (attr._y) {
                    attr._y.needsSetUp(true);
                }

                if (attr._fill) {
                    attr._fill.needsSetUp(true);
                }

                if (attr._stroke) {
                    attr._stroke.needsSetUp(true);
                }

                if (attr._opacity) {
                    attr._opacity.needsSetUp(true);
                }

                if (attr._lineSize) {
                    attr._lineSize.needsSetUp(true);
                }

                if (attr._shapeType) {
                    attr._shapeType.needsSetUp(true);
                }

                if (attr._lineType) {
                    attr._lineType.needsSetUp(true);
                }

                if (attr._textSize) {
                    attr._textSize.needsSetUp(true);
                }

                if (attr._textFill) {
                    attr._textFill.needsSetUp(true);
                }

                if (attr._label) {
                    attr._label.needsSetUp(true);
                }
            };

            baseLayerClass.prototype.toolTipFormatter = function (value) {
                if (arguments.length == 0) {
                    return this._toolTipFormatter;
                }

                this._toolTipFormatter = value;

                return this;
            };

            baseLayerClass.prototype.vvParent = function (value) {
                if (arguments.length == 0) {
                    return this._vvParent;
                }

                this._vvParent = value;
                this.markRebuildNeeded();

                return this;
            };

            ///// public property: xAxisInfo
            //xAxisInfo(): any;
            //xAxisInfo(value?: any): T;
            //xAxisInfo(value?: any): any
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._xAxisInfo;
            //    }
            //    this._xAxisInfo = value;
            //    this.markRebuildNeeded();
            //    return this;
            //}
            ///// public property: yAxisInfo
            //yAxisInfo(): any;
            //yAxisInfo(value?: any): T;
            //yAxisInfo(value?: any): any
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._yAxisInfo;
            //    }
            //    this._yAxisInfo = value;
            //    this.markRebuildNeeded();
            //    return this;
            //}
            ///// public property: zAxisInfo
            //zAxisInfo(): any;
            //zAxisInfo(value?: any): T;
            //zAxisInfo(value?: any): any        {
            //    if (arguments.length == 0)
            //    {
            //        return this._zAxisInfo;
            //    }
            //    this._zAxisInfo = value;
            //    this.markRebuildNeeded();
            //    return this;
            //}
            baseLayerClass.prototype.onKeyChanged = function () {
                if (this._dataAnimMgr) {
                    //---- pass on new key value to dataAnimMgr ----
                    this.bindProperties();

                    var key = this._key;
                    this._dataAnimMgr.keyFunc(key);
                }
            };

            baseLayerClass.prototype.onKey2Changed = function () {
                if (this._dataAnimMgr2) {
                    this.bindProperties();

                    //---- pass on new key value to dataAnimMgr2 ----
                    var key2 = this._key2;
                    this._dataAnimMgr2.keyFunc(key2);
                }
            };

            baseLayerClass.prototype.layerType = function (value) {
                if (arguments.length == 0) {
                    return this._layerType;
                }

                this._layerType = value;
                this.ctr = "vp.layers." + value;

                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.stat = function (value) {
                if (arguments.length == 0) {
                    return this._stat;
                }

                this._stat = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.statType = function (value) {
                return (this._stat) ? this._stat.statType : undefined;
            };

            baseLayerClass.prototype.toolTipCols = function (value) {
                if (arguments.length == 0) {
                    value = this._toolTipCols;
                    return value;
                }

                this._toolTipCols = value;

                //this.markRebuildNeeded();
                return this;
            };

            baseLayerClass.prototype.getItemStroke = function (seriesIndex, itemIndex, filteredData, daStroke) {
                var binding = this._stroke;

                if (binding) {
                    this._isStrokeMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, daStroke, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
            };

            baseLayerClass.prototype.getItemFill = function (seriesIndex, itemIndex, filteredData, daFill) {
                var attr = this._fill;

                if (attr) {
                    this._isFillMapped = attr.isMapped();

                    return attr.getItemValue(seriesIndex, itemIndex, filteredData, daFill, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
            };

            baseLayerClass.prototype.formatValue = function (value, colName, seriesIndex) {
                var formatter = this._toolTipFormatter;
                if (!formatter) {
                    formatter = this.defaultFormatValue;
                }

                var newValue = formatter.call(this, value, colName, seriesIndex);
                return newValue;
            };

            baseLayerClass.prototype.defaultFormatValue = function (value, colName, seriesIndex) {
                var xColList = this.xAfterStat();
                var yColList = this.yAfterStat();

                var isDiscrete = null;

                if (xColList.indexOf(colName) > -1) {
                    isDiscrete = this._x.layerDefaults.isDiscrete;
                } else if (yColList.indexOf(colName) > -1) {
                    isDiscrete = this._y.layerDefaults.isDiscrete;
                }

                if (isDiscrete) {
                    value = vp.formatters.string(value);
                } else {
                    value = vp.formatters.format(value);
                }

                //---- use formatter from attribute ----
                var newValue = null;

                var attr = this["_" + colName];
                if (attr) {
                    var formatter = attr.getActualFormatter();
                    newValue = formatter(value);
                } else {
                    newValue = vp.formatters.format(value);
                }

                return newValue;
            };

            /** subclass should implement this, if needed */
            baseLayerClass.prototype.adjustChartOptions = function () {
            };

            /// use the "hAlign" and "vAlign" property values to calculate the x/y adjustment
            /// needed for the text. requires the text element with the final text applied to it
            /// (and it should be attached to the document) so that it can be correctly measured.
            ///
            /// return the adjustment as a {x, y} object.
            baseLayerClass.prototype.calculateTextAdjust = function (textElem, hAlign, vAlign) {
                return vp.internal.calculateTextAdjust(textElem, hAlign, vAlign);
            };

            baseLayerClass.prototype.getItemOpacity = function (seriesIndex, itemIndex, filteredData, da) {
                var binding = this._opacity;

                if (binding) {
                    this._isOpacityMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
                //this._isOpacityMapped = false;
                ////---- start with constant value ----
                //var opacity = this.opacity.value;
                //if (opacity === undefined)
                //{
                //    //opacity = 1;
                //}
                //else if ((!this.opacity.isConstant) && (filteredData && filteredData.length))
                //{
                //    this._isOpacityMapped = true;
                //    //---- value is the name of the property we are bound to ----
                //    var propName = this.opacity.value;
                //    var propValue = filteredData[itemIndex][propName];
                //    if (this._opacityScale.needsSetUp())
                //    {
                //        var data = vp.data.dataSelect(filteredData, propName);
                //        var min = data.min();
                //        var max = data.max();
                //        this._opacityScale.setUp(min, max);
                //    }
                //    opacity = this._opacityScale.scale(propValue);       // get opacity from this._opacityScale mapping
                //}
                //return opacity;
            };

            baseLayerClass.prototype.getSizeCore = function (seriesIndex, itemIndex, filteredData, da, sizeName) {
                var binding;
                binding = (sizeName == "shapeSize") ? this._shapeSize : this._lineSize;

                if (binding) {
                    if (sizeName == "lineSize") {
                        this._isLineSizeMapped = binding.isMapped();
                    } else if (sizeName == "shapeSize") {
                        this._isShapeSizeMapped = binding.isMapped();
                    } else {
                        this._isLineSizeMapped = binding.isMapped();
                    }

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
            };

            baseLayerClass.prototype.getTextSize = function (seriesIndex, itemIndex, filteredData, da) {
                var binding = this._textSize;

                if (binding) {
                    this._isTextSizeMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
            };

            baseLayerClass.prototype.getTextFill = function (seriesIndex, itemIndex, filteredData, da) {
                var binding = this._textFill;

                if (binding) {
                    this._isTextFillMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
            };

            baseLayerClass.prototype.getItemLabel = function (seriesIndex, itemIndex, filteredData, da) {
                var binding = this._label;

                if (binding) {
                    this._isTextLabelMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
                //this._isTextLabelMapped = false;
                //var bind = this.label;
                //var value = bind.value;
                //if (value === undefined)
                //{
                //    //value = "";
                //}
                //else if ((!bind.isConstant) && (filteredData && filteredData.length))
                //{
                //    this._isTextLabelMapped = true;
                //    //---- value is the name of the property we are bound to ----
                //    var propName = this.label.value;
                //    var propValue = filteredData[itemIndex][propName];
                //    if (this._textScale.needsSetUp())
                //    {
                //        var data = vp.data.dataSelect(filteredData, propName);
                //        var min = data.min();
                //        var max = data.max();
                //        this._textScale.setUp(min, max);
                //    }
                //    value = this._textScale.scale(propValue);
                //}
                //return value;
            };

            /// return object that owns this element
            baseLayerClass.prototype.pop = function () {
                return this._vvParent;
            };

            baseLayerClass.prototype.getLineType = function (seriesIndex, itemIndex, filteredData, da) {
                var binding = this._lineType;

                if (binding) {
                    this._isLineTypeMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
                //this._isLineTypeMapped = false;
                //var value = this.lineType.value;
                //if (value === undefined)
                //{
                //    //value = "solid";       // default value
                //}
                //else if ((!this.lineType.isConstant) && (filteredData && filteredData.length))
                //{
                //    this._isLineTypeMapped = true;
                //    //---- value is the name of the property we are bound to ----
                //    var propName = this.lineType.value;
                //    var propValue = filteredData[itemIndex][propName];
                //    if (this._lineTypeScale.needsSetUp())
                //    {
                //        var data = vp.data.dataSelect(filteredData, propName);
                //        var min = data.min();
                //        var max = data.max();
                //        this._lineTypeScale.setUp(min, max);
                //    }
                //    value = this._lineTypeScale.scale(propValue);
                //}
                //else
                //{
                //    value = vp.lineTypeToDashArray(value);
                //}
                //return value;
            };

            /// add CONSTANT VALUED drawing attributes.
            ///
            /// we check for undefined so that we don't overwrite the existing theme values if not
            /// constant value was specified.
            baseLayerClass.prototype.addConstantDrawingAttributes = function (da, seriesIndex, filteredData) {
                var itemIndex = 0;

                this._isTextFillMapped = false;
                this._isLineSizeMapped = false;
                this._isTextSizeMapped = false;

                //---- STROKE ----
                var stroke = this.getItemStroke(seriesIndex, itemIndex, filteredData, da.strokePalette);
                if (stroke !== undefined) {
                    da.stroke = stroke;
                }

                //---- TEXTFILL ----
                var textFill = this.getTextFill(seriesIndex, itemIndex, filteredData, da.textFill);
                if (textFill != undefined) {
                    da.textFill = textFill;
                }

                //---- FILL ----
                var fill = this.getItemFill(seriesIndex, itemIndex, filteredData, da.fillPalette);
                if (fill !== undefined) {
                    da.fill = fill;
                }

                //---- OPACITY ----
                var opacity = this.getItemOpacity(seriesIndex, itemIndex, filteredData, da.opacity);
                if (opacity !== undefined) {
                    da.opacity = opacity;
                }

                //---- LINETYPE ----
                var lineType = this.getLineType(seriesIndex, itemIndex, filteredData, da.lineType);
                if (lineType !== undefined) {
                    da.lineType = lineType;
                }

                //---- SHAPE TYPE ----
                var shapeType = this.getItemShapeType(seriesIndex, itemIndex, filteredData, da.shapeType);
                if (shapeType !== undefined) {
                    da.shapeType = shapeType;
                }

                //---- SHAPESIZE ----
                var shapeSize = this.getSizeCore(seriesIndex, itemIndex, filteredData, da.shapeSize, "shapeSize");
                if (shapeSize != undefined) {
                    da.shapeSize = shapeSize;
                }

                //---- LINESIZE ----
                var lineSize = this.getSizeCore(seriesIndex, itemIndex, filteredData, da.lineSize, "lineSize");
                if (lineSize != undefined) {
                    da.lineSize = lineSize;
                }

                //---- TEXTSIZE ----
                var textSize = this.getTextSize(seriesIndex, itemIndex, filteredData, da.textSize);
                if (textSize != undefined) {
                    da.textSize = textSize;
                }

                ////---- SIZE ----
                //var size = this.getSizeCore(seriesIndex, itemIndex, filteredData, da.size, "size");
                //if (size != undefined)
                //{
                //    da.size = size;
                //}
                //---- LABEL ----
                var label = this.getItemLabel(seriesIndex, itemIndex, filteredData, da.label);
                if (label != undefined) {
                    da.textLabel = label;
                }

                //---- HALIGN ----
                var hAlign = this._hAlign;
                if (hAlign !== undefined) {
                    da.hAlign = hAlign;
                }

                //---- VALIGN ----
                var vAlign = this._vAlign;
                if (vAlign !== undefined) {
                    da.vAlign = vAlign;
                }

                //---- FONTFAMILY ----
                var fontFamily = this._fontFamily;
                if (fontFamily !== undefined) {
                    da.fontFamily = fontFamily;
                }

                return da;
            };

            baseLayerClass.prototype.addToList = function (list, name, value) {
                if (list.length) {
                    for (var i = 0; i < list.length; i++) {
                        var da = list[i];

                        da[name] = value;
                    }
                } else {
                    //---- single da was specified ----
                    list[name] = value;
                }
            };

            /// update the drawing attributes with those that are MAPPED for this itemIndex.
            baseLayerClass.prototype.updateDrawingAttributes = function (daList, seriesIndex, itemIndex, filteredData) {
                //---- STROKE ----
                if (this._isStrokeMapped) {
                    var value = this.getItemStroke(seriesIndex, itemIndex, filteredData, daList.stroke);
                    this.addToList(daList, "stroke", value);
                }

                //---- FILL ----
                if (this._isFillMapped) {
                    var value = this.getItemFill(seriesIndex, itemIndex, filteredData, daList.fill);
                    this.addToList(daList, "fill", value);
                }

                //---- OPACITY ----
                if (this._isOpacityMapped) {
                    var value = this.getItemOpacity(seriesIndex, itemIndex, filteredData, daList.opacity);
                    this.addToList(daList, "opacity", value);
                }

                //---- LINE TYPE ----
                if (this._isLineTypeMapped) {
                    var value = this.getLineType(seriesIndex, itemIndex, filteredData, daList.lineType);
                    this.addToList(daList, "lineType", value);
                }

                //---- SHAPE TYPE ----
                if (this._isShapeTypeMapped) {
                    var value = this.getItemShapeType(seriesIndex, itemIndex, filteredData, daList.shapeType);
                    this.addToList(daList, "shapeType", value);
                }

                //---- LINE SIZE ----
                if (this._isLineSizeMapped) {
                    var value = this.getSizeCore(seriesIndex, itemIndex, filteredData, daList.lineSize, "lineSize");
                    this.addToList(daList, "lineSize", value);
                }

                //---- SHAPE SIZE ----
                if (this._isShapeSizeMapped) {
                    var value = this.getSizeCore(seriesIndex, itemIndex, filteredData, daList.shapeSize, "shapeSize");
                    this.addToList(daList, "shapeSize", value);
                }

                //---- TEXT SIZE ----
                if (this._isTextSizeMapped) {
                    var value = this.getTextSize(seriesIndex, itemIndex, filteredData, daList.textSize);
                    this.addToList(daList, "textSize", value);
                }

                ////---- SIZE ----
                //if (this._isLineSizeMapped)
                //{
                //    var value = this.getSizeCore(seriesIndex, itemIndex, filteredData, daList.shapeSize, "size");
                //    this.addToList(daList, "size", value);
                //}
                //---- TEXT FILL ----
                if (this._isTextFillMapped) {
                    var value = this.getTextFill(seriesIndex, itemIndex, filteredData, daList.textFill);
                    this.addToList(daList, "textFill", value);
                }

                //---- TEXT LABEL ----
                if (this._isTextLabelMapped) {
                    var textLabel = this.getItemLabel(seriesIndex, itemIndex, filteredData, daList.text);
                    this.addToList(daList, "textLabel", textLabel);
                }
            };

            /// public setElementInfo():  a centralized way to set 2 common properties for each shape root element.
            /// NOTE: a layer/layer only needs to set the "dataId" and "seriesIndex" for the OUTER GROUP of its shapes.
            ///
            /// dataId:     id of data source for this shape/group (for layers with > 1 data source)
            /// seriesIndex:  index of associated series for this shape/group
            ///
            /// dataId and seriesIndex are used by dataAnimMgr.  Also used for tooltips?
            ///
            baseLayerClass.prototype.setElementInfo = function (elem, dataId, seriesIndex) {
                this.setElementInfoU(elem[0], dataId, seriesIndex);
                //elem
                //    .dataId(dataId)             // for layers with multiple data sources, this identifies the data source
                //    .shapeId(seriesIndex)       // for layers with multiple series, the is the index of the associated series
            };

            baseLayerClass.prototype.setElementInfoU = function (uelem, dataId, seriesIndex) {
                vp.dom.dataId(uelem, dataId); // for layers with multiple data sources, this identifies the data source

                vp.dom.shapeId(uelem, seriesIndex); // for layers with multiple series, the is the index of the associated series
            };

            /// apply constant/mapped attributes specifed in "da" to line element.
            /// we check for "undefined" to keep things fast & lightweight (in terms on resulting elements).
            baseLayerClass.prototype.applyLineAttributes = function (elem, da) {
                return vp.internal.applyLineAttributes(elem, da);
            };

            /// apply constant/mapped attributes specifed in "da" to a shape element.
            /// we check for "undefined" to keep things fast & lightweight (in terms on resulting elements).
            baseLayerClass.prototype.applyShapeAttributes = function (elem, da) {
                return vp.internal.applyShapeAttributes(elem, da);
            };

            /// apply constant/mapped attributes specifed in "da" to a text element.
            /// we check for "undefined" to keep things fast & lightweight (in terms on resulting elements).
            baseLayerClass.prototype.applyTextAttributes = function (elem, da, hAdjust, vAdjust) {
                return vp.internal.applyTextAttributes(elem, da, true, hAdjust, vAdjust);
            };

            baseLayerClass.prototype.getItemShapeType = function (seriesIndex, itemIndex, filteredData, da) {
                var binding = this._shapeType;

                if (binding) {
                    this._isShapeTypeMapped = binding.isMapped();

                    return binding.getItemValue(seriesIndex, itemIndex, filteredData, da, this.info.seriesNames, this.info.stackType);
                }

                return undefined;
            };

            /// public readonly: attributes()
            baseLayerClass.prototype.attributes = function () {
                return this;
            };

            /// public: xBeforeStat()
            baseLayerClass.prototype.xBeforeStat = function () {
                var attr = this.x();
                var colName = (attr) ? attr.colName() : undefined;
                var isConstant = false;

                if (colName === undefined) {
                    isConstant = false;
                }

                return { value: colName, isConstant: isConstant };
            };

            /// public: yBeforeStat()
            baseLayerClass.prototype.yBeforeStat = function () {
                var attr = this.y();
                var colName = (attr) ? attr.colName() : undefined;
                var isConstant = false;

                if (colName === undefined) {
                    isConstant = false;
                }

                return { value: colName, isConstant: isConstant };
            };

            /// return "x" data col, after processing by stat, if any ----
            baseLayerClass.prototype.xAfterStat = function () {
                return this._xColAfterStat;
            };

            /// return "y" data col, after processing by stat, if any ----
            baseLayerClass.prototype.yAfterStat = function () {
                return this._yColsAfterStat;
            };

            baseLayerClass.prototype.buildFrameFromValue = function (value, name) {
                var data = [];

                if (vp.utils.isArray(value)) {
                    for (var i = 0; i < value.length; i++) {
                        var record = {};
                        record[name] = value[i];

                        data.push(record);
                    }
                } else {
                    //---- create single record for scalar ----
                    var record = {};
                    record[name] = value;

                    data.push(record);
                }

                return data;
            };

            baseLayerClass.prototype.addValueToFrame = function (data, value, name) {
                if (vp.utils.isArray(value)) {
                    //---- add next row of vector to each data row ----
                    var nextVectorRow = 0;

                    for (var i = 0; i < data.length; i++) {
                        var row = data[i];
                        row[name] = value[nextVectorRow++];

                        if (nextVectorRow >= value.length) {
                            nextVectorRow = 0;
                        }
                    }
                } else {
                    for (var i = 0; i < data.length; i++) {
                        var row = data[i];
                        row[name] = value;
                    }
                }

                return data;
            };

            /// private: combineConstantAndMappedData(data)
            ///     - combine the data frame with constant data specified on non-mapped properties
            ///     - and update x/y colnames as needed.
            baseLayerClass.prototype.combineConstantAndMappedData = function (inData, idDataId) {
                var xi = this.xBeforeStat();
                var yi = this.yBeforeStat();

                xi.name = xi.value;
                yi.name = yi.value;

                var data = inData;
                var dataId = idDataId;

                if (xi.isConstant) {
                    //---- add scalar/vector value to "data" ----
                    var xName = "$xvalue";
                    xi.name = [xName];
                    var valueLen = (xi.value.length) ? xi.value.length : 1;

                    if ((data) && (data.length == valueLen)) {
                        data = this.addValueToFrame(data, xi.value, xName);
                    } else {
                        //---- create data from "xi.value" ----
                        data = this.buildFrameFromValue(xi.value, xName);
                        dataId = this._vvParent.getNextDataId();
                    }
                }

                if (yi.isConstant) {
                    var yName = "$yvalue";
                    yi.name = [yName];
                    var valueLen = (yi.value.length) ? yi.value.length : 1;

                    if ((data) && (data.length == valueLen)) {
                        data = this.addValueToFrame(data, yi.value, yName);
                    } else {
                        //---- create data from "xi.value" ----
                        data = this.buildFrameFromValue(yi.value, yName);
                        dataId = this._vvParent.getNextDataId();
                    }
                } else {
                    if (yi.name === undefined) {
                        //---- make this easier for subsequent code to work with ----
                        yi.name = [];
                    }
                }

                return { xInfo: xi, yInfo: yi, dataId: dataId, data: data };
            };

            /// private: runStatOnData(data)
            ///    - combines constant/mapped data, run stats on it, and returns transformed data + colNames
            ////
            baseLayerClass.prototype.runStatOnData = function (inData, inDataId) {
                var combo = this.combineConstantAndMappedData(inData, inDataId);

                if ((combo.data) && (this._stat != null) && (this._stat.ctr != "vp.stats.statIdentity")) {
                    combo = this._stat.runStatOnData(combo.xInfo.name, combo.yInfo.name, combo.data, this);

                    //---- stat generated a temp table; increase the data id ----
                    var dataId = this._vvParent.getNextDataId();
                    combo.dataId = dataId;
                } else {
                    combo = { xCol: combo.xInfo.name, yCols: combo.yInfo.name, dataId: combo.dataId, data: combo.data };
                }

                return combo;
            };

            /// private (but needs this to acess key): buildDam()
            baseLayerClass.prototype.buildDam = function () {
                var keyFunc = this._key;

                this._dataAnimMgr = new vp.animation.dataAnimMgrExClass(null, keyFunc, this._newTagOrFunc, this._layerId + "", this._isSeriesLayer);

                if (this._vvParent.shapesEnterFromBottom()) {
                    this._dataAnimMgr;
                    //.enterEffect(vp.animation.makeEffects("none", "bottom"))
                    //.exitEffect(vp.animation.makeEffects("none", "top"))
                }

                //--- inherit from parent ----
                this._isAnimEnabled = this._vvParent.isAnimEnabled();

                this.onAnimChanged();
            };

            /// private (but needs this to acess key): buildDam()
            baseLayerClass.prototype.buildDam2 = function () {
                var keyFunc = this._key2;

                this._dataAnimMgr2 = new vp.animation.dataAnimMgrExClass(null, keyFunc, this._newTagOrFunc2, this._layerId + "");

                if (this._vvParent.shapesEnterFromBottom()) {
                    this._dataAnimMgr2;
                    //.enterEffect(vp.animation.makeEffects("none", "bottom"))
                    //.exitEffect(vp.animation.makeEffects("none", "top"))
                }

                //--- inherit from parent ----
                this._isAnimEnabled = this._vvParent.isAnimEnabled();
                this.onAnimChanged();
            };

            baseLayerClass.prototype.isAnimEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isAnimEnabled;
                }

                this._isAnimEnabled = value;
                this.onAnimChanged();

                return this;
            };

            baseLayerClass.prototype.animDuration = function (value) {
                if (arguments.length == 0) {
                    return this._animDuration;
                }

                this._animDuration = value;
                this.onAnimChanged();

                return this;
            };

            baseLayerClass.prototype.seriesAxis = function (value) {
                if (arguments.length == 0) {
                    return this._seriesAxis;
                }

                this._seriesAxis = value;

                return this;
            };

            baseLayerClass.prototype.onAnimChanged = function () {
                if (this._dataAnimMgr) {
                    this._dataAnimMgr.animDuration(this._isAnimEnabled ? this._animDuration : 0);
                }

                if (this._dataAnimMgr2) {
                    this._dataAnimMgr2.animDuration(this._isAnimEnabled ? this._animDuration : 0);
                }
            };

            /// public: ensureDataAnimMgrExists()
            baseLayerClass.prototype.ensureDataAnimMgrExists = function () {
                if (!this._dataAnimMgr) {
                    this.buildDam();
                }
            };

            /// public: ensureDataAnimMgr2Exists()
            baseLayerClass.prototype.ensureDataAnimMgr2Exists = function () {
                if (!this._dataAnimMgr2) {
                    this.buildDam2();
                }
            };

            //getKeyFunc()
            //{
            //    var keyFunc = this.key();
            //    if (!keyFunc)
            //    {
            //        //keyFunc = this._vvParent.key();
            //        //if (!keyFunc)
            //        //{
            //        //    keyFunc = vp.utils.indexKeyFunc;
            //        //}
            //    }
            //    return keyFunc;
            //}
            //getKeyFunc2()
            //{
            //    var keyFunc2 = this.key2();
            //    if (!keyFunc2)
            //    {
            //        //keyFunc2 = this._vvParent.key2();
            //        //if (!keyFunc2)
            //        //{
            //        //    keyFunc2 = vp.utils.indexKeyFunc;
            //        //}
            //    }
            //    return keyFunc2;
            //}
            /// public: applyFilter(query)
            baseLayerClass.prototype.applyFilter = function (filterQuery, isNewDataSet, onlySetFilter) {
                var _this = this;
                this._filter = filterQuery;

                if (!onlySetFilter) {
                    this.ensureDataAnimMgrExists();
                    this.ensureDataAnimMgr2Exists();

                    //---- apply to data ----
                    var combo = this.getAllData();
                    if (combo.data && combo.data.length) {
                        var inData = combo.data;
                        if (this._filter) {
                            var keyFunc = this._key;

                            inData = inData.where(function (dataRecord, index) {
                                var key = keyFunc(dataRecord, index);
                                var dataEx = { dataId: 1, key: key, data: dataRecord };

                                var isIn = (!_this._filter.test(dataEx));
                                return isIn;
                            });
                        }

                        this._dataAnimMgr.setData(inData, isNewDataSet, combo.dataId);
                    }

                    //---- apply to data2, if defined ----
                    combo = this.getAllData2();
                    if (combo.data && combo.data.length) {
                        var inData = combo.data;
                        if (this._filter) {
                            var keyFunc = this._key;

                            inData = inData.where(function (dataRecord, index) {
                                var key = keyFunc(dataRecord, index);
                                var dataEx = { dataId: 2, key: key, data: dataRecord };

                                var isIn = (!_this._filter.test(dataEx));
                                return isIn;
                            });
                        }

                        this._dataAnimMgr2.setData(inData, isNewDataSet, combo.dataId);
                    }
                }

                //this.markRebuildNeeded();
                return this;
            };

            /** Set mapping of series columns. */
            baseLayerClass.prototype.setSeriesNamesForAnimation = function (value) {
                if (this._isSeriesLayer) {
                    var names = value;

                    //if (this._isSeriesVisible)
                    //{
                    //    //---- use booleans to control which names are visible ----
                    //    names = [];
                    //    for (var i = 0; i < this._isSeriesVisible.length; i++)
                    //    {
                    //        var isVisible = this._isSeriesVisible[i];
                    //        if (isVisible)
                    //        {
                    //            names.push(value[i]);
                    //        }
                    //    }
                    //}
                    this._dataAnimMgr.setSeriesNames(names);
                }
            };

            //---- public: getAllData ----
            baseLayerClass.prototype.getAllData = function () {
                var value = this._data;
                var combo = { data: [], xCol: [], yCols: [], dataId: 0 };

                if (value !== undefined) {
                    combo = this.runStatOnData(value, 1);

                    this._xColAfterStat = (combo.xCol) ? combo.xCol : [];
                    this._yColsAfterStat = (combo.yCols) ? combo.yCols : [];
                }

                return combo;
            };

            /// public: updateShapeVisuals() - default shape shading for UI state changes.
            ///
            /// this is the default implmentation for updating a layer's set of shapes
            /// when the selection or the current hover object has been changed.
            baseLayerClass.prototype.updateShapeVisuals = function (selectionCount, daSelected, daUnselected, daHover) {
                //this.ensureDataAnimMgrExists();
                if (this._dataAnimMgr) {
                    var plotShapes = this._dataAnimMgr.getExistingShapes();

                    for (var i = 0; i < plotShapes.length; i++) {
                        var elem = plotShapes[i];
                        this.updateSingleShapeVisuals(elem, daSelected, daUnselected, daHover, selectionCount, elem.isHighlighted, elem.isSelected);
                    }
                }

                if (this._dataAnimMgr2) {
                    var plotShapes = this._dataAnimMgr2.getExistingShapes();

                    for (var i = 0; i < plotShapes.length; i++) {
                        var elem = plotShapes[i];
                        this.updateSingleShapeVisuals(elem, daSelected, daUnselected, daHover, selectionCount, elem.isHighlighted, elem.isSelected);
                    }
                }
            };

            baseLayerClass.prototype.updateSingleShapeVisuals = function (elem, daSelected, daUnselected, daHover, selectionCount, isHighlighted, isSelected) {
                if (elem.tagName == "g") {
                    var kids = vp.dom.children(elem);

                    for (var i = 0; i < kids.length; i++) {
                        var kid = kids[i];
                        this.updateSingleShapeVisuals(kid, daSelected, daUnselected, daHover, selectionCount, isHighlighted, isSelected);
                    }
                } else if (elem.updateVisualHint != "none") {
                    var hint = elem.updateVisualHint || "both";

                    //---- restore FILL ----
                    var origFill = elem.origFill;
                    if ((origFill !== undefined) && (origFill !== null)) {
                        vp.dom.attr(elem, "fill", origFill);
                    }

                    //---- restore STROKE ----
                    var origStroke = elem.origStroke;
                    if ((origStroke !== undefined) && (origStroke !== null)) {
                        vp.dom.attr(elem, "stroke", origStroke);
                    }

                    //---- restore STROKE WIDTH ----
                    var origStrokeWidth = elem.origStrokeWidth;
                    if ((origStrokeWidth !== undefined) && (origStrokeWidth !== null)) {
                        vp.dom.attr(elem, "stroke-width", origStrokeWidth);
                    }

                    //else
                    //{
                    //    vp.dom.attr(elem, "stroke-width", 1);
                    //}
                    //---- restore OPACITY ----
                    var origOpacity = elem.origOpacity;
                    if ((origOpacity !== undefined) && (origOpacity !== null)) {
                        vp.dom.attr(elem, "opacity", origOpacity);
                    } else {
                        vp.dom.attr(elem, "opacity", 1);
                    }

                    var selectChangedDuringHighlight = ((elem.selectChangedDuringHighlight) || (elem.parentNode.selectChangedDuringHighlight));

                    //---- HOVER / SELECTION ----
                    if ((isHighlighted) && (!selectChangedDuringHighlight)) {
                        if ((hint == "stroke") || (hint == "both")) {
                            vp.dom.attr(elem, "stroke", daHover.stroke);
                        }
                        if ((hint == "fill") || (hint == "both")) {
                            vp.dom.attr(elem, "fill", daHover.fill);
                        }
                    } else if (selectionCount > 0) {
                        //---- SELECTED / UNSELECTED ----
                        if ((hint == "stroke") || (hint == "both")) {
                            var stroke = (isSelected) ? daSelected.stroke : daUnselected.stroke;

                            if (stroke) {
                                vp.dom.attr(elem, "stroke", stroke);
                            }

                            var strokeSize = (isSelected) ? daSelected.lineSize : daUnselected.lineSize;

                            if ((strokeSize !== null) && (strokeSize !== undefined)) {
                                vp.dom.attr(elem, "stroke-width", strokeSize);
                            }
                        }

                        if ((hint == "fill") || (hint == "both")) {
                            var fill = (isSelected) ? daSelected.fill : daUnselected.fill;

                            if (fill) {
                                vp.dom.attr(elem, "fill", fill);
                            }
                        }

                        if (hint == "opacity") {
                            var opacity = (isSelected) ? daSelected.opacity : daUnselected.opacity;

                            if ((opacity !== null) && (opacity !== undefined)) {
                                vp.dom.attr(elem, "opacity", opacity);
                            }
                        }
                    }
                }
            };

            //---- public: getAllData2 ----
            baseLayerClass.prototype.getAllData2 = function () {
                var value = this._data2;
                var combo = { data: [], xCol: [], yCols: [], dataId: 0 };

                if (value !== undefined) {
                    combo = this.runStatOnData(value, 2);

                    this._xCol2AfterStat = combo.xCol;
                    this._yCols2AfterStat = combo.yCols;
                }

                return combo;
            };

            baseLayerClass.prototype.validateData = function (data) {
                var dummy = 9;

                //if (data && data.selectWithFunc === undefined)
                //{
                //    vp.utils.error("agument passed to 'data()' must be a JavaScript array that is created after loading vuePlot.js");
                //}
                //---- walk thru and validate all numeric and data columns ----
                return data;
            };

            baseLayerClass.prototype.data = function (value, isNewDataSet) {
                this.ensureDataAnimMgrExists();

                if (arguments.length == 0) {
                    value = [];

                    if (this._dataAnimMgr) {
                        value = this._dataAnimMgr.getData();
                    }

                    return value;
                }

                var validatedData = this.validateData(value);

                this._data = validatedData;

                //---- don't do this now because rebuildChart() will do it later ----
                //this.onPlotDataChanged(false);
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.data2 = function (value2, isNewDataSet) {
                this.ensureDataAnimMgr2Exists();

                if (arguments.length == 0) {
                    var value = [];

                    if (this._dataAnimMgr2) {
                        value = this._dataAnimMgr2.getData();
                    }

                    return value;
                }

                this._data2 = value2;

                this.markRebuildNeeded();
                return this;
            };

            /// public: onPlotDataChanged() - called when "data" is set on vvPlot
            baseLayerClass.prototype.onPlotDataChanged = function (isNewDataSet) {
                //---- since this is like layer.rebuild(), rebind properties here ----
                this.bindProperties();

                //---- we should NOT make this call; vvParent has just called us to do layer-specific work ----
                //vvParent.onFilterChanged();
                this.applyFilter(this._filter, isNewDataSet);

                this.onChartRebuild();
                //this.markRebuildNeeded();
            };

            baseLayerClass.prototype.getProp = function (la, pa, propName) {
                var value = undefined;

                if ((la) && (la[propName] !== undefined)) {
                    value = la[propName];
                } else if ((pa) && (pa[propName] !== undefined)) {
                    value = pa[propName];
                }

                return value;
            };

            //---- rebind all common properties to constants or mappings ----
            baseLayerClass.prototype.bindProperties = function () {
            };

            /// public: onPlotData2Changed() - called when "data" is set on vvPlot
            baseLayerClass.prototype.onPlotData2Changed = function (isNewDataSet) {
                if (vp.utils.isUndefined(this._data2)) {
                    this.applyFilter(this._filter, isNewDataSet);
                }
            };

            baseLayerClass.prototype.markRebuildNeeded = function () {
                //---- layer checks its parent (vvPlot) ----
                if (this._vvParent) {
                    this._vvParent.markRebuildNeeded();
                }

                return this;
            };

            baseLayerClass.prototype.defaultStackType = function (value) {
                if (arguments.length == 0) {
                    return this._defaultStackType;
                }

                this._defaultStackType = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.chartName = function (value) {
                if (arguments.length == 0) {
                    return this._chartName;
                }

                this._chartName = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.postCreate = function (value) {
                if (arguments.length == 0) {
                    return this._postCreateFunc;
                }

                this._postCreateFunc = value;
                return this;
            };

            baseLayerClass.prototype.dataAnimMgr = function (value) {
                if (arguments.length == 0) {
                    return this._dataAnimMgr;
                }

                this._dataAnimMgr = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.dataAnimMgr2 = function (value) {
                if (arguments.length == 0) {
                    return this._dataAnimMgr2;
                }

                this._dataAnimMgr2 = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.newTagOrFunc = function (value) {
                if (arguments.length == 0) {
                    return this._newTagOrFunc;
                }

                this._newTagOrFunc = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.newTagOrFunc2 = function (value) {
                if (arguments.length == 0) {
                    return this._newTagOrFunc2;
                }

                this._newTagOrFunc2 = value;
                this.markRebuildNeeded();

                return this;
            };

            baseLayerClass.prototype.container = function (value) {
                if (arguments.length == 0) {
                    return this._container;
                }

                this._container = value;

                this.ensureDataAnimMgrExists();
                this._dataAnimMgr.container(value);

                this.ensureDataAnimMgr2Exists();
                this._dataAnimMgr2.container(value);

                //this.markRebuildNeeded();
                return this;
            };

            baseLayerClass.prototype.remove = function () {
                if (this._vvParent) {
                    this._vvParent.removeLayer((this) ? this : this);
                }
            };

            baseLayerClass.prototype.postUpdateShapes = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._postUpdateShapes;
                } else {
                    //--- SET value ----
                    this._postUpdateShapes = value;
                }

                return this;
            };

            //isSeriesVisible(): boolean[];
            //isSeriesVisible(value: boolean[]): T;
            //isSeriesVisible(value?: boolean[]): any
            //{
            //    if (arguments.length == 0)
            //    {
            //        //--- GET value ----
            //        return this._isSeriesVisible;
            //    }
            //    else
            //    {
            //        //--- SET value ----
            //        this._isSeriesVisible = value;
            //        this.markRebuildNeeded();
            //    }
            //    return this;
            //}
            baseLayerClass.prototype.postDraw = function (layInfo, shapes) {
                //---- older callback: postCreate passes a single shape at a time ----
                if (this._postCreateFunc) {
                    for (var i = 0; i < shapes.length; i++) {
                        this._postCreateFunc(shapes[i]);
                    }
                }

                //---- store shapes so we can remove them later if this shape is removed ----
                this._drawnShapes = shapes;

                //---- newer callback: postUpdateShapes passes a series of shapes at a time ----
                if (this._postUpdateShapes) {
                    var shapeArray = shapes.toArray();

                    this._postUpdateShapes(layInfo, shapeArray);
                }

                return this;
            };

            //---- COMMON code for AREA/LINE X (also used by POINT/TEXT) ----
            baseLayerClass.prototype.getLineX = function (index, xRecord, xScale, xIsCategoryScale) {
                //---- since this function is shared by other layer's (see layerPath), we support ----
                //---- both CATEGORY and LINEAR scales for X within this function ----
                var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];

                var x = xScale.scale(xValue);
                if (xIsCategoryScale) {
                    var w = Math.max(.25, xScale.itemWidth());
                    x += w / 2;

                    //---- IE has a problem with inserting gaps, so align here to pixel offsets ----
                    //---- also see: areaClass adjustment of "x" ----
                    if (vp.utils.isIE && w >= 4)
                    {
                        x = Math.round(x) + .5; 
                    }
                }

                return x;
            };

            //---- COMMON code for AREA/LINE stacking Y (also used by POINT/TEXT) ----
            baseLayerClass.prototype.getStackedLineY = function (index, yRecord, yScale, pi) {
                var dataValue = yRecord.data[index];

                var y = yScale.flipScale(dataValue);
                var h = Math.max(0, yScale.scaleSize(dataValue));
                var yZero = yScale.flipScale(0);

                if (pi.stackType == "stack") {
                    var adjValue = dataValue + pi.itemAccums[index];

                    //---- starts at dataValue, offset by previous..  height doesn't change ----
                    y = yScale.flipScale(adjValue);
                    yZero = yScale.flipScale(pi.itemAccums[index]);

                    pi.itemAccums[index] = adjValue;
                } else if (pi.stackType == "fill") {
                    var total = pi.itemTotals[index];

                    var newAccum = pi.itemAccums[index] + dataValue;
                    var adjValue2 = (total == 0) ? 0 : (newAccum / total);
                    var adjZero = (total == 0) ? 0 : (pi.itemAccums[index] / total);

                    y = yScale.flipScale(adjValue2);
                    yZero = yScale.flipScale(adjZero);

                    var adjHeight = (total == 0) ? 0 : (dataValue / total);
                    h = Math.max(0, yScale.scaleSize(adjHeight));

                    pi.itemAccums[index] = newAccum;
                }

                return { y: y, h: h, yZero: yZero };
            };
            return baseLayerClass;
        })(_layers.mappingsClass);
        _layers.baseLayerClass = baseLayerClass;

        var baseLayer = (function (_super) {
            __extends(baseLayer, _super);
            function baseLayer() {
                _super.apply(this, arguments);
            }
            return baseLayer;
        })(baseLayerClass);
        _layers.baseLayer = baseLayer;

        
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=-baseLayer.js.map

///----------------------------------------------------------------
/// (from layers\-line.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// -line.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots a line chart type layer for a plot object.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /**  the base class for the LINE LAYER class. "T" is the outer layer class. */
        var lineSuperClass = (function (_super) {
            __extends(lineSuperClass, _super);
            function lineSuperClass() {
                _super.call(this);

                this._isSeriesLayer = true;

                this.stat(vp.stats.statIdentity()).chartName("Line").newTagOrFunc("line").layerType("line").defaultStackType("dodge");
            }
            lineSuperClass.prototype.toolTipFormatter = function (value) {
                if (arguments.length == 0) {
                    return this._toolTipFormatter;
                }

                this._toolTipFormatter = value;

                return this;
            };

            lineSuperClass.prototype.adjustChartOptions = function () {
                this._xDefaults.zeroAxis = false;

                //---- support for fill PERCENT formatting ----
                var stackType = this.stackType();
                this._yDefaults.usePercentFormatting = (stackType == "fill");
                this._x.layerDefaults.ignoreDodge = true;

            };

            //getX(index: number, xRecord: any, xScale: any, xIsCategoryScale: boolean)
            //{
            //    //---- since this function is shared by other layer's (see layerPath), we support ----
            //    //---- both CATEGORY and LINEAR scales for X within this function ----
            //    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
            //    var x = xScale.scale(xValue);
            //    if (xIsCategoryScale)
            //    {
            //        var w = Math.max(.25, xScale.itemWidth());
            //        x += w / 2;
            //    }
            //    return x;
            //}
            //getY(index: number, yRecord: any, yScale: any, pi: ISeriesInfo)
            //{
            //    var dataValue = yRecord.data[index];
            //    var y = yScale.flipScale(dataValue);
            //    var h = Math.max(0, yScale.scaleSize(dataValue));
            //    if (pi.stackType == "stack")
            //    {
            //        var adjValue = dataValue + pi.itemAccums[index];
            //        //---- starts at dataValue, offset by previous..  height doesn't change ----
            //        y = yScale.flipScale(adjValue);
            //        pi.itemAccums[index] = adjValue;
            //    }
            //    else if (pi.stackType == "fill")
            //    {
            //        var total = pi.itemTotals[index];
            //        var newAccum = pi.itemAccums[index] + dataValue;
            //        var adjValue2 = (total == 0) ? 0 : (newAccum / total);
            //        y = yScale.flipScale(adjValue2);
            //        var adjHeight = (total == 0) ? 0 : (dataValue / total);
            //        h = Math.max(0, yScale.scaleSize(adjHeight));
            //        pi.itemAccums[index] = newAccum;
            //    }
            //    return y;
            //}
            /// public drawShapes() - draw line plot.
            lineSuperClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var lastx = 0;
                var lasty = 0;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var firstUpdateCall = true;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerLine", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var x = _this.getLineX(index, xRecord, xScale, xIsCategoryScale);
                    var yyy = _this.getStackedLineY(index, yRecord, yScale, pi);
                    var y = yyy.y;

                    if (index == 0) {
                        lastx = x;
                        lasty = y;
                    } else if (firstUpdateCall) {
                        //---- we are adding a new data point - get last values from the data ----
                        lastx = _this.getLineX(index - 1, xRecord, xScale, xIsCategoryScale);
                        var lastyyy = _this.getStackedLineY(index - 1, yRecord, yScale, pi);
                        lasty = lastyyy.y;
                    }

                    elem.from(lastx, lasty).to(x, y).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }

                    lastx = x;
                    lasty = y;
                    firstUpdateCall = false;
                });

                return shapes;
            };
            return lineSuperClass;
        })(layers.baseLayerClass);
        layers.lineSuperClass = lineSuperClass;

        var lineClass = (function (_super) {
            __extends(lineClass, _super);
            function lineClass() {
                _super.apply(this, arguments);
            }
            return lineClass;
        })(lineSuperClass);
        layers.lineClass = lineClass;

        function createLine() {
            return new lineClass();
        }
        layers.createLine = createLine;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=-line.js.map

///----------------------------------------------------------------
/// (from layers\-tile.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// tile.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - create a "tile" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** create a fixed size "tile" layer for a plot.  Tiles are layed out in a grid, starting with the upper left corner of the plot.
        The tile layer supports optional "x" and "y" mapped, which are used only to provide category labels for the x and y axes.
        For a variable sized tile plot, see the "xyTile" class. */
        var tileSuperClass = (function (_super) {
            __extends(tileSuperClass, _super);
            function tileSuperClass() {
                _super.call(this);
                //---- private state ----
                this._numCols = undefined;
                this._dummy = 0;

                this.layerType("tile").stat(vp.stats.statIdentity()).defaultStackType("dodge").chartName("Tile").newTagOrFunc("rect");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];
                this._xDefaults.isDiscrete = false;
                this._xDefaults.zeroAxis = false;
                this._xDefaults.combineDups = true;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["y"];
                this._yDefaults.isDiscrete = false;
                this._yDefaults.zeroAxis = false;
                this._yDefaults.combineDups = true;
            }
            tileSuperClass.prototype.adjustChartOptions = function () {
                //---- when we have no "x" and "y" data, we create some to keep the X and Y scales and gridlines ----
                //---- in sync with how we draw the cells ----
                var data = this.data();

                var count = data.length;
                var numCols = this.getNumCols(data.length, null);
                var numRows = Math.ceil(count / numCols);

                if (!this._xAttr.isMapped()) {
                    //options.xDataOverride = vp.utils.range(1, numCols);
                    this._xDefaults.dataOverride = vp.utils.range(1, numCols);
                }

                if (!this._yAttr.isMapped()) {
                    //options.yDataOverride = vp.utils.range(1, numRows);
                    this._yDefaults.dataOverride = vp.utils.range(1, numRows);
                }

                this._xDefaults.isDiscrete = true;
                this._yDefaults.isDiscrete = true;
                //---- don't hide gridlines, since some tile layers will not be completely full ----
            };

            tileSuperClass.prototype.getNumCols = function (numRows, xRecord) {
                var numCols = this._numCols;
                if (!numCols) {
                    //---- see if we can get from x mapping for labels ----
                    if ((numRows > 0) && (xRecord) && (this._xAttr.isUserMapped())) {
                        var firstCol = xRecord.data[0];
                        numCols = numRows; // default if not found

                        for (var i = 1; i < numRows; i++) {
                            if (firstCol == xRecord.data[i]) {
                                numCols = i;
                                break;
                            }
                        }
                    } else {
                        numCols = Math.floor(Math.sqrt(numRows));
                    }
                }

                return numCols;
            };

            /// public drawShapes() - draw tile plot.
            /// we draw a rectangle whose location is based on the "index" (record number) of the data.  An
            /// optional "numCols" property controls the number of columns in the X dimension.
            tileSuperClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                if (!da) {
                    da = vp.session.currentTheme().getDrawingAttributes("layerTile", seriesIndex);
                }

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //var xIsCategory = (xScale.scaleType() != vp.scales.ScaleType.linear);
                //var yIsCategory = (yScale.scaleType() != vp.scales.ScaleType.linear);
                //---- init these to full data width/height, in case there is only 1 row/col ----
                //var numCols = xRecord.data.distinct().length;   // number of unique values in X
                //var numRows = yRecord.data.distinct().length;   // number of unique values in Y
                var count = filteredData.length;
                var numCols = this.getNumCols(count, xRecord);
                var numRows = Math.ceil(count / numCols);

                var width = layInfo.width / numCols;
                var height = layInfo.height / numRows;

                var start = +Date.now();

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //var elem = vp.select(uelem);
                    //var elem = vp.visuals.createSingleWrapper(uelem);
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var scrLeft = width * (index % numCols);
                    var top = (height * Math.floor(index / numCols));
                    var scrTop = layInfo.height - top - height;

                    //---- apply LAYOUT and attributes ----
                    vp.dom.bounds(uelem, scrLeft, scrTop, width, height);
                    vp.dom.customAttr(uelem, "updateVisualHint", "fill");

                    vp.internal.applyShapeAttributesU(uelem, da);

                    if (isNewShape) {
                        layer.setElementInfoU(uelem, 1, seriesIndex);
                    }
                });

                var drawElapsed = +Date.now() - start;

                return shapes;
            };

            tileSuperClass.prototype.numCols = function (value) {
                if (arguments.length == 0) {
                    return this._numCols;
                }

                this._numCols = value;
                return this;
            };
            return tileSuperClass;
        })(layers.baseLayerClass);
        layers.tileSuperClass = tileSuperClass;

        var tileClass = (function (_super) {
            __extends(tileClass, _super);
            function tileClass() {
                _super.apply(this, arguments);
            }
            return tileClass;
        })(tileSuperClass);
        layers.tileClass = tileClass;

        function createTile() {
            return new tileClass();
        }
        layers.createTile = createTile;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=-tile.js.map

///----------------------------------------------------------------
/// (from layers\-xyTile.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// xyTile.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - create a "tile" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** This class is used to draw a variable sized "tile" layer for a plot.
        
        Each data record is expected to provide "x" and "y" offsets, so the resulting plot may
        contain variable width and variable height tiles.  The values of x in the first row determine
        the horizontal offsets of the tiles, and the values of y in the first column determine the
        vertical offsets of the tiles. This is the "mesh data" format typically used to draw a surface plot.
        
        Note that tiles are formed by connecting the x/y points in each record to each other, so if
        you want 4 tiles per row, each row must contain 5 records.
        
        For a simplier and faster tile plot, see the "tileClass" class. */
        //export class xyTileSuperClass<T extends xyTileSuperClass<T>> extends baseLayerClass<T>
        var xyTileSuperClass = (function (_super) {
            __extends(xyTileSuperClass, _super);
            //---- private state ----
            function xyTileSuperClass() {
                _super.call(this);

                this.layerType("tile").stat(vp.stats.statIdentity()).defaultStackType("dodge").chartName("Tile").newTagOrFunc("rect");
            }
            xyTileSuperClass.prototype.adjustChartOptions = function () {
            };

            /// public drawShapes() - draw tile plot.
            /// we grab xOffsets from first row and yOffsets from first column, then draw tiles between all
            /// xOffsets and yOffsets.  Note, this requires that we have at least 2 cols and at least 2 rows
            /// and that the first col/row shapes are of 0 size (same technique used in line charts) ----
            xyTileSuperClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- extract xOffsets, based on the first row of data ----
                var xOffsets = [];
                var xData = xRecord.data;
                var lastX = null;

                for (var i = 0; i < xData.length; i++) {
                    if ((i) && (xData[i] < lastX)) {
                        break;
                    }

                    xOffsets.push(xData[i]);
                    var lastX = xData[i];
                }

                var numCols = i;

                //---- extract yOffsets, based on the first column of data ----
                var yOffsets = [];
                var yData = yRecord.data;

                for (var i = 0; i < yData.length; i += numCols) {
                    yOffsets.push(yData[i]);
                }

                var numRows = yOffsets.length;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                if (!da) {
                    da = vp.session.currentTheme().getDrawingAttributes("layerTile", seriesIndex);
                }

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var xIsCategory = (xScale.scaleType() != 0 /* linear */);
                var yIsCategory = (yScale.scaleType() != 0 /* linear */);

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);
                    var colNum = index % numCols;
                    var rowNum = Math.floor(index / numCols);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var leftIndex = (colNum > 0) ? (colNum - 1) : colNum;
                    var botIndex = (rowNum > 0) ? (rowNum - 1) : rowNum;

                    var scrLeft = xScale.scale(xOffsets[leftIndex]);
                    var scrRight = xScale.scale(xOffsets[colNum]);
                    var scrWidth = scrRight - scrLeft;

                    var scrTop = yScale.flipScale(yOffsets[rowNum]);
                    var scrBottom = yScale.flipScale(yOffsets[botIndex]);
                    var scrHeight = scrBottom - scrTop;

                    //---- apply LAYOUT and attributes ----
                    elem.bounds(scrLeft, scrTop, scrWidth, scrHeight).customAttr("updateVisualHint", "fill");

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return xyTileSuperClass;
        })(layers.baseLayerClass);
        layers.xyTileSuperClass = xyTileSuperClass;

        var xyTileClass = (function (_super) {
            __extends(xyTileClass, _super);
            function xyTileClass() {
                _super.apply(this, arguments);
            }
            return xyTileClass;
        })(xyTileSuperClass);
        layers.xyTileClass = xyTileClass;

        function createXyTile() {
            return new xyTileClass();
        }
        layers.createXyTile = createXyTile;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=-xyTile.js.map

///----------------------------------------------------------------
/// (from layers\abLine.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// abLine.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates an abLine layer (set of lines based on slope, y-intercept values) for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an abLine layer (set of lines based on slope, y-intercept values) for a plot.  */
        var abLineClass = (function (_super) {
            __extends(abLineClass, _super);
            //---- private state ----
            function abLineClass() {
                _super.call(this);

                this.layerType("abLine").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("").newTagOrFunc("line");

                //---- defaults for X scale/axis ----
                this._xDefaults.isDiscrete = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.isDiscrete = false;
            }
            abLineClass.prototype.adjustChartOptions = function () {
            };

            abLineClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- AB LINE ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerAbLine", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(0, 1, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var x1 = xScale.domainMin();
                    var x2 = xScale.domainMax();

                    //---- "slope" is an alias for "x" ----
                    //---- "yIntercept" is an alias for "y" ----
                    var slope = xRecord.data[index];
                    if (slope === undefined) {
                        slope = 0;
                    }

                    var b = yRecord.data[index];
                    if (b === undefined) {
                        b = 1;
                    }

                    //---- compute y1, y2 ----
                    var y1 = slope * x1 + b;
                    var y2 = slope * x2 + b;

                    //---- now scale y1, y2 ----
                    y1 = yScale.flipScale(y1);
                    y2 = yScale.flipScale(y2);

                    //---- now scale x1, x2 ----
                    x1 = xScale.scale(x1);
                    x2 = xScale.scale(x2);

                    var elem = vp.select(uelem);

                    elem.from(x1, y1).to(x2, y2).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return abLineClass;
        })(layers.baseLayerClass);
        layers.abLineClass = abLineClass;

        function createAbLine() {
            return new abLineClass();
        }
        layers.createAbLine = createAbLine;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=abLine.js.map

///----------------------------------------------------------------
/// (from layers\area.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// area.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots an "area plot" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an area plot as a layer of a plot. */
        var areaClass = (function (_super) {
            __extends(areaClass, _super);
            //---- private state ----
            function areaClass() {
                _super.call(this);

                this._isSeriesLayer = true;

                this.layerType("area").stat(vp.stats.statIdentity()).defaultStackType("stack").chartName("Area").newTagOrFunc("polygon");

                this._xDefaults.colNames = ["x"];
                this._yDefaults.colNames = ["y"];
                this._x.layerDefaults.ignoreDodge = true;

            }
            areaClass.prototype.adjustChartOptions = function () {
                this._xDefaults.zeroAxis = false;

                //---- support for fill PERCENT formatting ----
                var stackType = this.stackType();
                this._yDefaults.usePercentFormatting = (stackType == "fill");
            };

            areaClass.prototype.addPoint = function (str, x, y) {
                str += x + "," + y + " ";
                return str;
            };

            /// public drawShapes() - draw area plot.
            areaClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var lastx = 0;
                var lasty = 0;
                var lastyZero = 0;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var firstUpdateCall = true;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerArea", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var dataValue = yRecord.data[index];
                    var elem = vp.select(uelem);

                    var xLeft = _this.getLineX(index, xRecord, xScale, xIsCategoryScale);
                    var yyy = _this.getStackedLineY(index, yRecord, yScale, pi);

                    var y = +yyy.y;
                    var h = +yyy.h;
                    var yZero = +yyy.yZero;

                    firstUpdateCall = false;

                    var w = Math.max(.25, xScale.itemWidth());
                    var x = xLeft;

                    if (index == 0) {
                        lastx = xLeft;
                        lasty = y;
                        lastyZero = yZero;
                    } else if (firstUpdateCall) {
                        //---- we are adding a new data point - get last values from the data ----
                        lastx = _this.getLineX(index - 1, xRecord, xScale, xIsCategoryScale);
                        yyy = _this.getStackedLineY(index - 1, yRecord, yScale, pi);

                        lasty = yyy.y;
                        lastyZero = yyy.yZero;
                    }

                    //---- build string of points ----
                    var points = "";
                    var xoverlap = (vp.utils.isIE && (x - lastx) >= 4) ? .5 : 0;

                    points = _this.addPoint(points, lastx, lastyZero);
                    points = _this.addPoint(points, lastx, lasty);
                    points = _this.addPoint(points, x + xoverlap, y);
                    points = _this.addPoint(points, x + xoverlap, yZero);

                    //---- apply LAYOUT attributes ----
                    elem.attr("points", points).customAttr("updateVisualHint", "fill");

                    //---- hide strokes when area shapes become very thin (keep fill as the predominate color) ----
                    if ((x - lastx) < 5) {
                        da.lineSize = 0;
                    }

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }

                    lastx = x;
                    lasty = y;
                    lastyZero = yZero;
                });

                return shapes;
            };
            return areaClass;
        })(layers.baseLayerClass);
        layers.areaClass = areaClass;

        function createArea() {
            return new areaClass();
        }
        layers.createArea = createArea;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=area.js.map

///----------------------------------------------------------------
/// (from layers\attrDefaults.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// attrDefaults.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - a structure to hold system-defined default values for attribute fields.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (layers) {
        /** settings for an attribute (value, scaling, legend data, etc).  User settings take precedence over these values. */
        var attrDefaults = (function () {
            function attrDefaults() {
                this.dataMin = undefined;
                this.dataMax = undefined;
                this.isMinMaxSoft = undefined;
                this.tickCount = undefined;
                this.dateFormat = undefined;
                this.zeroAxis = true;
                this.addMaxHeadroom = true;
                this.useNiceNumbers = true;
                this.percentGap = .30;
                this.combineDups = false;
                this.colNames = [];
                this.intOnlyBreaks = false;
                this.ignoreDodge = false;

            }
            return attrDefaults;
        })();
        layers.attrDefaults = attrDefaults;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=attrDefaults.js.map

///----------------------------------------------------------------
/// (from layers\bar.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// bar.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots a bar chart type layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
/// layer responsibilities (informal contract/API):
///     - set the stat that matches this layer
///     - set the baseLayer properties for this layer
///     - drawShapes() - draw the shapes for this layer
///     - getDefaultChartType() - get chart type that matches this layer
///     - adjustChartOptions(options) - adjust options to match needs of the layer (e.g., zero x axes)
///     - set the layer "newTagOrFunc" to a tag or function for new elements
///
///     - addSpecialControlsToChart() - optional; add special controls (like slider) to chart
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /**  creates a layer of vertical columns */
        var barClass = (function (_super) {
            __extends(barClass, _super);
            function barClass() {
                _super.call(this);
                //---- private state ----
                this._percentGap = .30;

                this._isSeriesLayer = true;

                this.layerType("bar").stat(vp.stats.statIdentity()).defaultStackType("stack").chartName("Bar").newTagOrFunc("rect").seriesAxis("x");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];

                //this._xDefaults.isDiscrete = false;
                //---- defaults for Y scale/axis ----
                this._yDefaults.percentGap = this._percentGap;
                this._yDefaults.colNames = ["y"];
                this._yDefaults.isDiscrete = true;
            }
            barClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.shapesEnterFromBottom = true;

                //---- support for fill PERCENT formatting ----
                var stackType = this.stackType();
                this._xDefaults.usePercentFormatting = (stackType == "fill");
            };

            //---- used by POINT and TEXT layers to align with BAR ----
            barClass.prototype.getXValues = function (pi, xValue, yValue, index, seriesIndex, xScale, yScale) {
                var xStartValue = 0;

                if (pi.stackType == "stack") {
                    if (xValue >= 0) {
                        //---- start x at previous POSITIVE stacking value ----
                        xStartValue = pi.itemAccums[index];
                        pi.itemAccums[index] += xValue;
                    } else {
                        //---- start x at previous NEGATIVE stacking value ----
                        xStartValue = pi.itemAccumsNeg[index];
                        pi.itemAccumsNeg[index] += (-xValue);
                    }
                } else if (pi.stackType == "fill") {
                    if (xValue >= 0) {
                        //---- start x at previous POSITIVE stacking value ----
                        xStartValue = pi.itemAccums[index];
                        pi.itemAccums[index] += xValue;
                    } else {
                        //---- start x at previous NEGATIVE stacking value ----
                        xStartValue = pi.itemAccumsNeg[index];
                        pi.itemAccumsNeg[index] += (-xValue);
                    }

                    //---- convert values into percentages ----
                    xStartValue /= pi.itemTotals[index];
                    xValue /= pi.itemTotals[index];
                } else if (pi.stackType == "dodge") {
                    var y = yScale.flipScale(yValue, seriesIndex);
                    var h = Math.max(.25, yScale.seriesItemWidth());

                    if (xValue < 0) {
                        xStartValue = xValue;
                    }
                }

                var xEndValue;

                if (xValue >= 0) {
                    xEndValue = xStartValue + xValue;
                } else {
                    xEndValue = xStartValue + (-xValue);
                }

                var x = xScale.scale(xStartValue);
                var x2 = xScale.scale(xEndValue);
                var w = x2 - x;

                return { y: y, h: h, x: x, w: w };
            };

            /// public drawShapes() - draw horizontal bar shapes.
            barClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerBar", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);
                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var yValue = (yIsCategoryScale) ? (index + 1) : yRecord.data[index];
                    var adjValue = xValue;

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    //---- for BAR LAYER: "x" should be LINEAR, "y" is typically CATEGORY ----
                    //---- vertical is easy part ----
                    var y = yScale.flipScale(yValue);
                    var h = Math.max(.25, yScale.itemWidth());

                    var xxx = _this.getXValues(pi, xValue, yValue, index, seriesIndex, xScale, yScale);

                    var x = xxx.x;
                    var w = xxx.w;

                    if (xxx.y) {
                        y = xxx.y;
                        h = xxx.h;
                    }

                    //---- layout elem ----
                    elem.attr("y", y).attr("x", x).attr("height", h).attr("width", w).customAttr("updateVisualHint", "fill");

                    //---- hide strokes when bars become very short (keep fill as the predominate color) ----
                    if (h < 5) {
                        da.lineSize = 0;
                    }

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };

            /** the size of the gap between columns (0-1). */
            barClass.prototype.percentGap = function (value) {
                if (arguments.length == 0) {
                    return this._percentGap;
                }

                this._percentGap = value;

                this._yDefaults.percentGap = value;

                this.markRebuildNeeded();
                return this;
            };
            return barClass;
        })(layers.baseLayerClass);
        layers.barClass = barClass;

        function createBar() {
            return new barClass();
        }
        layers.createBar = createBar;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=bar.js.map

///----------------------------------------------------------------
/// (from layers\boxPlot.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// boxPlot.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a "box plot" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /**  creates a "box plot" layer for a plot. */
        var boxPlotClass = (function (_super) {
            __extends(boxPlotClass, _super);
            function boxPlotClass() {
                _super.call(this);

                this._whiskerType = 1 /* tukey */;

                this._stat = vp.stats.statBoxPlot();
                this._stat.setWhiskerType(this._whiskerType);

                this.layerType("boxPlot").stat(this._stat).defaultStackType("identity").chartName("BoxPlot").newTagOrFunc("g");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];
                this._xDefaults.isDiscrete = true;
                this._xDefaults.zeroAxis = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["lower", "upper", "middle", "ymin", "ymax"];
                this._yDefaults.isDiscrete = false;
                this._yDefaults.zeroAxis = true;
            }
            boxPlotClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.showLegend = false;
            };

            boxPlotClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- BOX PLOT ----
                var layInfo = layer.info;
                var keyFunc = layInfo.keyFunc;
                var filteredData = layInfo.filteredData;
                var attributes = layer;

                //---- we only support 1 series but use multi y-cols, so set this explicitly ----
                var seriesIndex = 0;
                var seriesCount = 1;
                var dataId = 1;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                var daBox = vp.session.currentTheme().getDrawingAttributes("layerBoxPlot.box", seriesIndex);
                var daWhisker = vp.session.currentTheme().getDrawingAttributes("layerBoxPlot.whisker", seriesIndex);
                var daWhiskerEnd = vp.session.currentTheme().getDrawingAttributes("layerBoxPlot.whiskerEnd", seriesIndex);
                var daMedian = vp.session.currentTheme().getDrawingAttributes("layerBoxPlot.median", seriesIndex);
                var daOutliers = vp.session.currentTheme().getDrawingAttributes("layerBoxPlot.outliers", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(daBox, seriesIndex, filteredData);
                layer.addConstantDrawingAttributes(daWhisker, seriesIndex, filteredData);
                layer.addConstantDrawingAttributes(daWhiskerEnd, seriesIndex, filteredData);
                layer.addConstantDrawingAttributes(daMedian, seriesIndex, filteredData);
                layer.addConstantDrawingAttributes(daOutliers, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes([daBox, daWhisker, daWhiskerEnd, daMedian, daOutliers], seriesIndex, index, filteredData);

                    //---- each "shape" for a boxPlot is a GROUP containing: box, whiskers, median line, wiskerEnds, and outlier points ----
                    var group = vp.select(uelem).id("boxPlot").clear();

                    if (isNewShape) {
                        layer.setElementInfo(group, dataId, seriesIndex);
                    }

                    var xValue = (index + 1);
                    var x = xScale.scale(index);
                    var w = Math.max(.25, xScale.itemWidth());
                    var record = filteredData[index];
                    var xMid = x + w / 2;

                    var y1 = yScale.flipScale(record.highFence);
                    var y2 = yScale.flipScale(record.lowFence);

                    //---- add WHISKER (vertical line) ----
                    var whisker = group.append("line").id("whisker").attr("x1", xMid).attr("x2", xMid).attr("y1", y1).attr("y2", y2).customAttr("updateVisualHint", "none");

                    layer.applyShapeAttributes(whisker, daWhisker);

                    //---- add WHISKER ENDS (horizontal lines) ----
                    var lenHalf = w * daWhiskerEnd.length / 2;

                    var whiskerTop = group.append("line").id("whiskerTop").attr("x1", xMid - lenHalf).attr("x2", xMid + lenHalf).attr("y1", y1).attr("y2", y1).customAttr("updateVisualHint", "none");

                    var whiskerBottom = group.append("line").id("whiskerBottom").attr("x1", xMid - lenHalf).attr("x2", xMid + lenHalf).attr("y1", y2).attr("y2", y2).customAttr("updateVisualHint", "none");

                    layer.applyLineAttributes(whiskerTop, daWhiskerEnd);
                    layer.applyLineAttributes(whiskerBottom, daWhiskerEnd);

                    var dataH = Math.max(0, record.upper - record.lower);

                    var y = yScale.flipScale(record.upper);
                    var h = Math.max(0, yScale.scaleSize(dataH));

                    //---- add BOX ----
                    var box = group.append("rect").id("box").attr("x", x).attr("width", w).attr("y", y).attr("height", h).customAttr("updateVisualHint", "both");

                    layer.applyShapeAttributes(box, daBox);

                    var yMedian = yScale.flipScale(record.middle);

                    //---- add MEDIAN LINE ----
                    var mline = group.append("line").id("median").attr("x1", x).attr("x2", x + w).attr("y1", yMedian).attr("y2", yMedian).attr("stroke-width", "2").customAttr("updateVisualHint", "none");

                    layer.applyLineAttributes(mline, daMedian);

                    if (attributes._showOutliers) {
                        //---- draw outliers as 1 dim dot plot ----
                        var outliers = record.outliers;
                        outliers.generate(group, "circle", function (elem, yValue, index) {
                            elem.attr("cx", xMid).attr("cy", yScale.flipScale(yValue)).attr("r", daOutliers.shapeSize / 2).customAttr("updateVisualHint", "fill");

                            layer.applyShapeAttributes(elem, daOutliers);
                        });
                    }
                });

                return shapes;
            };

            boxPlotClass.prototype.whiskerType = function (value) {
                if (arguments.length === 0) {
                    return this._whiskerType;
                }

                this._whiskerType = value;
                this._stat.setWhiskerType(value);

                this.markRebuildNeeded();
                return this;
            };
            return boxPlotClass;
        })(layers.baseLayerClass);
        layers.boxPlotClass = boxPlotClass;

        function createBoxPlot() {
            return new boxPlotClass();
        }
        layers.createBoxPlot = createBoxPlot;

        (function (WhiskerType) {
            /** from min data point to max data point. */
            WhiskerType[WhiskerType["minMax"] = 0] = "minMax";

            /** min and max data points within  Q1 - 1.5*IQR, Q3 + 1.5*IQR   (IQR: Q3 - Q1). */
            WhiskerType[WhiskerType["tukey"] = 1] = "tukey";

            /** from 9th percentile to 91st percentile. */
            WhiskerType[WhiskerType["percentile9to91"] = 2] = "percentile9to91";

            /** from 2nd percentile to 98th percentile. */
            WhiskerType[WhiskerType["percentile2to98"] = 3] = "percentile2to98";

            /** one standard deviation above and below the MEAN of the data. */
            WhiskerType[WhiskerType["stdDev"] = 4] = "stdDev";
        })(layers.WhiskerType || (layers.WhiskerType = {}));
        var WhiskerType = layers.WhiskerType;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=boxPlot.js.map

///----------------------------------------------------------------
/// (from layers\candlestick.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// candlestick.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a candlestick layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a candlestick layer for a plot. */
        var candlestickClass = (function (_super) {
            __extends(candlestickClass, _super);
            //---- private state ----
            function candlestickClass() {
                _super.call(this);

                this.layerType("candleStick").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("CandleStick").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            candlestickClass.prototype.adjustChartOptions = function () {
            };

            candlestickClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this;

                var yMinCol = attributes._yMin.getAfterStatsPropName(0);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            candlestickClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- CANDLESTICK ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerCandlestick", seriesIndex);
                var daUp = vp.session.currentTheme().getDrawingAttributes("layerCandlestick.upDayBar", seriesIndex);
                var daDown = vp.session.currentTheme().getDrawingAttributes("layerCandlestick.downDayBar", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);
                layer.addConstantDrawingAttributes(daUp, seriesIndex, filteredData);
                layer.addConstantDrawingAttributes(daDown, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes([da, daUp, daDown], seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var attributes = layer;

                    var record = filteredData[index];

                    var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                    var yMinValue = record[yMinCol];

                    var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);
                    var yMaxValue = record[yMaxCol];

                    var yOpenCol = attributes._yOpen.getAfterStatsPropName(seriesIndex);
                    var yOpenValue = record[yOpenCol];

                    var yCloseCol = attributes._yClose.getAfterStatsPropName(seriesIndex);
                    var yCloseVal = record[yCloseCol];

                    var x = xScale.scale(xValue);
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);
                    var yOpen = yScale.flipScale(yOpenValue);
                    var yClose = yScale.flipScale(yCloseVal);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    //---- high/low line ----
                    var line = g.append("line").from(x, yMin).to(x, yMax).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line, da);

                    var barSize2 = da.shapeSize / 2;

                    //---- open/close box ----
                    var rect = g.append("rect").bounds(x - barSize2, Math.min(yOpen, yClose), da.shapeSize, Math.abs(yOpen - yClose)).customAttr("updateVisualHint", "stroke");

                    da.fill = (yOpen > yClose) ? daDown.fill : daUp.fill;

                    layer.applyShapeAttributes(rect, da);

                    if (isNewShape) {
                        layer.setElementInfo(line, 1, seriesIndex);
                        layer.setElementInfo(rect, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return candlestickClass;
        })(layers.baseLayerClass);
        layers.candlestickClass = candlestickClass;

        function createCandlestick() {
            return new candlestickClass();
        }
        layers.createCandlestick = createCandlestick;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=candlestick.js.map

///----------------------------------------------------------------
/// (from layers\column.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// column.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - defines a column plotLayer.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /**  creates a layer of vertical columns */
        //export class columnSuperClass<T extends columnSuperClass<T>> extends baseLayerClass<T>
        var columnSuperClass = (function (_super) {
            __extends(columnSuperClass, _super);
            function columnSuperClass() {
                _super.call(this);
                //---- private state ----
                this._percentGap = .30;

                this._isSeriesLayer = true;

                this.layerType("column").stat(vp.stats.statIdentity()).defaultStackType("stack").chartName("Column").newTagOrFunc("rect");

                //---- defaults for X scale/axis ----
                this._xDefaults.percentGap = this._percentGap;
                this._xDefaults.isDiscrete = true;
            }
            columnSuperClass.prototype.adjustChartOptions = function () {
                //---- support for fill PERCENT formatting ----
                var stackType = this.stackType();
                this._yDefaults.usePercentFormatting = (stackType == "fill");
                ;
            };

            //---- used by POINT and TEXT layers to align with BAR ----
            columnSuperClass.prototype.getYValues = function (yValue, pi, index, xScale, yScale, seriesIndex) {
                var yStartValue = 0;

                if (pi.stackType == "stack") {
                    if (yValue >= 0) {
                        //---- start y at previous POSITIVE stacking value ----
                        yStartValue = pi.itemAccums[index];
                        pi.itemAccums[index] += yValue;
                    } else {
                        //---- start y at previous NEGATIVE stacking value ----
                        yStartValue = pi.itemAccumsNeg[index];
                        pi.itemAccumsNeg[index] += (-yValue);
                    }
                } else if (pi.stackType == "fill") {
                    if (yValue >= 0) {
                        //---- start y at previous POSITIVE stacking value ----
                        yStartValue = pi.itemAccums[index];
                        pi.itemAccums[index] += yValue;
                    } else {
                        //---- start y at previous NEGATIVE stacking value ----
                        yStartValue = pi.itemAccumsNeg[index];
                        pi.itemAccumsNeg[index] += (-yValue);
                    }

                    //---- convert values into percentages ----
                    yStartValue /= pi.itemTotals[index];
                    yValue /= pi.itemTotals[index];
                } else if (pi.stackType == "dodge") {
                    var x = xScale.scale(index, seriesIndex);
                    var w = Math.max(.25, xScale.seriesItemWidth());

                    if (yValue < 0) {
                        yStartValue = yValue;
                    }
                }

                var yEndValue;

                if (yValue >= 0) {
                    yEndValue = yStartValue + yValue;
                } else {
                    yEndValue = yStartValue + (-yValue);
                }

                //---- flipped logic here ----
                var y2 = yScale.flipScale(yStartValue);
                var y = yScale.flipScale(yEndValue);
                var h = y2 - y;

                return { y: y, h: h, x: x, w: w };
            };

            /** draw vertical column shapes.
            NOTE: this is also used by layerHistogram, which sometimes uses a LINEAR XSCALE. */
            columnSuperClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                //vp.utils.debug("layerColumn.drawShapes: xRecord.data.length=" + xRecord.data.length);
                if (!da) {
                    //---- get THEME drawing attributes for each of the parts we will draw ----
                    da = vp.session.currentTheme().getDrawingAttributes("layerColumn", seriesIndex);
                }

                var recordCount = filteredData.length;
                var colWidth = Math.max(.25, xScale.itemWidth());

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);
                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var yValue = (yIsCategoryScale) ? (index) : yRecord.data[index];

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);
                    var x = 0;
                    var w = 0;

                    //---- horizontal is the easy part ----
                    x = xScale.scale(xValue);
                    w = colWidth;

                    var yyy = _this.getYValues(yValue, pi, index, xScale, yScale, seriesIndex);
                    var y = yyy.y;
                    var h = yyy.h;

                    if (yyy.x !== undefined) {
                        x = yyy.x;
                        w = yyy.w;
                    }

                    //---- apply LAYOUT attributes ----
                    elem.attr("x", x).attr("y", y).attr("width", w).attr("height", h).customAttr("updateVisualHint", "fill");

                    //---- hide strokes when bars become very thin (keep fill as the predominate color) ----
                    if (w < 5) {
                        da.lineSize = 0;
                    }

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };

            /** the size of the gap between columns (0-1). */
            columnSuperClass.prototype.percentGap = function (value) {
                if (arguments.length == 0) {
                    return this._percentGap;
                }

                this._percentGap = value;

                this._xDefaults.percentGap = value;

                this.markRebuildNeeded();
                return this;
            };
            return columnSuperClass;
        })(layers.baseLayerClass);
        layers.columnSuperClass = columnSuperClass;

        var columnClass = (function (_super) {
            __extends(columnClass, _super);
            function columnClass() {
                _super.apply(this, arguments);
            }
            return columnClass;
        })(columnSuperClass);
        layers.columnClass = columnClass;

        function createColumn() {
            return new columnClass();
        }
        layers.createColumn = createColumn;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=column.js.map

///----------------------------------------------------------------
/// (from layers\contour.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// contour.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a "contour plot" layer for a chart.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a "line range" layer for a plot. */
        var contourClass = (function (_super) {
            __extends(contourClass, _super);
            function contourClass() {
                _super.call(this);
                //---- private state ----
                this._contourCount = 5;

                var stat = vp.stats.createStatContour().contourCount(this._contourCount);

                this.layerType("contour").stat(stat).defaultStackType("identity").chartName("contour").newTagOrFunc("line");
            }
            contourClass.prototype.calcXScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var min = undefined;
                var max = undefined;

                if (data) {
                    //---- set data MIN/MAX for X attribute/scale ----
                    min = data.min(function (data, index) {
                        return Math.min(data.x1, data.x2);
                    });
                    max = data.max(function (data, index) {
                        return Math.max(data.x1, data.x2);
                    });
                    //---- leave some space around min/max ----
                    //min = (min < 0) ? (1.2 * min) : (.8 * min);
                    //max = (max < 0) ? (.8 * max) : (1.2 * max);
                }

                return { min: min, max: max };
            };

            contourClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var min = undefined;
                var max = undefined;

                if (data) {
                    //---- set data MIN/MAX for Y attribute/scale ----
                    min = data.min(function (data, index) {
                        return Math.min(data.y1, data.y2);
                    });
                    max = data.max(function (data, index) {
                        return Math.max(data.y1, data.y2);
                    });
                    //---- leave some space around min/max ----
                    //min = (min < 0) ? (1.2 * min) : (.8 * min);
                    //max = (max < 0) ? (.8 * max) : (1.2 * max);
                }

                return { min: min, max: max };
            };

            contourClass.prototype.contourCount = function (value) {
                if (arguments.length == 0) {
                    return this._contourCount;
                }

                this._contourCount = value;
                this._stat.contourCount(value);

                return this;
            };

            contourClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- CONTOUR ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layercontour", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var attributes = layer;

                    var record = filteredData[index];

                    //var x1Data = record.x1;from =
                    var x1Data = record.x1;
                    var y1Data = record.y1;
                    var x2Data = record.x2;
                    var y2Data = record.y2;

                    var x1 = xScale.scale(x1Data);
                    var x2 = xScale.scale(x2Data);

                    var y1 = yScale.flipScale(y1Data);
                    var y2 = yScale.flipScale(y2Data);

                    //if (xIsCategoryScale)
                    //{
                    //    x += xScale.itemWidth() / 2;
                    //}
                    vp.dom.from(uelem, x1, y1);
                    vp.dom.to(uelem, x2, y2);
                    uelem.updateVisualHint = "stroke";

                    vp.internal.applyLineAttributesU(uelem, da);

                    if (isNewShape) {
                        layer.setElementInfoU(uelem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return contourClass;
        })(layers.baseLayerClass);
        layers.contourClass = contourClass;

        function createContour() {
            return new contourClass();
        }
        layers.createContour = createContour;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=contour.js.map

///----------------------------------------------------------------
/// (from layers\crossBar.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// crossBar.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots a cross bar plot layer (rect with a horizontal line through it).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an area plot as a layer of a plot. */
        var crossBarClass = (function (_super) {
            __extends(crossBarClass, _super);
            //---- private state ----
            function crossBarClass() {
                _super.call(this);

                this.layerType("corssBar").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("CrossBar").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            crossBarClass.prototype.adjustChartOptions = function () {
            };

            crossBarClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this;

                var yMinCol = attributes._yMin.getAfterStatsPropName(0);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            crossBarClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- CROSS BAR ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerCrossBar", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var yValue = (yIsCategoryScale) ? (index) : yRecord.data[index];
                    var attributes = layer;

                    var record = filteredData[index];

                    var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                    var yMinValue = record[yMinCol];

                    var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);
                    var yMaxValue = record[yMaxCol];

                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    var itemSize = xScale.itemWidth();
                    var barSize2 = itemSize / 2;

                    //---- min/max box ----
                    var rect = g.append("rect").bounds(x - barSize2, yMax, itemSize, yMin - yMax).customAttr("updateVisualHint", "fill");

                    layer.applyShapeAttributes(rect, da);

                    //---- y line ----
                    var line = g.append("line").from(x - barSize2, y).to(x + barSize2, y).customAttr("updateVisualHint", "none");

                    layer.applyLineAttributes(line, da);

                    if (isNewShape) {
                        layer.setElementInfo(rect, 1, seriesIndex);
                        layer.setElementInfo(line, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return crossBarClass;
        })(layers.baseLayerClass);
        layers.crossBarClass = crossBarClass;

        function createCrossBar() {
            return new crossBarClass();
        }
        layers.createCrossBar = createCrossBar;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=crossBar.js.map

///----------------------------------------------------------------
/// (from layers\density.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// density.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a density layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a density layer for a plot. */
        var densityClass = (function (_super) {
            __extends(densityClass, _super);
            function densityClass() {
                _super.call(this);
                //---- private state ----
                this._binPercent = .03;

                this.layerType("density").stat(vp.stats.statDensity()).defaultStackType("stack").chartName("Density").newTagOrFunc("line");
            }
            densityClass.prototype.adjustChartOptions = function () {
            };

            densityClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- DENSITY ----
                return _super.prototype.drawShapes.call(this, shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da);
            };

            densityClass.prototype.onBinPercentChanged = function () {
                var stat = this.stat();

                if ((stat) && (stat.binPercent)) {
                    stat.binPercent(this._binPercent);
                    this.onPlotDataChanged(true);
                }

                this.markRebuildNeeded();
            };

            //---- property: binPercent ----
            densityClass.prototype.binPercent = function (value) {
                if (arguments.length == 0) {
                    return this._binPercent;
                }

                this._binPercent = value;
                this.onBinPercentChanged();

                return this;
            };
            return densityClass;
        })(layers.lineSuperClass);
        layers.densityClass = densityClass;

        function createDensity() {
            return new densityClass();
        }
        layers.createDensity = createDensity;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=density.js.map

///----------------------------------------------------------------
/// (from layers\errorBar.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// errorBar.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates an error bar layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an area plot as a layer of a plot. */
        var errorBarClass = (function (_super) {
            __extends(errorBarClass, _super);
            //---- private state ----
            function errorBarClass() {
                _super.call(this);

                this.layerType("errorBar").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("ErrorBar").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            errorBarClass.prototype.adjustChartOptions = function () {
            };

            errorBarClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this;

                var yMinCol = attributes._yMin.getAfterStatsPropName(0);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            errorBarClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- ERROR BAR ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerErrorBar", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var attributes = layer;

                    var record = filteredData[index];

                    var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                    var yMinValue = record[yMinCol];

                    var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);
                    var yMaxValue = record[yMaxCol];

                    var x = xScale.scale(xValue);
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    //---- high/low line ----
                    var line1 = g.append("line").from(x, yMin).to(x, yMax).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line1, da);

                    var barSize2 = da.shapeSize;

                    //---- top line ----
                    var line2 = g.append("line").from(x - barSize2, yMax).to(x + barSize2, yMax).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line2, da);

                    //---- bottom line ----
                    var line3 = g.append("line").from(x - barSize2, yMin).to(x + barSize2, yMin).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line3, da);

                    if (isNewShape) {
                        layer.setElementInfo(line1, 1, seriesIndex);
                        layer.setElementInfo(line2, 1, seriesIndex);
                        layer.setElementInfo(line3, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return errorBarClass;
        })(layers.baseLayerClass);
        layers.errorBarClass = errorBarClass;

        function createErrorBar() {
            return new errorBarClass();
        }
        layers.createErrorBar = createErrorBar;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=errorBar.js.map

///----------------------------------------------------------------
/// (from layers\graph.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// graph.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - create a node link graph as a layer of a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** create a node link graph as a layer of a plot. */
        var graphClass = (function (_super) {
            __extends(graphClass, _super);
            function graphClass() {
                _super.call(this);
                //---- private state ----
                this._drawParams = undefined;
                this._group = null;
                this._layoutTimer = null;
                this._padding = 10;
                this._useEllipse = true;

                this.layerType("graph").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("Graph").newTagOrFunc("g").newTagOrFunc2("g");
            }
            graphClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.showXAxis = false;
                this._plotDefaults.showYAxis = false;
                this._plotDefaults.showLegend = false;
                this._plotDefaults.showXTitle = false;
                this._plotDefaults.showYTitle = false;
                this._plotDefaults.showXGridLines = false;
                this._plotDefaults.showYGridLines = false;
            };

            graphClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- save off drawing parameters for later use ----
                this._drawParams = {
                    shapeRoot: shapeRoot, xRecord: xRecord, yRecord: yRecord, seriesIndex: seriesIndex,
                    pi: pi, xScale: xScale, yScale: yScale, stdChart: plot, layer: layer, info: layer.info
                };

                //---- buffer requests for layout so we don't send too many during a RESIZE operation ----
                if (this._layoutTimer) {
                    clearTimeout(this._layoutTimer);
                }

                this._layoutTimer = setTimeout(vp.utils.cb(this, this.startLayout), 125);

                //---- we will draw our shapes aync using "group" ----
                return vp.select();
            };

            graphClass.prototype.startLayout = function () {
                var _this = this;
                clearTimeout(this._layoutTimer);
                this._layoutTimer = null;

                var shapeRoot = this._drawParams.shapeRoot;
                var xRecord = this._drawParams.xRecord;
                var info = this._drawParams.info;

                //---- initiate a async layout from our web service ----
                var urlDir = vp.utils.getUrlDirectory();

                var w = info.width - 2 * this._padding;
                var h = info.height - 2 * this._padding;
                var yCols = this.yAfterStat();

                var idCol = (xRecord) ? xRecord.name : "id";
                var fromCol = ((yCols) && (yCols.length > 0)) ? yCols[0] : "from";
                var toCol = ((yCols) && (yCols.length > 1)) ? yCols[1] : "to";

                var nodeData = this.data();
                var edgeData = this.data2();

                //---- at least 1 node is required (edges are optional) ----
                if ((nodeData) && (nodeData.length > 0)) {
                    //---- set up a temp text element for measuring text ----
                    var tempTextElem = vp.select(document.body).append("text");

                    //---- get theme info (fontSize) for the graph's text element ----
                    var theme = vp.session.currentTheme();
                    var daText = theme.getDrawingAttributes("layerGraph.text");

                    //---- update with user constants ----
                    var seriesIndex = 1;
                    var filteredData = this.info.filteredData;
                    this.addConstantDrawingAttributes(daText, seriesIndex, filteredData);

                    //---- todo: allow for mapped fontSize attribute here ----
                    tempTextElem.css("font-size", daText.textSize + "pt");

                    //tempTextElem.css("font-family", "Consolas");
                    var nodeIndexes = {};

                    var nodes = nodeData.map(function (data, index) {
                        var idKey = data[idCol];
                        nodeIndexes[idKey] = index;

                        tempTextElem.text(idKey);
                        var bb = vp.dom.getBounds(tempTextElem[0]);

                        //---- adjust returned sizes for tighter fit ----
                        var bw = .90 * bb.width;
                        var bh = .45 * bb.height;

                        var shapeName = (_this._useEllipse) ? "Ellipse" : "Rectangle";

                        //---- todo: we should probably let user optionally specify node size ----
                        return {
                            width: bw, height: bh, shapeType: shapeName, userData: idKey,
                            origWidth: bw, origHeight: bh };
                    });

                    //---- remove temp label created above ----
                    tempTextElem.remove();

                    //---- build the ed list from edgeData ----
                    // EdgeData(int from, int to)
                    var edges = edgeData.map(function (data, index) {
                        var fromKey = data[fromCol];
                        var toKey = data[toCol];

                        var fromIndex = nodeIndexes[fromKey];
                        var toIndex = nodeIndexes[toKey];

                        return { from: fromIndex, to: toIndex };
                    });

                    //---- package up our parameters and data ----
                    var paramPackage = {
                        width: w, height: h, nodes: nodes, edges: edges
                    };

                    var strPackage = JSON.stringify(paramPackage);

                    //---- build our url with strPackage appended ----
                    //http://localhost/VuePlotServices/msaglService.aspx
                    var serviceName = (urlDir.contains("VuePlotDev")) ? "VuePlotServicesDev" : "VuePlotServices";
                    var aspUrl = urlDir + "/../../" + serviceName + "/msaglService.aspx";

                    var fullUrl = aspUrl + "?params=" + strPackage;
                    var safeUrl = encodeURI(fullUrl);

                    vp.file.httpRead(safeUrl, true, function (xmlhttp) {
                        //---- SUCCESS ----
                        var txt = xmlhttp.responseText;
                        var result = vp.file.getJsonFromResponse(txt);

                        _this.drawShapesWithLayout(result);
                    }, function (xmlhttp) {
                        //---- FAILED ----
                        alert("Error in layout service call: " + aspUrl);
                    });
                }
            };

            /// called async. when layout info has been returned from the server.  This draws both the nodes
            /// and the links (each a group with multiple child shapes).
            graphClass.prototype.drawShapesWithLayout = function (result) {
                var _this = this;
                //--- GRAPH DRAWING ----
                var nodes = result.nodes;
                var edges = result.edges;
                var arrowHeads = result.arrowHeads;

                var shapes = vp.select();
                var nodeData = this.data();
                var edgeData = this.data2();
                var layInfo = this.info;
                var filteredData = layInfo.filteredData;
                var elemTransform = "translate(" + this._padding + " " + this._padding + ")";

                //---- we only support 1 series but use multi y-cols, so set this explicitly ----
                var seriesIndex = 0;
                var seriesCount = 1;

                var theme = vp.session.currentTheme();

                //---- get THEME drawing attributes for each of the parts we will draw ----
                var daEdge = theme.getDrawingAttributes("layerGraph.edge", seriesIndex);
                var daText = theme.getDrawingAttributes("layerGraph.text", seriesIndex);
                var daArrow = theme.getDrawingAttributes("layerGraph.arrow", seriesIndex);
                var daNode = theme.getDrawingAttributes("layerGraph.node", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                this.addConstantDrawingAttributes(daEdge, seriesIndex, filteredData);
                this.addConstantDrawingAttributes(daText, seriesIndex, filteredData);
                this.addConstantDrawingAttributes(daArrow, seriesIndex, filteredData);
                this.addConstantDrawingAttributes(daNode, seriesIndex, filteredData);

                //---- create and position GROUP 2: EDGES and ARROW HEADS ----
                var edgeShapes = this.dataAnimMgr2().updateShapes(seriesIndex, seriesCount, function (uelem, d, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    _this.updateDrawingAttributes([daEdge, daArrow], seriesIndex, index, filteredData);

                    var data = edges[index];

                    var edgeGroup = vp.select(uelem).clear();

                    if (isNewShape) {
                        _this.setElementInfo(edgeGroup, 2, seriesIndex);
                        edgeGroup.id("edge");
                    }

                    edgeGroup.dataItem().data = edgeData[index]; // point to user data

                    //---- add EDGE path ----
                    var edge = edgeGroup.append("path").attr("d", data.pathData).transform(elemTransform).customAttr("updateVisualHint", "stroke");

                    _this.applyLineAttributes(edge, daEdge);

                    data = arrowHeads[index]; // point to layout data

                    //---- add ARROW HEAD path ----
                    var arrow = edgeGroup.append("path").attr("d", data.path).transform(elemTransform).customAttr("updateVisualHint", "fill");

                    _this.applyShapeAttributes(arrow, daArrow);
                });

                //---- create and position GROUP 1: NODES and TEXT ----
                var nodeShapes = this.dataAnimMgr().updateShapes(seriesIndex, seriesCount, function (uelem, d, index, isNewShape) {
                    var nodeGroup = vp.select(uelem).clear();

                    if (isNewShape) {
                        _this.setElementInfo(nodeGroup, 1, seriesIndex);
                        nodeGroup.id("node");
                    }

                    //---- update drawing attributes for this itemIndex ----
                    _this.updateDrawingAttributes([daNode, daText], seriesIndex, index, filteredData);

                    var data = nodes[index];
                    nodeGroup.dataItem().data = nodeData[index]; // point to user data

                    //---- add ELLIPSE and TEXT nodes ----
                    var shapeName = (_this._useEllipse) ? "ellipse" : "rect";

                    var nodeShape = nodeGroup.append(shapeName);
                    var text = nodeGroup.append("text");

                    //---- layout ELLIPSE ----
                    var w2 = data.width / 2;
                    var h2 = data.height / 2;

                    //---- current implementation of graph info doesn't work right for small size canvas, so ----
                    //---- we let user override node size when needed ----
                    if (daNode.shapeSize !== undefined) {
                        //var aspect = w2 / h2;
                        //w2 = daNode.shapeSize / 2;
                        //h2 = w2 / aspect;
                        //---- scale the existing sizes with shapeSize in this case ----
                        w2 *= daNode.shapeSize;
                        h2 *= daNode.shapeSize;
                    }

                    if (_this._useEllipse) {
                        nodeShape.attr("cx", data.x).attr("cy", data.y).attr("rx", w2).attr("ry", h2).transform(elemTransform).customAttr("updateVisualHint", "stroke");
                    } else {
                        nodeShape.attr("x", data.x - w2).attr("y", data.y - h2).attr("width", data.width).attr("height", data.height).transform(elemTransform).customAttr("updateVisualHint", "stroke");
                    }

                    _this.applyShapeAttributes(nodeShape, daNode); //, true, false);

                    //---- TODO: somehow scale text as per the layout ----
                    //var strScale = "scale(" + result.scaleX + "," + result.scaleY + "," + data.x + "," + data.y + ")";
                    //elemTransform = strScale + " " + elemTransform;
                    //---- layout TEXT ----
                    text.text(data.userData).position(data.x, data.y).transform(elemTransform).attr("cursor", "default").customAttr("updateVisualHint", "fill");

                    _this.applyTextAttributes(text, daText); //, false, true);
                });

                //---- tell vvPlot that we generated these shapes ----
                var allShapes = edgeShapes.merge(nodeShapes);
                this._drawParams.stdChart.addDrawnShapes(this, allShapes, seriesIndex);
            };
            return graphClass;
        })(layers.baseLayerClass);
        layers.graphClass = graphClass;

        function createGraph() {
            return new graphClass();
        }
        layers.createGraph = createGraph;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=graph.js.map

///----------------------------------------------------------------
/// (from layers\histogram.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// histogram.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a histogram layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a histogram layer for a plot. */
        var histogramClass = (function (_super) {
            __extends(histogramClass, _super);
            function histogramClass() {
                _super.call(this);
                //---- private state ----
                //---- todo: should we put this into vvMappings someday? ----
                this._binPercent = .03;
                this._forceCategory = false;
                this._usePercent = false;
                this._niceBuckets = false;

                var stat = vp.stats.statBin().binPercent(this._binPercent).forceCategory(this._forceCategory).usePercent(this._usePercent).niceBuckets(this._niceBuckets);

                //---- set base class properties ----
                this.layerType("histogram").stat(stat).defaultStackType("stack").chartName("Histogram").newTagOrFunc("rect");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];

                //this._xDefaults.isDiscrete = true;
                this._xDefaults.percentGap = 0;
                this._xDefaults.zeroAxis = false;
                this._xDefaults.addMaxHeadroom = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["y"];
                //this._yDefaults.isDiscrete = false;
            }
            histogramClass.prototype.calcXScaleForLayer = function (descRecord) {
                var result = null;

                if (this._xDefaults.dataMin !== undefined) {
                    result = { min: this._xDefaults.dataMin, max: this._xDefaults.dataMax };
                }

                return result;
            };

            histogramClass.prototype.adjustChartOptions = function () {
                //---- make xScale CATEGORY or LINEAR ----
                var dataIsNumeric = (!this._stat.isCategory());

                this._xDefaults.isDiscrete = (!dataIsNumeric);

                if (dataIsNumeric) {
                    //---- build custom "breaks" for a category histogram ----
                    var breaks = [];
                    var data = this.data();
                    var record = null;

                    if (data) {
                        for (var i = 0; i < data.length; i++) {
                            record = data[i];
                            breaks.push(record.min);
                        }

                        //---- push last record.max ----
                        if (record) {
                            breaks.push(record.max);
                        }
                    }

                    this._xDefaults.breaks = breaks;
                    this._xAttr.onBreaksChanged();
                    //layer.xAxisInfo()
                    //    .zeroAxis(false)
                    //    .addMaxHeadroom(false)
                } else {
                    this._xDefaults.breaks = null;
                    this._xAttr.onBreaksChanged();
                }

                this._yDefaults.intOnlyBreaks = (!this._usePercent);
            };

            histogramClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- HISTOGRAM ----
                //layer.info.drawBorder = true;
                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerHistogram", seriesIndex);

                return _super.prototype.drawShapes.call(this, shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da);
            };

            histogramClass.prototype.onBinPercentChanged = function () {
                var stat = this.stat();

                if ((stat) && (stat.binPercent)) {
                    stat.binPercent(this._binPercent);
                    this.onPlotDataChanged(true);
                }

                this.markRebuildNeeded();
            };

            //---- property: binPercent ----
            histogramClass.prototype.binPercent = function (value) {
                if (arguments.length == 0) {
                    return this._binPercent;
                }

                this._binPercent = value;
                this.onBinPercentChanged();

                return this;
            };

            histogramClass.prototype.onForceCategoryChanged = function () {
                var stat = this.stat();

                if ((stat) && (stat.forceCategory)) {
                    stat.forceCategory(this._forceCategory);
                    this.onPlotDataChanged(true);
                }

                this.markRebuildNeeded();
            };

            //---- property: forceCategory ----
            histogramClass.prototype.forceCategory = function (value) {
                if (arguments.length == 0) {
                    return this._forceCategory;
                }

                this._forceCategory = value;
                this.onForceCategoryChanged();

                return this;
            };

            histogramClass.prototype.onUsePercentChanged = function () {
                var stat = this.stat();

                if ((stat) && (stat.usePercent)) {
                    stat.usePercent(this._usePercent);
                    this.onPlotDataChanged(true);
                }

                this.markRebuildNeeded();
            };

            histogramClass.prototype.onNiceBucketsChanged = function () {
                var stat = this.stat();

                if ((stat) && (stat.niceBuckets)) {
                    stat.niceBuckets(this._niceBuckets);
                    this.onPlotDataChanged(true);
                }

                this.markRebuildNeeded();
            };

            //---- property: usePercent ----
            histogramClass.prototype.usePercent = function (value) {
                if (arguments.length == 0) {
                    return this._usePercent;
                }

                this._usePercent = value;
                this.onUsePercentChanged();

                return this;
            };

            //---- property: niceBuckets ----
            histogramClass.prototype.niceBuckets = function (value) {
                if (arguments.length == 0) {
                    return this._niceBuckets;
                }

                this._niceBuckets = value;
                this.onNiceBucketsChanged();

                return this;
            };
            return histogramClass;
        })(layers.columnSuperClass);
        layers.histogramClass = histogramClass;

        function createHistogram() {
            return new histogramClass();
        }
        layers.createHistogram = createHistogram;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=histogram.js.map

///----------------------------------------------------------------
/// (from layers\histogram2d.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// histogram2d.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a "2d histogram" (aka bin2d or heatmap) layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a "2d histogram" (aka bin2d or heatmap) layer for a plot. */
        var histogram2dClass = (function (_super) {
            __extends(histogram2dClass, _super);
            function histogram2dClass() {
                _super.call(this);
                //---- private state ----
                this._xBinCount = 9;
                this._xForceCategory = false;
                this._xNiceBuckets = false;
                this._xUsePercent = false;
                this._yBinCount = 9;
                this._yForceCategory = false;
                this._yNiceBuckets = false;
                this._yUsePercent = false;

                var stat = vp.stats.statBin2d();

                this.layerType("histogram2d").stat(stat).defaultStackType("stack").chartName("Histogram2d");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];

                //this._xDefaults.isDiscrete = true;
                this._xDefaults.percentGap = 0;
                this._xDefaults.combineDups = true;
                this._xDefaults.addMaxHeadroom = false;
                this._xDefaults.useNiceNumbers = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["x"];

                //this._yDefaults.isDiscrete = true;
                this._yDefaults.percentGap = 0;
                this._yDefaults.combineDups = true;
                this._yDefaults.addMaxHeadroom = false;
                this._yDefaults.useNiceNumbers = false;

                //---- set up attributes for a histogram2d (fill color is mapped to the total counts for each bin ----
                //---- use a WHITE TO DARK RED color palette ----
                var palette = [vp.color.colors.white, vp.color.colors.darkred];
                this.fill({ colName: "value", palette: palette });
            }
            histogram2dClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.gridLinesOnTop = true;

                var xIsCategory = this._stat.xIsCategory();
                var yIsCategory = this._stat.yIsCategory();

                this._xDefaults.isDiscrete = xIsCategory;
                this._yDefaults.isDiscrete = yIsCategory;

                this._xDefaults.breaks = undefined;
                this._yDefaults.breaks = undefined;

                this._xDefaults.dataOverride = undefined;
                this._yDefaults.dataOverride = undefined;

                var data = this.data();
                if (data) {
                    //----- set up X LABELS ----
                    if (xIsCategory) {
                        //---- data for CATEGORY labels ----
                        var data = this.data();
                        var bins = data.xResult.data;
                        var xColName = this.xBeforeStat().value;
                        var categories = vp.data.dataSelect(bins, xColName);

                        this._xDefaults.dataOverride = categories;
                    } else {
                        //---- breaks for NUMERIC labels ----
                        this._xDefaults.breaks = this.buildBreaks(data.xResult);
                        this._xAttr.onBreaksChanged();
                    }

                    //----- set up Y LABELS ----
                    if (yIsCategory) {
                        //---- data for CATEGORY labels ----
                        var data = this.data();
                        var bins = data.yResult.data;
                        var yColName = this.yBeforeStat().value;
                        var categories = vp.data.dataSelect(bins, yColName);

                        this._yDefaults.dataOverride = categories;
                    } else {
                        //---- breaks for NUMERIC labels ----
                        this._yDefaults.breaks = this.buildBreaks(data.yResult);
                        this._yAttr.onBreaksChanged();
                    }
                }

                this._xDefaults.intOnlyBreaks = (!this._xUsePercent);
                this._yDefaults.intOnlyBreaks = (!this._yUsePercent);
            };

            histogram2dClass.prototype.calcXScaleForLayer = function (descRecord) {
                var result = null;

                if (this._xDefaults.dataMin !== undefined) {
                    result = { min: this._xDefaults.dataMin, max: this._xDefaults.dataMax };
                }

                return result;
            };

            histogram2dClass.prototype.calcYScaleForLayer = function (descRecord) {
                var result = null;

                if (this._yDefaults.dataMin !== undefined) {
                    result = { min: this._yDefaults.dataMin, max: this._yDefaults.dataMax };
                }

                return result;
            };

            histogram2dClass.prototype.buildBreaks = function (results) {
                var bin = null;
                var breaks = [];

                if ((results) && (results.data)) {
                    var bins = results.data;

                    for (var i = 0; i < bins.length; i++) {
                        bin = bins[i];
                        breaks.push(bin.min);
                    }

                    //---- push last record.max ----
                    if (bin) {
                        breaks.push(bin.max);
                    }
                }

                return breaks;
            };

            histogram2dClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- HISTOGRAM ----
                //layer.info.drawBorder = true;
                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerHistogram2d", seriesIndex);

                var xAttrDefaults = this._x.layerDefaults;
                if (xAttrDefaults.dataOverride !== undefined) {
                    //---- get from category values ----
                    this._numCols = xAttrDefaults.dataOverride.length;
                } else {
                    //---- get from numeric breaks ----
                    this._numCols = xAttrDefaults.breaks.length - 1;
                }

                return _super.prototype.drawShapes.call(this, shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da);
            };

            histogram2dClass.prototype.onStatParamsChanged = function () {
                var stat = this.stat();

                if ((stat) && (stat.xBinParams)) {
                    stat.xBinParams(new vp.stats.binParams(this._xBinCount, this._xForceCategory, this._xUsePercent, this._xNiceBuckets));

                    stat.yBinParams(new vp.stats.binParams(this._yBinCount, this._yForceCategory, this._yUsePercent, this._yNiceBuckets));

                    this.onPlotDataChanged(true);
                }

                this.markRebuildNeeded();
            };

            //---- property: xBinCount ----
            histogram2dClass.prototype.xBinCount = function (value) {
                if (arguments.length == 0) {
                    return this._xBinCount;
                }

                this._xBinCount = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: yBinCount ----
            histogram2dClass.prototype.yBinCount = function (value) {
                if (arguments.length == 0) {
                    return this._yBinCount;
                }

                this._yBinCount = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: xForceCategory ----
            histogram2dClass.prototype.xForceCategory = function (value) {
                if (arguments.length == 0) {
                    return this._xForceCategory;
                }

                this._xForceCategory = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: yForceCategory ----
            histogram2dClass.prototype.yForceCategory = function (value) {
                if (arguments.length == 0) {
                    return this._yForceCategory;
                }

                this._yForceCategory = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: xUsePercent ----
            histogram2dClass.prototype.xUsePercent = function (value) {
                if (arguments.length == 0) {
                    return this._xUsePercent;
                }

                this._xUsePercent = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: yUsePercent ----
            histogram2dClass.prototype.yUsePercent = function (value) {
                if (arguments.length == 0) {
                    return this._yUsePercent;
                }

                this._yUsePercent = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: xNiceBuckets ----
            histogram2dClass.prototype.xNiceBuckets = function (value) {
                if (arguments.length == 0) {
                    return this._xNiceBuckets;
                }

                this._xNiceBuckets = value;
                this.onStatParamsChanged();

                return this;
            };

            //---- property: yNiceBuckets ----
            histogram2dClass.prototype.yNiceBuckets = function (value) {
                if (arguments.length == 0) {
                    return this._yNiceBuckets;
                }

                this._yNiceBuckets = value;
                this.onStatParamsChanged();

                return this;
            };
            return histogram2dClass;
        })(layers.tileSuperClass);
        layers.histogram2dClass = histogram2dClass;

        function createHistogram2d() {
            return new histogram2dClass();
        }
        layers.createHistogram2d = createHistogram2d;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=histogram2d.js.map

///----------------------------------------------------------------
/// (from layers\hLine.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// hLine.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates an hLine (set of horizontal lines) layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an hLine (set of horizontal lines) layer for a plot. */
        var hLineClass = (function (_super) {
            __extends(hLineClass, _super);
            //---- private state ----
            function hLineClass() {
                _super.call(this);

                this.layerType("hline").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("").newTagOrFunc("line");
            }
            hLineClass.prototype.adjustChartOptions = function () {
            };

            hLineClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- HLINE ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerHline", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(0, 1, function (uelem, dataItem, index, isNewShape) {
                    var xMin = xScale.rangeMin();
                    var xMax = xScale.rangeMax();

                    //---- "yintercept" is an alias for "y" ----
                    var yValue = yRecord.data[index];
                    var y = yScale.flipScale(yValue);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var elem = vp.select(uelem);

                    elem.from(xMin, y).to(xMax, y).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return hLineClass;
        })(layers.baseLayerClass);
        layers.hLineClass = hLineClass;

        function createHLine() {
            return new hLineClass();
        }
        layers.createHLine = createHLine;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=hLine.js.map

///----------------------------------------------------------------
/// (from layers\lineRange.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// lineRange.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a "line range" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a "line range" layer for a plot. */
        var lineRangeClass = (function (_super) {
            __extends(lineRangeClass, _super);
            //---- private state ----
            function lineRangeClass() {
                _super.call(this);

                this.layerType("lineRange").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("LineRange").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            lineRangeClass.prototype.adjustChartOptions = function () {
            };

            lineRangeClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this;

                var yMinCol = attributes._yMin.getAfterStatsPropName(0);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            lineRangeClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- LINE RANGE ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerLineRange", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var attributes = layer;

                    var record = filteredData[index];

                    var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                    var yMinValue = record[yMinCol];

                    var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);
                    var yMaxValue = record[yMaxCol];

                    var x = xScale.scale(xValue);
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    //---- high/low line ----
                    var elem = g.append("line").from(x, yMin).to(x, yMax).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return lineRangeClass;
        })(layers.baseLayerClass);
        layers.lineRangeClass = lineRangeClass;

        function createLineRange() {
            return new lineRangeClass();
        }
        layers.createLineRange = createLineRange;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=lineRange.js.map

///----------------------------------------------------------------
/// (from layers\openClose.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// openClose.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates an "open close" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an "open close" layer for a plot. */
        var openCloseClass = (function (_super) {
            __extends(openCloseClass, _super);
            //---- private state ----
            function openCloseClass() {
                _super.call(this);

                this.layerType("openClose").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("OpenClose").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            openCloseClass.prototype.adjustChartOptions = function () {
            };

            openCloseClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this;

                var yMinCol = attributes._yMin.getAfterStatsPropName(0);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            openCloseClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- OPEN CLOSE ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerOpenClose", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var attributes = layer;

                    var record = filteredData[index];

                    var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                    var yMinValue = record[yMinCol];

                    var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);
                    var yMaxValue = record[yMaxCol];

                    var yOpenCol = attributes._yOpen.getAfterStatsPropName(seriesIndex);
                    var yOpenValue = record[yOpenCol];

                    var yCloseCol = attributes._yClose.getAfterStatsPropName(seriesIndex);
                    var yCloseVal = record[yCloseCol];

                    var x = xScale.scale(xValue);
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);
                    var yOpen = yScale.flipScale(yOpenValue);
                    var yClose = yScale.flipScale(yCloseVal);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    //---- high/low line ----
                    var line1 = g.append("line").from(x, yMin).to(x, yMax).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line1, da);

                    var barSize2 = da.shapeSize;

                    //---- open line ----
                    var line2 = g.append("line").from(x - barSize2, yOpen).to(x, yOpen).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line2, da);

                    //---- close line ----
                    var line3 = g.append("line").from(x, yClose).to(x + barSize2, yClose).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line3, da);

                    if (isNewShape) {
                        layer.setElementInfo(line1, 1, seriesIndex);
                        layer.setElementInfo(line2, 1, seriesIndex);
                        layer.setElementInfo(line3, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return openCloseClass;
        })(layers.baseLayerClass);
        layers.openCloseClass = openCloseClass;

        function createOpenClose() {
            return new openCloseClass();
        }
        layers.createOpenClose = createOpenClose;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=openClose.js.map

///----------------------------------------------------------------
/// (from layers\path.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// path.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a path plot layer (a set of lines following a path) for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an area plot as a layer of a plot. */
        var pathClass = (function (_super) {
            __extends(pathClass, _super);
            //---- private state ----
            function pathClass() {
                _super.call(this);

                this.layerType("path").stat(vp.stats.statIdentity()).defaultStackType("stack").chartName("Path").newTagOrFunc("line");
            }
            pathClass.prototype.adjustChartOptions = function () {
                //options.xScaleOverride = "space";
                this._xDefaults.isDiscrete = false;
            };

            /// public drawShapes() - draw line plot.
            pathClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                return _super.prototype.drawShapes.call(this, shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da);
            };
            return pathClass;
        })(layers.lineSuperClass);
        layers.pathClass = pathClass;

        function createPath() {
            return new pathClass();
        }
        layers.createPath = createPath;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=path.js.map

///----------------------------------------------------------------
/// (from layers\pieSlice.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// pieSlice.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots a "pie chart" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** plots a "pie chart" layer for a plot. */
        var pieSliceClass = (function (_super) {
            __extends(pieSliceClass, _super);
            function pieSliceClass() {
                _super.call(this);
                //---- private state ----
                this._innerRadius = 0;
                this._spacingRadius = 0;
                this._outerMargin = 6;

                this._isSeriesLayer = true;

                this.layerType("pieSlice").stat(vp.stats.statIdentity()).defaultStackType("dodge").chartName("Pie").newTagOrFunc("path");
            }
            pieSliceClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.showXAxis = false;
                this._plotDefaults.showYAxis = false;
                this._plotDefaults.showXTitle = false;
                this._plotDefaults.showYTitle = false;

                this._plotDefaults.showXGridLines = false;
                this._plotDefaults.showYGridLines = false;
            };

            /// public drawShapes() - draw area plot.
            pieSliceClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var lastx = 0;
                var lasty = 0;
                var lastyZero = 0;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerPieSlice", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var left = xScale.rangeMin();
                var right = xScale.rangeMax();
                var top = yScale.rangeMin();
                var bottom = yScale.rangeMax();

                var margin = this._outerMargin;
                var rotation = 0;
                var xCenter = (left + right) / 2;
                var yCenter = (top + bottom) / 2;

                var seriesCount = layInfo.seriesCount;
                var finalRadius = Math.min(right - left, bottom - top) / 2;
                finalRadius -= margin;

                var availRadius = Math.max(0, finalRadius - this._innerRadius);
                var eachRadius = availRadius / seriesCount;
                var myRadius = (seriesCount > 1) ? Math.max(0, eachRadius - this._spacingRadius) : eachRadius;

                var innerRadius = this._innerRadius + seriesIndex * eachRadius;
                var outerRadius = innerRadius + myRadius;

                var seriesSum = 0;
                for (var i = 0; i < yRecord.data.length; i++) {
                    //---- use excel model and treat all slice values as a positive number ----
                    seriesSum += Math.abs(yRecord.data[i]);
                }

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    //---- use excel model and treat all slice values as a positive number ----
                    var dataValue = Math.abs(yRecord.data[index]);

                    var elem = vp.select(uelem);

                    var angle = 360 * (dataValue / seriesSum);

                    var path = vp.paths.getPieSlicePath(xCenter, yCenter, innerRadius, outerRadius, angle, rotation);
                    elem.attr("d", path);

                    //if (pi.stackType == "stack")
                    //{
                    //    var adjValue = dataValue + pi.itemAccums[index];
                    //    //---- starts at dataValue, offset by previous..  height doesn't change ----
                    //    y = yScale.flipScale(adjValue);
                    //    yZero = yScale.flipScale(pi.itemAccums[index]);
                    //    pi.itemAccums[index] = adjValue;
                    //}
                    //---- apply LAYOUT attributes ----
                    elem.customAttr("updateVisualHint", "fill");

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }

                    rotation += angle;
                });

                return shapes;
            };

            /** the radius of the center hole in the pie slice. */
            pieSliceClass.prototype.innerRadius = function (value) {
                if (arguments.length == 0) {
                    return this._innerRadius;
                }

                this._innerRadius = value;

                return this;
            };

            /** the space between rings, for multiple series */
            pieSliceClass.prototype.spacingRadius = function (value) {
                if (arguments.length == 0) {
                    return this._spacingRadius;
                }

                this._spacingRadius = value;

                return this;
            };

            /** the space between rings, for multiple series */
            pieSliceClass.prototype.outerMargin = function (value) {
                if (arguments.length == 0) {
                    return this._outerMargin;
                }

                this._outerMargin = value;

                return this;
            };
            return pieSliceClass;
        })(layers.baseLayerClass);
        layers.pieSliceClass = pieSliceClass;

        function createPieSlice() {
            return new pieSliceClass();
        }
        layers.createPieSlice = createPieSlice;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=pieSlice.js.map

///----------------------------------------------------------------
/// (from layers\plotDefaults.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// plotDefaults.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - a structure to hold system-defined default values for the plot object.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (layers) {
        /** default settings for the plot object (set internally).  User settings take precedence over these values.  */
        var plotDefaults = (function () {
            function plotDefaults() {
                this.shapesEnterFromBottom = false;
                this.showLegend = true;
                this.gridLinesOnTop = false;
                this.showXAxis = true;
                this.showYAxis = true;
                this.showXTitle = true;
                this.showYTitle = true;
                this.showXGridLines = true;
                this.showYGridLines = true;
            }
            return plotDefaults;
        })();
        layers.plotDefaults = plotDefaults;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=plotDefaults.js.map

///----------------------------------------------------------------
/// (from layers\point.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// point.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a "scatter plot" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a "scatter plot" layer for a plot. */
        var pointClass = (function (_super) {
            __extends(pointClass, _super);
            function pointClass() {
                _super.call(this);
                //---- private state ----
                this._da = null;

                this.layerType("point").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("Scatter").newTagOrFunc(vp.utils.cb(this, this.createElem));

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];
                this._xDefaults.zeroAxis = false;
                this._xDefaults.combineDups = true;
                this._xDefaults.addMaxHeadroom = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["y"];
                this._yDefaults.zeroAxis = false;
                this._yDefaults.combineDups = true;
                this._yDefaults.addMaxHeadroom = false;
            }
            pointClass.prototype.createElem = function (dataRecord, index, seriesIndex, filteredData) {
                //da = vp.session.currentTheme().getDrawingAttributes("layerPoint", seriesIndex);
                var da = this._da;

                //---- update drawing attributes for this itemIndex ----
                this.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                //var shapeType = layer.getItemShape(seriesIndex, index, filteredData);
                var shapeType = da.shapeType;

                var elem = this.elementFromShapeType(shapeType);

                /// note: for path shapes, we generate data to fit desired bounds.  We avoid the
                /// alternate method of applying a transform because it conflicts with animation
                /// transforms and it scales the line width (which we don't want).
                return elem;
            };

            pointClass.prototype.elementFromShapeType = function (shapeType) {
                var elem = null;
                var shapeName = null;
                var pathData = null;

                if (vp.utils.isNumber(shapeType)) {
                    if (shapeType == 0 /* circle */) {
                        shapeName = "circle";
                    } else if (shapeType == 4 /* square */) {
                        shapeName = "rect";
                    } else {
                        //---- path ----
                        shapeName = "path";
                    }
                } else {
                    elem = shapeName = "text";
                }

                elem = vp.dom.createSvg(shapeName);
                elem.shapeType = shapeType;

                return elem;
            };

            pointClass.prototype.adjustChartOptions = function () {
            };

            pointClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                //--- POINT ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- is scale one of the category types? ----
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                //---- should scale use DATA or INDEX? ----
                var xUsesIndex = (xScale.scaleType() == 3 /* category */);
                var yUsesIndex = (yScale.scaleType() == 3 /* category */);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerPoint", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);
                this._da = da;

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var xValue = (xUsesIndex) ? (index) : xRecord.data[index];
                    var yValue = (yUsesIndex) ? (index + 1) : yRecord.data[index];

                    //var xValue = xRecord.data[index];
                    //var yValue = yRecord.data[index];
                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);

                    //var seriesAxis = this._seriesAxis;
                    if (xIsCategoryScale) {
                        //---- center shape on width of X band ----
                        x += xScale.itemWidth() / 2;
                    }

                    if (yIsCategoryScale) {
                        //---- center shape on height of Y band ----
                        y += yScale.itemWidth() / 2;
                    }

                    //---- see if the primary layer wants to override our x, y ----
                    var primaryLayer = _this.getPrimaryLayer(plot);
                    if (primaryLayer && primaryLayer != _this) {
                        if (primaryLayer.getYValues) {
                            var yyy = primaryLayer.getYValues(yValue, pi, index, xScale, yScale, seriesIndex);
                            y = yyy.y;
                            var h = yyy.h;

                            if (yValue < 0) {
                                //---- bottom of column ----
                                y = y + h;
                            } else {
                                //---- top of column ----
                            }

                            if (yyy.x !== undefined) {
                                x = yyy.x;
                                var w = yyy.w;

                                x = x + w / 2;
                            }
                        } else if (primaryLayer.getXValues) {
                            var xxx = primaryLayer.getXValues(pi, xValue, yValue, index, seriesIndex, xScale, yScale);

                            x = xxx.x;
                            w = xxx.w;

                            if (xValue < 0) {
                                //---- left of bar ----
                                x = x;
                            } else {
                                //---- right of bar ----
                                x = x + w;
                            }

                            if (xxx.y !== undefined) {
                                y = xxx.y;
                                h = xxx.h;

                                y = y + h / 2;
                            }
                        } else if (primaryLayer.getStackedLineY) {
                            var lineY = _this.getStackedLineY(index, yRecord, yScale, pi);

                            y = +lineY.y;
                            h = +lineY.h;

                            w = Math.max(.25, xScale.itemWidth());
                            var xLeft = _this.getLineX(index, xRecord, xScale, xIsCategoryScale);
                            x = xLeft;
                        }
                    }

                    _this.setShapeElemAttrs(uelem, da, x, y);

                    var isFilled = false;
                    var isStroked = true;

                    isStroked = (da.stroke != "transparent");
                    isFilled = (da.fill != "transparent");

                    if ((isStroked) && (isFilled)) {
                        elem.customAttr("updateVisualHint", "fill");
                    } else if (isStroked) {
                        elem.customAttr("updateVisualHint", "stroke");
                    } else {
                        elem.customAttr("updateVisualHint", "fill");
                    }

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };

            pointClass.prototype.setShapeElemAttrs = function (uelem, da, x, y) {
                var shapeType = uelem.shapeType;
                var elem = vp.select(uelem);

                var itemSize = da.shapeSize;
                var itemSize2 = itemSize / 2;

                //---- handle all circle-based shapes ----
                if (shapeType == 0 /* circle */) {
                    elem.attr("cx", x).attr("cy", y).attr("r", itemSize / 2);
                } else if (vp.utils.isString(shapeType)) {
                    //---- text ----
                    elem.attr("x", x - itemSize2 + 2).attr("y", y + itemSize2 - 1).text(shapeType).attr("font-size", itemSize);
                } else if (uelem.tagName == "path") {
                    var pathData = vp.paths.getPathDataForShape(shapeType, x, y, da.shapeSize, itemSize);
                    vp.dom.attr(uelem, "d", pathData);
                } else {
                    //---- square ----
                    elem.bounds(x - itemSize2, y - itemSize2, itemSize, itemSize);
                }
            };
            return pointClass;
        })(layers.baseLayerClass);
        layers.pointClass = pointClass;

        function createPoint() {
            return new pointClass();
        }
        layers.createPoint = createPoint;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=point.js.map

///----------------------------------------------------------------
/// (from layers\pointRange.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// pointRange.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a "point range" layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a "point range" layer for a plot. */
        var pointRangeClass = (function (_super) {
            __extends(pointRangeClass, _super);
            //---- private state ----
            function pointRangeClass() {
                _super.call(this);

                this.layerType("pointRange").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("PointRange").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            pointRangeClass.prototype.adjustChartOptions = function () {
            };

            pointRangeClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- POINT RANGE ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerPointRange", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var yValue = (yIsCategoryScale) ? (index) : yRecord.data[index];
                    var attributes = layer;

                    var record = filteredData[index];

                    var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                    var yMinValue = record[yMinCol];

                    var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);
                    var yMaxValue = record[yMaxCol];

                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    //---- high/low line ----
                    var line = g.append("line").from(x, yMin).to(x, yMax).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line, da);

                    //---- circle ----
                    var circle = g.append("circle").attr("cx", x).attr("cy", y).attr("r", da.shapeSize / 2).customAttr("updateVisualHint", "stroke");

                    layer.applyShapeAttributes(circle, da);

                    if (isNewShape) {
                        layer.setElementInfo(line, 1, seriesIndex);
                        layer.setElementInfo(circle, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return pointRangeClass;
        })(layers.baseLayerClass);
        layers.pointRangeClass = pointRangeClass;

        function createPointRange() {
            return new pointRangeClass();
        }
        layers.createPointRange = createPointRange;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=pointRange.js.map

///----------------------------------------------------------------
/// (from layers\polygon.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// polygon.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a polygon layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a polygon layer for a plot. */
        var polygonClass = (function (_super) {
            __extends(polygonClass, _super);
            //---- private state ----
            function polygonClass() {
                _super.call(this);

                this.layerType("area").stat(vp.stats.statIdentity()).defaultStackType("stack").chartName("Area").newTagOrFunc("polygon");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];
                this._xDefaults.isDiscrete = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["y"];
                this._yDefaults.isDiscrete = false;
            }
            polygonClass.prototype.adjustChartOptions = function () {
                this._xDefaults.isDiscrete = false;
            };

            polygonClass.prototype.addPoint = function (str, x, y) {
                str += x + "," + y + " ";
                return str;
            };

            /// public drawShapes() - draw polygon plot.
            polygonClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var lastx = 0;
                var lasty = 0;
                var lastyZero = 0;
                var pts = "";
                var fillRule = layer.fillRule();

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerPolygon", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var xValue = xRecord.data[index];
                    var yValue = yRecord.data[index];
                    var elem = vp.select(uelem);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);

                    pts = _this.addPoint(pts, x, y);

                    var lastPt = (index == filteredData.length - 1);
                    if (lastPt) {
                        //---- apply LAYOUT attributes ----
                        elem.attr("points", pts);

                        elem.customAttr("updateVisualHint", "both");

                        layer.applyShapeAttributes(elem, da);

                        if (isNewShape) {
                            layer.setElementInfo(elem, 1, seriesIndex);
                        }
                    }
                });

                return shapes;
            };
            return polygonClass;
        })(layers.baseLayerClass);
        layers.polygonClass = polygonClass;

        function createPolygon() {
            return new polygonClass();
        }
        layers.createPolygon = createPolygon;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=polygon.js.map

///----------------------------------------------------------------
/// (from layers\ribbon.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// ribbon.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a ribbon layer of a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an area plot as a layer of a plot. */
        var ribbonClass = (function (_super) {
            __extends(ribbonClass, _super);
            //---- private state ----
            function ribbonClass() {
                _super.call(this);

                this.layerType("ribbon").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("Ribbon").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            ribbonClass.prototype.adjustChartOptions = function () {
            };

            ribbonClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this;

                var yMinCol = attributes._yMin.getAfterStatsPropName(0);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            ribbonClass.prototype.addPoint = function (str, x, y) {
                str += x + "," + y + " ";
                return str;
            };

            ribbonClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                //--- RIBBON ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                var lastx = 0;
                var lastyMin = 0;
                var lastyMax = 0;
                var firstUpdateCall = true;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                var dax = (da) ? da : vp.session.currentTheme().getDrawingAttributes("layerRibbon", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(dax, seriesIndex, filteredData);

                var attributes = layer;
                var yMinCol = attributes._yMin.getAfterStatsPropName(seriesIndex);
                var yMaxCol = attributes._yMax.getAfterStatsPropName(seriesIndex);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var g = vp.select(uelem);
                    g.clear();

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(dax, seriesIndex, index, filteredData);

                    var itemOpacity = layer.getItemOpacity(seriesIndex, index, filteredData, dax.opacity);

                    var record = filteredData[index];

                    //---- NOTE: ribbon only supports "dodge" stackType ----
                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var x = xScale.scale(xValue);
                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    var yMinValue = record[yMinCol];
                    var yMaxValue = record[yMaxCol];
                    var yMin = yScale.flipScale(yMinValue);
                    var yMax = yScale.flipScale(yMaxValue);

                    if (index == 0) {
                        lastx = x;
                        lastyMin = yMin;
                        lastyMax = yMax;
                    } else if (firstUpdateCall) {
                        //---- we are adding a new data point - get last values from the data ----
                        var lastxValue = (xIsCategoryScale) ? (index - 1) : xRecord.data[index - 1];

                        lastx = xScale.scale(lastxValue);
                        if (xIsCategoryScale) {
                            lastx += xScale.itemWidth() / 2;
                        }

                        var lastRecord = filteredData[index - 1];

                        var lastyMinValue = lastRecord[yMinCol];
                        var lastyMaxValue = lastRecord[yMaxCol];

                        lastyMin = yScale.flipScale(lastyMinValue);
                        lastyMax = yScale.flipScale(lastyMaxValue);
                    }

                    firstUpdateCall = false;

                    //---- build string of points ----
                    var points = "";
                    points = _this.addPoint(points, lastx, lastyMin);
                    points = _this.addPoint(points, lastx, lastyMax);
                    points = _this.addPoint(points, x, yMax);
                    points = _this.addPoint(points, x, yMin);

                    //---- ribbon polygon ----
                    var elem = g.append("polygon").attr("points", points).customAttr("updateVisualHint", "fill");

                    layer.applyShapeAttributes(elem, dax);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }

                    lastx = x;
                    lastyMin = yMin;
                    lastyMax = yMax;
                });

                return shapes;
            };
            return ribbonClass;
        })(layers.baseLayerClass);
        layers.ribbonClass = ribbonClass;

        function createRibbon() {
            return new ribbonClass();
        }
        layers.createRibbon = createRibbon;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=ribbon.js.map

///----------------------------------------------------------------
/// (from layers\segment.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// segment.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a segment layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a set of lines as a layer of a plot. */
        var segmentClass = (function (_super) {
            __extends(segmentClass, _super);
            //---- private state ----
            function segmentClass() {
                _super.call(this);

                this.layerType("segment").stat(vp.stats.statIdentity()).defaultStackType("stack").chartName("Segment").newTagOrFunc("line");
            }
            segmentClass.prototype.calcXScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this;

                var xMinCol = attributes._x.getAfterStatsPropName(0);
                var xMaxCol = attributes._xEnd.getAfterStatsPropName(0);

                var xMin = data.min(function (data) {
                    return data[xMinCol];
                });
                var xMax = data.max(function (data) {
                    return data[xMaxCol];
                });

                return { min: xMin, max: xMax };
            };

            segmentClass.prototype.calcYScaleForLayer = function (descRecord) {
                var data = this.info.filteredData;
                var attributes = this.attributes();

                var yMinCol = attributes._y.getAfterStatsPropName(0);
                var yMaxCol = attributes._yEnd.getAfterStatsPropName(0);

                var yMin = data.min(function (data) {
                    return data[yMinCol];
                });
                var yMax = data.max(function (data) {
                    return data[yMaxCol];
                });

                return { min: yMin, max: yMax };
            };

            segmentClass.prototype.adjustChartOptions = function () {
            };

            /// public drawShapes() - draw LAYER SEGMENT.
            segmentClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var lastx = 0;
                var lasty = 0;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerSegment", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var attributes = layer.attributes();

                    //var itemOpacity = layer.getItemOpacity(seriesIndex, index, filteredData);
                    var xEndCol = attributes._xEnd.getAfterStatsPropName(seriesIndex);
                    var yEndCol = attributes._yEnd.getAfterStatsPropName(seriesIndex);

                    var xValue = xRecord.data[index];
                    var yValue = yRecord.data[index];

                    var xEndValue = filteredData[index][xEndCol];
                    var yEndValue = filteredData[index][yEndCol];

                    var x = xScale.scale(xValue);
                    var xEnd = xScale.scale(xEndValue);
                    var y = yScale.flipScale(yValue);
                    var yEnd = yScale.flipScale(yEndValue);

                    //---- apply LAYOUT attributes ----
                    elem.from(x, y).to(xEnd, yEnd);

                    //---- apply BASIC attributes ----
                    elem.customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return segmentClass;
        })(layers.baseLayerClass);
        layers.segmentClass = segmentClass;

        function createSegment() {
            return new segmentClass();
        }
        layers.createSegment = createSegment;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=segment.js.map

///----------------------------------------------------------------
/// (from layers\spaceFill.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// spaceFill.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - create a space filling layer to draw treemaps and other space filling plots.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** create a space filling layer to draw treemaps and other space filling plots. */
        var spaceFillClass = (function (_super) {
            __extends(spaceFillClass, _super);
            //---- private state ----
            function spaceFillClass() {
                _super.call(this);

                this.layerType("spaceFill").stat(vp.stats.statSpaceFill()).defaultStackType("stack").chartName("SpaceFill").newTagOrFunc("rect");
            }
            spaceFillClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.showXAxis = false;
                this._plotDefaults.showYAxis = false;
                this._plotDefaults.showYTitle = false;
                this._plotDefaults.showXGridLines = false;
                this._plotDefaults.showYGridLines = false;
            };

            /// public drawShapes() - layout and draw space fill rectangles.
            spaceFillClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerSpaceFill", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- for SPACEFILL LAYER: we don't use x/y scales; we layout directly in pixel space ----
                var xMin = xScale.rangeMin();
                var xMax = xScale.rangeMax();

                var yMin = yScale.rangeMin();
                var yMax = yScale.rangeMax();

                var xRange = xMax - xMin;
                var yRange = yMax - yMin;

                //var rects = computeRects(xRecord.data, bounds, da, filteredData);
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var elem = vp.select(uelem);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    //---- get layout of element in unit bounds ----
                    var ub = filteredData[index]._bounds;

                    //---- scale to screen bounds ----
                    var x = xMin + ub.left * xRange;
                    var y = yMin + ub.top * yRange;
                    var w = xMin + ub.width * xRange;
                    var h = yMin + ub.height * yRange;

                    //---- layout elem ----
                    elem.attr("x", x).attr("y", y).attr("width", w).attr("height", h).customAttr("updateVisualHint", "fill");

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };

            //---- property: startLoc ----
            spaceFillClass.prototype.startLoc = function (value) {
                var stat = this.stat();

                if (arguments.length == 0) {
                    return stat.startLoc();
                }

                stat.startLoc(value);
                return this;
            };

            //---- property: chunking ----
            spaceFillClass.prototype.chunking = function (value) {
                var stat = this.stat();

                if (arguments.length == 0) {
                    return stat.chunking();
                }

                stat.chunking(value);
                return this;
            };

            //---- property: phrasing ----
            spaceFillClass.prototype.phrasing = function (value) {
                var stat = this.stat();

                if (arguments.length == 0) {
                    return stat.phrasing();
                }

                stat.phrasing(value);
                return this;
            };
            return spaceFillClass;
        })(layers.baseLayerClass);
        layers.spaceFillClass = spaceFillClass;

        function createSpaceFill() {
            return new spaceFillClass();
        }
        layers.createSpaceFill = createSpaceFill;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=spaceFill.js.map

///----------------------------------------------------------------
/// (from layers\stem.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// stem.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a stem layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a stem layer for a plot. */
        var stemClass = (function (_super) {
            __extends(stemClass, _super);
            //---- private state ----
            function stemClass() {
                _super.call(this);

                this.layerType("stem").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("Stem").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            stemClass.prototype.adjustChartOptions = function () {
            };

            stemClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- STEM ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerStem", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var yValue = (yIsCategoryScale) ? (index) : yRecord.data[index];
                    var attributes = layer.attributes();

                    var record = filteredData[index];

                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);
                    var yZero = yScale.flipScale(0);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    //---- line from zero to Y ----
                    var line = g.append("line").from(x, yZero).to(x, y).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line, da);

                    //---- circle ----
                    var circle = g.append("circle").attr("cx", x).attr("cy", y).attr("r", da.shapeSize / 2).customAttr("updateVisualHint", "stroke");

                    layer.applyShapeAttributes(circle, da);

                    if (isNewShape) {
                        layer.setElementInfo(line, 1, seriesIndex);
                        layer.setElementInfo(circle, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return stemClass;
        })(layers.baseLayerClass);
        layers.stemClass = stemClass;

        function createStem() {
            return new stemClass();
        }
        layers.createStem = createStem;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=stem.js.map

///----------------------------------------------------------------
/// (from layers\step.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// step.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a step layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an area plot as a layer of a plot. */
        var stepClass = (function (_super) {
            __extends(stepClass, _super);
            //---- private state ----
            function stepClass() {
                _super.call(this);

                this.layerType("step").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("Step").newTagOrFunc("g");

                //---- defaults for X axis ----
                this._xDefaults.isDiscrete = true;
            }
            stepClass.prototype.adjustChartOptionsfunction = function () {
            };

            stepClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //--- STEP ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                var lastx = 0;
                var lasty = 0;

                //---- get stair direction ("vh" or "hv") ----
                var direction = layer.attributes()._direction;
                direction = (direction === undefined) ? "vh" : direction;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerStep", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var g = vp.select(uelem).clear();

                    //.attr("opacity", itemOpacity)
                    var xValue = (xIsCategoryScale) ? (index) : xRecord.data[index];
                    var yValue = yRecord.data[index];

                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);

                    if (xIsCategoryScale) {
                        x += xScale.itemWidth() / 2;
                    }

                    if (index == 0) {
                        lastx = x;
                        lasty = y;
                    }

                    var line1 = null;
                    var line2 = null;

                    if (direction == "vh") {
                        //---- step vertical ----
                        line1 = g.append("line").from(lastx, lasty).to(lastx, y);

                        //---- step horizontal ----
                        line2 = g.append("line").from(lastx, y).to(x, y);
                    } else {
                        //---- step horizontal ----
                        line1 = g.append("line").from(lastx, lasty).to(x, lasty);

                        //---- step vertical ----
                        line2 = g.append("line").from(x, lasty).to(x, y);
                    }

                    line1.customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line1, da);

                    line2.customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(line2, da);

                    if (isNewShape) {
                        layer.setElementInfo(line1, 1, seriesIndex);
                        layer.setElementInfo(line2, 1, seriesIndex);
                    }

                    lastx = x;
                    lasty = y;
                });

                return shapes;
            };
            return stepClass;
        })(layers.baseLayerClass);
        layers.stepClass = stepClass;

        function createStep() {
            return new stepClass();
        }
        layers.createStep = createStep;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=step.js.map

///----------------------------------------------------------------
/// (from layers\streamGraph.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// streamGraph.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a stream plot layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a stream plot layer for a plot. */
        var streamGraphClass = (function (_super) {
            __extends(streamGraphClass, _super);
            function streamGraphClass() {
                _super.call(this);
                //---- private state ----
                this._useSmoothing = false;
                this._lastTopSegments = null;

                this.layerType("streamGraph").stat(vp.stats.statIdentity()).defaultStackType("stack").chartName("Area").newTagOrFunc("polygon");

                //---- defaults for X scale/axis ----
                //this._xDefaults.scaleDefault("date")
                this._xDefaults.isDiscrete = true; // doesn't draw correctly unless X values are evenly spaced
                this._xDefaults.dateFormat = "string";

                this._xDefaults.colNames = ["x"];
                this._xDefaults.zeroAxis = false;
                this._xDefaults.addMaxHeadroom = false;

                //---- defaults for Y scale/axis ----
                this._xDefaults.isDiscrete = false;
                this._xDefaults.colNames = ["y"];

                this._plotDefaults.showYAxis = false;
                this._plotDefaults.showYGridLines = false;
            }
            streamGraphClass.prototype.adjustChartOptions = function () {
            };

            streamGraphClass.prototype.addPoint = function (str, x, y) {
                str += x + "," + y + " ";
                return str;
            };

            streamGraphClass.prototype.addPoints = function (str, pts, reverseOrder) {
                if (pts) {
                    if (reverseOrder) {
                        for (var i = pts.length - 1; i >= 0; i--) {
                            var pt = pts[i];
                            str += pt.x + "," + pt.y + " ";
                        }
                    } else {
                        for (var i = 0; i < pts.length; i++) {
                            var pt = pts[i];
                            str += pt.x + "," + pt.y + " ";
                        }
                    }
                }

                return str;
            };

            /// public drawShapes() - draw streamPlot.
            /// series are drawn from top to bottom.
            streamGraphClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                var shapes = null;
                var vvPlot = layer.vvParent();
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;
                var lastx = 0;
                var lasty = 0;
                var lastyZero = 0;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerStreamGraph", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                //---- remember the x and y values that we generate for later interpolation ----
                var xa = [];
                var ya = [];
                var yz = [];

                //---- generate shapes for each data record (with current series) ----
                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var xDataValue = xRecord.data[index];
                    var yDataValue = yRecord.data[index];
                    var elem = vp.select(uelem);

                    //var xLeft = xScale.scale(index, -1);
                    //var w = Math.max(.25, xScale.itemWidth());
                    //var x = xLeft + w / 2;
                    var x = xScale.scale(xDataValue);

                    var y = yScale.flipScale(yDataValue);
                    var yZero = yScale.flipScale(0);
                    var h = Math.max(0, yScale.scaleSize(yDataValue));

                    var plotHeight = layInfo.height;
                    var halfHeight = plotHeight / 2;

                    //---- we use "yBaseLine" to center stack of polygons at each point ----
                    var yBaseLine = halfHeight - yScale.scaleSize(pi.itemTotals[index]) / 2;

                    if (true) {
                        var adjValue = yDataValue + pi.itemAccums[index];

                        //---- starts at yDataValue, offset by previous..  height doesn't change ----
                        y = -yBaseLine + yScale.flipScale(adjValue);
                        yZero = -yBaseLine + yScale.flipScale(pi.itemAccums[index]);

                        pi.itemAccums[index] = adjValue;
                    }

                    xa[index] = x;
                    ya[index] = y;
                    yz[index] = yZero;

                    if (index == 0) {
                        lastx = x;
                        lasty = y;
                        lastyZero = yZero;
                    }

                    //---- build string of points ----
                    var points = "";
                    points = _this.addPoint(points, lastx, lastyZero);
                    points = _this.addPoint(points, lastx, lasty);
                    points = _this.addPoint(points, x, y);
                    points = _this.addPoint(points, x, yZero);

                    //---- apply LAYOUT attributes ----
                    elem.attr("points", points).customAttr("updateVisualHint", "fill");

                    layer.applyShapeAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }

                    lastx = x;
                    lasty = y;
                    lastyZero = yZero;
                });

                if (this._useSmoothing) {
                    //---- test ----
                    var testPts = [
                        { x: 20, y: 10 }, { x: 20.1, y: 12 }, { x: 20.5, y: 14 },
                        { x: 21, y: 16 }, { x: 24, y: 18 }, { x: 24.2, y: 20 }, { x: 26, y: 22 }];
                    var result = this.computeYByCol(testPts);

                    //---- smooth bottom and top of each rectangle ----
                    lastx = 0;
                    lasty = 0;
                    lastyZero = 0;

                    //---- calc the TOP interpolated points for this rect ----
                    var topSegments = vp.curveFitting.spline(xa, ya);

                    //---- calc the BOTTOM interpolated points for this rect ----
                    var bottomSegments = (seriesIndex) ? this._lastTopSegments : vp.curveFitting.spline(xa, yz);

                    for (var i = 0; i < shapes.length; i++) {
                        var x = xa[i];
                        var y = ya[i];
                        var yZero = yz[i];

                        if ((y == yZero) && (lasty == lastyZero)) {
                            //---- ensure that we never draw a curve shape for zero height area ----
                            var shape = shapes[i];
                            vp.dom.attr(shape, "points", "");

                            //---- shift up the segment from the bottom line for next series ----
                            topSegments[i - 1] = bottomSegments[i - 1];
                        } else {
                            //---- skip the first shape (0-width) ----
                            if (i > 0) {
                                //---- ensure bottom line doesn't cross above top line ----
                                var topSegment = topSegments[i - 1];
                                var botSegment = bottomSegments[i - 1];

                                var crossing = false;

                                if (!crossing) {
                                    var shape = shapes[i];
                                    var points = "";

                                    //---- add the points that define the rect ----
                                    points = this.addPoint(points, lastx, lastyZero);
                                    points = this.addPoint(points, lastx, lasty);
                                    points = this.addPoints(points, topSegment, false);
                                    points = this.addPoint(points, x, y);
                                    points = this.addPoint(points, x, yZero);
                                    points = this.addPoints(points, botSegment, true);

                                    vp.dom.attr(shape, "points", points);
                                } else {
                                    bottomSegments[i] = null;
                                }
                            }
                        }

                        lastx = x;
                        lasty = y;
                        lastyZero = yZero;
                    }

                    this._lastTopSegments = topSegments;
                }

                return shapes;
            };

            //---- map ordered but arbitrary X/Y pairs to one x per pixel & corresponding y value ----
            streamGraphClass.prototype.computeYByCol = function (pts, fromCol, toCol) {
                var newPts = [];
                var curr = null;
                var last = null;
                var nextIndex = 0;
                curr = pts[nextIndex++];
                var col = fromCol;

                while (col <= toCol) {
                    //--- get y for "col" ---
                    if (Math.floor(curr.x) == col) {
                        var total = 0;
                        var count = 0;
                        var needOuterBreak = false;

                        while (Math.floor(curr.x) == col) {
                            total += curr.y;
                            count++;
                            last = curr;

                            if (nextIndex == pts.length) {
                                needOuterBreak = true;
                                break;
                            }

                            curr = pts[nextIndex++];
                        }

                        newPts.push({ x: col, y: total / count });
                        col++;

                        if (needOuterBreak) {
                            break;
                        }
                    } else if (Math.floor(curr.x) < col) {
                        //---- ran out of data - just use last ----
                        newPts.push({ x: col, y: last.y });
                        col++;
                    } else {
                        //---- must interpolate Y from last/curr ----
                        var m = (curr.y - last.y) / (curr.x - last.x);
                        var b = curr.y - m * curr.x;

                        var y = m * col + b;
                        newPts.push({ x: col, y: y });
                        col++;
                    }
                }

                return newPts;
            };

            streamGraphClass.prototype.checkForCrossing = function (topPoints, botPoints) {
                var isCrossing = ((!topPoints) || (!botPoints));
                if (!isCrossing) {
                    var fromCol = Math.floor(Math.min(topPoints[0].x, botPoints[0].x));
                    var toCol = Math.floor(Math.min(topPoints[topPoints.length - 1].x, botPoints[botPoints.length - 1].x));

                    var topByCol = this.computeYByCol(topPoints, fromCol, toCol);
                    var botByCol = this.computeYByCol(botPoints, fromCol, toCol);

                    if (topByCol.length != botByCol.length) {
                        vp.utils.error("internal error in streamGraph");
                    }

                    for (var i = 0; i < topByCol.length; i++) {
                        var top = topByCol[i];
                        var bot = botByCol[i];

                        if (bot.y < top.y) {
                            //---- we can only change the top data (since we are drawing each series from bottom to top), so, ----
                            //---- where top is too low, just use bottom ----
                            isCrossing = true;
                            top.y = bot.y;
                        }
                    }
                }

                if (isCrossing) {
                    //---- substitute the new bottom data ----
                    botPoints = botByCol;
                }

                return false;
            };

            //---- property: useSmoothing ----
            streamGraphClass.prototype.useSmoothing = function (value) {
                if (arguments.length == 0) {
                    return this._useSmoothing;
                }

                this._useSmoothing = value;

                return this;
            };
            return streamGraphClass;
        })(layers.baseLayerClass);
        layers.streamGraphClass = streamGraphClass;

        function createStreamGraph() {
            return new streamGraphClass();
        }
        layers.createStreamGraph = createStreamGraph;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=streamGraph.js.map

///----------------------------------------------------------------
/// (from layers\text.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// text.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots text strings at specified x/y locations as a plot layer.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** plots text strings at specified x/y locations as a plot layer. */
        var textClass = (function (_super) {
            __extends(textClass, _super);
            //---- private state ----
            function textClass() {
                _super.call(this);

                /** true, since we can be used in parallel with series-type layers. */
                this._isSeriesLayer = true;

                this.layerType("text").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("Text").newTagOrFunc("text");

                //---- defaults for X scale/axis ----
                this._xDefaults.colNames = ["x"];

                //this._xDefaults.isDiscrete = false;
                this._xDefaults.zeroAxis = false;
                this._xDefaults.combineDups = true;
                this._xDefaults.addMaxHeadroom = false;

                //---- defaults for Y scale/axis ----
                this._yDefaults.colNames = ["y"];

                //this._yDefaults.isDiscrete = false;
                this._yDefaults.zeroAxis = false;
                this._yDefaults.combineDups = true;
                this._yDefaults.addMaxHeadroom = false;
            }
            textClass.prototype.adjustChartOptions = function () {
            };

            textClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                //---- TEXT PLOT ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- is scale one of the category types? ----
                var xIsCategoryScale = (xScale.scaleType() != 0 /* linear */);
                var yIsCategoryScale = (yScale.scaleType() != 0 /* linear */);

                //---- should scale use DATA or INDEX? ----
                var xUsesIndex = (xScale.scaleType() == 3 /* category */);
                var yUsesIndex = (yScale.scaleType() == 3 /* category */);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerText");

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    var xValue = (xUsesIndex) ? (index) : xRecord.data[index];
                    var yValue = (yUsesIndex) ? (index + 1) : yRecord.data[index];

                    var elem = vp.select(uelem);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var x = xScale.scale(xValue);
                    var y = yScale.flipScale(yValue);
                    var hAdjust = undefined;
                    var vAdjust = undefined;

                    if (xIsCategoryScale) {
                        //---- center shape on width of X band ----
                        x += xScale.itemWidth() / 2;
                    }

                    if (yIsCategoryScale) {
                        //---- center shape on height of Y band ----
                        y += yScale.itemWidth() / 2;
                    }

                    var xMid = x;
                    var yMid = y;

                    //---- see if the primary layer wants to override our x, y ----
                    var primaryLayer = _this.getPrimaryLayer(plot);
                    if (primaryLayer && primaryLayer != _this) {
                        if (primaryLayer.getYValues) {
                            var yyy = primaryLayer.getYValues(yValue, pi, index, xScale, yScale, seriesIndex);
                            y = yyy.y;
                            var h = yyy.h;

                            vAdjust = { sign: 1, value: 0 };

                            if (yValue < 0) {
                                //---- bottom of column ----
                                yMid = y + h;
                                vAdjust.sign = -1;
                                vAdjust.value = 1.5;
                            } else {
                                //---- top of column ----
                                yMid = y;
                                vAdjust.value = -.5;
                            }

                            if (yyy.x !== undefined) {
                                x = yyy.x;
                                var w = yyy.w;

                                xMid = x + w / 2;
                            }
                        } else if (primaryLayer.getXValues) {
                            var xxx = primaryLayer.getXValues(pi, xValue, yValue, index, seriesIndex, xScale, yScale);

                            x = xxx.x;
                            w = xxx.w;
                            hAdjust = { sign: 1, value: 0 };
                            vAdjust = { sign: 1, value: .5 };

                            if (xValue < 0) {
                                //---- left of bar ----
                                xMid = x;
                                hAdjust.sign = -1;
                                hAdjust.value = -.4;
                            } else {
                                //---- right of bar ----
                                xMid = x + w;
                                hAdjust.value = 1.4;
                            }

                            if (xxx.y !== undefined) {
                                y = xxx.y;
                                h = xxx.h;

                                yMid = y + h / 2;
                            }
                        } else if (primaryLayer.getStackedLineY) {
                            var lineY = _this.getStackedLineY(index, yRecord, yScale, pi);
                            vAdjust = { sign: 1, value: 0 };

                            y = +lineY.y;
                            h = +lineY.h;
                            yMid = y;
                            vAdjust.value = 1;

                            w = Math.max(.25, xScale.itemWidth());
                            var xLeft = _this.getLineX(index, xRecord, xScale, xIsCategoryScale);
                            x = xLeft;
                            xMid = x;
                        }
                    }

                    if (layInfo.swapAxes) {
                        var t = xMid;
                        xMid = yMid;
                        yMid = t;
                    }

                    elem.attr("x", xMid).attr("y", yMid).attr("cursor", "default").customAttr("updateVisualHint", "fill");

                    layer.applyTextAttributes(elem, da, hAdjust, vAdjust);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return textClass;
        })(layers.baseLayerClass);
        layers.textClass = textClass;

        function createText() {
            return new textClass();
        }
        layers.createText = createText;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=text.js.map

///----------------------------------------------------------------
/// (from layers\treeMap.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// treeMap.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a treemap layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates a treemap layer for a plot. */
        var treeMapClass = (function (_super) {
            __extends(treeMapClass, _super);
            function treeMapClass() {
                _super.call(this);
                //---- private state ----
                this._rootCount = 0;
                this._leaveCount = 0;
                this._maxDepth = 0;
                this._nameColCount = 0;
                this._namesWithBlanks = 0;
                this._statsCallBack = null;
                this._colorAttribute = null;
                this._sizeCol = null;
                this._nodes = [];

                this.layerType("treemap").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("treemap").newTagOrFunc("null");

                //---- use a WHITE TO DARK RED color palette ----
                var palette = [vp.color.colors.white, vp.color.colors.darkred];

                this.fill({ palette: palette });
            }
            treeMapClass.prototype.adjustChartOptions = function () {
                this._plotDefaults.showXAxis = false;
                this._plotDefaults.showYAxis = false;
                this._plotDefaults.showLegend = false;
                this._plotDefaults.showXTitle = false;
                this._plotDefaults.showYTitle = false;

                this._plotDefaults.showXGridLines = false;
                this._plotDefaults.showYGridLines = false;
            };

            treeMapClass.prototype.toSysColor = function (cr) {
                var rgb = vp.color.getColorFromString(cr);
                var sysColor = vp.internal.System.Drawing.Color.FromArgb4(rgb[0], rgb[1], rgb[2]);

                return sysColor;
            };

            treeMapClass.prototype.getTreeStats = function () {
                return {
                    rootCount: this._rootCount, leaveCount: this._leaveCount, maxDepth: this._maxDepth,
                    nameColCount: this._nameColCount, namesWithBlanks: this._namesWithBlanks };
            };

            treeMapClass.prototype.statsCallBack = function (callback) {
                this._statsCallBack = callback;
            };

            /// watch out for rootNode which has no "SizeMetric" property.
            treeMapClass.prototype.addChildSizesToParent = function (parentNode, depth) {
                var kids = parentNode.Nodes.ToArray();
                var isRootNode = (parentNode.SizeMetric === undefined);

                var fillAttribute = this._fill;
                var isFillMapped = fillAttribute.isMapped();
                var colorScale = fillAttribute.scale();

                var isSizeMapped = (parentNode.sizeValue !== undefined);
                this._maxDepth = Math.max(this._maxDepth, depth);

                var selfSize = 0;
                if (!isRootNode) {
                    var defaultSize = (kids.length > 0) ? 0 : 100;
                    selfSize = (isSizeMapped) ? parentNode.sizeValue : defaultSize;

                    //---- don't allow negative sizes (flag as error in client/app) ----
                    if (selfSize < 0) {
                        selfSize = 0;
                    }
                }

                var selfColor = (isFillMapped) ? parentNode.colorValue : 0;
                var totalSize = selfSize;

                for (var k = 0; k < kids.length; k++) {
                    var kid = kids[k];
                    var kidSize = this.addChildSizesToParent(kid, depth + 1);

                    totalSize += kidSize;
                    //totalColor += result.color;
                }

                parentNode.Nodes.EmptySpace.SizeMetric = selfSize; // node's "self" size

                if (!isRootNode) {
                    parentNode.SizeMetric = totalSize; // self + child sizes

                    //---- build TOOLTIP ----
                    var str = parentNode.Text + ": size=" + totalSize;
                    if (true) {
                        str += ", color=" + selfColor;
                    }

                    parentNode.SetToolTip(str);

                    //---- set fill color ----
                    var cr = (isFillMapped) ? colorScale.scale(selfColor) : "white";

                    //var cr = colorScale.scale(selfColor);
                    parentNode.AbsoluteColor = this.toSysColor(cr);
                }

                return totalSize;
            };

            treeMapClass.prototype.makeNode = function (name, nodeSize, fill, record, daNode, daText, dataItem) {
                var node = new vp.internal.Microsoft.Treemap.Generator.Node(name, nodeSize, fill, record);

                node.PenWidthPx = 1;

                var textFill = daText.textFill;
                if (textFill) {
                    var sysColorText = this.toSysColor(textFill);
                    node.SetTextColor(sysColorText);
                }

                //node.colorValue = (record && this._colorAttribute.isMapped()) ? record[this._colorAttribute.colName()] : 0;
                node.colorValue = 0;

                if (record && this._colorAttribute.isMapped()) {
                    var colName = this._colorAttribute.colName();
                    node.colorValue = record[colName];
                }

                node.sizeValue = daNode.shapeSize; // (record) ? record[this._sizeCol] : 0;

                if (record) {
                    this._leaveCount++;
                }

                this._nodes.push({ node: node, dataItem: dataItem });

                return node;
            };

            treeMapClass.prototype.ensureNodeExists = function (parentNode, name, nodeSize, fill, record, daNode, daText, dataItem) {
                var node = null;

                //---- search parent ----
                var kids = parentNode.Nodes.ToArray();

                for (var k = 0; k < kids.length; k++) {
                    var kid = kids[k];
                    if (kid.Text == name) {
                        node = kid;
                        break;
                    }
                }

                if (!node) {
                    node = this.makeNode(name, nodeSize, fill, record, daNode, daText, dataItem);
                    parentNode.Nodes.Add(node);
                }

                return node;
            };

            treeMapClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                var _this = this;
                //---- clear stats ----
                this._rootCount = 0;
                this._leaveCount = 0;
                this._maxDepth = 0;
                this._nameColCount = 0;
                this._namesWithBlanks = 0;

                this._colorAttribute = this._fill;
                var lineSizeAttribute = this._lineSize;

                //---- set up SIZE for identity scaling ----
                if (lineSizeAttribute && lineSizeAttribute.isMapped()) {
                    lineSizeAttribute.isScalingEnabled(false);
                }

                //---- TREEMAP PLOT ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                var htmlRoot = layInfo.htmlShapesGroup;

                //---- make it visible (it is normally hidden) ----
                htmlRoot.css("display", "block");

                var w = htmlRoot.width();
                var h = htmlRoot.height();

                var generator = new vp.internal.Microsoft.Treemap.Generator.TreemapGenerator(htmlRoot);

                //---- get THEME drawing attributes for each of the parts we will draw ----
                var daNode = vp.session.currentTheme().getDrawingAttributes("layerTreemap");
                var daText = daNode;

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(daNode, seriesIndex, filteredData);
                layer.addConstantDrawingAttributes(daText, seriesIndex, filteredData);

                var rootNode = generator;
                var nodesByName = {};

                var lineColor = this.toSysColor(daNode.stroke);
                generator.BorderColor = lineColor;
                generator.PenWidthPx = 1; //daNode.lineSize;
                generator.IsAnimationEnabled = plot.isAnimEnabled();

                var fontSize = daText.textSize;
                if (fontSize.endsWith && fontSize.endsWith("pt")) {
                    fontSize = fontSize.substr(0, fontSize.length - 2);
                }
                generator.FontNormSizePt = +fontSize;
                generator.FontFamily = daText.fontFamily;
                generator.FontSolidColor = this.toSysColor(daText.stroke);

                var nameList = filteredData.nameList;
                if (nameList) {
                    this._nameColCount = nameList.length;
                }

                //---- TreeMap is different than other layers because we use code written by another group ----
                //---- and the creation of shapes is not under our direct control.  So, we need to explictly ----
                //---- gather nodes as they are created and, at the end, extract the HTML elements from them ----
                //---- and return them as "shapes". ----
                this._nodes = [];

                layer.dataAnimMgr().updateShapes(seriesIndex, layInfo.seriesCount, function (uelem, dataItem, index, isNewShape) {
                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(daNode, seriesIndex, index, filteredData);
                    layer.updateDrawingAttributes(daText, seriesIndex, index, filteredData);

                    var fontSize = daText.textSize;
                    if (fontSize.endsWith && fontSize.endsWith("pt")) {
                        fontSize = fontSize.substr(0, fontSize.length - 2);
                    }
                    generator.FontNormSizePt = +fontSize;
                    generator.FontFamily = daText.fontFamily;
                    generator.FontSolidColor = _this.toSysColor(daText.stroke);

                    var fill = _this.toSysColor(daNode.fill);
                    var nodeSize = +daNode.shapeSize;
                    var record = filteredData[index];

                    if (nameList) {
                        var parent = rootNode;

                        //---- find index of last valid (non-blank) name in this record ----
                        var lastValidIndex = nameList.length - 1;
                        while (lastValidIndex >= 0) {
                            var colName = nameList[lastValidIndex];
                            var value = record[colName];

                            if (value == "") {
                                lastValidIndex--;
                            } else {
                                break;
                            }
                        }

                        var foundOneOrMoreBlanks = (lastValidIndex < nameList.length - 1);

                        for (var n = 0; n <= lastValidIndex; n++) {
                            var colName = nameList[n];
                            var value = record[colName];

                            if (value != "") {
                                var rec = (n < lastValidIndex) ? null : record;
                                parent = _this.ensureNodeExists(parent, value, nodeSize, fill, rec, daNode, daText, dataItem);
                            } else {
                                foundOneOrMoreBlanks = true;
                            }
                        }

                        if (foundOneOrMoreBlanks) {
                            _this._namesWithBlanks++;
                        }
                    } else {
                        var id = xRecord.data[index];

                        //var parent = yRecord.data[index];
                        var node = _this.makeNode(id, nodeSize, fill, record, daNode, daText, dataItem);
                        nodesByName[id] = node;
                    }
                    // var elem = vp.select(uelem)
                    //elem
                    //    .attr("x", xMid)
                    //    .attr("y", yMid)
                    //    .attr("cursor", "default")
                    //    .customAttr("updateVisualHint", "fill")
                    //layer.applyTextAttributes(elem, da);
                    //if (isNewShape)
                    //{
                    //    layer.setElementInfo(elem, 1, seriesIndex);
                    //}
                });

                if (!nameList) {
                    for (var i = 0; i < filteredData.length; i++) {
                        var id = xRecord.data[i];
                        var parent = yRecord.data[i];

                        var childNode = nodesByName[id];
                        var parentNode = nodesByName[parent];

                        if (!parentNode) {
                            parentNode = rootNode;
                        }

                        parentNode.Nodes.Add(childNode);
                    }
                }

                this._rootCount = rootNode.Nodes.ToArray().length;

                //---- add all child values to each parent ----
                this.addChildSizesToParent(rootNode, 0);

                //---- this call creates the HTML DIV elements for each node ----
                generator.Draw();

                //---- convert _nodes to shapes ----
                var shapes = this._nodes.map(function (n) {
                    var node = n.node;
                    var dataItem = n.dataItem;

                    var elem = node.m_oShape;

                    elem.attr("cursor", "default").customAttr("updateVisualHint", "fill").customAttr("dataItem", dataItem);

                    //layer.applyTextAttributes(elem, da);
                    if (true) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }

                    return elem[0];
                });

                shapes = vp.select(shapes);

                if (this._statsCallBack) {
                    this._statsCallBack();
                }

                return shapes;
            };
            return treeMapClass;
        })(layers.baseLayerClass);
        layers.treeMapClass = treeMapClass;

        function createTreeMap() {
            return new treeMapClass();
        }
        layers.createTreeMap = createTreeMap;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=treeMap.js.map

///----------------------------------------------------------------
/// (from layers\vLine.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// vLine.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates an vLine (set of vertical lines) layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layers) {
        /** creates an vLine (set of vertical lines) layer for a plot. */
        var vLineClass = (function (_super) {
            __extends(vLineClass, _super);
            //---- private state ----
            function vLineClass() {
                _super.call(this);

                this.layerType("vline").stat(vp.stats.statIdentity()).defaultStackType("identity").chartName("").newTagOrFunc("line");
            }
            vLineClass.prototype.adjustChartOptions = function () {
            };

            vLineClass.prototype.drawShapes = function (shapeRoot, xRecord, yRecord, seriesIndex, pi, layer, xScale, yScale, plot, da) {
                //---- VLINE ----
                var layInfo = layer.info;
                var filteredData = layInfo.filteredData;

                //---- get THEME drawing attributes for each of the parts we will draw ----
                da = vp.session.currentTheme().getDrawingAttributes("layerVline", seriesIndex);

                //---- update the drawing attributes with CONSTANT attribute values from client code ----
                layer.addConstantDrawingAttributes(da, seriesIndex, filteredData);

                var shapes = layer.dataAnimMgr().updateShapes(0, 1, function (uelem, dataItem, index, isNewShape) {
                    var yMin = yScale.rangeMin();
                    var yMax = yScale.rangeMax();

                    //---- "xIntercept" is an alias for "x" ----
                    var xValue = xRecord.data[index];
                    var x = xScale.scale(xValue);

                    //---- update drawing attributes for this itemIndex ----
                    layer.updateDrawingAttributes(da, seriesIndex, index, filteredData);

                    var elem = vp.select(uelem);

                    elem.from(x, yMin).to(x, yMax).customAttr("updateVisualHint", "stroke");

                    layer.applyLineAttributes(elem, da);

                    if (isNewShape) {
                        layer.setElementInfo(elem, 1, seriesIndex);
                    }
                });

                return shapes;
            };
            return vLineClass;
        })(layers.baseLayerClass);
        layers.vLineClass = vLineClass;

        function createVLine() {
            return new vLineClass();
        }
        layers.createVLine = createVLine;
    })(vp.layers || (vp.layers = {}));
    var layers = vp.layers;
})(vp || (vp = {}));
//# sourceMappingURL=vLine.js.map
///-----------------------------------------------------------------------------------------------------------------
/// baseLayout.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - base class for layouts.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (layouts) {
        var baseLayoutClass = (function () {
            function baseLayoutClass() {
                //---- private state ----
                this._width = 100;
                this._height = 100;
                this._count = 1;
                this._useCenter = false;
            }
            baseLayoutClass.prototype.getBoundsByIndex = function (index) {
                return this.makeBounds(0, 0, this._width, this._height);
            };

            baseLayoutClass.prototype.makeBounds = function (x, y, w, h) {
                if (this._useCenter) {
                    x += w / 2;
                    y += h / 2;
                }

                return { x: x, y: y, width: w, height: h };
            };

            baseLayoutClass.prototype.width = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._width;
                } else {
                    //--- SET value ----
                    this._width = value;
                    return this;
                }
            };

            baseLayoutClass.prototype.height = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._height;
                } else {
                    //--- SET value ----
                    this._height = value;
                    return this;
                }
            };

            baseLayoutClass.prototype.count = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._count;
                } else {
                    //--- SET value ----
                    this._count = Math.round(value);
                    return this;
                }
            };

            baseLayoutClass.prototype.useCenter = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._useCenter;
                } else {
                    //--- SET value ----
                    this._useCenter = value;
                    return this;
                }
            };
            return baseLayoutClass;
        })();
        layouts.baseLayoutClass = baseLayoutClass;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
//# sourceMappingURL=baseLayout.js.map

///----------------------------------------------------------------
/// (from layouts\dock.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// dock.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items within a docking container.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /**  returns a path layout object that will layout items within a docking container. */
        var dockClass = (function (_super) {
            __extends(dockClass, _super);
            //_childDatas = [];
            //_layoutNeeded = false;
            function dockClass() {
                _super.call(this);
                //---- private state ----
                this._needInit = true;
                this._left = 0;
                this._top = 0;
                this._right = 0;
                this._bottom = 0;
            }
            dockClass.prototype.init = function () {
                this._left = 0;
                this._top = 0;
                this._right = _super.prototype.width.call(this) - 1;
                this._bottom = _super.prototype.height.call(this) - 1;

                this._needInit = false;
            };

            dockClass.prototype.getBounds = function (itemWidth, itemHeight, dockType) {
                if (this._needInit) {
                    this.init();
                }

                var x = this._left;
                var y = this._top;

                if (dockType == "left") {
                    this._left += itemWidth;
                    itemHeight = this.makeSize(this._bottom - this._top);
                } else if (dockType == "top") {
                    this._top += itemHeight;
                    itemWidth = this.makeSize(this._right - this._left);
                } else if (dockType == "right") {
                    x = this._right - itemWidth;
                    this._right = x;
                    itemHeight = this.makeSize(this._bottom - this._top);
                } else if (dockType == "bottom") {
                    y = this._bottom - itemHeight;
                    this._bottom = y;
                    itemWidth = this.makeSize(this._right - this._left);
                } else {
                    itemWidth = this.makeSize(this._right - this._left);
                    itemHeight = this.makeSize(this._bottom - this._top);
                }
                ;

                return _super.prototype.makeBounds.call(this, x, y, itemWidth, itemHeight);
            };

            dockClass.prototype.makeSize = function (value) {
                return Math.max(0, value);
            };
            return dockClass;
        })(layouts.baseLayoutClass);
        layouts.dockClass = dockClass;

        function createDock() {
            return new dockClass();
        }
        layouts.createDock = createDock;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
//# sourceMappingURL=dock.js.map

///----------------------------------------------------------------
/// (from layouts\grid.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// grid.ts.  Copyright (c) 2012 Microsoft Corporation.
///           Part of the vuePlot library - lays out items in an X/Y grid.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see layouts.html
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a grid layout object that will layout items in a rectangular grid shape. */
        var gridClass = (function (_super) {
            __extends(gridClass, _super);
            function gridClass() {
                _super.call(this);
                //---- private state ----
                this._userRows = undefined;
                this._userColumns = undefined;
                this._rows = 1;
                this._columns = 1;
                this._layoutNeeded = true;
            }
            gridClass.prototype.getBoundsByIndex = function (index) {
                if (this._layoutNeeded) {
                    this.computeLayout();
                }

                var width = _super.prototype.width.call(this);
                var height = _super.prototype.height.call(this);

                if ((this._rows < 1) || (this._columns < 1) || (_super.prototype.count.call(this) <= 1)) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                var itemWidth = width / this._columns;
                var itemHeight = height / this._rows;

                var row = Math.floor(index / this._columns);
                var col = index % this._columns;

                var x = col * itemWidth;
                var y = row * itemHeight;

                return _super.prototype.makeBounds.call(this, x, y, itemWidth, itemHeight);
            };

            gridClass.prototype.markLayoutNeeded = function () {
                this._layoutNeeded = true;
            };

            //---- private: computeLayout() ----
            gridClass.prototype.computeLayout = function () {
                this._layoutNeeded = false;
                var count = _super.prototype.count.call(this);

                if (vp.utils.isDefined(this._userRows)) {
                    this._rows = this._userRows;
                    this._columns = (this._userColumns === undefined) ? Math.ceil(this._count / this._rows) : this._userColumns;
                } else {
                    this._columns = (this._userColumns === undefined) ? Math.ceil(Math.sqrt(count)) : this._userColumns;
                    this._rows = Math.ceil(this._count / this._columns);
                }
            };

            gridClass.prototype.rowCount = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._userRows;
                } else {
                    //--- SET value ----
                    this._userRows = value;
                    return this;
                }
            };

            gridClass.prototype.colCount = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._userColumns;
                } else {
                    //--- SET value ----
                    this._userColumns = value;
                    return this;
                }
            };
            return gridClass;
        })(layouts.baseLayoutClass);
        layouts.gridClass = gridClass;

        function createGrid() {
            return new gridClass();
        }
        layouts.createGrid = createGrid;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
//# sourceMappingURL=grid.js.map

///----------------------------------------------------------------
/// (from layouts\horizontal.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// horizontal.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items in the horizontal direction.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a horizontal object closure that will layout items from left to right. */
        var horizontalClass = (function (_super) {
            __extends(horizontalClass, _super);
            function horizontalClass() {
                _super.call(this);
            }
            horizontalClass.prototype.getBoundsByIndex = function (index) {
                if (_super.prototype.count.call(this) <= 1) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                var itemWidth = _super.prototype.width.call(this) / _super.prototype.count.call(this);
                var itemHeight = _super.prototype.height.call(this);

                var x = index * itemWidth;
                var y = 0;

                return _super.prototype.makeBounds.call(this, x, y, itemWidth, itemHeight);
            };
            return horizontalClass;
        })(layouts.baseLayoutClass);
        layouts.horizontalClass = horizontalClass;

        function createHorizontal() {
            return new horizontalClass();
        }
        layouts.createHorizontal = createHorizontal;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
//# sourceMappingURL=horizontal.js.map

///----------------------------------------------------------------
/// (from layouts\path.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// path.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items along an SVG layeretry path.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a path layout object that will layout items along an SVG layeretry path. */
        var pathClass = (function (_super) {
            __extends(pathClass, _super);
            function pathClass() {
                _super.call(this);
                //---- private state ----
                this._path = null;
                this._itemWidth = 100;
                this._itemHeight = 100;
                this._atStart = true;
                this._atEnd = true;
            }
            pathClass.prototype.getBoundsByIndex = function (index) {
                if (_super.prototype.count.call(this) <= 1) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                //---- NOTE: this is NOT supported on IE9 (but IE10 supports it) ----
                var bounds = null;

                if (this._path.getTotalLength) {
                    var total = this._path.getTotalLength();
                    var pcount = _super.prototype.count.call(this);
                    if (!this._atEnd) {
                        pcount++;
                    }

                    if (!this._atStart) {
                        index++;
                        pcount++;
                    }

                    var percent = index / (pcount - 1);

                    var pt = this._path.getPointAtLength(percent * total);

                    bounds = _super.prototype.makeBounds.call(this, pt.x, pt.y, this._itemWidth, this._itemHeight);
                } else {
                    //---- not yet implemented ----
                    bounds = _super.prototype.makeBounds.call(this, 0, 0, 100, 100);
                }

                return bounds;
            };

            pathClass.prototype.rand = function (min, max) {
                return min + (max - min) * Math.random();
            };

            pathClass.prototype.path = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._path;
                } else {
                    //--- SET value ----
                    this._path = value;
                    return this;
                }
            };

            pathClass.prototype.itemWidth = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._itemWidth;
                } else {
                    //--- SET value ----
                    this._itemWidth = value;
                    return this;
                }
            };

            pathClass.prototype.itemHeight = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._itemHeight;
                } else {
                    //--- SET value ----
                    this._itemHeight = value;
                    return this;
                }
            };

            pathClass.prototype.atStart = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._atStart;
                } else {
                    //--- SET value ----
                    this._atStart = value;
                    return this;
                }
            };

            pathClass.prototype.atEnd = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._atEnd;
                } else {
                    //--- SET value ----
                    this._atEnd = value;
                    return this;
                }
            };
            return pathClass;
        })(layouts.baseLayoutClass);
        layouts.pathClass = pathClass;

        function createPath() {
            return new pathClass();
        }
        layouts.createPath = createPath;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
//# sourceMappingURL=path.js.map

///----------------------------------------------------------------
/// (from layouts\pieLabelHelper.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// pieLabelHelper.ts.  Copyright (c) 2014 Microsoft Corporation.
///     Part of the vuePlot library - gives information about a pie layout.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (layouts) {
        /** Provide following info about each pie slide: center, radius, startAngle, endAngle, color, midArc,
        cxText, cyText, hTextAlign, vTextAlign). */
        function pieLabelHelper(width, height, outerMargin, labelMargin, colorPalette, data, valueColName, labelColName) {
            var size = Math.min(width, height);
            var radius = size / 2 - outerMargin;
            var center = { cx: width / 2, cy: height / 2 };

            var dataSum = data.sum(function (record, index) {
                var value = (valueColName) ? record[valueColName] : record;
                return Math.abs(value);
            });

            var startAngle = 0;
            var infoRecords = [];

            for (var i = 0; i < data.length; i++) {
                var record = data[i];

                var value = Math.abs((valueColName) ? record[valueColName] : record);
                var label = (labelColName) ? record[labelColName] : record;

                var angle = value / dataSum * 360;
                var endAngle = startAngle + angle;
                var midAngle = startAngle + angle / 2;

                var cr = (colorPalette) ? vp.color.colorFromPalette(colorPalette, i) : null;
                var radians = (midAngle - 90) * Math.PI / 180;

                var xMidArc = center.cx + radius * Math.sin(radians);
                var yMidArc = center.cy + radius * Math.cos(radians);

                var xText = center.cx + (radius + labelMargin) * Math.cos(radians);
                var yText = center.cy + (radius + labelMargin) * Math.sin(radians);

                var halign = (midAngle > 180) ? 1 : 0;

                var valign = .5;
                if (midAngle > 315 || midAngle < 45) {
                    valign = 1;
                } else if (midAngle >= 135 && midAngle <= 225) {
                    valign = 0;
                }

                var info = {
                    center: center, radius: radius, startAngle: startAngle, endAngle: endAngle,
                    color: cr, midArc: { x: xMidArc, y: yMidArc }, xText: xText, yText: yText,
                    hTextAlign: halign, vTextAlign: valign, label: label
                };

                infoRecords.push(info);

                startAngle = endAngle;
            }

            return infoRecords;
        }
        layouts.pieLabelHelper = pieLabelHelper;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
//# sourceMappingURL=pieLabelHelper.js.map

///----------------------------------------------------------------
/// (from layouts\random.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// random.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items in random places.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a random layout object that will layout items in random (overlapping) places. */
        var randomClass = (function (_super) {
            __extends(randomClass, _super);
            function randomClass() {
                _super.call(this);
                //---- private state ----
                this._itemWidth = 100;
                this._itemHeight = 100;
            }
            randomClass.prototype.getBoundsByIndex = function (index) {
                if (_super.prototype.count.call(this) <= 1) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                var x = this.rand(0, _super.prototype.width.call(this) - this._itemWidth);
                var y = this.rand(0, _super.prototype.height.call(this) - this._itemHeight);

                return _super.prototype.makeBounds.call(this, x, y, this._itemWidth, this._itemHeight);
            };

            randomClass.prototype.rand = function (min, max) {
                return min + (max - min) * Math.random();
            };

            randomClass.prototype.itemWidth = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._itemWidth;
                } else {
                    //--- SET value ----
                    this._itemWidth = value;
                    return this;
                }
            };

            randomClass.prototype.itemHeight = function (value) {
                if (arguments.length == 0) {
                    //--- GET value ----
                    return this._itemHeight;
                } else {
                    //--- SET value ----
                    this._itemHeight = value;
                    return this;
                }
            };
            return randomClass;
        })(layouts.baseLayoutClass);
        layouts.randomClass = randomClass;

        function createRandom() {
            return new randomClass();
        }
        layouts.createRandom = createRandom;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
//# sourceMappingURL=random.js.map

///----------------------------------------------------------------
/// (from layouts\vertical.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// vertical.ts.  Copyright (c) 2012 Microsoft Corporation.
///            Part of the vuePlot library - lays out items in the vertical direction.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (layouts) {
        /** returns a vertical layout object that will layout items from top to bottom. */
        var verticalClass = (function (_super) {
            __extends(verticalClass, _super);
            function verticalClass() {
                _super.call(this);
            }
            verticalClass.prototype.getBoundsByIndex = function (index) {
                if (_super.prototype.count.call(this) <= 1) {
                    //---- degenerate case ----
                    return _super.prototype.getBoundsByIndex.call(this, index);
                }

                var itemWidth = _super.prototype.width.call(this);
                var itemHeight = _super.prototype.height.call(this) / _super.prototype.count.call(this);

                var x = 0;
                var y = index * itemHeight;

                return _super.prototype.makeBounds.call(this, x, y, itemWidth, itemHeight);
            };
            return verticalClass;
        })(layouts.baseLayoutClass);
        layouts.verticalClass = verticalClass;

        function createVertical() {
            return new verticalClass();
        }
        layouts.createVertical = createVertical;
    })(vp.layouts || (vp.layouts = {}));
    var layouts = vp.layouts;
})(vp || (vp = {}));
//# sourceMappingURL=vertical.js.map
///-----------------------------------------------------------------------------------------------------------------
/// attribute.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates an attribute object (hold constant value or mapping information) for an attribute like "x" or "color".
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (scales) {
        /** settings for an attribute (value, scaling, and legend data). */
        var attributeClass = (function () {
            function attributeClass(attrName, scale) {
                //---- public field ----
                this.ctr = "vp.scales.attributeClass";
                this.layerDefaults = new vp.layers.attrDefaults();
                this.plotDefaults = new vp.layers.attrDefaults();
                //---- debugging support ----
                this._attrName = "";
                this._owner = null;
                //---- for drawing legend/axis ----
                this._breaks = undefined;
                this._labels = undefined;
                this._zeroAxis = undefined;
                this._domainMin = undefined;
                this._domainMax = undefined;
                this._isDiscrete = undefined;
                this._combineDups = undefined;
                this._numDecimalPlaces = undefined;
                this._useNiceNumbers = undefined;
                this._tickCount = undefined;
                this._intOnlyBreaks = undefined;
                this._addHeadRoom = undefined;
                this._expandSpace = undefined;
                this._isScaleLocked = false;
                this._title = undefined;
                this._flipInLegend = undefined;
                this._formatter = undefined;
                this._isLegendVisible = true;
                this._isScalingEnabled = true;
                this._calculatedTickCount = undefined;
                //---- TODO: add support for "_expand" property (adds space to X and Y axes beyond domainMin/domainMax) -----
                //---- for scaling /formatting of values ----
                //_dataMin: number = undefined;       // calculated from simple/stacking data
                //_dataMax: number = undefined;       // calculated from simple/stacking data
                this._value = undefined;
                this._colName = undefined;
                this._palette = undefined;
                this._colData = null;
                this._percentGap = undefined;
                this._dateFormat = undefined;
                this._afterPropName = null;
                this._scale = null;
                this._scaleNeedsSetup = true;
                this._hasScaleDomainBeenSet = false;
                this._attrName = attrName;
                this._scale = scale;
            }
            /** sets one or more attribute properties.  If 'value' is an array of strings, it sets
            the 'colName' property.  If 'value' is a scalar, it sets the 'value' property.
            Otherwise, if 'value' is an object with key/value pairs, it is used to set
            the names properties of the attribute.  */
            attributeClass.prototype.quickSet = function (value) {
                var isArray = vp.utils.isArray(value);

                if (isArray && value.length && vp.utils.isString(value[0])) {
                    this.colName(value);
                } else if ((value != null) && (!isArray) && (vp.utils.isObject(value))) {
                    //---- a set of key/value pairs on the object ----
                    var keys = vp.utils.keys(value);
                    for (var k = 0; k < keys.length; k++) {
                        var key = keys[k];
                        var val = value[key];

                        this[key](val); // call our setter function for this property
                    }
                } else {
                    //---- primitive value passed in ----
                    this._value = value;
                    ;
                    this._colName = undefined;
                }

                return (this._owner) ? this._owner : this;
            };

            attributeClass.prototype.getActualIsDiscrete = function () {
                var value = (this._isDiscrete !== undefined) ? this._isDiscrete : this.plotDefaults.isDiscrete;
                if (value === undefined) {
                    value = this.layerDefaults.isDiscrete;
                }

                return value;
            };

            attributeClass.prototype.getActualZeroAxis = function () {
                var value = (this._zeroAxis !== undefined) ? this._zeroAxis : this.layerDefaults.zeroAxis;
                return value;
            };

            attributeClass.prototype.getActualCombineDups = function () {
                var value = (this._combineDups !== undefined) ? this._combineDups : this.layerDefaults.combineDups;
                return value;
            };

            attributeClass.prototype.getActualIntOnlyBreaks = function () {
                var value = (this._intOnlyBreaks !== undefined) ? this._intOnlyBreaks : this.layerDefaults.intOnlyBreaks;
                return value;
            };

            attributeClass.prototype.getActualPercentGap = function () {
                var value = (this._percentGap !== undefined) ? this._percentGap : this.layerDefaults.percentGap;
                return value;
            };

            attributeClass.prototype.getActualTickCount = function () {
                //---- special case: here, we use "_calculatedTickCount" as override ----
                var value = (this._calculatedTickCount !== undefined) ? this._calculatedTickCount : this.layerDefaults.tickCount;
                return value;
            };

            attributeClass.prototype.getActualAddHeadroom = function () {
                var value = (this._addHeadRoom !== undefined) ? this._addHeadRoom : this.layerDefaults.addMaxHeadroom;
                return value;
            };

            attributeClass.prototype.getActualExpandSpace = function () {
                var value = this._expandSpace;
                return value;
            };

            attributeClass.prototype.getActualUseNiceNumbers = function () {
                var value = (this._useNiceNumbers !== undefined) ? this._useNiceNumbers : this.layerDefaults.useNiceNumbers;

                //var minSpecified = ((this._domainMin !== undefined) || (this.defaults.dataMin !== undefined));
                //var maxSpecified = ((this._domainMax !== undefined) || (this.defaults.dataMax !== undefined));
                //if (minSpecified || maxSpecified)
                //{
                //    value = false;
                //}
                return value;
            };

            attributeClass.prototype.getActualDateFormat = function () {
                var value = (this._dateFormat !== undefined) ? this._dateFormat : this.layerDefaults.dateFormat;
                return value;
            };

            //getActualData()
            //{
            //    var value;
            //    if (this._colData !== undefined)
            //    {
            //        value = this._colData;
            //    }
            //    else
            //    {
            //        value = this.systemDefaults.dataOverride;
            //    }
            //    return value;
            //}
            attributeClass.prototype.needsSetUp = function (value) {
                if (arguments.length === 0) {
                    return this._scaleNeedsSetup;
                }

                this._scaleNeedsSetup = value;
                return this;
            };

            /** the constant value of the attribute. */
            attributeClass.prototype.value = function (val) {
                if (arguments.length === 0) {
                    return this._value;
                }

                this._value = val;
                if (val !== undefined) {
                    this._colName = undefined;
                }

                return this;
            };

            attributeClass.prototype.dateFormat = function (value) {
                if (arguments.length === 0) {
                    return this._dateFormat;
                }

                this._dateFormat = value;

                return this;
            };

            attributeClass.prototype.combineDups = function (value) {
                if (arguments.length === 0) {
                    return this._combineDups;
                }

                this._combineDups = value;
                return this;
            };

            attributeClass.prototype.expandSpace = function (value) {
                if (arguments.length === 0) {
                    return this._expandSpace;
                }

                this._expandSpace = value;
                return this;
            };

            attributeClass.prototype.addHeadRoom = function (value) {
                if (arguments.length === 0) {
                    return this._addHeadRoom;
                }

                this._addHeadRoom = value;
                return this;
            };

            attributeClass.prototype.intOnlyBreaks = function (value) {
                if (arguments.length === 0) {
                    return this._intOnlyBreaks;
                }

                this._intOnlyBreaks = value;
                return this;
            };

            attributeClass.prototype.isLegendVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isLegendVisible;
                }

                this._isLegendVisible = value;
                return this;
            };

            attributeClass.prototype.isScaleLocked = function (value) {
                if (arguments.length === 0) {
                    return this._isScaleLocked;
                }

                this._isScaleLocked = value;
                return this;
            };

            attributeClass.prototype.isScalingEnabled = function (value) {
                if (arguments.length === 0) {
                    return this._isScalingEnabled;
                }

                this._isScalingEnabled = value;
                return this;
            };

            attributeClass.prototype.zeroAxis = function (value) {
                if (arguments.length === 0) {
                    return this._zeroAxis;
                }

                this._zeroAxis = value;
                return this;
            };

            attributeClass.prototype.useNiceNumbers = function (value) {
                if (arguments.length === 0) {
                    return this._useNiceNumbers;
                }

                this._useNiceNumbers = value;
                return this;
            };

            attributeClass.prototype.tickCount = function (value) {
                if (arguments.length === 0) {
                    return this._tickCount;
                }

                this._tickCount = value;
                return this;
            };

            attributeClass.prototype.domainMin = function (value) {
                if (arguments.length === 0) {
                    return this._domainMin;
                }

                this._domainMin = value;
                if (value !== undefined) {
                    this.zeroAxis(false);
                }
                return this;
            };

            attributeClass.prototype.domainMax = function (value) {
                if (arguments.length === 0) {
                    return this._domainMax;
                }

                this._domainMax = value;
                if (value !== undefined) {
                    this.zeroAxis(false);
                }
                return this;
            };

            attributeClass.prototype.percentGap = function (value) {
                if (arguments.length === 0) {
                    return this._percentGap;
                }

                this._percentGap = value;
                return this;
            };

            attributeClass.prototype.formatter = function (value) {
                if (arguments.length === 0) {
                    return this._formatter;
                }

                this._formatter = value;
                return this;
            };

            attributeClass.prototype.numDecimalPlaces = function (value) {
                if (arguments.length === 0) {
                    return this._numDecimalPlaces;
                }

                this._numDecimalPlaces = value;
                return this;
            };

            attributeClass.prototype.breaks = function (value) {
                if (arguments.length === 0) {
                    return this._breaks;
                }

                this._breaks = value;
                this.onBreaksChanged();

                return this;
            };

            attributeClass.prototype.onBreaksChanged = function () {
                var breaks = (this._breaks) ? this._breaks : this.layerDefaults.breaks;

                if (breaks && breaks.length) {
                    this.layerDefaults.dataMin = breaks.min();
                    this.layerDefaults.dataMax = breaks.max();
                    this.layerDefaults.isMinMaxSoft = false;

                    var isDiscrete = this.getActualIsDiscrete();
                    this.layerDefaults.tickCount = (isDiscrete) ? (1 + breaks.length) : breaks.length;
                    this.layerDefaults.useNiceNumbers = false;

                    this._scaleNeedsSetup = true;
                }
            };

            attributeClass.prototype.labels = function (value) {
                if (arguments.length === 0) {
                    return this._labels;
                }

                this._labels = value;
                return this;
            };

            /** gets the actual formatting function to be used to label values in the axis/legend for this attribute. */
            attributeClass.prototype.getActualFormatter = function () {
                var actual = this._formatter;
                if (!actual) {
                    if (this.layerDefaults.usePercentFormatting) {
                        actual = vp.formatters.percent;
                    } else {
                        var isDiscrete = this.getActualIsDiscrete();
                        var dateFormat = this.getActualDateFormat();

                        if (isDiscrete) {
                            actual = vp.formatters.string;
                        } else if (dateFormat) {
                            actual = eval("vp.formatters." + dateFormat);
                        } else {
                            actual = vp.formatters.comma;
                        }
                    }
                }

                return actual;
            };

            /** Running stats on our data can change our X and Y column mappings.  This function returns
            the new property name assoicated with this attribute. */
            attributeClass.prototype.getAfterStatsPropName = function (seriesIndex) {
                var propName = this._afterPropName;

                if (!propName) {
                    //----- use original colName ----
                    if (this._colName && this._colName.length) {
                        if (seriesIndex >= this._colName.length) {
                            seriesIndex = 0;
                        }

                        propName = this._colName[seriesIndex];
                    }
                }

                return propName;
            };

            /** gets the actual array of input data values used for the axis/legend breaks for this attribute.
            The user-specified set of breaks takes priority.
            Otherwise, for DISCRETE attributes WITH Dup merging, this is the set of unique key values with a NULL appended at the end;
            Otherwise, for DISCRETE attributes WITHOUT Dup merging, this is the 0-relative set of index values for each row with an
            "N" (the record count) appended at the end;
            For "_seriesIndex", this is the 0-relative set of index values for each series;
            Otherwise, (most popular case) it is the set of "tickCount" values between "min" and "max". */
            attributeClass.prototype.getActualBreaks = function () {
                var actual = (this._breaks !== undefined) ? this._breaks : this.layerDefaults.breaks;
                if (!actual) {
                    actual = [];

                    if (this._scale) {
                        var min = this._scale.domainMin();
                        var max = this._scale.domainMax();
                        var propName = this.getAfterStatsPropName(0);

                        var isDiscrete = this.getActualIsDiscrete();
                        if (isDiscrete) {
                            if (this._colData && this._colData.length) {
                                actual = this._colData;
                                var combineDups = this.getActualCombineDups();

                                if (combineDups) {
                                    actual = actual.distinct();
                                    actual.push(null); // for extra tick
                                } else if (actual && actual.length) {
                                    actual = vp.utils.range(0, actual.length, 1); //  - 1, 1);
                                }
                            }
                        } else if (propName == "_seriesIndex" || propName == "_seriesName") {
                            //actual = this._colData;
                            actual = vp.utils.range(min, max, 1);
                        } else {
                            //---- generate breaks from min/max/tickCount scale ----
                            var tickCount = this.getActualTickCount();

                            var incr = (max - min) / (tickCount - 1);
                            actual = vp.utils.range(min, max, incr);
                        }
                    }
                }

                return actual;
            };

            /** returns the actual labels for the associated axis/legend. */
            attributeClass.prototype.getActualLabels = function (breakData) {
                if (!breakData) {
                    breakData = this.getActualBreaks();
                }

                var actual = this._labels;
                if (!actual) {
                    actual = [];

                    if (true) {
                        var formatter = this.getActualFormatter();
                        var propName = this.getAfterStatsPropName(0);

                        var count = breakData.length;
                        if (this.getActualIsDiscrete()) {
                            count--;
                        }

                        actual = [];

                        //---- for comma formatter, look at the range of break values to determine the best numDecimals to use ----
                        var numDecimals = this._numDecimalPlaces;

                        if ((formatter == vp.formatters.comma) && (numDecimals == undefined)) {
                            var range = this._scale._domainMax - this._scale._domainMin;
                            if (range > 0) {
                                var singleTickInterval = range / this.getActualTickCount();
                                var log10Val = Math.log10(singleTickInterval);
                                if (log10Val < 0) {
                                    numDecimals = Math.ceil(-log10Val);
                                }
                            }
                        }

                        for (var i = 0; i < count; i++) {
                            var dataValue = breakData[i];

                            var isDiscrete = this.getActualIsDiscrete();
                            var combineDups = this.getActualCombineDups();

                            if (propName == "_seriesIndex" || propName == "_seriesName") {
                                //---- data value is series index ----
                                dataValue = this._colData[dataValue];
                            } else if ((isDiscrete) && (!combineDups)) {
                                //---- data value is record index ----
                                dataValue = this._colData[dataValue];
                            }

                            var str = formatter(dataValue, numDecimals);
                            actual[i] = str;
                        }
                    } else {
                        //---- default for unmapped column is just the 1-relative record numbers (e.g., x for column plot) ----
                        actual = vp.utils.range(1, breakData.length, 1);
                    }
                }

                return actual;
            };

            attributeClass.prototype.colName = function (value) {
                if (arguments.length === 0) {
                    return this._colName;
                }

                if (value === undefined) {
                    this._colName = value;
                } else {
                    if (vp.utils.isArray(value)) {
                        this._colName = value;
                    } else {
                        this._colName = [value];
                    }

                    this._value = undefined;
                }

                this._scaleNeedsSetup = true;
                return this;
            };

            attributeClass.prototype.title = function (value) {
                if (arguments.length === 0) {
                    return this._title;
                }

                this._title = value;
                return this;
            };

            attributeClass.prototype.flipInLegend = function (value) {
                if (arguments.length === 0) {
                    return this._flipInLegend;
                }

                this._flipInLegend = value;
                return this;
            };

            attributeClass.prototype.isDiscrete = function (value) {
                if (arguments.length === 0) {
                    return this._isDiscrete;
                }

                this._isDiscrete = value;
                return this;
            };

            attributeClass.prototype.palette = function (value) {
                if (arguments.length === 0) {
                    return this._palette;
                }

                this._palette = value;
                return this;
            };

            /** the array of values associated with this mapped column.  Usually calculated in
            setUpScale(). */
            attributeClass.prototype.colData = function (value) {
                if (arguments.length === 0) {
                    return this._colData;
                }

                this._colData = value;
                return this;
            };

            ///** an array of values to use instead of the filteredData, when setting up the scale. */
            //dataOverride(value?: any[])
            //{
            //    if (arguments.length === 0)
            //    {
            //        return this._dataOverride;
            //    }
            //    this._dataOverride = value;
            //    return this;
            //}
            /** the object that owns this attribute. */
            attributeClass.prototype.owner = function (value) {
                if (arguments.length === 0) {
                    return this._owner;
                }

                this._owner = value;
                return this;
            };

            /** returns the layer that owns this attribute. */
            attributeClass.prototype.pop = function () {
                return this._owner;
            };

            /** returns true if user mapped this attribute to a column. */
            attributeClass.prototype.isUserMapped = function () {
                var colName = this._colName;

                var mapped = (colName && colName.length > 0);
                return mapped;
            };

            /** returns true if user or system mapped this attribute to a column. */
            attributeClass.prototype.isMapped = function () {
                var propName = this.getAfterStatsPropName(0);

                var mapped = ((propName != null) && (propName.length > 0));
                return mapped;
            };

            /** get the constant or mapped value of the attribute, for the specified item. */
            attributeClass.prototype.getItemValue = function (seriesIndex, itemIndex, filteredData, daForAttr, seriesNames, stackType) {
                //---- start with no value specified ----
                var value = null;
                var isMapped = this.isMapped();

                if (isMapped) {
                    var propName = this.getAfterStatsPropName(seriesIndex);
                    var seriesCount = (seriesNames && seriesNames.length) ? seriesNames.length : 1;
                    var hasData = (filteredData && filteredData.length);

                    if (hasData) {
                        var palette = this._palette;
                        if ((!palette) || (!palette.length)) {
                            palette = daForAttr;
                        }

                        value = this.getMappedValue(propName, filteredData, seriesCount, seriesIndex, itemIndex, palette, seriesNames, daForAttr, stackType);
                    }
                } else {
                    //---- no col mapping ----
                    value = this._value;
                }

                return value;
            };

            /** get the mapped value of the attribute, for the specified item. */
            attributeClass.prototype.getMappedValue = function (propName, filteredData, seriesCount, seriesIndex, itemIndex, palette, seriesNames, daForAttr, stackType) {
                var isDiscrete = this.getActualIsDiscrete();
                var propValue = null;

                if (propName == "_itemIndex") {
                    propValue = itemIndex;
                } else if (propName == "_seriesIndex") {
                    propValue = seriesIndex;
                } else if (propName == "_seriesName") {
                    var seriesName = seriesNames[seriesIndex];
                    propValue = this._scale.getIndexOfKey(seriesName);
                } else {
                    propValue = filteredData[itemIndex][propName];

                    if (isDiscrete) {
                        var combineDups = this.getActualCombineDups();

                        if (!combineDups) {
                            //---- e.g., this enables mapping "coffee" to a valid discrete color ----
                            propValue = itemIndex;
                        }
                    } else if (this._scale) {
                        //---- prevent exceptions for bad data here ----
                        if (isNaN(+propValue)) {
                            propValue = this.callOnError("NaN", { msg: "scaling input value", value: propValue, rowIndex: itemIndex, colName: propName });
                        }
                    }
                }

                var scale = this._scale;
                var value = propValue;

                if (scale) {
                    if (this._isScalingEnabled) {
                        if (this._scaleNeedsSetup) {
                            this.setupScale(filteredData, seriesNames, daForAttr, stackType, propName);
                        }

                        var value = scale.scale(propValue);
                    } else {
                        value = propValue;
                    }
                } else {
                    var formatter = this.getActualFormatter();
                    value = formatter(propValue);
                }

                return value;
            };

            attributeClass.prototype.scale = function (value) {
                if (arguments.length == 0) {
                    return this._scale;
                }

                this._scale = value;
                return this;
            };

            attributeClass.prototype.getDataForAttribute = function (propName, filteredData, seriesNames) {
                var data = [];

                //---- get data & call scale for each row, so that scale has needed info for building the legend ----
                if (propName == "_itemIndex") {
                    var count = filteredData.length;

                    data = vp.utils.range(0, count - 1, 1);
                } else if (propName == "_seriesIndex" || propName == "_seriesName") {
                    data = seriesNames;
                } else {
                    data = vp.data.dataSelect(filteredData, propName);
                    if ((!data) || (!data.length)) {
                        //---- could not find specified propname - just return 1-based index (for discrete mapping) ----
                        data = vp.utils.range(1, filteredData.length); //filteredData;
                    }
                }

                return data;
            };

            attributeClass.prototype.getOnErrorFromPlot = function () {
                var onErr = null;

                var layer = this._owner;
                if (layer && layer._vvParent) {
                    var plot = layer._vvParent;
                    onErr = plot._onError;
                }

                return onErr;
            };

            attributeClass.prototype.callOnError = function (errType, info) {
                var result = undefined;

                var onErr = this.getOnErrorFromPlot();
                if (onErr) {
                    result = onErr(errType, info);
                } else {
                    result = 0;
                }

                return result;
            };

            attributeClass.prototype.setScaleDomain = function (min, max, tickCount) {
                if (!this._isScaleLocked || !this._hasScaleDomainBeenSet) {
                    this._scale.domainMin(min).domainMax(max);

                    if (arguments.length == 3) {
                        this._calculatedTickCount = tickCount;
                    }

                    this._hasScaleDomainBeenSet = true;
                }
            };

            /** this is called to setUp the scale for this attribute before the legend is drawn.  The
            scale is then used by the legend drawing code. */
            attributeClass.prototype.setupScale = function (filteredData, seriesNames, daForAttr, stackType, afterPropName) {
                this._afterPropName = afterPropName;
                var propName = this.getAfterStatsPropName(0);

                var seriesCount = (seriesNames && seriesNames.length) ? seriesNames.length : 1;

                var data = this.layerDefaults.dataOverride;
                if (data === undefined) {
                    data = this.getDataForAttribute(propName, filteredData, seriesNames);
                }

                this._colData = data;

                //if (this._dateFormat !== undefined)
                //{
                //    this.breaks(data);
                //}
                if (this._scale) {
                    var isDiscrete = this.getActualIsDiscrete();
                    var combineDups = this.getActualCombineDups();
                    var scaleType = 0 /* linear */;

                    if (isDiscrete) {
                        scaleType = (combineDups) ? 4 /* categoryKey */ : 3 /* category */;
                    }

                    //---- OK, we are now ready to setup the scale ----
                    var scale = this._scale.scaleType(scaleType);

                    var palette = this._palette;
                    if ((!palette) || (!palette.length)) {
                        if (vp.utils.isArray(daForAttr)) {
                            palette = daForAttr;
                        }
                    }

                    if ((palette) && (palette.length)) {
                        scale.palette(palette);
                    }

                    var recordCount = 0;

                    if (isDiscrete) {
                        //---- CATEGORY data ----
                        if (combineDups) {
                            recordCount = data.distinct().length;
                        } else {
                            recordCount = data.length;
                        }

                        this.setScaleDomain(1, recordCount);
                    } else if (propName == "_seriesIndex" || propName == "_seriesName") {
                        //---- SERIES INDEX data ----
                        recordCount = seriesCount;

                        this.setScaleDomain(0, recordCount - 1);

                        if (propName == "_seriesName") {
                            this._scale.setCategoryKeys(data);
                        }
                    } else {
                        //---- NUMERIC data ----
                        recordCount = data.length;

                        var actualDataMin = 0;
                        var actualDataMax = 0;

                        //---- compute min/max using fast method ----
                        actualDataMin = data.min();
                        actualDataMax = data.max();

                        //---- handle data errors ----
                        if (isNaN(actualDataMin)) {
                            //---- need to call on onError to correct input value issues ----
                            var onErr = this.getOnErrorFromPlot();
                            if (onErr) {
                                while (isNaN(actualDataMin)) {
                                    for (var i = 0; i < data.length; i++) {
                                        if (isNaN(data[i])) {
                                            var result = this.callOnError("NaN", { msg: "computing scale min/max", value: data[i], rowIndex: i, colName: this._colName });

                                            if (isNaN(result)) {
                                                break;
                                            }

                                            data[i] = result;
                                        }
                                    }

                                    actualDataMin = data.min();
                                    actualDataMax = data.max();
                                }
                            }
                        }

                        //---- defaults.dataMin and defaults.dataMax (set by plot, using union of all layers) take precedense here ----
                        if (this.layerDefaults.dataMin !== undefined) {
                            actualDataMin = this.layerDefaults.dataMin;
                        }

                        if (this.layerDefaults.dataMax !== undefined) {
                            actualDataMax = this.layerDefaults.dataMax;
                        }

                        var useNiceNumbers = this.getActualUseNiceNumbers();
                        var isMinMaxSoft = this.layerDefaults.isMinMaxSoft;

                        var minOverride = this._domainMin;
                        var maxOverride = this._domainMax;

                        //if (isMinMaxSoft)
                        //{
                        //    if (this.defaults.dataMin !== undefined)
                        //    {
                        //        actualDataMin = this.defaults.dataMin;
                        //    }
                        //    if (this.defaults.dataMax !== undefined)
                        //    {
                        //        actualDataMax = this.defaults.dataMax;
                        //    }
                        //}
                        //else
                        //{
                        //    if ((minOverride === undefined) && (this.defaults.dataMin !== undefined))
                        //    {
                        //        minOverride = this.defaults.dataMin;
                        //    }
                        //    if ((maxOverride === undefined) && (this.defaults.dataMax !== undefined))
                        //    {
                        //        maxOverride = this.defaults.dataMax;
                        //    }
                        //}
                        var addHeadroom = this.getActualAddHeadroom();
                        var zeroAxis = this.getActualZeroAxis();
                        var intOnlyBreaks = this.getActualIntOnlyBreaks();

                        //---- special case ----
                        var tickOverride = (this._tickCount !== undefined) ? this._tickCount : this.layerDefaults.tickCount;

                        var minSpecified = (this._domainMin !== undefined);
                        var maxSpecified = (this._domainMax !== undefined);

                        var calcMinMax = ((!minSpecified) && (!maxSpecified) && (useNiceNumbers));
                        if (!calcMinMax) {
                            if (minOverride === undefined) {
                                minOverride = actualDataMin;
                            }

                            if (maxOverride === undefined) {
                                maxOverride = actualDataMax;
                            }
                        }

                        //---- manually apply "zeroAxis" to overrides ----
                        if ((zeroAxis) && (minOverride !== undefined) && (maxOverride !== undefined)) {
                            if (minOverride > 0) {
                                minOverride = 0;
                            } else if (maxOverride < 0) {
                                maxOverride = 0;
                            }
                        }

                        //---- limit percents to -1..+1 ----
                        if (this.layerDefaults.usePercentFormatting) {
                            if (!minSpecified) {
                                addHeadroom = false;

                                if (actualDataMin < -1) {
                                    actualDataMin = -1;
                                }
                            }

                            if (!maxSpecified) {
                                if (actualDataMax > 1) {
                                    actualDataMax = 1;
                                }
                            }
                        }

                        //---- adjust MIN/MAX and TICKCOUNT ----
                        var result = scales.niceNumbers.calculate(actualDataMin, actualDataMax, zeroAxis, intOnlyBreaks, minOverride, maxOverride, tickOverride, addHeadroom);

                        this.setScaleDomain(result.min, result.max, result.tickCount);
                    }

                    //---- special handling for category SPACE scales ----
                    //if ((scale.scaleName == "space") && (isDiscrete))
                    if (scale.scaleName == "space") {
                        var percentGap = this.getActualPercentGap();

                        var sc = seriesCount;
                        if (stackType == "dodge" && this.layerDefaults.ignoreDodge)
                        {
                            sc = 1;
                        }

                        scale.onSetUp(recordCount, sc, stackType, percentGap);

                        scale.isPaletteDiscrete(true);
                    }

                    var expandSpace = this.getActualExpandSpace();
                    scale.expandSpace(expandSpace);
                }

                this._scaleNeedsSetup = false;
                return this;
            };
            return attributeClass;
        })();
        scales.attributeClass = attributeClass;

        function createAttribute(attrName, scale) {
            return new attributeClass(attrName, scale);
        }
        scales.createAttribute = createAttribute;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=attribute.js.map

///----------------------------------------------------------------
/// (from scales\barHelper.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// barHelper.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - creates a step layer for a plot.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (scales) {
        /** helps place ticks, labels, and shapes for category type plots.  Also supports multiple-series "clustered" layouts.  */
        var barHelperClass = (function () {
            /** recordCount should be set to the number of CATEGORY values in the domain.  */
            function barHelperClass(scale, recordCount, seriesCount, percentGap) {
                this._percentGap = .25;
                this._seriesCount = 0;
                this._recordCount = 0;
                this._areaSize = 0;
                this._multiBarSize = 0;
                this._gapSize = 0;
                this._rangeMin = 0;
                this._rangeMax = 0;
                this._scale = scale;
                this._recordCount = recordCount;
                this._seriesCount = seriesCount;

                if (percentGap !== undefined) {
                    this._percentGap = percentGap;
                }

                this.caclAll();
            }
            barHelperClass.prototype.caclAll = function () {
                var count = this._recordCount;

                this._areaSize = 0;
                this._gapSize = 0;
                this._multiBarSize = 0;

                var range = this._scale.palette();
                this._rangeMin = range[0];
                this._rangeMax = range[1];

                var totalWidth = Math.abs(this._rangeMax - this._rangeMin);

                if ((count > 0) && (totalWidth > 0)) {
                    this._areaSize = Math.max(0, totalWidth / count);
                    this._gapSize = this._areaSize * (this._percentGap / 2);
                    this._multiBarSize = Math.max(0, this._areaSize - (2 * this._gapSize));
                }
            };

            barHelperClass.prototype.percentGap = function (value) {
                if (arguments.length === 0) {
                    return this._percentGap;
                }

                this._percentGap = value;
                this.caclAll();

                return this;
            };

            /** return the offset along the axis where the specified tick should be drawn. */
            barHelperClass.prototype.getTickOffset = function (tickIndex) {
                return this._rangeMin + (tickIndex * this._areaSize);
            };

            /** return the offset along the axis where the center of the specified label should be drawn. */
            barHelperClass.prototype.getBarAreaCenter = function (rowIndex) {
                return this._rangeMin + ((rowIndex + .5) * this._areaSize);
            };

            /** return the size of the each bar area (includes gaps and multi-series bars). */
            barHelperClass.prototype.getBarAreaSize = function () {
                return this._areaSize;
            };

            /** The main scaling function for discrete scales.
            For X axes, return the offset for the "LEFT" property of the specified bar.  This will scale
            rowIndex=0 to the "rangeMin" and rowIndex=recordCount to the "rangeMax".
            For Y axes, return the offset for the "BOTTOM" property of the specified bar.  This will scale
            rowIndex=0 to the "rangeMax" and rowIndex=recordCount to the "rangeMin".  */
            barHelperClass.prototype.getBarOffset = function (rowIndex, seriesIndex, supressGapSize) {
                var barOffset = 0;

                if (this._rangeMin > this._rangeMax) {
                    var areaSize = -this._areaSize;
                    barOffset = this._rangeMin + (rowIndex * areaSize);
                } else {
                    var areaSize = this._areaSize;
                    barOffset = this._rangeMin + (rowIndex * areaSize);
                }

                if (!supressGapSize) {
                    barOffset += this._gapSize;
                }

                if ((this._seriesCount > 1) && (seriesIndex !== undefined) && (seriesIndex > -1)) {
                    var perBarWidth = this._multiBarSize / this._seriesCount;
                    barOffset += seriesIndex * perBarWidth;
                }

                return barOffset;
            };

            barHelperClass.prototype.getSeriesBarOffset = function (seriesIndex) {
                var offset = 0;
                if ((seriesIndex !== undefined) && (seriesIndex > -1)) {
                    var perBarWidth = this._multiBarSize / this._seriesCount;
                    offset += seriesIndex * perBarWidth;
                }

                return offset;
            };

            /** return the size of a single bar. */
            barHelperClass.prototype.getBarSize = function () {
                return (this._multiBarSize / this._seriesCount);
            };
            return barHelperClass;
        })();
        scales.barHelperClass = barHelperClass;

        function createBarHelper(scale, recordCount, seriesCount, percentGap) {
            return new barHelperClass(scale, recordCount, seriesCount, percentGap);
        }
        scales.createBarHelper = createBarHelper;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=barHelper.js.map

///----------------------------------------------------------------
/// (from scales\colorScale.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// colorScale.ts.  Copyright (c) 2014 Microsoft Corporation.
///     Part of the vuePlotCore library - color scale class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var colorScaleClass = (function (_super) {
            __extends(colorScaleClass, _super);
            function colorScaleClass() {
                _super.call(this);

                this.ctr = "vp.scales.colorScaleClass";
                this.scaleName = "color";
            }
            //---- override base method: return a color string (not rgb array) ----
            colorScaleClass.prototype.lerpScale = function (value) {
                var result = _super.prototype.lerpScale.call(this, value);
                if (!vp.utils.isString(result)) {
                    result = vp.color.toColor(result);
                }

                return result;
            };

            //---- override base method ----
            colorScaleClass.prototype.interpolateValues = function (min, max, t) {
                var red = this.lerp(min[0], max[0], t);
                var green = this.lerp(min[1], max[1], t);
                var blue = this.lerp(min[2], max[2], t);

                return [red, green, blue];
            };

            //---- override base method ----
            colorScaleClass.prototype.onMapTypeChanged = function () {
                _super.prototype.onMapTypeChanged.call(this);
                this.onPaletteChanged();
            };

            //---- override base method ----
            colorScaleClass.prototype.onPaletteChanged = function () {
                _super.prototype.onPaletteChanged.call(this);

                //---- ensure all palette entries are rgb arrays, if interpolating ----
                if (this.scaleType() == 0 /* linear */) {
                    var palette = this._palette;
                    if (palette) {
                        for (var i = 0; i < palette.length; i++) {
                            if (vp.utils.isString(palette[i])) {
                                palette[i] = vp.color.getColorFromString(palette[i]);
                            }
                        }
                    }
                }
            };
            return colorScaleClass;
        })(vp.scales.baseScaleClass);
        scales.colorScaleClass = colorScaleClass;

        function createColor() {
            return new colorScaleClass;
        }
        scales.createColor = createColor;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=colorScale.js.map

///----------------------------------------------------------------
/// (from scales\lineType.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// lineType.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - lineType scale class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var lineTypeClass = (function (_super) {
            __extends(lineTypeClass, _super);
            function lineTypeClass() {
                _super.call(this);

                this.ctr = "vp.scales.lineTypeClass";
                this.scaleName = "lineType";

                this._palette = [0, 6];
            }
            return lineTypeClass;
        })(vp.scales.baseScaleClass);
        scales.lineTypeClass = lineTypeClass;

        function createLineType() {
            return new lineTypeClass;
        }
        scales.createLineType = createLineType;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=lineType.js.map

///----------------------------------------------------------------
/// (from scales\opacity.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// opacity.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - scale for opacity values on shapes.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var opacityClass = (function (_super) {
            __extends(opacityClass, _super);
            function opacityClass() {
                _super.call(this);

                this.ctr = "vp.scales.opacityClass";
                this.scaleName = "opacity";

                this._palette = [.4, .5, .7, .8];
            }
            return opacityClass;
        })(vp.scales.baseScaleClass);
        scales.opacityClass = opacityClass;

        function createOpacity() {
            return new opacityClass;
        }
        scales.createOpacity = createOpacity;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=opacity.js.map

///----------------------------------------------------------------
/// (from scales\shape.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// shape.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - shape scale class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var shapeClass = (function (_super) {
            __extends(shapeClass, _super);
            function shapeClass() {
                _super.call(this);

                this.ctr = "vp.scales.shapeClass";
                this.scaleName = "shape";

                this._palette = [0, 25]; // pre-defined shapes
            }
            return shapeClass;
        })(vp.scales.baseScaleClass);
        scales.shapeClass = shapeClass;

        function createShape() {
            return new shapeClass;
        }
        scales.createShape = createShape;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=shape.js.map

///----------------------------------------------------------------
/// (from scales\size.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// size.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - size scale class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var sizeClass = (function (_super) {
            __extends(sizeClass, _super);
            function sizeClass() {
                _super.call(this);

                this.ctr = "vp.scales.sizeClass";
                this.scaleName = "size";

                this._palette = [5, 10, 15, 20, 25];
            }
            return sizeClass;
        })(vp.scales.baseScaleClass);
        scales.sizeClass = sizeClass;

        function createSize() {
            return new sizeClass;
        }
        scales.createSize = createSize;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=size.js.map

///----------------------------------------------------------------
/// (from scales\space.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// space.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - space scale class (used to scale numbers into X and Y dimensions).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var spaceClass = (function (_super) {
            __extends(spaceClass, _super);
            function spaceClass() {
                _super.call(this);
                this._autoRange = true;
                this._barHelper = null;
                this._baseScale = this.scale;
                this._isFlipped = false;
                this._internalCall = false;
                /** scale the value (using LERP scaling), with an optional seriesIndex adjustment */
                this.scale = function (value, seriesIndex) {
                    if ((this._isFlipped) && (!this._internalCall)) {
                        this.flipPalette();
                    }

                    var newValue = this._baseScale(value);

                    if ((seriesIndex !== undefined) && (seriesIndex > -1) && (this._barHelper)) {
                        //---- add offset for this seriesIndex ----
                        newValue += this._barHelper.getSeriesBarOffset(seriesIndex);
                        ;
                    }

                    return newValue;
                };

                this.ctr = "vp.scales.spaceClass";
                this.scaleName = "space";

                this._palette = [0, 100];
            }
            /** return the width (size) of a full item (1-N bars, without gap space) for associated axis. */
            spaceClass.prototype.itemWidth = function () {
                var value = (this._barHelper) ? this._barHelper.getBarSize() : 0;
                return value;
            };

            spaceClass.prototype.onRangeChanged = function () {
                //---- recalculate all since range changed ----
                if (this._barHelper) {
                    this._barHelper.caclAll();
                }
            };

            /** return the width (size) of a full item for associated axis. */
            spaceClass.prototype.seriesItemWidth = function () {
                var value = (this._barHelper) ? this._barHelper.getBarSize() : 0;
                return value;
            };

            spaceClass.prototype.onSetUp = function (dataCount, seriesCount, stackType, percentGap) {
                //---- don't treat as multiple series UNLESS we are using clustered layout ----
                if (stackType != "dodge") {
                    seriesCount = 1;
                }

                this._barHelper = scales.createBarHelper(this, dataCount, seriesCount, percentGap);

                this._isFlipped = false;
            };

            spaceClass.prototype.flipPalette = function () {
                var palette = this._palette;
                if (palette.length != 2) {
                    throw "Error - cannot flip palette with length=" + palette.length;
                }

                this._palette = [palette[1], palette[0]];
                this._isFlipped = (!this._isFlipped);

                this.onRangeChanged();
            };

            /** Overrides baseScale's implementation.  This uses barHelper to map the recordIndex
            to an offset in the palette min/max.  This REQUIRES that the palette contain [rangeMin, rangeMax].
            */
            spaceClass.prototype.categoryScale = function (recordIndex, seriesIndex, supressGapSize) {
                var newValue;

                if ((this._isFlipped) && (!this._internalCall)) {
                    this.flipPalette();
                }

                if (this._barHelper) {
                    newValue = this._barHelper.getBarOffset(recordIndex, seriesIndex, supressGapSize);
                } else {
                    newValue = this._baseScale(recordIndex);
                }

                return newValue;
            };

            /** flip the palette before scaling; typically used to reverse the direction of the Y axis. */
            spaceClass.prototype.flipScale = function (value, seriesIndex) {
                if ((!this._isFlipped) && (!this._internalCall)) {
                    this.flipPalette();
                }

                this._internalCall = true;
                var newValue = this.scale(value, seriesIndex);
                this._internalCall = false;

                return newValue;
            };

            spaceClass.prototype.scaleSize = function (value) {
                //---- try to keep values in domain range so they scale correctly ----
                var sv = this.lerpScale(value);
                var sz = this.lerpScale(this._domainMin);

                return Math.abs(sv - sz);
            };

            spaceClass.prototype.autoRange = function (value) {
                if (arguments.length === 0) {
                    return this._autoRange;
                }

                this._autoRange = value;
                return this;
            };
            return spaceClass;
        })(vp.scales.baseScaleClass);
        scales.spaceClass = spaceClass;

        function createSpace() {
            return new spaceClass();
        }
        scales.createSpace = createSpace;

        //export function createCategory()
        //{
        //    return new spaceClass()
        //        .scaleType(vp.scales.ScaleType.linear);
        //}
        /** an interface for xScale and yScale passed to layer when drawing shapes. */
        var ISpaceScale = (function (_super) {
            __extends(ISpaceScale, _super);
            function ISpaceScale() {
                _super.apply(this, arguments);
            }
            return ISpaceScale;
        })(vp.scales.spaceClass);
        scales.ISpaceScale = ISpaceScale;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=space.js.map

///----------------------------------------------------------------
/// (from scales\textSize.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// textSize.ts.  Copyright (c) 2012 Microsoft Corporation.
///     Part of the vuePlot library - textSize scale class.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (scales) {
        var textSizeClass = (function (_super) {
            __extends(textSizeClass, _super);
            function textSizeClass() {
                _super.call(this);

                this.ctr = "vp.scales.textSizeClass";
                this.scaleName = "textSize";

                this._palette = [5, 10, 15, 20, 25, 32, 48];
            }
            return textSizeClass;
        })(vp.scales.baseScaleClass);
        scales.textSizeClass = textSizeClass;

        function createTextSize() {
            return new textSizeClass;
        }
        scales.createTextSize = createTextSize;
    })(vp.scales || (vp.scales = {}));
    var scales = vp.scales;
})(vp || (vp = {}));
//# sourceMappingURL=textSize.js.map
///-----------------------------------------------------------------------------------------------------------------
/// createBins.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library
///     - groups numeric data into a set of "bins".
///     - "bins" are like buckets that group items according to a data range.
///-----------------------------------------------------------------------------------------------------------------
/// returns an array of {min, max, count, density} bin objects for the specified data and binsize.
vp.createBins = function (origData, binCount, addIndexes, niceBuckets, addAssignments)
{
    /// formats a float number where num of decimal digits corresponds to binSize.
    var formatFloat = function(value, binSize)
    {
        var numDigts = 0;

        if (binSize > 0)
        {
            var logSize = Math.log(binSize) / Math.LOG10E;
            if (logSize < 1)
            {
                numDigts = Math.max(0, Math.ceil(-logSize) - 1);
            }
        }

        var str = vp.formatters.comma(value, numDigts);
        return str;
    }

    var bins = [];
    var assignments = [];

    if (binCount > 0)
    {
        var data = vp.cleanData(origData, 0);      // convert non-numbers to 0

        var dataMax = data.max();
        var dataMin = data.min();

        if (dataMin == dataMax)
        {
            binCount = 1;           // single value - force to just 1 data bucket
        }
        else if (niceBuckets)
        {
            //var linearScale = vp.scales.createSpace();    // linear();
            //var extendDomainToZero = false;

            //linearScale.calcNiceParams(dataMin, dataMax, extendDomainToZero, undefined, undefined,
            //    binCount, false);

            var result = vp.scales.niceNumbers.calculate(dataMin, dataMax, false, undefined, undefined, undefined,
                binCount, false);

            dataMin = result.min;
            dataMax = result.max;
            binCount = result.tickCount;
        }

        var dataRange = dataMax - dataMin;
        var binRange = dataRange / binCount;

        //---- build empty bins ----
        var binNum = 1;
       
        for (var i = 0; i < binCount; i++)
        {
            var min = dataMin + (i * binRange);
            var max = Math.min(dataMax, min + binRange);

            var space = (i == binCount - 1) ? "" : " ";

            var name = "[" + formatFloat(min, binRange) + ", " + formatFloat(max, binRange) + space + "]"
            var bin = { min: min, max: max, count: 0, name: name };

            if (addIndexes)
            {
                bin.indexes = [];
            }

            bins.push(bin);

            binNum++;
        }

        //---- fill bins ----
        for (var i = 0; i < data.length; i++)
        {
            var value = data[i];
            var fltIndex = (binRange === 0) ? 0 : ((value - dataMin) / binRange);
            var binIndex = Math.max(0, Math.floor(fltIndex - vp.utils.epsilon));

            /// this shouldn't happen but still does in some instances.
            if (binIndex >= bins.length)
            {
                binIndex = bins.length - 1;
            }

            var bin = bins[binIndex];
            bin.count = bin.count + 1;

            if (addIndexes)
            {
                bin.indexes.push(i);
            }

            if (addAssignments)
            {
                assignments[i] = binIndex;
            }
        }

        //---- add "density" field ----   
        var itemCount = data.length;

        for (var i = 0; i < bins.length; i++)
        {
            var bin = bins[i];
            bin.density = bin.count / itemCount;
        }

        var maxCount = bins.max(function (data) { return data.count });
        var maxDensity = bins.max(function (data) { return data.density });

        for (var i = 0; i < bins.length; i++)
        {
            var bin = bins[i];

            //---- add "ncount" field (count scaled to maximum of 1) ----
            bin.ncount = bin.count / maxCount;

            //---- add "ndensity" field (density scaled to maximum of 1) ----
            bin.ndensity = bin.density / maxDensity;
        }
    }

    if (addAssignments)
    {
        bins.assignments = assignments;
    }

    return bins;
};


///----------------------------------------------------------------
/// (from stats\createBoxPlotData.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// createBoxPlotData.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library
///     - groups the ycol data by the xcol and then calcuates the quartile stats for a boxplot.
///-----------------------------------------------------------------------------------------------------------------
vp.createBoxPlotData = function (data, xCol, yCol, whiskerType)
{
    function getPercentile(sdata, percentile)
    {
        var index = Math.round(percentile/100 * (sdata.length-1));
        var value = sdata[index];

        return value;
    }

    function getStdDev(sdata)
    {
        var mean = sdata.sum() / sdata.length;

        var diffs = sdata.map(function (value, index)
        {
            var diffSq = (value - mean) * (value - mean);
            return diffSq;
        });

        var meanDiff = diffs.sum() / sdata.length;
        
        var stdDev = Math.sqrt(meanDiff);
        return stdDev;
    }
    
    var totalCount = data.length;

    var groups = data.groupBy(xCol);

    var boxData = groups.map(function (group, index)
    {
        var ydata = group.values.map(function (data, index) { return data[yCol]; });

        var sdata = ydata.orderByNum();
        var median = 0;
        var q1 = 0;
        var q3 = 0;

        var count = sdata.length;
        var index = Math.floor(count/2);

        if (count > 1)
        {
            //---- we are using "method 2" from this Quartile definition: http://en.wikipedia.org/wiki/Quartile ----
            if (count % 2)
            {
                //---- count is ODD - use middle value ----
                median = sdata[index];

                var lowIndex = Math.floor(index / 2);
                q1 = (sdata[lowIndex] + sdata[lowIndex + 1]) / 2;

                var highIndex = index + lowIndex;
                q3 = (sdata[highIndex] + sdata[highIndex + 1]) / 2;
            }
            else
            {
                //---- count is EVEN - must average 2 middle values ----
                var before = sdata[index - 1];
                var after = sdata[index];

                median = (before + after) / 2;

                var lowIndex = Math.floor(index / 2);
                q1 = sdata[lowIndex];
                q3 = sdata[index + lowIndex + 1];
            }
        }
        else
        {
            median = sdata[0];
            q1 = median;
            q3 = median;
        }

        var yMin = sdata[0];
        var yMax = sdata[count-1];

        var iqr = q3 - q1;
        var lowFence, highFence;

        if (whiskerType == 0)
        {
            //---- minMax ----
            lowFence = yMin;
            highFence = yMax;
        }
        else if (whiskerType == 1)
        {
            //---- tukey ----
            lowFence = Math.max(yMin, q1 - 1.5 * iqr);
            highFence = Math.min(yMax, q3 + 1.5 * iqr);
        }
        else if (whiskerType == 2)
        {
            //---- percentiles9to91 ----
            lowFence = getPercentile(sdata, 9);
            highFence = getPercentile(sdata, 91);
        }
        else if (whiskerType == 3)
        {
            //---- percentile2to98 ----
            lowFence = getPercentile(sdata, 2);
            highFence = getPercentile(sdata, 98);
        }
        else
        {
            //---- stdDev ----
            var stdDev = getStdDev(sdata);
            var mean = sdata.sum() / sdata.length;

            lowFence = mean - stdDev;
            highFence = mean + stdDev;
        }
        
        var outliers = [];

        vp.utils.debug("vp.createBoxPlotData: sdata.length=" + sdata.length);

        //---- build list of outliers ----
        for (var s = 0; s < sdata.length; s++)
        {
            //if (s % 300 === 0)
            //{
            //    vp.utils.debug("vp.createBoxPlotData: in loop with s=" + s);
            //}

            var value = sdata[s];
            if (value < lowFence)
            {
                outliers.push(value);
            }
            else if (value > highFence)
            {
                outliers.push(value);
            }
        }

        var result =
        {
            name: group.values[0][xCol], lower: q1, middle: median, upper: q3, yMin: yMin, yMax: yMax,
            lowFence: lowFence, highFence: highFence, outliers: outliers
        };

        vp.utils.debug("vp.createBoxPlotData: result.lower=" + result.lower);

        return result;
    });

    return boxData;
};

///----------------------------------------------------------------
/// (from stats\createCategoryBins.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// createCategoryBins.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the vuePlot library
///     - return an array of counts/density for each unique value.
///-----------------------------------------------------------------------------------------------------------------
vp.createCategoryBins = function (vector, colName, addAssignments)
{
    var totalCount = vector.length;
    //var groups = vector.groupBy();
    var assignments = [];
    var keyMap = {};
    var groups = [];

    for (var i = 0; i < vector.length; i++)
    {
        var key = vector[i];
        var bucket = keyMap[key];

        if (!bucket)
        {
            bucket = { count: 0, key: key, name: key, bucketIndex: groups.length};
            keyMap[key] = bucket;

            groups.push(bucket);
        }

        bucket.count++;

        if (addAssignments)
        {
            assignments[i] = bucket.bucketIndex;
        }
    }

    var binData = groups.map(function (data, index)
    {
        var count = data.count;

        var retObj = { count: count, density: count / totalCount};
        retObj[colName] = data.key;

        return retObj;
    });

    if (addAssignments)
    {
        binData.assignments = assignments;
    }

    return binData;
};
///-----------------------------------------------------------------------------------------------------------------
/// excelTheme.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - defines the Excel theme for vuePlot chars.
///-----------------------------------------------------------------------------------------------------------------

vp.themes = vp.themes || {};        // ensure namespace is defined

vp.themes.excel = function ()
{
    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.themes.excel";

    /// public: getInteractionColors()
    closure.getInteractionColors = function ()
    {
        var ic = {};

        ic.selectedColor = "yellow";
        ic.nonSelectedColor = "black";
        ic.highlightColor = "orange";

        return ic;
    };

    /// public: getDrawingAttributes()
    closure.getDrawingAttributes = function (part)
    {
        var ab = {};

        //---- get attribute defaults ----
        ab.color = "blue",
        ab.fill = "red";
        ab.shape = 19;              // solid colored circle
        ab.shapeSize = 8;           // pixels
        ab.lineSize = 1;            // pixels
        ab.textSize = 11;           // font-size in points
        ab.hAlign = .5;             // text is centered horizontally
        ab.vAlign = .5;             // text is centered vertically

        ab.textSize = "11pt";           // font-size in points
        ab.fontFamily = "arial";

        //---- get the part-specific attributes ----
        switch (part)
        {
            //---- GRAPH ----
            case "layerGraph.edge":
                ab.color = "black";
                break;

            case "layerGraph.text":
                ab.color = "black";
                break;

            case "layerGraph.node":
                ab.color = "black"
                ab.fill = "yellow";
                break;

            case "layerGraph.arrow":
                ab.color = "black"
                break;

            //---- POINT ----
            case "layerPoint":
                ab.fill = "blue";
                break;
        }

        return ab;
    };

    //---- init code ----
    return closure;
};



///----------------------------------------------------------------
/// (from themes\grayTheme.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// grayTheme.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - defines the default theme for vuePlot charts: gray.
///-----------------------------------------------------------------------------------------------------------------

vp.themes = vp.themes || {};        // ensure namespace is defined
vp.themeCallback = null;

vp.themes.gray = function ()
{
    //---- private state ----
    var fillPalette = vp.colorPalettes.grays(8, .8, .2);
    var strokePalette = vp.colorPalettes.grays(8, .8, .1);

    var gridLineColor = "#ccc";
    var tickColor = "#777";          // "#e0e0e0" is too light for ticks against a gray background
    var skipTickColor = "#808080";

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.themes.gray";

    closure.setCallback = function (callback)
    {
        vp.themeCallback = callback;
    };

    closure.fillPalette = function ()
    {
        return fillPalette;
    };

    //---- public: getDrawingAttributes ----
    closure.getDrawingAttributes = function (part, seriesIndex)
    {
        seriesIndex = (seriesIndex === undefined) ? 0 : seriesIndex;     // default value if undefined
        var ab = {isThemeAttr: true};

        //---- DEFAULT values ----

        //---- SHAPE ----
        ab.shapeType = 0;           // 0=circle
        ab.shapeSize = 8;           // pixels

        ab.fill = "gray";
        ab.stroke = "gray";
        ab.fillPalette = fillPalette;
        ab.strokePalette = strokePalette;

        //---- LINE ----
        ab.lineSize = 1;            // pixels
        ab.lineType = 1;            // solid

        //----- TEXT ----
        ab.hAlign = .5;             // text is centered horizontally
        ab.vAlign = .5;             // text is centered vertically
        ab.fontFamily = "tahoma";
        ab.textSize = "11pt";           // font-size in points
        ab.textFill = "black";
        
        //---- margins around element (currently supported for only a few parts) ----
        ab.left = 0;
        ab.top = 0;
        ab.right = 0;
        ab.bottom = 0;

        //---- get the part-specific attributes (these override the defaults) ----
        switch (part)
        {
            //---- SELECTION ----
            case "selected":
                ab = {};        // zap defaults
                ab.stroke = "purple";
                ab.fill = "purple";
               // ab.lineSize = 1;
                break;

            case "unselected":
                ab = {};        // zap defaults
                break;

            case "hover":
                ab = {};        // zap defaults
                ab.stroke = "red";
                ab.fill = "cyan";
                ab.lineSize = 1;
                break;

            //---- DRAG RECT ----
            case "dragRect":
                ab.fill = "transparent";        // "gray";
                ab.stroke = "#303030";
                ab.lineSize = 2;
                ab.lineType = "dashed";
                //ab.opacity = .3;
                break;

            //---- CHART FRAME ----
            case "chartFrame.title":
                ab.fill = "#777";
                ab.textSize = "12pt";
                //ab.fontWeight = "bold";
                ab.top = 0;    
                ab.bottom = 4;
                break;

                //---- to give 1px margins all around, use: "1, 0, 0, 3" ----
                //---- above verified on rfernand8, 6/20/2013, IE10, 100% zoom. ----
            case "chartFrame.margins":
                ab.left = 11;
                ab.top = 10;
                ab.right = 10;
                ab.bottom = 13;
                break;

            case "fastDataGrid.hdrRow":
                ab.font = "bold 10pt Consolas";
                ab.background = "#f0f0f0";
                ab.fill = "#111";
                break;

            case "fastDataGrid.dataRow":
                ab.font = "10pt Consolas";
                ab.boldFont = "bold 10pt Consolas";
                ab.background = "#f0f0f0";
                ab.fill = "#555";
                break;

            case "fastDataGrid.altRow":
                ab.font = "10pt Consolas";
                ab.background = "#e0e0e0";
                ab.fill = "#555";
                break;

            case "fastDataGrid.divider":
                ab.stroke = "#cccccc";
                break;

            case "chartFrame.plotBg":
                ab.fill = "white";
                ab.lineSize = 1;
                ab.stroke = "red";  //gridLineColor;
                break;

            case "chartFrame.gridLines":
                ab.stroke = gridLineColor;
                ab.lineSize = 1;
                break;

                //---- XAXIS ----
            case "xaxis.tick":
                ab.stroke = tickColor;
                ab.lineSize = 1;
                ab.length = 5;
                ab.spaceToLabel = 5;
                break;

            case "xaxis.skipTick":              // tick for a skipped label
                ab.stroke = skipTickColor;
                ab.lineSize = "1";
                ab.length = 5;
                ab.spaceToLabel = 3;
                ab.opacity = 0;             // hide these
                break;

            case "xaxis.label":
                ab.fill = "gray";
                ab.textSize = "10pt";
                break;

            case "xaxis.axisLine":
                ab.stroke = tickColor;
                ab.lineSize = "1";
                break;

            case "xaxis.title":
                ab.fill = "gray";
                ab.textSize = "10pt";
                ab.top = 10;
                ab.bottom = 6;
                break;

                //---- YAXIS ----
            case "yaxis.tick":
                ab.stroke = tickColor;
                ab.lineSize = "1";
                ab.length = 5;
                ab.spaceToLabel = 3;
                break;

            case "yaxis.skipTick":
                ab.stroke = tickColor;
                ab.lineSize = "1";
                ab.length = 5;
                ab.spaceToLabel = 3;
                ab.opacity = 0;     // hide these
                break;

            case "yaxis.label":
                ab.fill = "gray";
                ab.textSize = "10pt";
                break;

            case "yaxis.axisLine":
                ab.stroke = tickColor;
                ab.lineSize = "1";
                break;

            case "yaxis.title":
                ab.fill = "gray";
                ab.textSize = "10pt";
                ab.left = 4;
                break;

            //---- LEGEND ----
            case "legend.title":
                ab.textSize = "10pt";
                ab.fill = "#444";
                ab.bottom = -5;
                break;

            case "legend.key":
                ab.shapeWidth = 20;
                ab.shapeHeight = 20;
                ab.fill = "gray";
                ab.stroke = "white";
                ab.lineSize = 0;
                break;

            case "legend.keyText":
                ab.fill = "gray";
                ab.textSize = "10pt";
                break;

            case "legend.box":
                ab.fill = "transparent";
                ab.stroke = "darkgray";
                ab.lineSize = 1;
                ab.right = 26;              // why so much needed?
                break;

            case "legend.tick":
                ab.stroke = "gray";
                ab.lineSize = 1;
                break;

            //---- LEGEND AXIS ----
            case "legendAxis.tick":
                ab.stroke = tickColor;
                ab.lineSize = "1";
                ab.length = 5;
                ab.spaceToLabel = 3;
                break;

            case "legendAxis.skipTick":
                ab.stroke = tickColor;
                ab.lineSize = "1";
                ab.length = 5;
                ab.spaceToLabel = 3;
                ab.opacity = 0;     // hide these
                break;

            case "legendAxis.label":
                ab.fill = "gray";
                ab.textSize = "10pt";
                break;

            case "legendAxis.axisLine":
                ab.stroke = tickColor;
                ab.lineSize = "0";
                break;

            case "legendAxis.title":
                ab.fill = "gray";
                ab.textSize = "10pt";
                break;

            //---- GRAPH ----
            case "layerGraph.edge":
                ab.stroke = "#aaa";
                break;

            case "layerGraph.text":
                ab.fill = "#777";
                break;

            case "layerGraph.node":
                ab.stroke = "#444"
                ab.fill = "#eee";
                ab.shapeSize = undefined;   // let user define explictly when needed to override node sizing
                break;

            case "layerGraph.arrow":
                ab.stroke = "transparent"
                ab.fill = "#777";
                break;

            //---- POINT ----
            case "layerPoint":
                //---- some shapes only draw with stroke - give user full responsiblity/control -----
                //ab.stroke = "transparent";    
                break;

            //---- AREA ----
            case "layerArea":
                ab.stroke = "transparent";
                break;

            //---- PIE ----
            case "layerPieSlice":
                ab.stroke = "#ccc";
                ab.lineSize = 1;
                break;

            //---- STREAM GRAPH ----
            case "layerStreamGraph":
                ab.stroke = "transparent";
                break;

            //---- LINE ----
            case "layerLine":
                ab.lineSize = 1;
                break;

            //---- CROSSBAR ----
            case "layerCrossBar":
                ab.fill = "transparent";
                break;

            //---- CANDLESTICK ----
            case "layerCandlestick.upDayBar":
                ab.fill = "#333";
                break;

            case "layerCandlestick.downDayBar":
                ab.fill = "white";
                break;

            //---- BOX PLOT ----
            case "layerBoxPlot.box":
                ab.fill = "white";
                ab.stroke = "#777";
                break;

            case "layerBoxPlot.median":
                ab.stroke = "#777";
                ab.lineSize = 2;
                break;

            case "layerBoxPlot.whisker":
                ab.stroke = "#777";
                ab.lineType = 2;        // dashed
                break;

            case "layerBoxPlot.whiskerEnd":
                ab.stroke = "#777";
                ab.length = .36;         // percentage of box width
                break;

            case "layerBoxPlot.outliers":
                ab.fill = "transparent";
                ab.stroke = "#777";
                break;

                //---- HISTOGRAM ----
            case "layerHistogram":
                ab.stroke = "#333";
                ab.lineSize = .5;
                break;

                //---- HISTOGRAM 2D ----
            case "layerHistogram2d":
                ab.stroke = "green";
                ab.lineSize = 0;
                break;

                //---- TREEEMAP ----
            case "layerTreemap":
                ab.fill = "lightgray";
                ab.stroke = "gray";
                ab.lineSize = 0;
                ab.textSize = "11pt";           // font-size in points
                ab.fontFamily = "tahoma";
                ab.textFill = "#444";
                break;
        }

        if (vp.themeCallback)
        {
            vp.themeCallback(part,  seriesIndex, ab);
        }

        return ab;
    };

    //---- init code ----
    return closure;
};



///----------------------------------------------------------------
/// (from themes\themeMgr.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// themeMgr.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - manages the themes for the plot subsystem.
///-----------------------------------------------------------------------------------------------------------------
/// themes are a simplified stying system, designed for use by the parts of a plot:
///     - axes, title, legend, plotPanel, and the various layers
///
/// themes are designed to be quick and cross-platform (easy to implement in javascript,
///     c#, c++).  when a theme is changed, it only affects any new plots built, or plots that are rebuilt.
///-----------------------------------------------------------------------------------------------------------------
vp.session.themeMgrClass = function ()
{
    //---- private state ----
    var theme = null;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.session.themeMgrClass";

    //---- property: theme ----
    closure.theme = function (value)
    {
        if (arguments.length == 0)
        {
            if (!theme)
            {
                //---- create on first demand to avoid init dependency issues ----
                theme = vp.themes.gray();   // the default
            }
            return theme;
        }

        theme = value; 
        return closure;
    };

    //---- init code ----
    return closure;
};

/// this is the global instance of the themeMgr that vuePlot client code should reference.
vp.session.themeMgr = vp.session.themeMgrClass();

vp.session.currentTheme = function ()
{
    return vp.session.themeMgr.theme();
};


///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (internal) {
        (function (System) {
            var InvalidOperationException = (function () {
                function InvalidOperationException(s) {
                }
                return InvalidOperationException;
            })();
            System.InvalidOperationException = InvalidOperationException;

            var ArgumentOutOfRangeException = (function () {
                function ArgumentOutOfRangeException(a, v, s) {
                }
                return ArgumentOutOfRangeException;
            })();
            System.ArgumentOutOfRangeException = ArgumentOutOfRangeException;

            var AssertionException = (function () {
                function AssertionException(e) {
                }
                return AssertionException;
            })();
            System.AssertionException = AssertionException;
        })(internal.System || (internal.System = {}));
        var System = internal.System;
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));

var vp;
(function (vp) {
    (function (internal) {
        (function (System) {
            (function (Diagnostics) {
                var Debug = (function () {
                    function Debug() {
                    }
                    Debug.Assert = function (e) {
                        if (typeof (e) == "boolean") {
                            if (!e)
                                throw new vp.internal.System.AssertionException(e);
                        } else if (typeof (e) == "string") {
                            if (e == null || e == "")
                                throw new vp.internal.System.AssertionException(e);
                        } else {
                            if (e == null)
                                throw new vp.internal.System.AssertionException(e);
                        }
                    };

                    Debug.AssertNotEmpty = function (s) {
                        Debug.Assert(s);
                    };
                    return Debug;
                })();
                Diagnostics.Debug = Debug;
            })(System.Diagnostics || (System.Diagnostics = {}));
            var Diagnostics = System.Diagnostics;
        })(internal.System || (internal.System = {}));
        var System = internal.System;
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));
//# sourceMappingURL=-system.js.map

///----------------------------------------------------------------
/// (from treemap\emptySpace.js)
///----------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (internal) {
        internal.MAX_VALUE = 9007199254740992;
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));

var vp;
(function (vp) {
    (function (internal) {
        (function (Microsoft) {
            (function (Treemap) {
                (function (Generator) {
                    (function (EmptySpaceLocation) {
                        EmptySpaceLocation[EmptySpaceLocation["DeterminedByLayoutAlgorithm"] = 0] = "DeterminedByLayoutAlgorithm";
                        EmptySpaceLocation[EmptySpaceLocation["Top"] = 1] = "Top";
                    })(Generator.EmptySpaceLocation || (Generator.EmptySpaceLocation = {}));
                    var EmptySpaceLocation = Generator.EmptySpaceLocation;

                    (function (LayoutAlgorithm) {
                        LayoutAlgorithm[LayoutAlgorithm["BottomWeightedSquarified"] = 0] = "BottomWeightedSquarified";
                        LayoutAlgorithm[LayoutAlgorithm["TopWeightedSquarified"] = 1] = "TopWeightedSquarified";
                    })(Generator.LayoutAlgorithm || (Generator.LayoutAlgorithm = {}));
                    var LayoutAlgorithm = Generator.LayoutAlgorithm;

                    (function (NodeLevelsWithText) {
                        NodeLevelsWithText[NodeLevelsWithText["All"] = 0] = "All";
                        NodeLevelsWithText[NodeLevelsWithText["Leaves"] = 1] = "Leaves";
                        NodeLevelsWithText[NodeLevelsWithText["None"] = 2] = "None";
                        NodeLevelsWithText[NodeLevelsWithText["Range"] = 3] = "Range";
                    })(Generator.NodeLevelsWithText || (Generator.NodeLevelsWithText = {}));
                    var NodeLevelsWithText = Generator.NodeLevelsWithText;

                    (function (ContentLocation) {
                        ContentLocation[ContentLocation["CenteredText"] = 0] = "CenteredText";
                        ContentLocation[ContentLocation["TopText"] = 1] = "TopText";
                        ContentLocation[ContentLocation["OwnerDraw"] = 2] = "OwnerDraw";
                    })(Generator.ContentLocation || (Generator.ContentLocation = {}));
                    var ContentLocation = Generator.ContentLocation;

                    //*****************************************************************************
                    //    Class: EmptySpace
                    //
                    /// <summary>
                    ///    Represents the empty space within a parent rectangle.
                    /// </summary>
                    ///
                    /// <remarks>
                    ///    The <see cref="Node.Nodes" /> collection owned by each <see cref="Node" />
                    ///    object has an <see cref="Nodes.EmptySpace" /> property.  EmptySpace has a
                    ///    <see cref="SizeMetric" /> property that determines how much empty space
                    ///    appears in the the parent rectangle corresponding to the <see
                    /// cref="Node" />.
                    ///
                    ///    <para>
                    ///    The location of the empty space is determined by the <see
                    /// cref="ITreemapComponent.EmptySpaceLocation" /> property.
                    ///    </para>
                    ///
                    ///    <para>
                    ///    See <see cref="Node.SizeMetric" /> for details on how the size of each
                    /// node rectangle is computed and how EmptySpace is involved in the
                    ///    computations.
                    ///    </para>
                    ///
                    ///    </remarks>
                    ///
                    ///    <seealso cref="Node.SizeMetric" />
                    ///    <seealso cref="ITreemapComponent.EmptySpaceLocation" />
                    //*****************************************************************************
                    var EmptySpace = (function () {
                        //*************************************************************************
                        //    Constructor: EmptySpace()
                        //
                        /// <summary>
                        ///    Initializes a new instance of the EmptySpace class.
                        /// </summary>
                        //*************************************************************************
                        function EmptySpace() {
                            this.m_fSizeMetric = 0;
                            this.m_oTreemapGenerator = null;
                        }
                        Object.defineProperty(EmptySpace.prototype, "SizeMetric", {
                            //*************************************************************************
                            //    Property: SizeMetric
                            //
                            /// <summary>
                            ///    Gets or sets the size of the empty space in the parent rectangle.
                            /// </summary>
                            ///
                            /// <value>
                            ///    A metric that determines the size of the empty space in the parent
                            /// rectangle.  Must be greater than or equal to zero.  The default value
                            /// is zero, which causes the child rectangles to completely fill the
                            /// parent rectangle.
                            /// </value>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_fSizeMetric);
                            },
                            set: function (value) {
                                // Validate the parameter.
                                Generator.Node.ValidateSizeMetric(value, "EmptySpace.SizeMetric");

                                if (this.m_fSizeMetric != value) {
                                    this.m_fSizeMetric = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(EmptySpace.prototype, "TreemapGenerator", {
                            //*************************************************************************
                            //  Property: TreemapGenerator
                            //
                            /// <summary>
                            /// Sets the object that owns this object.
                            /// </summary>
                            ///
                            /// <value>
                            /// The TreemapGenerator object that owns this object.
                            /// </value>
                            ///
                            /// <remarks>
                            /// This method must be called after this object is added to the
                            ///TreemapGenerator.
                            /// </remarks>
                            //*************************************************************************
                            set: function (value) {
                                // Don't do this.  Here is one scenario in which
                                // m_oTreemapGenerator is not null:
                                //
                                // 1. The user double-clicks a node.
                                //
                                // 2. The double-click handler zooms into the double-clicked node
                                //    by clearing all nodes from the treemap, then adding back the
                                //    double-clicked node.
                                //
                                // Debug.Assert(m_oTreemapGenerator == null);
                                this.m_oTreemapGenerator = value;

                                this.AssertValid();
                            },
                            enumerable: true,
                            configurable: true
                        });

                        //*************************************************************************
                        //    Method: FireRedrawRequired()
                        //
                        /// <summary>
                        ///    Fires the TreemapGenerator.RedrawRequired event if appropriate.
                        /// </summary>
                        ///
                        /// <remarks>
                        /// This should be called when something occurs that affects the treemap's
                        /// appearance.
                        /// </remarks>
                        //*************************************************************************
                        EmptySpace.prototype.FireRedrawRequired = function () {
                            if (this.m_oTreemapGenerator != null)
                                this.m_oTreemapGenerator.FireRedrawRequired();
                        };

                        //*************************************************************************
                        //    Method: AssertValid()
                        //
                        /// <summary>
                        ///    Asserts if the object is in an invalid state.  Debug-only.
                        /// </summary>
                        //*************************************************************************
                        EmptySpace.prototype.AssertValid = function () {
                            Generator.Node.ValidateSizeMetric(this.m_fSizeMetric, "EmptySpace.m_fSizeMetric");
                        };
                        return EmptySpace;
                    })();
                    Generator.EmptySpace = EmptySpace;
                })(Treemap.Generator || (Treemap.Generator = {}));
                var Generator = Treemap.Generator;
            })(Microsoft.Treemap || (Microsoft.Treemap = {}));
            var Treemap = Microsoft.Treemap;
        })(internal.Microsoft || (internal.Microsoft = {}));
        var Microsoft = internal.Microsoft;
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));
//# sourceMappingURL=emptySpace.js.map

///----------------------------------------------------------------
/// (from treemap\generator.js)
///----------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (internal) {
        (function (Microsoft) {
            (function (Treemap) {
                (function (Generator) {
                    var Diag = vp.internal.System.Diagnostics;

                    //*****************************************************************************
                    //	Class: TreemapGenerator
                    //
                    /// <summary>
                    /// Treemap drawing engine.
                    /// </summary>
                    ///
                    /// <remarks>
                    ///	TreemapGenerator is one of two components that render a hierarchical data
                    /// set as a treemap, which is a set of nested rectangles.  The size of each
                    ///	rectangle is determined by a property of each item in the data set, and the
                    ///	rectangle's fill color is determined by another property.
                    ///
                    /// <para>
                    ///	The following table summarizes the two treemap components.
                    /// </para>
                    ///
                    ///	<list type="table">
                    ///
                    ///	<listheader>
                    /// <term>Component</term>
                    /// <term>For Use In</term>
                    /// <term>Required Assemblies</term>
                    ///	</listheader>
                    ///
                    ///	<item>
                    ///	<term>TreemapGenerator</term>
                    ///	<term>
                    ///	Any application that wants to draw a treemap onto a <see cref="Bitmap" />
                    /// or <see cref="Graphics" /> object, or do custom drawing
                    ///	</term>
                    ///	<term>
                    ///	TreemapGenerator.dll
                    ///	</term>
                    ///	</item>
                    ///
                    ///	<item>
                    ///	<term>TreemapControl</term>
                    ///	<term>
                    ///	Windows Forms applications
                    ///	</term>
                    ///	<term>
                    ///	TreemapControl.dll, TreemapGenerator.dll
                    ///	</term>
                    ///	</item>
                    ///
                    ///	</list>
                    ///
                    ///	<para>
                    /// TreemapGenerator is a drawing engine without its own user interface.  It
                    ///	draws on a <see cref="Bitmap" /> object provided by the caller.
                    ///	This allows it to be used in a variety of environments, including Web
                    ///	applications that generate images on the server for downloading to client
                    ///	browsers.
                    ///	</para>
                    ///
                    ///	<para>
                    ///	Using the TreemapGenerator in an application involves three steps:
                    /// <list type="bullet">
                    /// <item>
                    /// <description>Populate the <see cref="Nodes" /> collection
                    ///	</description>
                    /// </item>
                    /// <item>
                    /// <description>
                    ///	Set properties that determine how the treemap is drawn
                    ///	</description>
                    /// </item>
                    /// <item>
                    /// <description>
                    ///	Draw the treemap using one of the <see cref="Draw(Bitmap, Boolean)" />
                    /// methods
                    ///	</description>
                    /// </item>
                    /// </list>
                    ///	</para>
                    ///
                    ///	<para>
                    ///	The <see cref="Nodes" /> property on TreemapGenerator
                    ///	returns a collection of top-level <see cref="Node" /> objects.  Each
                    ///	<see cref="Node" /> object in turn has a <see cref="Node.Nodes" /> property
                    ///	that returns a collection of child <see cref="Node" /> objects.  These
                    ///	nested collections are directly analogous to the Nodes collections in the
                    ///	standard .NET TreeView control.
                    ///	</para>
                    ///
                    ///	<para>
                    ///	Each <see cref="Node" /> object has a <see cref="Node.SizeMetric" />
                    ///	property that determines the size of the node's rectangle relative to other
                    ///	nodes in the collection, <see cref="Node.ColorMetric" /> and <see
                    /// cref="Node.AbsoluteColor" /> properties that determine the rectangle's fill
                    /// color, and a <see cref="Node.Text" /> property that determines the text
                    /// that is drawn within the rectangle.  The text's location within the
                    /// rectangle is determined by the <see cref="TextLocation" /> property.
                    ///	</para>
                    ///
                    ///	<para>
                    /// Several overloaded <see cref="Draw(Bitmap, Boolean)" /> methods are
                    /// provided.  You can draw onto an entire <see cref="Bitmap" />, part of a
                    /// <see cref="Bitmap" />, or a <see cref="Graphics" /> object.  You can
                    /// also implement your own drawing code by calling <see
                    /// cref="Draw(Rectangle)" /> and handling the <see cref="DrawItem" />
                    /// event.
                    ///	</para>
                    ///
                    ///	<para>
                    /// To improve performance, call <see cref="BeginUpdate" /> before populating
                    /// the treemap with nodes.  This prevents the treemap from being immediately
                    /// updated.  Call <see cref="EndUpdate" /> when you are done.
                    ///	</para>
                    ///
                    /// </remarks>
                    ///
                    ///	<example>
                    ///	Here is sample C# code that populates a TreemapGenerator
                    ///	with two top-level nodes, each of which has two child nodes.  A few
                    ///	properties that determine how the treemap is drawn are set, and the treemap
                    ///	is drawn onto a bitmap object.
                    ///
                    /// <code>
                    ///
                    /// protected void
                    /// MakeTreemapBitmap()
                    /// {
                    ///     // Create a TreemapGenerator object.
                    ///
                    ///     TreemapGenerator oTreemapGenerator = new TreemapGenerator();
                    ///
                    ///     // Improve performance by turning off updating while the treemap is
                    ///     // being populated.
                    ///
                    ///     oTreemapGenerator.BeginUpdate();
                    ///     PopulateTreemap(oTreemapGenerator);
                    ///     oTreemapGenerator.EndUpdate();
                    ///
                    ///     // Set some properties on the treemap and draw it onto a bitmap.
                    ///
                    ///     SetTreemapProperties(oTreemapGenerator);
                    ///     DrawTreemap(oTreemapGenerator);
                    /// }
                    ///
                    /// protected void
                    /// PopulateTreemap(TreemapGenerator oTreemapGenerator)
                    /// {
                    ///     Nodes oNodes;
                    ///     Node oNode;
                    ///     Nodes oChildNodes;
                    ///     Node oChildNode;
                    ///
                    ///     // Get the collection of top-level nodes.
                    ///
                    ///     oNodes = oTreemapGenerator.Nodes;
                    ///
                    ///     // Add a top-level node to the collection.
                    ///
                    ///     oNode = oNodes.Add("Top Level 1", 25F, 100F);
                    ///
                    ///     // Add child nodes to the top-level node.
                    ///
                    ///     oChildNodes = oNode.Nodes;
                    ///     oChildNode = oChildNodes.Add("Child 1-1", 90F, 2.5F);
                    ///     oChildNode = oChildNodes.Add("Child 1-2", 10F, -34.5F);
                    ///
                    ///     // Add another top-level node.
                    ///
                    ///     oNode = oNodes.Add("Top Level 2", 50F, -40.1F);
                    ///
                    ///     // Add child nodes to the second top-level node.
                    ///
                    ///     oChildNodes = oNode.Nodes;
                    ///     oChildNode = oChildNodes.Add("Child 2-1", 61F, 0F);
                    ///     oChildNode = oChildNodes.Add("Child 2-2", 100F, 200F);
                    ///
                    ///     // (As an alternative to making multiple calls to the Nodes.Add
                    ///     // method, the component can be populated via an XML string
                    ///     // passed to the TreemapGenerator.NodesXml property.)
                    /// }
                    ///
                    /// protected void
                    /// SetTreemapProperties(TreemapGenerator oTreemapGenerator)
                    /// {
                    ///     // All TreemapGenerator properties have default values that yield
                    ///     // reasonable results in many cases.  We want to change the
                    ///     // range of colors for this example.
                    ///
                    ///     // Make Node.ColorMetric values of -200 to 200 map to a color
                    ///     // range between blue and yellow.
                    ///
                    ///     oTreemapGenerator.MinColorMetric = -200F;
                    ///     oTreemapGenerator.MaxColorMetric = 200F;
                    ///
                    ///     oTreemapGenerator.MinColor = Color.Blue;
                    ///     oTreemapGenerator.MaxColor = Color.Yellow;
                    ///
                    ///     // (If desired, set other properties that determine border widths,
                    ///     // spacing between rectangles, fonts, etc.)
                    /// }
                    ///
                    /// protected void
                    /// DrawTreemap(TreemapGenerator oTreemapGenerator)
                    /// {
                    ///     // Create a bitmap.
                    ///
                    ///     Bitmap oBitmap = new Bitmap(200, 200);
                    ///
                    ///     // Draw the treemap onto the bitmap.
                    ///
                    ///     oTreemapGenerator.Draw(oBitmap, false);
                    ///
                    ///     // (Do something with the bitmap...)
                    /// }
                    ///
                    /// </code>
                    ///
                    ///	</example>
                    //*****************************************************************************
                    var TreemapGenerator = (function () {
                        /// Minimum value allowed for the <see cref="DiscreteNegativeColors" />
                        /// and <see cref="DiscretePositiveColors" /> properties.
                        /// </summary>
                        //*************************************************************************
                        //	Constructor: TreemapGenerator()
                        //
                        /// <summary>
                        /// Initializes a new instance of the TreemapGenerator class.
                        /// </summary>
                        //*************************************************************************
                        function TreemapGenerator(displayRoot) {
                            this.m_displayRoot = displayRoot;
                            this.m_oNodes = new Generator.Nodes(null);
                            this.m_oNodes.TreemapGenerator = this;

                            this.m_iPaddingPx = 5;
                            this.m_iPaddingDecrementPerLevelPx = 1;
                            this.m_iPenWidthPx = 3;
                            this.m_iPenWidthDecrementPerLevelPx = 1;

                            this.m_oBackColor = internal.System.Drawing.SystemColors.Window;
                            this.m_oBorderColor = internal.System.Drawing.SystemColors.WindowFrame;

                            this.m_sFontFamily = "Arial";
                            this.m_fFontNormSizePt = 8;
                            this.m_fFontMinSizePt = 4;
                            this.m_fFontMaxSizePt = 48;
                            this.m_fFontIncrementPt = 2;

                            this.m_oFontSolidColor = internal.System.Drawing.SystemColors.WindowText;
                            this.m_iFontMinAlpha = 105;
                            this.m_iFontMaxAlpha = 255;
                            this.m_iFontAlphaIncrementPerLevel = 50;

                            this.m_fAnimDuration = 400; // default animation duration
                            this.m_bIsAnimationEnabled = true;

                            this.m_oSelectedFontColor = internal.System.Drawing.SystemColors.HighlightText;
                            this.m_oSelectedBackColor = internal.System.Drawing.SystemColors.Highlight;

                            this.m_iNodeLevelsWithText = 0 /* All */;
                            this.m_iMinNodeLevelWithText = 0;
                            this.m_iMaxNodeLevelWithText = 999;

                            this.m_eContentLocation = 1 /* TopText */;
                            this.m_ownerDraw = null;
                            this.m_eEmptySpaceLocation = 0 /* DeterminedByLayoutAlgorithm */;
                            this.m_oSelectedNode = null;

                            this.m_bInBeginUpdate = false;

                            this.m_eLayoutAlgorithm = 0 /* BottomWeightedSquarified */;
                        }
                        Object.defineProperty(TreemapGenerator.prototype, "Nodes", {
                            //*************************************************************************
                            //	Property: Nodes
                            //
                            /// <summary>
                            ///	Gets the collection of top-level <see cref="Node" /> objects.
                            /// </summary>
                            ///
                            /// <value>
                            ///	A <see cref="Microsoft.Research.CommunityTechnologies.Treemap.Nodes" />
                            ///	collection of top-level <see cref="Node" /> objects.
                            /// </value>
                            ///
                            /// <remarks>
                            ///	Items in the collection can be accessed by a zero-based index.  They
                            /// can also be enumerated.
                            /// </remarks>
                            ///
                            ///	<seealso cref="Microsoft.Research.CommunityTechnologies.Treemap.Nodes"
                            ///	/>
                            ///	<seealso cref="Microsoft.Research.CommunityTechnologies.Treemap.Node" />
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oNodes);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(TreemapGenerator.prototype, "LayoutAlgorithm", {
                            //*************************************************************************
                            //	Property: LayoutAlgorithm
                            //
                            /// <summary>
                            ///	Gets or sets the algorithm used to lay out the treemap's rectangles.
                            /// </summary>
                            ///
                            /// <value>
                            /// A <see cref="Microsoft.Research.CommunityTechnologies.Treemap.
                            /// LayoutAlgorithm" /> enumeration that indicates how the treemap's
                            /// rectangles are laid out.  The default value is
                            /// LayoutAlgorithm.BottomWeightedSquarified.
                            /// </value>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_eLayoutAlgorithm);
                            },
                            set: function (value) {
                                if (this.m_eLayoutAlgorithm != value) {
                                    this.m_eLayoutAlgorithm = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "PaddingPx", {
                            //*************************************************************************
                            //	Property: PaddingPx
                            //
                            /// <summary>
                            /// Gets or sets the padding that is added to the rectangles for top-level
                            ///	nodes.
                            /// </summary>
                            ///
                            /// <value>
                            /// The padding that is added to the rectangles for top-level nodes, in
                            ///	pixels.  The value must be between
                            ///	<see cref="TreemapGenerator.MinPaddingPx" /> and
                            /// <see cref="TreemapGenerator.MaxPaddingPx" />.  The default value is 5.
                            /// </value>
                            ///
                            /// <remarks>
                            /// The rectangle of a top-level node is drawn using a pen of width <see
                            /// cref="PenWidthPx" /> along the node's interior.  The rectangle formed
                            /// by the interior edges of that rectangle is then shrunk by <see
                            /// cref="PaddingPx" />, and the node's children are drawn within that
                            /// shrunken rectangle.
                            ///
                            /// <para>
                            ///	If the <see cref="PaddingDecrementPerLevelPx" /> property is 0,
                            ///	PaddingPx is the padding that is added to all node rectangles.
                            ///	Otherwise, <see cref="PaddingDecrementPerLevelPx" /> is subtracted from
                            ///	the padding at each node level.  Decreasing the padding at lower levels
                            ///	can improve the general appearance of the treemap.
                            /// </para>
                            ///
                            /// </remarks>
                            ///
                            ///	<seealso cref="PaddingDecrementPerLevelPx" />
                            ///	<seealso cref="MinPaddingPx" />
                            ///	<seealso cref="MaxPaddingPx" />
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_iPaddingPx);
                            },
                            set: function (value) {
                                if (value < TreemapGenerator.MinPaddingPx || value > TreemapGenerator.MaxPaddingPx) {
                                    throw new vp.internal.System.ArgumentOutOfRangeException("PaddingPx", value, "TreemapGenerator.PaddingPx: Must be between " + TreemapGenerator.MinPaddingPx + " and " + TreemapGenerator.MaxPaddingPx + ".");
                                }

                                if (this.m_iPaddingPx != value) {
                                    this.m_iPaddingPx = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "PaddingDecrementPerLevelPx", {
                            //*************************************************************************
                            //	Property: PaddingDecrementPerLevelPx
                            //
                            /// <summary>
                            /// Gets or sets the number of pixels that is subtracted from the padding
                            ///	at each node level.
                            /// </summary>
                            ///
                            /// <value>
                            /// The number of pixels that is subtracted from the rectangle padding
                            ///	at each node level.  The value must be between
                            ///	<see cref="TreemapGenerator.MinPaddingDecrementPerLevelPx" /> and
                            ///	<see cref="TreemapGenerator.MaxPaddingDecrementPerLevelPx" />.  The
                            ///	default value is 1.
                            /// </value>
                            ///
                            /// <remarks>
                            ///	The rectangles for top-level nodes are drawn with a padding of
                            ///	<see cref="PaddingPx" />.  Set PaddingDecrementPerLevelPx to a positive
                            ///	value to force the padding to decrease at each level.  This can improve
                            /// the general appearance of the treemap.  A value of 0 causes all
                            /// nodes to use <see cref="PaddingPx" />.
                            ///
                            ///	<para>
                            /// If <see cref="PaddingPx" /> is 5 and PaddingDecrementPerLevelPx is 1,
                            ///	for example, the padding for the top-level, child, and grandchild nodes
                            ///	will be 5, 4, and 3 pixels, respectively.  Padding is never less than
                            ///	<see cref="MinPaddingPx" /> pixels.
                            ///	</para>
                            ///
                            /// </remarks>
                            ///
                            ///	<seealso cref="PaddingPx" />
                            ///	<seealso cref="MinPaddingDecrementPerLevelPx" />
                            ///	<seealso cref="MaxPaddingDecrementPerLevelPx" />
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_iPaddingDecrementPerLevelPx);
                            },
                            set: function (value) {
                                if (value < TreemapGenerator.MinPaddingDecrementPerLevelPx || value > TreemapGenerator.MaxPaddingDecrementPerLevelPx) {
                                    throw new vp.internal.System.ArgumentOutOfRangeException("PaddingDecrementPerLevelPx", value, "TreemapGenerator.PaddingDecrementPerLevelPx: Must be" + " between " + TreemapGenerator.MinPaddingDecrementPerLevelPx + " and " + TreemapGenerator.MaxPaddingDecrementPerLevelPx + ".");
                                }

                                if (this.m_iPaddingDecrementPerLevelPx != value) {
                                    this.m_iPaddingDecrementPerLevelPx = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "PenWidthPx", {
                            //*************************************************************************
                            //	Property: PenWidthPx
                            //
                            /// <summary>
                            /// Gets or sets the pen width that is used to draw the rectangles for the
                            ///	top-level nodes.
                            /// </summary>
                            ///
                            /// <value>
                            /// The pen width that is used to draw the rectangles for the top-level
                            ///	nodes, in pixels.  The value must be between
                            ///	<see cref="TreemapGenerator.MinPenWidthPx" /> and
                            ///	<see cref="TreemapGenerator.MaxPenWidthPx" />.  The default value is 3.
                            /// </value>
                            ///
                            /// <remarks>
                            /// The rectangle of a top-level node is drawn using a pen of width <see
                            /// cref="PenWidthPx" /> along the node's interior.  The rectangle formed
                            /// by the interior edges of that rectangle is then shrunk by <see
                            /// cref="PaddingPx" />, and the node's children are drawn within that
                            /// shrunken rectangle.
                            ///
                            /// <para>
                            ///	If the <see cref="PenWidthDecrementPerLevelPx" /> property is 0, all
                            /// rectangles are drawn with a pen width of PenWidthPx pixels.  Otherwise,
                            ///	<see cref="PenWidthDecrementPerLevelPx" /> is subtracted from
                            ///	the pen width at each node level.  Decreasing the pen width at lower
                            ///	levels can improve the general appearance of the treemap.
                            /// </para>
                            ///
                            /// </remarks>
                            ///
                            ///	<seealso cref="PenWidthDecrementPerLevelPx" />
                            ///	<seealso cref="MinPenWidthPx" />
                            ///	<seealso cref="MaxPenWidthPx" />
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_iPenWidthPx);
                            },
                            set: function (value) {
                                if (value < TreemapGenerator.MinPenWidthPx || value > TreemapGenerator.MaxPenWidthPx) {
                                    throw new vp.internal.System.ArgumentOutOfRangeException("PenWidthPx", value, "TreemapGenerator.PenWidthPx: Must be between " + TreemapGenerator.MinPenWidthPx + " and " + TreemapGenerator.MaxPenWidthPx + ".");
                                }

                                if (this.m_iPenWidthPx != value) {
                                    this.m_iPenWidthPx = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "PenWidthDecrementPerLevelPx", {
                            //*************************************************************************
                            //	Property: PenWidthDecrementPerLevelPx
                            //
                            /// <summary>
                            /// Gets or sets the number of pixels that is subtracted from the pen
                            ///	width at each node level.
                            /// </summary>
                            ///
                            /// <value>
                            /// The number of pixels that is subtracted from the pen width at each
                            ///	node level.  The value must be between
                            ///	<see cref="TreemapGenerator.MinPenWidthDecrementPerLevelPx" />
                            ///	and <see cref="TreemapGenerator.MaxPenWidthDecrementPerLevelPx" />.
                            ///	The default value is 1.
                            /// </value>
                            ///
                            /// <remarks>
                            ///
                            ///	The rectangles for top-level nodes are drawn with a pen width of
                            ///	<see cref="PenWidthPx" /> pixels.  Set PenWidthDecrementPerLevelPx to
                            ///	a positive value to force the pen width to decrease at each level.
                            /// This can improve the general appearance of the treemap.  A value of 0
                            ///	causes all nodes to use <see cref="PenWidthPx" />.
                            ///
                            ///	<para>
                            /// If <see cref="PenWidthPx" /> is 4 and PenWidthDecrementPerLevelPx is
                            ///	1, for example, the pen width for the top-level nodes will be 4, the
                            ///	width for the child nodes will be 3, the width for the grandchildren
                            ///	will be 2, and so on.  The pen width is never less than <see
                            /// cref="MinPenWidthPx" />.
                            ///	</para>
                            ///
                            /// </remarks>
                            ///
                            ///	<seealso cref="PenWidthPx" />
                            ///	<seealso cref="MinPenWidthDecrementPerLevelPx" />
                            ///	<seealso cref="MaxPenWidthDecrementPerLevelPx" />
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_iPenWidthDecrementPerLevelPx);
                            },
                            set: function (value) {
                                if (value < TreemapGenerator.MinPaddingDecrementPerLevelPx || value > TreemapGenerator.MaxPaddingDecrementPerLevelPx) {
                                    throw new vp.internal.System.ArgumentOutOfRangeException("PenWidthDecrementPerLevelPx", value, "TreemapGenerator.PenWidthDecrementPerLevelPx: Must be" + " between " + TreemapGenerator.MinPaddingDecrementPerLevelPx + " and " + TreemapGenerator.MaxPaddingDecrementPerLevelPx + ".");
                                }

                                if (this.m_iPenWidthDecrementPerLevelPx != value) {
                                    this.m_iPenWidthDecrementPerLevelPx = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "BackColor", {
                            //*************************************************************************
                            //	Property: BackColor
                            //
                            /// <summary>
                            /// Gets or sets the treemap's background color.
                            /// </summary>
                            ///
                            /// <value>
                            /// The treemap's background color, as a <see cref="Color" />.  The default
                            /// value is <see cref="SystemColors.Window" />.
                            /// </value>
                            ///
                            /// <remarks>
                            /// The background color is used to paint the padding between the treemap
                            /// rectangle and the top-level nodes, as well as any empty space in the
                            /// top-level <see cref="Nodes" /> collection.
                            /// </remarks>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oBackColor);
                            },
                            set: function (value) {
                                if (this.m_oBackColor != value) {
                                    this.m_oBackColor = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "BorderColor", {
                            //*************************************************************************
                            //	Property: BorderColor
                            //
                            /// <summary>
                            /// Gets or sets the color of rectangle borders.
                            /// </summary>
                            ///
                            /// <value>
                            ///	The color of the rectangle borders, as a <see cref="Color" />.  The
                            /// default value is <see cref="SystemColors.WindowFrame" />.
                            /// </value>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oBorderColor);
                            },
                            set: function (value) {
                                if (this.m_oBorderColor != value) {
                                    this.m_oBorderColor = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "FontFamily", {
                            //*************************************************************************
                            //	Property: FontFamily
                            //
                            /// <summary>
                            ///	Gets or sets the font family to use for node text.
                            /// </summary>
                            ///
                            /// <value>
                            ///	The name of the font family to use for node text.  The default value is
                            /// Arial.
                            /// </value>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_sFontFamily);
                            },
                            set: function (value) {
                                // Make sure the font exists.
                                var oFont = new vp.internal.System.Drawing.Font(value, 8);
                                var sActualFamilyName = oFont.FontFamily.Name;

                                if (sActualFamilyName.toLowerCase() != value.toLowerCase()) {
                                    throw new vp.internal.System.ArgumentOutOfRangeException("FontFamily", value, "TreemapGenerator.FontFamily: No such font.");
                                }

                                if (this.m_sFontFamily != value) {
                                    this.m_sFontFamily = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "FontSolidColor", {
                            //*************************************************************************
                            //	Property: FontSolidColor
                            //
                            /// <summary>
                            ///	Gets or sets the color to use for unselected node text.
                            /// </summary>
                            ///
                            /// <value>
                            ///	The color to use for the text of unselected nodes, as a <see
                            /// cref="Color" />.  The default value is <see
                            /// cref="SystemColors.WindowText" />.
                            /// </value>
                            ///
                            /// <remarks>
                            /// This must be a solid color, which means its alpha component must be
                            ///	255.  Text can be drawn using transparent colors; see
                            ///	<see cref="SetFontAlphaRange" /> for details.
                            ///
                            /// <para>
                            /// The control's color usage varies with the value of the <see
                            /// cref="TextLocation" /> property.  See <see cref="TextLocation" /> for
                            /// details.
                            /// </para>
                            ///
                            ///	</remarks>
                            ///
                            ///	<seealso cref="SetFontAlphaRange" />
                            ///	<seealso cref="SelectedFontColor" />
                            ///	<seealso cref="SelectedBackColor" />
                            ///	<seealso cref="TextLocation" />
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oFontSolidColor);
                            },
                            set: function (value) {
                                if (value.A != 255) {
                                    throw new vp.internal.System.ArgumentOutOfRangeException("FontSolidColor", value, "TreemapGenerator.FontSolidColor: Must not be" + " transparent.");
                                }

                                if (this.m_oFontSolidColor != value) {
                                    this.m_oFontSolidColor = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "FontNormSizePt", {
                            //*************************************************************************
                            //	Property: FontSolidColor
                            //
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return this.m_fFontNormSizePt;
                            },
                            set: function (value) {
                                if (this.m_fFontNormSizePt != value) {
                                    this.m_fFontNormSizePt = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "AnimationDuration", {
                            //*************************************************************************
                            //	Property: AnimationDuration
                            //
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_bIsAnimationEnabled) ? this.m_fAnimDuration : 0;
                            },
                            set: function (value) {
                                this.m_fAnimDuration = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "IsAnimationEnabled", {
                            //*************************************************************************
                            //	Property: IsAnimationEnabled
                            //
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return this.m_bIsAnimationEnabled;
                            },
                            set: function (value) {
                                this.m_bIsAnimationEnabled = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "SelectedFontColor", {
                            //*************************************************************************
                            //	Property: SelectedFontColor
                            //
                            /// <summary>
                            ///	Gets or sets the color to use for selected node text.
                            /// </summary>
                            ///
                            /// <value>
                            ///	The color to use for the text of the selected node, as a <see
                            /// cref="Color" />.  The default value is <see
                            /// cref="SystemColors.HighlightText" />.
                            /// </value>
                            ///
                            /// <remarks>
                            /// The control's color usage varies with the value of the <see
                            /// cref="TextLocation" /> property.  See <see cref="TextLocation" /> for
                            /// details.
                            /// </remarks>
                            ///
                            ///	<seealso cref="FontSolidColor" />
                            ///	<seealso cref="SelectedBackColor" />
                            ///	<seealso cref="TextLocation" />
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oSelectedFontColor);
                            },
                            set: function (value) {
                                if (this.m_oSelectedFontColor != value) {
                                    this.m_oSelectedFontColor = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "SelectedBackColor", {
                            //*************************************************************************
                            //	Property: SelectedBackColor
                            //
                            /// <summary>
                            ///	Gets or sets the color to use to highlight the selected node.
                            /// </summary>
                            ///
                            /// <value>
                            /// The color to use to highlight the selected node, as a <see
                            /// cref="Color" />.  The default value is <see
                            /// cref="SystemColors.Highlight" />.
                            /// </value>
                            ///
                            /// <remarks>
                            /// The control's color usage varies with the value of the <see
                            /// cref="TextLocation" /> property.  See <see cref="TextLocation" /> for
                            /// details.
                            /// </remarks>
                            ///
                            ///	<seealso cref="FontSolidColor" />
                            ///	<seealso cref="SelectedFontColor" />
                            ///	<seealso cref="TextLocation" />
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oSelectedBackColor);
                            },
                            set: function (value) {
                                if (this.m_oSelectedBackColor != value) {
                                    this.m_oSelectedBackColor = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "NodeLevelsWithText", {
                            //*************************************************************************
                            //	Property: NodeLevelsWithText
                            //
                            /// <summary>
                            ///	Gets or sets the node levels to show text for.
                            /// </summary>
                            ///
                            /// <value>
                            /// A <see cref="Microsoft.Research.CommunityTechnologies.Treemap.
                            /// NodeLevelsWithText" /> enumeration that indicates which node levels
                            /// should include text.  The default value is All.
                            /// </value>
                            ///
                            ///	<seealso cref="TreemapGenerator.SetNodeLevelsWithTextRange" />
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_iNodeLevelsWithText);
                            },
                            set: function (value) {
                                if (this.m_iNodeLevelsWithText != value) {
                                    this.m_iNodeLevelsWithText = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "ContentLocation", {
                            //*************************************************************************
                            //	Property: ContentLocation
                            //
                            /// <summary>
                            ///	Gets or sets the location within a node's rectangle where the node's
                            /// text is shown.
                            /// </summary>
                            ///
                            /// <value>
                            /// A <see cref="Microsoft.Research.CommunityTechnologies.Treemap.
                            /// ContentLocation" /> enumeration that indicates the location of a node's
                            /// text within the node's rectangle.  The default value is <see
                            /// cref="Microsoft.Research.CommunityTechnologies.Treemap.ContentLocation.
                            /// Top" />.
                            /// </value>
                            ///
                            /// <remarks>
                            /// The effects of this property are detailed in the following table.
                            ///
                            ///	<list type="table">
                            ///
                            ///	<listheader>
                            /// <term></term>
                            /// <term>Top</term>
                            /// <term>CenterCenter</term>
                            ///	</listheader>
                            ///
                            ///	<item>
                            ///	<term>Text Location</term>
                            ///	<term>
                            /// The text is displayed at the top of the node's rectangle.  For non-leaf
                            /// nodes, the text is centered and limited to a single line.  For leaf
                            /// nodes, the text is left-justified and can wrap to fill the entire
                            /// rectangle.
                            ///	</term>
                            ///	<term>
                            /// The text is centered both vertically and horizontally within the node's
                            /// rectangle and is limited to a single line.
                            ///	</term>
                            ///	</item>
                            ///
                            ///	<item>
                            ///	<term>Text Size</term>
                            ///	<term>
                            /// All node text is drawn using the font size specified by the minSizePt
                            /// parameter passed to the <see cref="SetFontSizeRange" /> method.  The
                            /// maxSizePt and incrementPt parameters are ignored in this case.
                            ///	</term>
                            ///	<term>
                            /// The size of the font used to draw node text varies from node to node.
                            /// The range of font sizes is specified by the minSizePt, maxSizePt, and
                            /// incrementPt parameters passed to the <see cref="SetFontSizeRange" />
                            /// method.
                            ///	</term>
                            ///	</item>
                            ///
                            ///	<item>
                            ///	<term>Text Transparency</term>
                            ///	<term>
                            /// All node text is opaque and the parameters passed to <see
                            /// cref="SetFontAlphaRange" /> are ignored.
                            ///	</term>
                            ///	<term>
                            /// The transparency of node text can be varied using <see
                            /// cref="SetFontAlphaRange" />.
                            ///	</term>
                            ///	</item>
                            ///
                            ///	<item>
                            ///	<term>Colors</term>
                            ///	<term>
                            /// For non-selected nodes, node text is drawn using <see
                            /// cref="FontSolidColor" /> and is always opaque.  The text's background
                            /// is the color of the node itself.
                            ///
                            /// <para>
                            /// For the selected node, the text is drawn using <see
                            /// cref="SelectedFontColor" /> and is always opaque.  <see
                            /// cref="SelectedBackColor" /> is used for both the text's background and
                            /// for a highlight rectangle drawn around the node's rectangle.
                            /// </para>
                            ///	</term>
                            ///	<term>
                            /// For non-selected nodes, node text is drawn using <see
                            /// cref="FontSolidColor" />, and the transparency of the text can be
                            /// varied using <see cref="SetFontAlphaRange" />.
                            ///
                            /// <para>
                            /// For the selected node, the text is drawn using <see
                            /// cref="SelectedFontColor" /> and is always opaque.  <see
                            /// cref="SelectedBackColor" /> is used for a highlight rectangle drawn
                            /// around the node's rectangle.
                            /// </para>
                            ///
                            /// <para>
                            /// The text's background is always the color of the node itself,
                            /// regardless of whether the node is selected.
                            /// </para>
                            ///	</term>
                            ///	</item>
                            ///
                            ///	</list>
                            ///
                            /// </remarks>
                            ///
                            ///	<seealso cref="SetFontSizeRange" />
                            ///	<seealso cref="SetFontAlphaRange" />
                            ///	<seealso cref="FontSolidColor" />
                            ///	<seealso cref="SelectedFontColor" />
                            ///	<seealso cref="SelectedBackColor" />
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_eContentLocation);
                            },
                            set: function (value) {
                                if (this.m_eContentLocation != value) {
                                    this.m_eContentLocation = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "ContentDrawer", {
                            // get owner draw callback; null if none.
                            get: function () {
                                this.AssertValid();

                                return this.m_ownerDraw;
                            },
                            // set owner draw callback; changes content location to owner draw;
                            // immediately calls SetDrawingContent with the current font and colors
                            set: function (value) {
                                if (this.m_ownerDraw != value) {
                                    this.BeginUpdate();
                                    this.m_ownerDraw = value;
                                    if (value == null)
                                        this.m_eContentLocation = 1 /* TopText */;
                                    else
                                        this.m_eContentLocation = 2 /* OwnerDraw */;

                                    // TODO: call this again if any of them change
                                    this.m_ownerDraw.SetDrawingContext(this.m_sFontFamily, this.m_fFontNormSizePt, this.m_oFontSolidColor, this.m_oSelectedFontColor, this.m_oSelectedBackColor);

                                    this.EndUpdate();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "EmptySpaceLocation", {
                            //*************************************************************************
                            //	Property: EmptySpaceLocation
                            //
                            /// <summary>
                            ///	Gets or sets the location within a node's rectangle where the node's
                            /// empty space is shown.
                            /// </summary>
                            ///
                            /// <value>
                            /// A <see cref="Microsoft.Research.CommunityTechnologies.Treemap.
                            /// EmptySpaceLocation" /> enumeration that indicates the location of a
                            /// node's empty space within the node's rectangle.  The default value is
                            /// <see cref="Microsoft.Research.CommunityTechnologies.Treemap.
                            /// EmptySpaceLocation.DeterminedByLayoutAlgorithm" />.
                            /// </value>
                            ///
                            /// <remarks>
                            /// You can force empty space to appear in a node's rectangle by setting
                            /// the Node.Nodes.EmptySpace.<see
                            /// cref="Microsoft.Research.CommunityTechnologies.Treemap.EmptySpace.
                            /// SizeMetric" /> property to a positive value.  The location of the empty
                            /// space is determined by the <see cref="EmptySpaceLocation" /> property.
                            ///
                            /// <para>
                            ///	See <see cref="Node.SizeMetric" /> for details on how the size of each
                            /// node rectangle is computed and how EmptySpace is involved in the
                            ///	computations.
                            /// </para>
                            ///
                            /// </remarks>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_eEmptySpaceLocation);
                            },
                            set: function (value) {
                                if (this.m_eEmptySpaceLocation != value) {
                                    this.m_eEmptySpaceLocation = value;
                                    this.FireRedrawRequired();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(TreemapGenerator.prototype, "SelectedNode", {
                            //*************************************************************************
                            //	Property: SelectedNode
                            //
                            /// <summary>
                            ///	Gets the selected <see cref="Node" />, if there is one.
                            /// </summary>
                            ///
                            /// <value>
                            /// The selected <see cref="Node" />, or null if there is none.
                            /// </value>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oSelectedNode);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        //*************************************************************************
                        //	Method: GetNodeLevelsWithTextRange()
                        //
                        /// <summary>
                        ///	Gets the range of node levels for which text is shown.
                        /// </summary>
                        ///
                        /// <param name="minLevel">
                        /// Minimum node level.  Level 0 is the top level.
                        /// </param>
                        ///
                        /// <param name="maxLevel">
                        /// Maximum node level.  Level 0 is the top level.
                        /// </param>
                        ///
                        /// <remarks>
                        /// The range returned by this method is used only if <see
                        /// cref="NodeLevelsWithText" /> is set to Range.
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.GetNodeLevelsWithTextRange = function (minLevel, maxLevel) {
                            // TODO: need to return both values
                        };

                        //*************************************************************************
                        //	Method: SetNodeLevelsWithTextRange()
                        //
                        /// <summary>
                        ///	Sets the range of node levels for which text is shown.
                        /// </summary>
                        ///
                        /// <param name="minLevel">
                        /// Minimum node level.  Level 0 is the top level.  Must be greater than or
                        /// equal to 0.
                        /// </param>
                        ///
                        /// <param name="maxLevel">
                        /// Maximum node level.  Level 0 is the top level.  Must be greater than or
                        /// equal to zero and greater than or equal to <paramref name="minLevel" />.
                        /// </param>
                        ///
                        /// <remarks>
                        /// The range specified in this method is used only if <see
                        /// cref="NodeLevelsWithText" /> is set to Range.  The default minimum and
                        /// maximum values are 0 and 999.
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.SetNodeLevelsWithTextRange = function (minLevel, maxLevel) {
                            // Validate the arguments.
                            if (minLevel < 0) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("minLevel", minLevel, "TreemapGenerator.SetNodeLevelsWithTextRange: Must be >= 0.");
                            }

                            if (maxLevel < 0) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("maxLevel", maxLevel, "TreemapGenerator.SetNodeLevelsWithTextRange: Must be >= 0.");
                            }

                            if (maxLevel < minLevel) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("maxLevel", maxLevel, "TreemapGenerator.SetNodeLevelsWithTextRange:" + " Must be >= minLevel.");
                            }

                            this.m_iMinNodeLevelWithText = minLevel;
                            this.m_iMaxNodeLevelWithText = maxLevel;

                            this.FireRedrawRequired();

                            this.AssertValid();
                        };

                        //*************************************************************************
                        //	Method: GetFontSizeRange()
                        //
                        /// <summary>
                        ///	Gets the range of font sizes used for node text.
                        /// </summary>
                        ///
                        /// <param name="minSizePt">
                        /// Minimum font size, in points.
                        /// </param>
                        ///
                        /// <param name="maxSizePt">
                        /// Maximum font size, in points.
                        /// </param>
                        ///
                        /// <param name="incrementPt">
                        /// Increment between font sizes, in points.
                        /// </param>
                        ///
                        /// <remarks>
                        ///	See <see cref="SetFontSizeRange" /> for details on how font sizes are
                        /// specified for node text.
                        /// </remarks>
                        ///
                        ///	<seealso cref="SetFontSizeRange" />
                        //*************************************************************************
                        TreemapGenerator.prototype.GetFontSizeRange = function (minSizePt, maxSizePt, incrementPt) {
                            // TODO: need to return all three values
                        };

                        //*************************************************************************
                        //	Method: SetFontSizeRange()
                        //
                        /// <summary>
                        ///	Sets the range of font sizes used for node text.
                        /// </summary>
                        ///
                        /// <param name="minSizePt">
                        /// Minimum font size, in points.
                        /// </param>
                        ///
                        /// <param name="maxSizePt">
                        /// Maximum font size, in points.
                        /// </param>
                        ///
                        /// <param name="incrementPt">
                        /// Increment between font sizes, in points.
                        /// </param>
                        ///
                        /// <remarks>
                        /// When <see cref="TextLocation" /> is set to <see
                        /// cref="Microsoft.Research.CommunityTechnologies.Treemap.TextLocation.
                        /// Top" />, all node text is drawn using the font size specified by
                        /// the <paramref name="minSizePt" /> parameter.  The <paramref
                        /// name="maxSizePt" /> and <paramref name="incrementPt" /> parameters are
                        /// ignored in this case.
                        ///
                        /// <para>
                        /// When <see cref="TextLocation" /> is set to <see
                        /// cref="Microsoft.Research.CommunityTechnologies.Treemap.TextLocation.
                        /// CenterCenter" />, the size of the font used to draw node text varies
                        /// from node to node.  For each node, the largest font in the range
                        /// specified by <paramref name="minSizePt" />, <paramref
                        /// name="maxSizePt" />, and <paramref name="incrementPt" /> that won't
                        /// exceed the bounds of the node's rectangle is used.
                        /// </para>
                        ///
                        ///	<para>
                        ///	By default, the <see cref="TreemapGenerator" /> uses
                        ///	<paramref name="minSizePt" />=8, <paramref name="maxSizePt" />=100,
                        ///	and <paramref name="incrementPt" />=2.
                        ///	</para>
                        ///
                        /// </remarks>
                        ///
                        ///	<example>
                        /// If <see cref="TextLocation" /> is set to <see
                        /// cref="Microsoft.Research.CommunityTechnologies.Treemap.TextLocation.
                        /// Top" />, <paramref name="minSizePt" /> is 8.0, <paramref
                        /// name="maxSizePt" /> is 10.0, and <paramref name="incrementPt" /> is
                        /// 2.0, all node text is drawn using a font size of 8.0.  (<paramref
                        /// name="maxSizePt" /> and <paramref name="incrementPt" /> are ignored in
                        /// this case.)
                        ///
                        /// <para>
                        /// If <see cref="TextLocation" /> is set to <see
                        /// cref="Microsoft.Research.CommunityTechnologies.Treemap.TextLocation.
                        /// CenterCenter" />, <paramref name="minSizePt" /> is 2.0, <paramref
                        /// name="maxSizePt" /> is 10.0, and <paramref name="incrementPt" /> is
                        /// 2.0, node text is drawn using one of the following font sizes: 2.0,
                        /// 4.0, 6.0, 8.0, 10.0.
                        /// </para>
                        ///
                        ///	</example>
                        //*************************************************************************
                        TreemapGenerator.prototype.SetFontSizeRange = function (minSizePt, normSizePt, maxSizePt, incrementPt) {
                            // Validate the arguments.
                            Microsoft.Treemap.Util.MaximizingFontMapper.ValidateSizeRange(minSizePt, maxSizePt, incrementPt, "TreemapGenerator.SetFontSizeRange()");

                            this.m_fFontNormSizePt = normSizePt;
                            this.m_fFontMinSizePt = minSizePt;
                            this.m_fFontMaxSizePt = maxSizePt;
                            this.m_fFontIncrementPt = incrementPt;

                            this.FireRedrawRequired();

                            this.AssertValid();
                        };

                        //*************************************************************************
                        //	Method: GetFontAlphaRange()
                        //
                        /// <summary>
                        ///	Gets the range of transparency used for node text.
                        /// </summary>
                        ///
                        /// <param name="minAlpha">
                        /// Alpha value used for the level with maximum transparency.
                        /// </param>
                        ///
                        /// <param name="maxAlpha">
                        /// Alpha value used for the level with minimum transparency.
                        /// </param>
                        ///
                        /// <param name="incrementPerLevel">
                        /// Amount that alpha is incremented from level to level.
                        /// </param>
                        ///
                        /// <remarks>
                        ///	See <see cref="SetFontAlphaRange" /> for details on how transparency is
                        /// specified for node text.
                        ///	</remarks>
                        ///
                        ///	<seealso cref="SetFontAlphaRange" />
                        //*************************************************************************
                        TreemapGenerator.prototype.GetFontAlphaRange = function (minAlpha, maxAlpha, incrementPerLevel) {
                            // TODO: need to return all three values
                        };

                        //*************************************************************************
                        //	Method: SetFontAlphaRange()
                        //
                        /// <summary>
                        ///	Sets the range of transparency used for node text.
                        /// </summary>
                        ///
                        /// <param name="minAlpha">
                        /// Alpha value to use for the level with maximum transparency.  Must be
                        ///	between 0 and 255.
                        /// </param>
                        ///
                        /// <param name="maxAlpha">
                        /// Alpha value to use for the level with minimum transparency.  Must be
                        ///	between 0 and 255 and >= <paramref name="minAlpha" />.
                        /// </param>
                        ///
                        /// <param name="incrementPerLevel">
                        /// Amount that alpha should be incremented from level to level.  Must
                        ///	be > 0.
                        /// </param>
                        ///
                        /// <remarks>
                        ///	When <see cref="TextLocation" /> is set to <see cref="Microsoft.
                        /// Research.CommunityTechnologies.Treemap.TextLocation.Top" />, all
                        /// node text is drawn opaque and the values passed to this method are
                        /// ignored.
                        ///
                        /// <para>
                        ///	To improve text legibility when <see cref="TextLocation" /> is set to
                        /// <see cref="Microsoft.Research.CommunityTechnologies.Treemap.
                        /// TextLocation.CenterCenter" />, the <see cref="TreemapGenerator" />
                        /// varies the transparency of node text.  The text for higher-level nodes
                        /// is more transparent than the text for lower-level nodes, so the
                        /// lower-level text shows through the higher-level text.
                        /// </para>
                        ///
                        ///	<para>
                        ///	Alpha values range from 0 (transparent) to 255 (opaque).
                        ///	</para>
                        ///
                        ///	<para>
                        ///	By default, the <see cref="TreemapGenerator" /> uses
                        ///	<paramref name="minAlpha" />=105, <paramref name="maxAlpha" />=255,
                        ///	and <paramref name="incrementPerLevel" />=50.
                        ///	</para>
                        ///
                        /// </remarks>
                        ///
                        ///	<example>
                        ///	If <see cref="TextLocation" /> is set to <see cref="Microsoft.Research.
                        /// CommunityTechnologies.Treemap.TextLocation.CenterCenter" />, <paramref
                        /// name="minAlpha" /> is 55, <paramref name="maxAlpha" /> is 255, and
                        /// <paramref name="incrementPerLevel" /> is 100, then the text for level-0
                        /// (top-level) nodes will be drawn with alpha=55, the text for level-1
                        /// nodes will be drawn with alpha=155, and the text for level-2 nodes and
                        /// below will be drawn with alpha=255.
                        ///	</example>
                        ///
                        ///	<seealso cref="GetFontAlphaRange" />
                        //*************************************************************************
                        TreemapGenerator.prototype.SetFontAlphaRange = function (minAlpha, maxAlpha, incrementPerLevel) {
                            // Validate the arguments.
                            Microsoft.Treemap.GraphicsLib.TransparentBrushMapper.ValidateAlphaRange(minAlpha, maxAlpha, incrementPerLevel, "TreemapGenerator.SetFontAlphaRange");

                            this.m_iFontMinAlpha = minAlpha;
                            this.m_iFontMaxAlpha = maxAlpha;
                            this.m_iFontAlphaIncrementPerLevel = incrementPerLevel;

                            this.FireRedrawRequired();

                            this.AssertValid();
                        };

                        //*************************************************************************
                        //	Method: BeginUpdate()
                        //
                        /// <summary>
                        /// Disables any redrawing of the treemap.
                        /// </summary>
                        ///
                        /// <remarks>
                        /// To improve performance, call BeginUpdate before adding <see
                        /// cref="Node" /> objects to the treemap.  Call <see cref="EndUpdate" />
                        /// when you are done.
                        /// </remarks>
                        ///
                        ///	<seealso cref="EndUpdate" />
                        //*************************************************************************
                        TreemapGenerator.prototype.BeginUpdate = function () {
                            this.AssertValid();

                            this.m_bInBeginUpdate = true;
                        };

                        //*************************************************************************
                        //	Method: EndUpdate()
                        //
                        /// <summary>
                        /// Enables the redrawing of the treemap.
                        /// </summary>
                        ///
                        /// <remarks>
                        /// To improve performance, call <see cref="BeginUpdate" /> before
                        /// adding <see cref="Node" /> objects to the treemap.  Call EndUpdate when
                        /// you are done.
                        /// </remarks>
                        ///
                        ///	<seealso cref="BeginUpdate" />
                        //*************************************************************************
                        TreemapGenerator.prototype.EndUpdate = function () {
                            this.AssertValid();

                            this.m_bInBeginUpdate = false;

                            // Assume the caller made changes between the BeginUpdate() and
                            // EndUpdate() calls that require a redraw.
                            this.FireRedrawRequired();
                        };

                        //*************************************************************************
                        //	Method: Clear()
                        //
                        /// <summary>
                        ///	Removes all nodes from the treemap.
                        /// </summary>
                        //*************************************************************************
                        TreemapGenerator.prototype.Clear = function () {
                            // Cancel any selection.
                            this.CancelSelectedNode();

                            // Remove all top-level nodes.
                            this.m_oNodes.Clear();

                            // TODO: remove notes from display
                            // The treemap needs to be redrawn.
                            this.FireRedrawRequired();

                            this.AssertValid();
                        };

                        //*************************************************************************
                        //	Method: Draw()
                        //
                        /// <summary>
                        /// Draws the treemap onto a <see cref="Graphics" /> object.
                        /// </summary>
                        ///
                        /// <remarks>
                        ///	The selection is not drawn.
                        ///
                        /// <para>
                        /// This method can be used to print the treemap.  To draw the treemap onto
                        /// a <see cref="Bitmap" /> instead, use <see
                        /// cref="Draw(Bitmap, Boolean)" />.
                        /// </para>
                        ///
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.Draw = function () {
                            var treemapRectangle = new vp.internal.System.Drawing.Rectangle(0, 0, this.m_displayRoot.width(), this.m_displayRoot.height());

                            Diag.Debug.Assert(!treemapRectangle.IsEmpty);
                            this.AssertValid();

                            // Compute and draw all the nodes' rectangles.
                            this.CalculateAndDrawRectangles(treemapRectangle, this.m_oNodes, null);

                            if (this.m_iNodeLevelsWithText != 2 /* None */) {
                                // Draw all the text.
                                // Create the object that knows how to draw node text, then tell it to
                                // draw the text for all the nodes in the treemap.
                                var oTextDrawer = this.CreateTextDrawer();

                                oTextDrawer.DrawTextForAllNodes(this.m_displayRoot, this.m_iPaddingPx, this.m_iPaddingDecrementPerLevelPx, this.m_oNodes);
                            }
                        };

                        //*************************************************************************
                        //	Method: GetNodeFromPoint()
                        //
                        /// <overloads>
                        /// Gets the <see cref="Node" /> object containing a specified point.
                        /// </overloads>
                        ///
                        /// <summary>
                        /// Gets the <see cref="Node" /> object containing a specified PointF.
                        /// </summary>
                        ///
                        /// <param name="pointF">
                        /// Point to get a <see cref="Node" /> object for.
                        /// </param>
                        ///
                        /// <param name="node">
                        /// Where the <see cref="Node" /> object gets stored.
                        /// </param>
                        ///
                        /// <returns>
                        ///	true if a <see cref="Node" /> object was found, false if not.
                        /// </returns>
                        ///
                        /// <remarks>
                        ///	This method looks for the innermost node whose rectangle contains the
                        /// specified point.  If found, the <see cref="Node" /> object is stored in
                        ///	<paramref name="node" /> and true is returned.  false is returned
                        ///	otherwise.
                        ///
                        ///	<para>
                        ///	<see cref="Draw(Bitmap, Boolean)" /> should be called before this
                        /// method is used.  If it hasn't been called yet, false is returned.
                        ///	</para>
                        ///
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.GetNodeFromPoint = function (pointF) {
                            // Let the m_oNodes collection do the work.
                            return this.m_oNodes.GetNodeFromPoint(pointF);
                        };

                        //*************************************************************************
                        //	Method: SelectNode()
                        //
                        /// <summary>
                        ///	Selects a node.
                        /// </summary>
                        ///
                        /// <param name="node">
                        /// The <see cref="Node" /> to select.  Specify null to remove the
                        ///	selection.
                        /// </param>
                        ///
                        /// <param name="bitmap">
                        /// If <see cref="Draw(Bitmap, Boolean)" /> has already been called, this
                        /// should be the same Bitmap that was passed to <see
                        /// cref="Draw(Bitmap, Boolean)" />.  Otherwise, specify null.  <paramref
                        /// name="node" /> will then be drawn as selected the first time <see
                        /// cref="Draw(Bitmap, Boolean)" /> is called.
                        /// </param>
                        ///
                        /// <remarks>
                        ///	This redraws the specified node's rectangle and text to show it as
                        ///	selected.  If another node was already selected, it gets redrawn as
                        ///	unselected.
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.SelectNode = function (node) {
                            // Make the documentation tools happy without having to use camel
                            // casing throughout this method.
                            var oNode = node;

                            if (oNode != null) {
                                oNode.AssertValid();

                                // If the node is already selected, do nothing.
                                if (oNode == this.m_oSelectedNode)
                                    return;
                            }

                            this.CancelSelectedNode();

                            if (oNode != null) {
                                // Draw oNode as selected.
                                this.DrawNodeAsSelected(oNode);
                            }

                            this.m_oSelectedNode = oNode;
                        };

                        //*************************************************************************
                        //	Method: CalculateAndDrawRectangles()
                        //
                        /// <summary>
                        /// Calculates and draws the rectangles for a collection of Node objects
                        /// and all their descendents.
                        /// </summary>
                        ///
                        /// <param name="oTreemapRectangle">
                        /// Outer rectangle for the entire treemap.
                        /// </param>
                        ///
                        /// <param name="oNodes">
                        /// Collection of Node objects.
                        /// </param>
                        ///
                        /// <param name="oParentNode">
                        /// Parent of oNodes, or null if oNodes are top-level.
                        /// </param>
                        //*************************************************************************
                        TreemapGenerator.prototype.CalculateAndDrawRectangles = function (oTreemapRectangle, oNodes, oParentNode) {
                            Diag.Debug.Assert(oNodes != null);
                            this.AssertValid();

                            // Paint the background.
                            var oBackgroundBrush = this.m_oBackColor;

                            // TODO: overall background        displayRoot.FillRectangle(oBackgroundBrush, oTreemapRectangle);
                            // Create an object that knows how to lay out a treemap.
                            var oLayoutEngine = this.CreateLayoutEngine();

                            // Calculate the rectangles for all the nodes.
                            this.CalculateRectangles(oNodes, oTreemapRectangle, oParentNode, this.GetTopLevelTopPaddingPx(), this.m_iPaddingPx, this.m_iPenWidthPx, oLayoutEngine);

                            // Create an object that creates and caches pens.
                            // var oPenCache = new Microsoft.Treemap.GraphicsLib.PenCache();
                            // oPenCache.Initialize(this.m_oBorderColor);
                            // Draw all the rectangles.
                            this.DrawRectangles(oNodes, 0, this.m_oBorderColor);
                        };

                        //*************************************************************************
                        //	Method: CalculateRectangles()
                        //
                        /// <summary>
                        /// Calculates the rectangles for a collection of Node objects.
                        /// </summary>
                        ///
                        /// <param name="oNodes">
                        /// Collection of Node objects.
                        /// </param>
                        ///
                        /// <param name="oParentRectangle">
                        /// Parent rectangle that will contain the node rectangles.
                        /// </param>
                        ///
                        /// <param name="oParentNode">
                        /// Parent of <paramref name="oNodes" />, or null if <paramref
                        /// name="oNodes" /> are top-level.
                        /// </param>
                        ///
                        /// <param name="iTopPaddingPx">
                        /// Padding to add to the top of the parent rectangle, in pixels.
                        /// </param>
                        ///
                        /// <param name="iLeftRightBottomPaddingPx">
                        /// Padding to add to the left, right, and bottom of the parent rectangle,
                        /// in pixels.
                        /// </param>
                        ///
                        /// <param name="iPenWidthPx">
                        /// Width of the pen used to draw the node rectangles.
                        /// </param>
                        ///
                        /// <param name="oLayoutEngine">
                        /// Object that knows how to lay out a treemap.
                        /// </param>
                        ///
                        /// <remarks>
                        ///	This method sets the Rectangle and PenWidthPx properties on each Node
                        ///	object in the oNodes collection so that the rectangles fit into
                        ///	oParentRectangle with no overlap and have appropriate padding.  It then
                        /// recurses through all the descendent Node objects and does the same to
                        /// them.
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.CalculateRectangles = function (oNodes, oParentRectangle, oParentNode, iTopPaddingPx, iLeftRightBottomPaddingPx, iPenWidthPx, oLayoutEngine) {
                            Diag.Debug.Assert(oNodes != null);
                            Diag.Debug.Assert(iTopPaddingPx > 0);
                            Diag.Debug.Assert(iLeftRightBottomPaddingPx > 0);
                            Diag.Debug.Assert(iPenWidthPx >= 0); // roland > 0);
                            Diag.Debug.Assert(oLayoutEngine != null);
                            this.AssertValid();

                            var iSavedTopPaddingPx = iTopPaddingPx;

                            if (oParentNode == null) {
                                // oParentRectangle is the outer rectangle for the entire treemap.
                                // The outer rectangle should always have uniform padding.
                                iTopPaddingPx = iLeftRightBottomPaddingPx;
                            }

                            // Attempt to add padding to the parent rectangle.
                            oParentRectangle = this.AddPaddingToParentRectangle(oParentRectangle, iTopPaddingPx, iLeftRightBottomPaddingPx);

                            if (oParentRectangle == null) {
                                // The rectangle is too small to add padding.  Set all node
                                // rectangles to empty so they won't be drawn.
                                oLayoutEngine.SetNodesRectanglesToEmpty(oNodes, true);

                                return;
                            }

                            if (oParentNode == null) {
                                // Restore the specified top padding for use at lower levels.
                                iTopPaddingPx = iSavedTopPaddingPx;
                            }

                            // Calculate rectangles for the nodes in oNodes.
                            oLayoutEngine.CalculateNodeRectangles(oNodes, oParentRectangle, oParentNode, this.m_eEmptySpaceLocation);

                            // Calculate the left/right/bottom padding and pen width that will be
                            // used for the children of each node in oNodes.
                            var iDecrementedLeftRightBottomPaddingPx = this.DecrementPadding(iLeftRightBottomPaddingPx);

                            var iDecrementedPenWidthPx = this.DecrementPenWidth(iPenWidthPx);

                            // The top padding depends on the text location.
                            var iDecrementedTopPaddingPx = 0;

                            switch (this.m_eContentLocation) {
                                case 0 /* CenteredText */:
                                    // The top padding should be the same as the left/right/bottom
                                    // padding in this case.
                                    iDecrementedTopPaddingPx = iDecrementedLeftRightBottomPaddingPx;

                                    break;

                                case 1 /* TopText */:
                                    // The top padding, which is where the node text is displayed
                                    // in this case, should not change.
                                    iDecrementedTopPaddingPx = iTopPaddingPx;

                                    break;

                                case 2 /* OwnerDraw */:
                                    // if iTopPadding is 0, make like CenteredText
                                    // otherwise use that top padding like TopText
                                    if (iTopPaddingPx == 0)
                                        iDecrementedTopPaddingPx = iDecrementedLeftRightBottomPaddingPx;
                                    else
                                        iDecrementedTopPaddingPx = iTopPaddingPx;
                                    break;

                                default:
                                    Diag.Debug.Assert(false);
                                    break;
                            }

                            for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                                var oNode = oNodes.Item(iNode);

                                // Skip over empty rectangles.
                                if (oNode.Rectangle.IsEmpty)
                                    continue;

                                // Add padding to those sides of the node's rectangle that aren't
                                // next to an edge of the parent.
                                var oPaddedChildRectangle = this.AddPaddingToChildRectangle2(oNode.Rectangle, oParentRectangle, iLeftRightBottomPaddingPx);

                                if (oPaddedChildRectangle == null) {
                                    // The rectangle is too small to add padding to.  Fix the
                                    // rectangle in some sensible way.
                                    oNode.Rectangle = this.FixSmallRectangle(oNode.Rectangle);
                                    oNode.PenWidthPx = 1;

                                    // Set all descendant node rectangles to empty so they won't be
                                    // drawn.
                                    oLayoutEngine.SetNodesRectanglesToEmpty(oNode.Nodes, true);

                                    continue;
                                }

                                // Save the padded node rectangle and pen width.
                                oNode.Rectangle = oPaddedChildRectangle;

                                //---- why are we try to override the user's pen width property?? ----
                                oNode.PenWidthPx = iPenWidthPx;

                                // Subtract the pen width from the node's rectangle before using it
                                // to calculate rectangles for the node's children.
                                var oPaddedAndPennedNodeRectangle = internal.System.Drawing.Rectangle.Inflate(oPaddedChildRectangle, -iPenWidthPx, -iPenWidthPx);

                                // Calculate rectangles for this node's children.
                                this.CalculateRectangles(oNode.Nodes, oPaddedAndPennedNodeRectangle, oNode, iDecrementedTopPaddingPx, iDecrementedLeftRightBottomPaddingPx, iDecrementedPenWidthPx, oLayoutEngine);
                            }
                        };

                        //*************************************************************************
                        //	Method: DrawRectangles()
                        //
                        /// <summary>
                        /// Draws the rectangles for a collection of Node objects and all their
                        /// descendents.
                        /// </summary>
                        ///
                        /// <param name="oNodes">
                        /// Collection of Node objects.
                        /// </param>
                        ///
                        /// <param name="iNodeLevel">
                        /// Level of the nodes in oNodes.  Top-level nodes are level 0.
                        /// </param>
                        ///
                        /// <param name="oPenCache">
                        /// Object that creates and caches pens.
                        /// </param>
                        ///
                        /// <remarks>
                        ///	It's assumed that the Rectangle and PenWidthPx properties have already
                        /// been set on each Node object.
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.DrawRectangles = function (oNodes, iNodeLevel, oPenColor) {
                            Diag.Debug.Assert(oNodes != null);
                            Diag.Debug.Assert(iNodeLevel >= 0);

                            for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                                var oNode = oNodes.Item(iNode);
                                var oNodeRectangle = oNode.Rectangle;

                                // Skip over empty rectangles.  An empty rectangle indicates that
                                // a node's calculated rectangle is too small to display.
                                if (oNodeRectangle.IsEmpty)
                                    continue;

                                // Get a pen to use for the rectangle's border.
                                //            var oNonDisposablePen = oPenCache.GetPen(oNode.PenWidthPx);
                                var oBrush = oNode.AbsoluteColor;

                                // The node's AbsoluteColor value should determine the
                                // fill color.
                                //
                                // This is not as efficient as using ColorGradientMapper
                                // objects to cache brushes in the UseColorMetric case, but
                                // since each node can have a unique color, caching brushes
                                // isn't practical in the UseAbsoluteColor case.  On a
                                // 1.80 GHz Pentium M, it takes about 0.004 ms to create
                                // and dispose a SolidBrush, so the overhead involved in
                                // creating per-node brushes isn't too great in most cases.
                                // Fill the rectangle's interior and draw its border.
                                var animDuration = (this.m_bIsAnimationEnabled) ? this.m_fAnimDuration : 0;

                                oNode.DisplayRectangle(this.m_displayRoot, oNode.PenWidthPx, oPenColor, oBrush, iNodeLevel, animDuration);

                                // Repeat for this node's child nodes.
                                this.DrawRectangles(oNode.Nodes, iNodeLevel + 1, oPenColor);
                            }
                        };

                        //*************************************************************************
                        //	Method: DrawNodeAsSelected()
                        //
                        /// <summary>
                        ///	Redraws a node's rectangle and text to show it as selected.
                        /// </summary>
                        ///
                        /// <param name="oNode">
                        /// The node to draw as selected.
                        /// </param>
                        ///
                        /// <param name="oTreemapRectangle">
                        /// Outer rectangle for the entire treemap.
                        /// </param>
                        //*************************************************************************
                        TreemapGenerator.prototype.DrawNodeAsSelected = function (oNode) {
                            Diag.Debug.Assert(oNode != null);
                            oNode.AssertValid();

                            // Adjust the pen width of the node to something that will make the
                            // selection obvious.
                            oNode.SetRectangleFill(this.m_oSelectedBackColor);

                            // Create the object that knows how to draw node text, then tell it to
                            // draw the text for the selected node.
                            var oTextDrawer = this.CreateTextDrawer();

                            oTextDrawer.DrawTextForSelectedNode(oNode);
                        };

                        //*************************************************************************
                        //	Method: FireRedrawRequired()
                        //
                        /// <summary>
                        ///	Fires the RedrawRequired event if appropriate.
                        /// </summary>
                        ///
                        /// <remarks>
                        /// This should be called when something occurs that affects the treemap's
                        /// appearance.
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.FireRedrawRequired = function () {
                            ;
                        };

                        //*************************************************************************
                        //	Method: CancelSelectedNode()
                        //
                        /// <summary>
                        ///	Cancels the selected node.
                        /// </summary>
                        ///
                        /// <remarks>
                        ///	The treemap is not redrawn.
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.CancelSelectedNode = function () {
                            if (this.m_oSelectedNode) {
                                this.m_oSelectedNode.SetRectangleFill(this.m_oSelectedNode.AbsoluteColor);
                                this.m_oSelectedNode.SetTextColor(this.m_oFontSolidColor); // TODO: use transparent brush mapper for those cases

                                // TODO: ContentLocation.OwnerDraw
                                this.m_oSelectedNode = null;
                            }
                        };

                        //*************************************************************************
                        //	Method: CreateLayoutEngine()
                        //
                        /// <summary>
                        /// Creates an object that knows how to lay out the rectangles in a
                        /// treemap.
                        /// </summary>
                        ///
                        /// <returns>
                        ///	New object that implements <see cref="ILayoutEngine" />.
                        /// </returns>
                        //*************************************************************************
                        TreemapGenerator.prototype.CreateLayoutEngine = function () {
                            switch (this.m_eLayoutAlgorithm) {
                                case 0 /* BottomWeightedSquarified */:
                                    return (new Microsoft.Treemap.Util.BottomWeightedSquarifiedLayoutEngine());

                                case 1 /* TopWeightedSquarified */:
                                    return (new Microsoft.Treemap.Util.TopWeightedSquarifiedLayoutEngine());

                                default:
                                    Diag.Debug.Assert(false);
                                    return (null);
                            }
                        };

                        //*************************************************************************
                        //	Method: CreateTextDrawer()
                        //
                        /// <summary>
                        /// Creates an object that knows how to draw the text for the nodes in a
                        /// treemap.
                        /// </summary>
                        ///
                        /// <returns>
                        ///	New object that implements <see cref="ITextDrawer" />.
                        /// </returns>
                        //*************************************************************************
                        TreemapGenerator.prototype.CreateTextDrawer = function () {
                            this.AssertValid();

                            switch (this.m_eContentLocation) {
                                case 0 /* CenteredText */:
                                    return (new Microsoft.Treemap.Util.CenterCenterTextDrawer(this.m_iNodeLevelsWithText, this.m_iMinNodeLevelWithText, this.m_iMaxNodeLevelWithText, this.m_sFontFamily, this.m_fFontNormSizePt, this.m_fFontMinSizePt, this.m_fFontMaxSizePt, this.m_fFontIncrementPt, this.m_oFontSolidColor, this.m_iFontMinAlpha, this.m_iFontMaxAlpha, this.m_iFontAlphaIncrementPerLevel, this.m_oSelectedFontColor, this.AnimationDuration));

                                case 1 /* TopText */:
                                    return (new Microsoft.Treemap.Util.TopTextDrawer(this.m_iNodeLevelsWithText, this.m_iMinNodeLevelWithText, this.m_iMaxNodeLevelWithText, this.m_sFontFamily, this.m_fFontNormSizePt, this.m_fFontMinSizePt, this.GetTopMinimumTextHeight(), this.m_oFontSolidColor, this.m_oSelectedFontColor, this.m_oSelectedBackColor, this.AnimationDuration));

                                case 2 /* OwnerDraw */:
                                    return new Microsoft.Treemap.Util.OwnerDrawDrawer(this.m_ownerDraw, this.m_iNodeLevelsWithText, this.m_iMinNodeLevelWithText, this.m_iMaxNodeLevelWithText, this.m_sFontFamily, this.m_fFontNormSizePt, this.m_oFontSolidColor, this.m_oSelectedFontColor, this.m_oSelectedBackColor, this.AnimationDuration);

                                default:
                                    Diag.Debug.Assert(false);
                                    return (null);
                            }
                        };

                        //*************************************************************************
                        //	Method: AddPaddingToParentRectangle()
                        //
                        /// <summary>
                        /// Adds padding to a parent rectangle.
                        /// </summary>
                        ///
                        /// <param name="oParentRectangle">
                        /// Parent rectangle to add padding to.  Gets modified if true is returned.
                        /// </param>
                        ///
                        /// <param name="iTopPaddingPx">
                        /// Padding to add to the top of <paramref name="oParentRectangle" />, in
                        /// pixels.  May get modified if true is returned.
                        /// </param>
                        ///
                        /// <param name="iLeftRightBottomPaddingPx">
                        /// Padding to add to the left, right, and bottom of <paramref
                        /// name="oParentRectangle" />, in pixels.  May get modified if true is
                        /// returned.
                        /// </param>
                        ///
                        /// <returns>
                        /// true if padding was successfully added, false if not.
                        /// </returns>
                        ///
                        /// <remarks>
                        /// This method attempts to add padding to <paramref
                        /// name="oParentRectangle" />.  If the resulting padded rectangle is
                        /// larger than the minimum rectangle size, the padded rectangle is stored
                        /// at <paramref name="oParentRectangle" /> and true is returned.
                        /// Otherwise, an attempt is made using a minimum padding value.  If both
                        /// attempts fail, false is returned.
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.AddPaddingToParentRectangle = function (oParentRectangle, iTopPaddingPx, iLeftRightBottomPaddingPx) {
                            Diag.Debug.Assert(iTopPaddingPx >= 0);
                            Diag.Debug.Assert(iLeftRightBottomPaddingPx >= 0);

                            // Try the specified padding.
                            var oPaddedParentRectangle = this.AddPaddingToRectangle(oParentRectangle, iTopPaddingPx, iLeftRightBottomPaddingPx);

                            // Is the deflated rectangle smaller than the minimum size?
                            if (this.RectangleIsSmallerThanMin(oPaddedParentRectangle)) {
                                // Yes.
                                return null;
                            }

                            return oPaddedParentRectangle;
                        };

                        //*************************************************************************
                        //	Method: AddPaddingToRectangle()
                        //
                        /// <summary>
                        /// Adds padding to a rectangle.
                        /// </summary>
                        ///
                        /// <param name="oRectangle">
                        /// Rectangle to add padding to.
                        /// </param>
                        ///
                        /// <param name="iTopPaddingPx">
                        /// Padding to add to the top of <paramref name="oRectangle" />, in pixels.
                        /// </param>
                        ///
                        /// <param name="iLeftRightBottomPaddingPx">
                        /// Padding to add to the left, right, and bottom of <paramref
                        /// name="oRectangle" />, in pixels.
                        /// </param>
                        ///
                        /// <returns>
                        /// Padded rectangle.
                        /// </returns>
                        //*************************************************************************
                        TreemapGenerator.prototype.AddPaddingToRectangle = function (oRectangle, iTopPaddingPx, iLeftRightBottomPaddingPx) {
                            Diag.Debug.Assert(iTopPaddingPx >= 0);
                            Diag.Debug.Assert(iLeftRightBottomPaddingPx >= 0);

                            return (internal.System.Drawing.Rectangle.FromLTRB(oRectangle.Left + iLeftRightBottomPaddingPx, oRectangle.Top + iTopPaddingPx, oRectangle.Right - iLeftRightBottomPaddingPx, oRectangle.Bottom - iLeftRightBottomPaddingPx));
                        };

                        //*************************************************************************
                        //	Method: AddPaddingToChildRectangle()
                        //
                        /// <summary>
                        /// Adds padding to a child node rectangle.
                        /// </summary>
                        ///
                        /// <param name="oChildRectangle">
                        /// Child rectangle to add padding to.  Gets updated if true is returned.
                        /// </param>
                        ///
                        /// <param name="oParentRectangle">
                        /// Parent of <paramref name="oChildRectangle" />.
                        /// </param>
                        ///
                        /// <param name="iPaddingPx">
                        /// Padding to add to those sides of <paramref name="oChildRectangle" />
                        /// that are not next to the side of the parent rectangle, in pixels.
                        /// </param>
                        ///
                        /// <returns>
                        /// true if padding was successfully added, false if not.
                        /// </returns>
                        ///
                        /// <remarks>
                        ///	This method attempts to add padding to those sides of a child node's
                        /// rectangle that are not next to the side of the parent rectangle.  (If a
                        /// side of the child rectangle is next to the side of the parent, the
                        /// parent provides the padding for that side.  Only sides that are not
                        /// next to the side of the parent rectangle need their own padding.)  If
                        /// the attempt succeeds, the results are stored at <paramref
                        /// name="oChildRectangle" /> and true is returned.  false is returned
                        /// otherwise.
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.AddPaddingToChildRectangle2 = function (oChildRectangle, oParentRectangle, iPaddingPx) {
                            // Add the specified padding to those sides of the node's rectangle
                            // that aren't next to an edge of the parent.
                            var oPaddedChildRectangle = this.AddPaddingToChildRectangle(oChildRectangle, oParentRectangle, iPaddingPx);

                            // Is the resulting rectangle too small?
                            if (this.RectangleIsSmallerThanMin(oPaddedChildRectangle)) {
                                // Yes.  Try using the minimum padding.
                                if (iPaddingPx > TreemapGenerator.MinPaddingPx) {
                                    oPaddedChildRectangle = this.AddPaddingToChildRectangle(oChildRectangle, oParentRectangle, TreemapGenerator.MinPaddingPx);
                                }

                                if (this.RectangleIsSmallerThanMin(oPaddedChildRectangle)) {
                                    // It's still too small.
                                    return null;
                                }
                            }

                            return oPaddedChildRectangle;
                        };

                        //*************************************************************************
                        //	Method: AddPaddingToChildRectangle()
                        //
                        /// <summary>
                        /// Adds padding to a child node rectangle.
                        /// </summary>
                        ///
                        /// <param name="oChildRectangle">
                        /// Child rectangle to add padding to.
                        /// </param>
                        ///
                        /// <param name="oParentRectangle">
                        /// Parent rectangle.
                        /// </param>
                        ///
                        /// <param name="iPaddingPx">
                        /// Padding to add to <paramref name="oChildRectangle" />, in pixels.
                        /// </param>
                        ///
                        /// <returns>
                        /// Modified copy of <paramref name="oChildRectangle" /> with added padding.
                        /// </returns>
                        ///
                        /// <remarks>
                        ///	This method adds padding to those sides of a child node's rectangle
                        /// that are not next to the side of the parent rectangle.  (If a side of
                        /// the child rectangle is next to the side of the parent, the parent
                        /// provides the padding for that side.  Only sides that are not next to
                        /// the side of the parent rectangle need their own padding.)
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.AddPaddingToChildRectangle = function (oChildRectangle, oParentRectangle, iPaddingPx) {
                            var fLeft = oChildRectangle.Left;
                            var fTop = oChildRectangle.Top;
                            var fRight = oChildRectangle.Right;
                            var fBottom = oChildRectangle.Bottom;

                            // Add only half the padding.  The rectangle next to this one will add
                            // the other half.
                            var fHalfPaddingPx = (iPaddingPx + 1) / 2;

                            if (Math.round(oChildRectangle.Left) != Math.round(oParentRectangle.Left)) {
                                fLeft += fHalfPaddingPx;
                            }

                            if (Math.round(oChildRectangle.Top) != Math.round(oParentRectangle.Top)) {
                                fTop += fHalfPaddingPx;
                            }

                            if (Math.round(oChildRectangle.Right) != Math.round(oParentRectangle.Right)) {
                                fRight -= fHalfPaddingPx;
                            }

                            if (Math.round(oChildRectangle.Bottom) != Math.round(oParentRectangle.Bottom)) {
                                fBottom -= fHalfPaddingPx;
                            }

                            return (internal.System.Drawing.Rectangle.FromLTRB(fLeft, fTop, fRight, fBottom));
                        };

                        //*************************************************************************
                        //	Method: GetTopLevelTopPaddingPx()
                        //
                        /// <summary>
                        /// Gets the padding to use at the top of top-level node rectangles.
                        /// </summary>
                        ///
                        /// <param name="oGraphics">
                        /// Object to draw onto.
                        /// </param>
                        ///
                        /// <returns>
                        /// The padding to use at the top of the rectangles for the top-level
                        /// nodes, in pixels.
                        /// </returns>
                        //*************************************************************************
                        TreemapGenerator.prototype.GetTopLevelTopPaddingPx = function () {
                            this.AssertValid();

                            var iTopLevelTopPaddingPx;

                            switch (this.m_eContentLocation) {
                                case 0 /* CenteredText */:
                                    // The top padding should be the value specified in the
                                    // PaddingPx property.
                                    iTopLevelTopPaddingPx = this.m_iPaddingPx;
                                    break;

                                case 1 /* TopText */:
                                    // The top padding is set by the object that draws text for
                                    // this case.
                                    iTopLevelTopPaddingPx = Microsoft.Treemap.Util.TopTextDrawer.GetTextHeight(this.m_displayRoot, this.m_sFontFamily, this.m_fFontNormSizePt, this.GetTopMinimumTextHeight()) + 2;

                                    break;

                                case 2 /* OwnerDraw */:
                                    iTopLevelTopPaddingPx = this.m_ownerDraw.GetTopHeight(this.m_displayRoot);

                                    break;

                                default:
                                    Diag.Debug.Assert(false);
                                    iTopLevelTopPaddingPx = -1;

                                    break;
                            }

                            return (iTopLevelTopPaddingPx);
                        };

                        //*************************************************************************
                        //	Method: GetTopMinimumTextHeight()
                        //
                        /// <summary>
                        /// Gets the minimum allowed height of the text when <see
                        /// cref="TextLocation" /> is set to Top.
                        /// </summary>
                        //*************************************************************************
                        TreemapGenerator.prototype.GetTopMinimumTextHeight = function () {
                            this.AssertValid();

                            // The text must be at least as large as the padding added to the
                            // inside of top-level nodes.
                            return (this.DecrementPadding(this.m_iPaddingPx));
                        };

                        //*************************************************************************
                        //	Method: DecrementPadding()
                        //
                        /// <summary>
                        ///	Decrements the padding that gets added to the rectangles for the Node
                        /// objects in a Nodes collection.
                        /// </summary>
                        ///
                        /// <param name="iPaddingPx">
                        /// Padding to decrement, in pixels.
                        /// </param>
                        ///
                        /// <returns>
                        /// Decremented padding, in pixels.
                        /// </returns>
                        ///
                        /// <remarks>
                        ///	The padding can be made to decrease at each node level by setting <see
                        /// cref="PaddingDecrementPerLevelPx" /> to a positive value.
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.DecrementPadding = function (iPaddingPx) {
                            return (Math.max(iPaddingPx - this.m_iPaddingDecrementPerLevelPx, TreemapGenerator.MinPaddingPx));
                        };

                        //*************************************************************************
                        //	Method: DecrementPenWidth()
                        //
                        /// <summary>
                        ///	Decrements the pen width that is used to draw the rectangles for the
                        /// Node objects in a Nodes collection.
                        /// </summary>
                        ///
                        /// <param name="iPenWidthPx">
                        /// Pen width to decrement, in pixels.
                        /// </param>
                        ///
                        /// <returns>
                        /// Decremented pen width, in pixels.
                        /// </returns>
                        ///
                        /// <remarks>
                        ///	The pen width can be made to decrease at each node level by setting
                        ///	<see cref="PenWidthDecrementPerLevelPx" /> to a positive value.
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.DecrementPenWidth = function (iPenWidthPx) {
                            return (Math.max(iPenWidthPx - this.m_iPenWidthDecrementPerLevelPx, 1));
                        };

                        //*************************************************************************
                        //	Method: RectangleIsSmallerThanMin()
                        //
                        /// <summary>
                        ///	Determines whether a rectangle's height or width is smaller than an
                        /// allowed size.
                        /// </summary>
                        ///
                        /// <param name="oRectangle">
                        /// Rectangle to test.
                        /// </param>
                        ///
                        /// <returns>
                        /// true if <paramref name="oRectangle" /> is smaller than the minimum.
                        /// </returns>
                        //*************************************************************************
                        TreemapGenerator.prototype.RectangleIsSmallerThanMin = function (oRectangle) {
                            return (oRectangle.Width < TreemapGenerator.MinRectangleWidthOrHeightPx || oRectangle.Height < TreemapGenerator.MinRectangleWidthOrHeightPx);
                        };

                        //*************************************************************************
                        //	Method: FixSmallRectangle()
                        //
                        /// <summary>
                        /// Deals with a rectangle that is smaller than an allowed size.
                        /// </summary>
                        ///
                        /// <param name="oUnpaddedNodeRectangle">
                        /// RectangleF.  Node's rectangle, without padding.
                        /// </param>
                        ///
                        /// <returns>
                        ///	Modified copy of oUnpaddedNodeRectangle.
                        /// </returns>
                        ///
                        /// <remarks>
                        ///	This method is called when it's determined that a node's rectangle with
                        ///	padding is too small to display as a rectangle.  It returns a modified
                        ///	rectangle to use for the node.
                        /// </remarks>
                        //*************************************************************************
                        TreemapGenerator.prototype.FixSmallRectangle = function (oUnpaddedNodeRectangle) {
                            var fLeft = oUnpaddedNodeRectangle.Left;
                            var fTop = oUnpaddedNodeRectangle.Top;
                            var fRight = oUnpaddedNodeRectangle.Right;
                            var fBottom = oUnpaddedNodeRectangle.Bottom;
                            var fWidth = oUnpaddedNodeRectangle.Width;
                            var fHeight = oUnpaddedNodeRectangle.Height;
                            var fHalfMin = TreemapGenerator.MinRectangleWidthOrHeightPx / 2;

                            if (fHeight < TreemapGenerator.MinRectangleWidthOrHeightPx) {
                                // Make the rectangle the minimum height, properly centered.
                                fTop = (fTop + fBottom) / 2.0 - fHalfMin;
                                fBottom = fTop + TreemapGenerator.MinRectangleWidthOrHeightPx;
                            }

                            if (fWidth < TreemapGenerator.MinRectangleWidthOrHeightPx) {
                                // Make the rectangle the minimum width, properly centered.
                                fLeft = (fLeft + fRight) / 2 - fHalfMin;
                                fRight = fLeft + TreemapGenerator.MinRectangleWidthOrHeightPx;
                            }

                            var oFixedRectangle = internal.System.Drawing.Rectangle.FromLTRB(fLeft, fTop, fRight, fBottom);

                            if (fHeight < TreemapGenerator.MinRectangleWidthOrHeightPx) {
                                Diag.Debug.Assert(Math.round(oFixedRectangle.Height) == TreemapGenerator.MinRectangleWidthOrHeightPx);
                            }

                            if (fWidth < TreemapGenerator.MinRectangleWidthOrHeightPx) {
                                Diag.Debug.Assert(Math.round(oFixedRectangle.Width) == TreemapGenerator.MinRectangleWidthOrHeightPx);
                            }

                            return (oFixedRectangle);
                        };

                        //*************************************************************************
                        //	Method: AssertValid()
                        //
                        /// <summary>
                        ///	Asserts if the object is in an invalid state.  Debug-only.
                        /// </summary>
                        //*************************************************************************
                        TreemapGenerator.prototype.AssertValid = function () {
                            Diag.Debug.Assert(this.m_oNodes != null);
                            this.m_oNodes.AssertValid();

                            Diag.Debug.Assert(this.m_iPaddingPx >= TreemapGenerator.MinPaddingPx);
                            Diag.Debug.Assert(this.m_iPaddingPx <= TreemapGenerator.MaxPaddingPx);

                            Diag.Debug.Assert(this.m_iPaddingDecrementPerLevelPx >= TreemapGenerator.MinPaddingDecrementPerLevelPx);

                            Diag.Debug.Assert(this.m_iPaddingDecrementPerLevelPx <= TreemapGenerator.MaxPaddingDecrementPerLevelPx);

                            Diag.Debug.Assert(this.m_iPenWidthPx >= TreemapGenerator.MinPenWidthPx);
                            Diag.Debug.Assert(this.m_iPenWidthPx <= TreemapGenerator.MaxPenWidthPx);

                            Diag.Debug.Assert(this.m_iPenWidthDecrementPerLevelPx >= TreemapGenerator.MinPenWidthDecrementPerLevelPx);

                            Diag.Debug.Assert(this.m_iPenWidthDecrementPerLevelPx <= TreemapGenerator.MaxPenWidthDecrementPerLevelPx);

                            // m_oBackColor
                            // m_oBorderColor
                            Diag.Debug.AssertNotEmpty(this.m_sFontFamily);

                            Diag.Debug.Assert(this.m_fFontNormSizePt > 0);
                            Diag.Debug.Assert(this.m_fFontMinSizePt > 0);
                            Diag.Debug.Assert(this.m_fFontMaxSizePt > 0);
                            Diag.Debug.Assert(this.m_fFontMaxSizePt >= this.m_fFontMinSizePt);
                            Diag.Debug.Assert(this.m_fFontNormSizePt >= this.m_fFontMinSizePt);
                            Diag.Debug.Assert(this.m_fFontNormSizePt <= this.m_fFontMaxSizePt);
                            Diag.Debug.Assert(this.m_fFontIncrementPt > 0);

                            Diag.Debug.Assert(this.m_oFontSolidColor.A == 255);
                            Diag.Debug.Assert(this.m_iFontMinAlpha >= 0 && this.m_iFontMinAlpha <= 255);
                            Diag.Debug.Assert(this.m_iFontMaxAlpha >= 0 && this.m_iFontMaxAlpha <= 255);
                            Diag.Debug.Assert(this.m_iFontMaxAlpha >= this.m_iFontMinAlpha);
                            Diag.Debug.Assert(this.m_iFontAlphaIncrementPerLevel > 0);

                            // m_oSelectedFontColor
                            // m_oSelectedBackColor
                            // Diag.Debug.Assert( Enum.IsDefined(typeof(NodeLevelsWithText), this.m_iNodeLevelsWithText) );
                            Diag.Debug.Assert(this.m_iMinNodeLevelWithText >= 0);
                            Diag.Debug.Assert(this.m_iMaxNodeLevelWithText >= 0);
                            Diag.Debug.Assert(this.m_iMaxNodeLevelWithText >= this.m_iMinNodeLevelWithText);

                            // Diag.Debug.Assert( Enum.IsDefined(typeof(ContentLocation), this.m_eContentLocation) );
                            // Diag.Debug.Assert( Enum.IsDefined(typeof(EmptySpaceLocation), this.m_eEmptySpaceLocation) );
                            if (this.m_oSelectedNode != null)
                                this.m_oSelectedNode.AssertValid();

                            // m_bInBeginUpdate
                            // Diag.Debug.Assert( Enum.IsDefined(typeof(LayoutAlgorithm), this.m_eLayoutAlgorithm) );
                            if (this.m_ownerDraw) {
                                Diag.Debug.Assert(this.m_eContentLocation == 2 /* OwnerDraw */);
                            } else {
                                Diag.Debug.Assert(this.m_eContentLocation != 2 /* OwnerDraw */);
                            }
                        };
                        TreemapGenerator.MinPaddingPx = 1;

                        TreemapGenerator.MaxPaddingPx = 100;

                        TreemapGenerator.MinPaddingDecrementPerLevelPx = 0;

                        TreemapGenerator.MaxPaddingDecrementPerLevelPx = 99;

                        TreemapGenerator.MinPenWidthPx = 0;

                        TreemapGenerator.MaxPenWidthPx = 100;

                        TreemapGenerator.MinPenWidthDecrementPerLevelPx = 0;

                        TreemapGenerator.MaxPenWidthDecrementPerLevelPx = 99;

                        TreemapGenerator.MinRectangleWidthOrHeightPx = 1;
                        return TreemapGenerator;
                    })();
                    Generator.TreemapGenerator = TreemapGenerator;
                })(Treemap.Generator || (Treemap.Generator = {}));
                var Generator = Treemap.Generator;
            })(Microsoft.Treemap || (Microsoft.Treemap = {}));
            var Treemap = Microsoft.Treemap;
        })(internal.Microsoft || (internal.Microsoft = {}));
        var Microsoft = internal.Microsoft;
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));
//# sourceMappingURL=generator.js.map

///----------------------------------------------------------------
/// (from treemap\graphicsLib.js)
///----------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (internal) {
        (function (Microsoft) {
            (function (Treemap) {
                (function (GraphicsLib) {
                    var Diag = vp.internal.System.Diagnostics;

                    var GraphicsUtil = (function () {
                        function GraphicsUtil() {
                        }
                        //*************************************************************************
                        //  Method: RectangleFToRectangle()
                        //
                        /// <summary>
                        /// Converts a RectangleF to a Rectangle.
                        /// </summary>
                        ///
                        /// <param name="oRectangle">
                        /// Rectangle to convert.
                        /// </param>
                        ///
                        /// <param name="iPenWidthPx">
                        /// Width of the pen that will be used to draw the rectangle.
                        /// </param>
                        ///
                        /// <returns>
                        /// Converted rectangle.
                        /// </returns>
                        ///
                        /// <remarks>
                        /// This method converts a floating-point RectangleF to an integer
                        /// Rectangle, compensating for some GDI oddities in the process.
                        ///
                        /// <para>
                        /// If precise rectangle drawing is required, the caller should convert
                        /// all RectangleF objects to Rectangles using this method, then use the
                        /// Graphics.DrawRectangle(Pen, Rectangle) method to draw them.  The
                        /// floating-point version of Graphics.DrawRectangle() should not be used.
                        /// </para>
                        ///
                        /// </remarks>
                        //*************************************************************************
                        GraphicsUtil.RectangleFToRectangle = function (oRectangle, iPenWidthPx) {
                            /*
                            GDI draws floating-point rectangles in an odd manner.  Consider the
                            following code:
                            
                            RectangleF oRectangle =
                            RectangleF.FromLTRB(fLeft, fTop, fRight, fBottom);
                            
                            Pen oPen = new Pen(Color.Black, iPenWidthPx);
                            oPen.Alignment = PenAlignment.Inset;
                            
                            displayRoot.DrawRectangle(oPen, oRectangle.X, oRectangle.Y,
                            oRectangle.Width, oRectangle.Height);
                            
                            If iPenWidthPx is 1, then GDI rounds all the rectangle's coordinates
                            before drawing the rectangle.  For example, fLeft values between
                            0 and 0.50, inclusive, cause the left edge to be drawn at X=0.  fLeft
                            values between 0.51 and 1.50 result in a left edge at X=1.  Similarly,
                            fBottom values between 4.51 and 5.50 result in a bottom edge at Y=5,
                            and fBottom values between 5.51 and 6.50 result in a bottom edge at Y=6.
                            fRight and fTop are treated the same way.  This all seems like sensible
                            behavior.
                            
                            If iPenWidthPx is greater than 1, however, the behavior changes.  The
                            fLeft and fTop values are rounded up, while the fRight and fBottom
                            values are rounded down.  For example, fLeft values between 0.1 and 1.0
                            cause the left edge to be drawn at X=1, and fLeft values between 1.1
                            and 2.0 result in a left edge at X=2.  fBottom values between
                            4.1 and 5.0 cause the bottom edge to be drawn at Y=4, and fBottom
                            values between 5.1 and 6.0 cause the bottom edge to be drawn at Y=5.
                            
                            The odd behavior for pen widths greater than 1 causes unexpected and
                            inconsistent rectangle spacing.  To fix this problem, the following
                            code rounds all values.  If the rectangle is going to be drawn with a
                            pen width greater than 1, the code then adds 1 to the right and bottom
                            values to compensate for GDI's inconsistency.
                            
                            This also fixes an oddity where GDI sometimes leaves off corner pixels
                            when drawing rectangles using floating-point coordinates.
                            */
                            var iLeft = Math.round(oRectangle.Left);
                            var iRight = Math.round(oRectangle.Right);
                            var iTop = Math.round(oRectangle.Top);
                            var iBottom = Math.round(oRectangle.Bottom);

                            /*
                            if (iPenWidthPx > 1)
                            {
                            iRight++;
                            iBottom++;
                            }
                            */
                            return (internal.System.Drawing.Rectangle.FromLTRB(iLeft, iTop, iRight, iBottom));
                        };
                        return GraphicsUtil;
                    })();
                    GraphicsLib.GraphicsUtil = GraphicsUtil;

                    /*
                    //*****************************************************************************
                    //    Class: PenCache
                    //
                    /// <summary>
                    ///    Creates a Pen object on request and caches it for future requests.
                    /// </summary>
                    ///
                    /// <remarks>
                    ///    Call the Initialize() method to specify the color of all the pens that
                    ///    will be requested.  You can then call GetPen() to get a Pen object of a
                    ///    particular width.  If you call GetPen() again with the same width, the
                    ///    cached pen will be returned instead of being created from scratch.
                    ///
                    /// <para>
                    ///    Call Dispose() when you are done using the object.
                    /// </para>
                    ///
                    ///    </remarks>
                    //*****************************************************************************
                    
                    export class PenCache
                    {
                    constructor ()
                    {
                    this.m_oPens = {};
                    }
                    
                    //*************************************************************************
                    //    Method: Initialize()
                    //
                    /// <summary>
                    /// Initialize method.
                    /// </summary>
                    ///
                    /// <param name="oPenColor">
                    /// Color.  Color of all the pens that will be created.
                    /// </param>
                    ///
                    /// <remarks>
                    ///    This must be called before any other methods or properties are used.
                    /// </remarks>
                    //*************************************************************************
                    
                    public Initialize(oPenColor : System.Drawing.Color)
                    {
                    this.m_oPenColor = oPenColor;
                    }
                    
                    //*************************************************************************
                    //    Method: GetPen()
                    //
                    /// <summary>
                    /// GetPen method.
                    /// </summary>
                    ///
                    /// <param name="iWidthPx">
                    /// Int32.  Width of the pen, in pixels.
                    /// </param>
                    ///
                    /// <returns>
                    ///    Pen of the specified width.
                    /// </returns>
                    ///
                    /// <remarks>
                    ///    Returns a pen of the specified width.  If the pen already exists in the
                    ///    internal cache, the cached pen is returned.
                    /// </remarks>
                    //*************************************************************************
                    
                    public GetPen(iWidthPx : number) : System.Drawing.Pen
                    {
                    if (iWidthPx <= 0)
                    {
                    throw new vp.internal.System.ArgumentOutOfRangeException("iWidthPx", iWidthPx,
                    "PenCache.GetPen(): iWidthPx must be > 0.");
                    }
                    
                    // If the pen isn't in the cache, create and cache it.
                    
                    var oPen = <System.Drawing.Pen>this.m_oPens[iWidthPx];
                    
                    if (oPen == null)
                    {
                    oPen = new vp.internal.System.Drawing.Pen(this.m_oPenColor, iWidthPx);
                    //            oPen.Alignment = System.Drawing.Drawing2D.PenAlignment.Inset;
                    this.m_oPens[iWidthPx] = oPen;
                    }
                    
                    return (oPen);
                    }
                    
                    //*************************************************************************
                    //    Method: AssertValid()
                    //
                    /// <summary>
                    /// AssertValid method.
                    /// </summary>
                    ///
                    /// <remarks>
                    ///    Asserts if the object is in an invalid state.  Debug-only.
                    /// </remarks>
                    //*************************************************************************
                    
                    AssertValid()
                    {
                    Diag.Debug.Assert(this.m_oPens != null);
                    }
                    
                    //*************************************************************************
                    //    Protected member data
                    //*************************************************************************
                    
                    // Dictionary of pens, keyed by pen width in pixels.
                    
                    m_oPens: { };
                    
                    // Color of all the pens.
                    
                    m_oPenColor : System.Drawing.Color;
                    }
                    
                    */
                    //*****************************************************************************
                    //	Class: TransparentBrushMapper
                    //
                    /// <summary>
                    ///	Provides a solid brush that uses a transparent color.
                    /// </summary>
                    ///
                    /// <remarks>
                    ///	This object creates a set of transparent brushes, with a transparency that
                    ///	varies from a maximum to a minimum in equal steps.  Each brush has a
                    ///	"level" that varies from 0 to the number of brushes minus 1.  The lowest-
                    ///	level brush has the maximum transparency and the highest-level has the
                    ///	minimum transparency.
                    ///
                    /// <para>
                    ///	Call the Initialize() method to specify a brush color and the transparency
                    ///	levels to use.  Initialize() creates all the brushes at once and saves them
                    ///	in an internal array.  You can then call LevelToBrush() to get a Brush
                    ///	object for a specified level.  If the specified level is greater than the
                    ///	level of the highest-level (minimum transparency) brush, the highest-level
                    ///	brush is returned.
                    /// </para>
                    ///
                    /// <para>
                    ///	Call Dispose() when you are done using the object.
                    /// </para>
                    ///
                    ///	</remarks>
                    //*****************************************************************************
                    var TransparentBrushMapper = (function () {
                        //*************************************************************************
                        //	Constructor: TransparentBrushMapper()
                        //
                        /// <summary>
                        /// TransparentBrushMapper constructor.
                        /// </summary>
                        //*************************************************************************
                        function TransparentBrushMapper() {
                            this.m_oTransparentBrushes = null;
                            this.m_iTransparentBrushes = 0;
                        }
                        //*************************************************************************
                        //	Method: Initialize()
                        //
                        /// <summary>
                        /// Initialize method.
                        /// </summary>
                        ///
                        /// <param name="oSolidColor">
                        /// Color.  Color to use for all brushes.  Must have alpha set to 255.
                        /// </param>
                        ///
                        /// <param name="iMinAlpha">
                        /// Int32.  Alpha value to use for the level with maximum transparency.
                        /// Must be between 0 and 255.
                        /// </param>
                        ///
                        /// <param name="iMaxAlpha">
                        /// Int32.  Alpha value to use for the level with minimum transparency.
                        /// Must be between 0 and 255.  Must be >= iMinAlpha.
                        /// </param>
                        ///
                        /// <param name="iAlphaIncrementPerLevel">
                        /// Int32.  Amount that alpha should be incremented from level to level.
                        /// Must be > 0.
                        /// </param>
                        ///
                        /// <remarks>
                        ///	This must be called before any other methods or properties are used.
                        /// </remarks>
                        //*************************************************************************
                        TransparentBrushMapper.prototype.Initialize = function (oSolidColor, iMinAlpha, iMaxAlpha, iAlphaIncrementPerLevel) {
                            var sMethodName = "TransparentBrushMapper.Initialize()";

                            if (oSolidColor.A != 255) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("oSolidColor", oSolidColor, sMethodName + ": oSolidColor must not be transparent.");
                            }

                            TransparentBrushMapper.ValidateAlphaRange(iMinAlpha, iMaxAlpha, iAlphaIncrementPerLevel, sMethodName);

                            // Create an empty array.
                            this.m_oTransparentBrushes = new Array();

                            for (var iAlpha = iMinAlpha; iAlpha <= iMaxAlpha; iAlpha += iAlphaIncrementPerLevel) {
                                // Create and save a transparent brush.
                                var oTransparentColor = internal.System.Drawing.Color.FromArgb3(iAlpha, oSolidColor);
                                var oTransparentBrush = oTransparentColor;
                                this.m_oTransparentBrushes.push(oTransparentBrush);
                            }

                            this.m_iTransparentBrushes = this.m_oTransparentBrushes.length;

                            this.AssertValid();
                        };

                        //*************************************************************************
                        //	Method: LevelToTransparentBrush()
                        //
                        /// <summary>
                        /// LevelToTransparentBrush method.
                        /// </summary>
                        ///
                        /// <param name="iLevel">
                        /// Int32.  Level of transparency.  Must be >= 0.  If this is greater than
                        ///	the level of the highest-level (minimum transparency) brush, the
                        ///	highest-level brush is returned.
                        /// </param>
                        ///
                        /// <returns>
                        ///	Brush with the specified level of transparency.
                        /// </returns>
                        ///
                        /// <remarks>
                        ///	Returns a Brush object with a specified level of transparency.
                        /// </remarks>
                        //*************************************************************************
                        TransparentBrushMapper.prototype.LevelToTransparentBrush = function (iLevel) {
                            this.AssertValid();

                            if (iLevel < 0) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("iLevel", iLevel, "TransparentBrushMapper.LevelToTransparentBrush: iLevel must" + " be >= 0.");
                            }

                            // A level greater than the level of the highest-level brush should be
                            // mapped to the highest-level brush.
                            if (iLevel >= this.m_iTransparentBrushes)
                                iLevel = this.m_iTransparentBrushes - 1;

                            return this.m_oTransparentBrushes[iLevel];
                        };

                        //*************************************************************************
                        //	Method: ValidateAlphaRange()
                        //
                        /// <summary>
                        /// ValidateAlphaRange method.
                        /// </summary>
                        ///
                        /// <param name="iMinAlpha">
                        /// Int32.  Alpha value to use for the level with maximum transparency.
                        /// Must be between 0 and 255.
                        /// </param>
                        ///
                        /// <param name="iMaxAlpha">
                        /// Int32.  Alpha value to use for the level with minimum transparency.
                        /// Must be between 0 and 255.  Must be >= iMinAlpha.
                        /// </param>
                        ///
                        /// <param name="iIncrementPerLevel">
                        /// Int32.  Amount that alpha should be incremented from level to level.
                        /// Must be > 0.
                        /// </param>
                        ///
                        /// <param name="sCaller">
                        /// String.  Name of the caller.  Used in exception messages.  Sample:
                        ///	"TransparentBrushMapper.Initialize()".
                        /// </param>
                        ///
                        /// <remarks>
                        ///	Throws an exception if one of the parameters is invalid.
                        /// </remarks>
                        //*************************************************************************
                        TransparentBrushMapper.ValidateAlphaRange = function (iMinAlpha, iMaxAlpha, iIncrementPerLevel, sCaller) {
                            if (iMinAlpha < 0 || iMinAlpha > 255) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("iMinAlpha", iMinAlpha, sCaller + ": iMinAlpha must be between 0 and 255.");
                            }

                            if (iMaxAlpha < 0 || iMaxAlpha > 255) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("iMaxAlpha", iMaxAlpha, sCaller + ": iMaxAlpha must be between 0 and 255.");
                            }

                            if (iMaxAlpha < iMinAlpha) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("iMaxAlpha", iMaxAlpha, sCaller + ": iMaxAlpha must be >= iMinAlpha.");
                            }

                            if (iIncrementPerLevel <= 0) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("iIncrementPerLevel", iIncrementPerLevel, sCaller + ": iIncrementPerLevel must be > 0.");
                            }
                        };

                        //*************************************************************************
                        //	Method: AssertValid()
                        //
                        /// <summary>
                        /// AssertValid method.
                        /// </summary>
                        ///
                        /// <remarks>
                        ///	Asserts if the object is in an invalid state.  Debug-only.
                        /// </remarks>
                        //*************************************************************************
                        TransparentBrushMapper.prototype.AssertValid = function () {
                            Diag.Debug.Assert(this.m_oTransparentBrushes != null);
                            Diag.Debug.Assert(this.m_iTransparentBrushes != 0);
                        };
                        return TransparentBrushMapper;
                    })();
                    GraphicsLib.TransparentBrushMapper = TransparentBrushMapper;
                })(Treemap.GraphicsLib || (Treemap.GraphicsLib = {}));
                var GraphicsLib = Treemap.GraphicsLib;
            })(Microsoft.Treemap || (Microsoft.Treemap = {}));
            var Treemap = Microsoft.Treemap;
        })(internal.Microsoft || (internal.Microsoft = {}));
        var Microsoft = internal.Microsoft;
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));
//# sourceMappingURL=graphicsLib.js.map

///----------------------------------------------------------------
/// (from treemap\node.js)
///----------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (internal) {
        (function (Microsoft) {
            (function (Treemap) {
                (function (Generator) {
                    var Diag = vp.internal.System.Diagnostics;

                    //*****************************************************************************
                    //    Class: Node
                    //
                    /// <summary>
                    /// Represents one rectangle within a treemap.
                    /// </summary>
                    ///
                    /// <remarks>
                    /// <see cref="Node" /> objects are arranged in a hierarchy.  The
                    ///    <see cref="ITreemapComponent.Nodes" /> property on <see
                    /// cref="ITreemapComponent" /> returns a <see
                    /// cref="Microsoft.Treemap.Generator.Nodes" />
                    ///    collection containing the top-level <see cref="Node" /> objects.  Each <see
                    /// cref="Node" /> object has a <see
                    /// cref="Microsoft.Treemap.Generator.Nodes" />
                    ///    collection containing its child <see cref="Node" /> objects.  A leaf <see
                    /// cref="Node" /> object has an empty <see
                    /// cref="Microsoft.Treemap.Generator.Nodes" />
                    /// collection.
                    ///
                    /// <para>
                    ///    To add a <see cref="Node" /> to the hierarchy, you can use one of the
                    /// Nodes.<see cref="Microsoft.Treemap.Generator.Nodes.
                    /// Add(String, Single, Single)" /> methods.  This will create the <see
                    /// cref="Node" /> and add it to the Nodes collection in one step.  You can
                    /// also explicitly create a new <see cref="Node" /> object and add it to the
                    /// hierarchy using the Nodes.<see
                    /// cref="Microsoft.Treemap.Generator.Nodes.Add(Node)" />
                    /// method that takes a <see cref="Node" /> object.
                    /// </para>
                    ///
                    /// <para>
                    /// The size of the Node's rectangle is determined by the <see
                    /// cref="SizeMetric" /> property.  The fill color of the rectangle is
                    /// determined by either the <see cref="ColorMetric" /> or <see
                    /// cref="AbsoluteColor" /> property, depending on how <see
                    /// cref="ITreemapComponent.NodeColorAlgorithm" /> is set.
                    /// </para>
                    ///
                    /// <para>
                    /// To conserve memory, the Node's <see cref="ColorMetric" /> and <see
                    /// cref="AbsoluteColor" /> properties are stored in the same internal field,
                    /// meaning that a <see cref="Node" /> can store either a color metric or an
                    /// absolute color, but not both.  See <see cref="Microsoft.Research.
                    /// CommunityTechnologies.Treemap.TreemapGenerator.NodeColorAlgorithm" /> for
                    /// more details.
                    /// </para>
                    ///
                    /// <para>
                    /// The Node's <see cref="Text" /> gets displayed within the Node's rectangle.
                    /// A <see cref="Node" /> has an optional <see cref="Tag" /> and <see
                    /// cref="ToolTip" />.
                    /// </para>
                    ///
                    /// </remarks>
                    //*****************************************************************************
                    var Node = (function () {
                        //*************************************************************************
                        //    Constructor: Node()
                        //
                        /// <summary>
                        /// Initializes a new instance of the Node class with the specified text,
                        /// size metric, color metric, tag, and tooltip.
                        /// </summary>
                        ///
                        /// <param name="text">
                        /// Text to display within the Node's rectangle.  Can be null or empty.
                        /// </param>
                        ///
                        /// <param name="sizeMetric">
                        /// Determines the size of the Node's rectangle.  See
                        ///    <see cref="SizeMetric" />.
                        /// </param>
                        ///
                        /// <param name="colorMetric">
                        /// Determines the fill color of the Node's rectangle.  See
                        /// <see cref="ColorMetric" />.
                        /// </param>
                        ///
                        /// <param name="tag">
                        /// Arbitrary object to associate with the Node.  Can be null.
                        /// </param>
                        ///
                        /// <param name="toolTip">
                        /// Tooltip to show for the Node.  Can be null or empty.  Used by
                        /// TreemapControl, not used by <see cref="TreemapGenerator" />.
                        /// </param>
                        ///
                        /// <param name="textColor">
                        /// The color of the text in the node.  Can be null or empty.
                        /// </param>
                        ///
                        ///    <seealso cref="SizeMetric" />
                        ///    <seealso cref="ColorMetric" />
                        //*************************************************************************
                        function Node(text, sizeMetric, absoluteColor, tag, toolTip, textColor) {
                            this.InitializeWithValidation(text, sizeMetric, absoluteColor);

                            this.m_oTag = tag;
                            this.m_sToolTip = toolTip;
                            this.m_oTextColor = textColor;

                            this.AssertValid();
                        }
                        Object.defineProperty(Node.prototype, "Text", {
                            //*************************************************************************
                            //    Property: Text
                            //
                            /// <summary>
                            /// Gets or sets the Node's text.
                            /// </summary>
                            ///
                            /// <value>
                            ///    The text that gets displayed within the Node's rectangle.  Can be null
                            /// or empty.
                            /// </value>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_sText);
                            },
                            set: function (value) {
                                if (this.m_sText != value) {
                                    this.m_sText = value;
                                    this.FireRedrawRequired();
                                }

                                this.AssertValid();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Node.prototype, "SizeMetric", {
                            //*************************************************************************
                            //    Property: SizeMetric
                            //
                            /// <summary>
                            ///    Gets or sets the metric that determines the size of the Node's
                            ///    rectangle.
                            /// </summary>
                            ///
                            /// <value>
                            /// The metric that determines the size of the Node's rectangle within the
                            ///    parent rectangle.  Must be greater than or equal to zero.
                            /// </value>
                            ///
                            /// <remarks>
                            ///    To compute the rectangle sizes for the nodes in a
                            ///    <see cref="Microsoft.Treemap.Generator.Nodes" />
                            ///    collection, the drawing engine adds up the SizeMetric value for the
                            ///    <see cref="Node" /> objects, adds the <see cref="Microsoft.Research.
                            /// CommunityTechnologies.Treemap.EmptySpace.SizeMetric" /> value from the
                            /// <see cref="EmptySpace" /> object owned by the <see
                            /// cref="Microsoft.Treemap.Generator.Nodes" />
                            ///    collection, and divides the size of the parent rectangle by the
                            /// resulting sum.  This "area per SizeMetric" factor is multiplied by each
                            /// Node's SizeMetric value to obtain the size of the Node's rectangle.
                            ///
                            ///    <para>
                            ///    Thus, the size of the Node's rectangle depends on the following:
                            ///
                            /// <list type="bullet">
                            ///
                            /// <item>
                            /// <description>The Node's SizeMetric value</description>
                            /// </item>
                            ///
                            /// <item>
                            /// <description>The SizeMetric values of the Node's siblings</description>
                            /// </item>
                            ///
                            /// <item>
                            /// <description>The SizeMetric value of the Nodes.EmptySpace object
                            ///    </description>
                            /// </item>
                            ///
                            /// <item>
                            /// <description>The size of the parent rectangle</description>
                            /// </item>
                            ///
                            /// </list>
                            ///
                            ///    </para>
                            ///
                            /// </remarks>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_fSizeMetric);
                            },
                            set: function (value) {
                                // Validate the parameter.
                                Node.ValidateSizeMetric(value, "Node.SizeMetric");

                                if (this.m_fSizeMetric != value) {
                                    this.m_fSizeMetric = value;
                                    this.FireRedrawRequired();
                                }

                                this.AssertValid();
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Node.prototype, "AbsoluteColor", {
                            //*************************************************************************
                            //    Property: AbsoluteColor
                            //
                            /// <summary>
                            ///    Gets or sets the fill color of the Node's rectangle when <see
                            /// cref="ITreemapComponent.NodeColorAlgorithm" /> is
                            /// set to <see cref="NodeColorAlgorithm.UseAbsoluteColor" />.
                            /// </summary>
                            ///
                            /// <value>
                            ///    The fill color of the Node's rectangle.
                            /// </value>
                            ///
                            /// <remarks>
                            /// Use this property only when <see
                            /// cref="ITreemapComponent.NodeColorAlgorithm" /> is set to <see
                            /// cref="NodeColorAlgorithm.UseAbsoluteColor" />.  If you set this
                            /// property when <see cref="ITreemapComponent.NodeColorAlgorithm" /> is
                            /// set to <see cref="NodeColorAlgorithm.UseColorMetric" />, the node will
                            /// have an unexpected color.
                            ///
                            /// <para>
                            /// (To conserve memory, the Node's <see cref="ColorMetric" /> and <see
                            /// cref="AbsoluteColor" /> properties are stored in the same internal
                            /// field, meaning that a <see cref="Node" /> can store either a color
                            /// metric or an absolute color, but not both.  See <see
                            /// cref="Microsoft.Treemap.Generator.
                            /// TreemapGenerator.NodeColorAlgorithm" /> for more details.)
                            /// </para>
                            ///
                            /// </remarks>
                            ///
                            ///    <seealso cref="Microsoft.Treemap.Generator.
                            /// TreemapGenerator.NodeColorAlgorithm" />
                            ///
                            ///    <seealso cref="ColorMetric" />.
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oNodeColor);
                            },
                            set: function (value) {
                                if (this.m_oNodeColor != value) {
                                    this.m_oNodeColor = value;
                                    this.FireRedrawRequired();
                                }

                                this.AssertValid();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Node.prototype, "Tag", {
                            //*************************************************************************
                            //    Property: Tag
                            //
                            /// <summary>
                            ///    Gets or sets the arbitrary object associated with the Node.
                            /// </summary>
                            ///
                            /// <value>
                            ///    The arbitrary object associated with the Node, as an
                            ///    <see cref="Object" />.  The default value is null.
                            /// </value>
                            ///
                            /// <remarks>
                            ///    This property exists only for the caller's convenience.  It is not used
                            ///    by the treemap components.
                            ///
                            /// <para>
                            /// By default, this property is serialized as a String in the XML returned
                            /// by <see cref="ITreemapComponent.NodesXml" />.  See <see
                            /// cref="ITreemapComponent.NodesXml" /> for more details.
                            /// </para>
                            ///
                            /// </remarks>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oTag);
                            },
                            set: function (value) {
                                this.m_oTag = value;

                                this.AssertValid();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Node.prototype, "ToolTip", {
                            //*************************************************************************
                            //    Property: ToolTip
                            //
                            /// <summary>
                            ///    Gets or sets the Node's tooltip.
                            /// </summary>
                            ///
                            /// <value>
                            ///    The tooltip to display for the Node.  Use "\n" or "\r\n" to separate
                            /// multiple lines.  Can be null.
                            /// </value>
                            ///
                            /// <remarks>
                            ///    The tooltip is used by the TreemapControl.  It is not used by the <see
                            /// cref="TreemapGenerator" />.
                            /// </remarks>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_sToolTip);
                            },
                            set: function (value) {
                                this.m_sToolTip = value;

                                this.AssertValid();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Node.prototype, "Bounds", {
                            //*************************************************************************
                            //    Property: Bounds
                            //
                            /// <summary>
                            ///    Gets the node's rectangle.
                            /// </summary>
                            ///
                            /// <value>
                            ///    The rectangle the node is drawn within.
                            /// </value>
                            ///
                            /// <remarks>
                            /// If the treemap hasn't been drawn yet or the the node's rectangle is too
                            /// small to draw, Rectangle.<see cref="System.Drawing.Rectangle.Empty" />
                            /// is returned.
                            /// </remarks>
                            //
                            //  This is a public version of RectangleToDraw.  The details of Rectangle
                            //  vs. RectangleToDraw are too complicated to make public.
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                if (!this.m_bRectangleSet) {
                                    return (internal.System.Drawing.Rectangle.Empty);
                                }

                                return (this.RectangleToDraw);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Node.prototype, "Nodes", {
                            //*************************************************************************
                            //    Property: Nodes
                            //
                            /// <summary>
                            ///    Gets the collection of child <see cref="Node" /> objects.
                            /// </summary>
                            ///
                            /// <value>
                            ///    A <see cref="Microsoft.Treemap.Generator.Nodes" />
                            ///    collection of child <see cref="Node" /> objects.
                            /// </value>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oNodes);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Node.prototype, "Parent", {
                            //*************************************************************************
                            //    Property: Parent
                            //
                            /// <summary>
                            ///    Gets the parent <see cref="Node" /> object.
                            /// </summary>
                            ///
                            /// <value>
                            ///    The parent <see cref="Node" /> object, or null if this Node belongs to
                            /// the top-level <see cref="Nodes" /> collection or the Node hasn't been
                            /// added to a collection.
                            /// </value>
                            //
                            //  This is called Parent instead of ParentNode to make it consistent with
                            //  the .NET TreeNode.Parent property.
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oParentNode);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Node.prototype, "Level", {
                            //*************************************************************************
                            //    Property: Level
                            //
                            /// <summary>
                            ///    Gets the Node's level.
                            /// </summary>
                            ///
                            /// <value>
                            ///    The Node's level.  Top-level nodes are at level 0.
                            /// </value>
                            ///
                            /// <remarks>
                            /// 0 is returned if the Node hasn't been added to a collection.
                            /// </remarks>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                var oParentNode = this.Parent;
                                var iLevel = 0;

                                while (oParentNode != null) {
                                    oParentNode = oParentNode.Parent;
                                    iLevel++;
                                }

                                return (iLevel);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        //*************************************************************************
                        //    Method: PrivateSetParent()
                        //
                        /// <summary>
                        ///    Do not call this method.
                        /// </summary>
                        ///
                        /// <param name="oParentNode">
                        ///    Do not call this method.  It is for use only by other treemap
                        ///    components.
                        /// </param>
                        //*************************************************************************
                        Node.prototype.PrivateSetParent = function (oParentNode) {
                            // This gets called by TreemapControl.
                            this.SetParent(oParentNode);

                            this.AssertValid();
                        };

                        Object.defineProperty(Node.prototype, "HasBeenDrawn", {
                            //*************************************************************************
                            //    Property: HasBeenDrawn
                            //
                            /// <summary>
                            /// Gets a flag indicating whether the rectangle has been drawn.
                            /// </summary>
                            ///
                            /// <value>
                            /// true if the rectangle has been drawn.
                            /// </value>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                // The TreemapGenerator sets the node's rectangle right before
                                // drawing it.  If the rectangle is empty, it means that either the
                                // TreemapGenerator hasn't drawn the treemap yet, or it has but
                                // this node has a rectangle that's too small to draw.
                                if (this.m_oRectangle && !this.m_oRectangle.IsEmpty) {
                                    Diag.Debug.Assert(this.m_bRectangleSet);

                                    return (true);
                                }

                                return (false);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Node.prototype, "Rectangle", {
                            //*************************************************************************
                            //    Property: Rectangle
                            //
                            /// <summary>
                            /// Gets or sets the node's rectangle.
                            /// </summary>
                            ///
                            /// <value>
                            /// The node's rectangle.
                            /// </value>
                            ///
                            /// <remarks>
                            ///    This property provides the floating-point rectangle that should be
                            ///    used in all rectangle calculations.  To draw the rectangle, use the
                            ///    RectangleToDraw property instead.
                            ///
                            /// <para>
                            ///    Do not get this property without setting it first.
                            /// </para>
                            ///
                            ///    <seealso cref="Node.RectangleToDraw" />
                            ///
                            /// </remarks>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                // No one should ask for the rectangle if it hasn't been set yet.
                                Diag.Debug.Assert(this.m_bRectangleSet);

                                return (this.m_oRectangle);
                            },
                            set: function (value) {
                                this.m_oRectangle = value;

                                this.m_bRectangleSet = true; // !value.IsEmpty;

                                this.AssertValid();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        Object.defineProperty(Node.prototype, "RectangleToDraw", {
                            //*************************************************************************
                            //    Property: RectangleToDraw
                            //
                            /// <summary>
                            /// Gets the integer rectangle to draw.  Read-only.
                            /// </summary>
                            ///
                            /// <value>
                            /// The integer rectangle to draw.
                            /// </value>
                            ///
                            /// <remarks>
                            ///    This property provides the integer rectangle that should be used for
                            ///    drawing the node's rectangle.  All rectangle calculations should use
                            ///    the floating-point Rectangle property instead.
                            ///
                            /// <para>
                            ///    Do not get this property without setting Rectangle first.
                            /// </para>
                            ///
                            ///    <seealso cref="Node.Rectangle" />
                            ///
                            /// </remarks>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                // Convert to an integer Rectangle and compensate for some GDI
                                // oddities in the process.
                                return (Microsoft.Treemap.GraphicsLib.GraphicsUtil.RectangleFToRectangle(this.Rectangle, this.PenWidthPx));
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Node.prototype, "AspectRatio", {
                            //*************************************************************************
                            //    Property: AspectRatio
                            //
                            /// <summary>
                            /// Gets the aspect ratio of the node's rectangle.  Read-only.
                            /// </summary>
                            ///
                            /// <value>
                            /// Aspect ratio of the node's rectangle.
                            /// </value>
                            ///
                            /// <remarks>
                            ///    The aspect ratio is the ratio of the rectangle's longer side to its
                            ///    shorter side.  Do not get this property without setting
                            ///    Node.Rectangle first.  If the shorter side has a length of zero,
                            ///    Double.MaxValue is returned.
                            ///
                            ///    <seealso cref="Node.Rectangle" />
                            ///
                            /// </remarks>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                Diag.Debug.Assert(this.m_bRectangleSet);

                                var fWidth = this.m_oRectangle.Width;
                                var fHeight = this.m_oRectangle.Height;

                                if (fWidth > fHeight) {
                                    if (fHeight == 0)
                                        return vp.internal.MAX_VALUE;

                                    return (fWidth / fHeight);
                                }

                                if (fWidth == 0)
                                    return vp.internal.MAX_VALUE;

                                return (fHeight / fWidth);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Node.prototype, "PenWidthPx", {
                            //*************************************************************************
                            //    Property: PenWidthPx
                            //
                            /// <summary>
                            /// Gets or sets the width of the pen used to draw the node's rectangle, in
                            /// pixels.
                            /// </summary>
                            ///
                            /// <value>
                            /// Width of the pen used to draw the node's rectangle, in pixels.
                            /// </value>
                            ///
                            /// <remarks>
                            ///    Do not get this property without setting it first.
                            /// </remarks>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                // No one should ask for the pen width if it hasn't been set yet.
                                Diag.Debug.Assert(this.m_iPenWidthPx != -1);

                                return this.m_iPenWidthPx;
                            },
                            set: function (value) {
                                this.m_iPenWidthPx = value;

                                this.AssertValid();
                            },
                            enumerable: true,
                            configurable: true
                        });


                        //*************************************************************************
                        //    Method: InitializeWithValidation()
                        //
                        /// <summary>
                        ///    Validates the arguments and initializes the object.
                        /// </summary>
                        ///
                        /// <param name="sText">
                        /// Text to display within the node's rectangle.
                        /// </param>
                        ///
                        /// <param name="fSizeMetric">
                        /// Determines the size of the node's rectangle.
                        /// </param>
                        ///
                        /// <param name="fColorMetric">
                        /// Determines the fill color of the node's rectangle.
                        /// </param>
                        ///
                        /// <remarks>
                        ///    This is used by several constructors.
                        /// </remarks>
                        //*************************************************************************
                        Node.prototype.InitializeWithValidation = function (sText, fSizeMetric, color) {
                            // Validate the parameters.
                            var sMethodName = "Node";
                            Node.ValidateSizeMetric(fSizeMetric, sMethodName);

                            this.m_oTreemapGenerator = null;
                            this.m_oParentNode = null;
                            this.m_sText = sText;
                            this.m_fSizeMetric = fSizeMetric;
                            this.m_oNodeColor = color;
                            this.m_oTag = null;
                            this.m_sToolTip = null;
                            this.m_oNodes = new Generator.Nodes(this);

                            // m_oRectangle
                            // m_oSavedRectangle
                            this.m_iPenWidthPx = -1;

                            this.m_bRectangleSet = false;
                            this.m_bRectangleSaved = false;

                            this.m_oShape = null;
                            this.m_oText = null;
                        };

                        //*************************************************************************
                        //    Method: SetParent()
                        //
                        /// <summary>
                        ///    Sets the parent node.
                        /// </summary>
                        ///
                        /// <param name="oParentNode">
                        ///    The parent <see cref="Node" /> object, or null if this node belongs to
                        /// the top-level <see cref="Nodes" /> collection or the node hasn't been
                        /// added to a collection.
                        /// </param>
                        //*************************************************************************
                        Node.prototype.SetParent = function (oParentNode) {
                            Diag.Debug.Assert(oParentNode != this);

                            this.m_oParentNode = oParentNode;

                            this.AssertValid();
                        };

                        Object.defineProperty(Node.prototype, "TreemapGenerator", {
                            //*************************************************************************
                            //  Property: TreemapGenerator
                            //
                            /// <summary>
                            /// Sets the object that owns this object.
                            /// </summary>
                            ///
                            /// <value>
                            /// The TreemapGenerator object that owns this object.
                            /// </value>
                            ///
                            /// <remarks>
                            /// This method must be called after this node object is added to the
                            /// TreemapGenerator.
                            /// </remarks>
                            //*************************************************************************
                            get: function () {
                                return this.m_oTreemapGenerator;
                            },
                            set: function (value) {
                                this.m_oTreemapGenerator = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        //*************************************************************************
                        //    Method: GetNodeFromPoint()
                        //
                        /// <summary>
                        ///    Looks for the innermost node whose rectangle contains the specified
                        ///    point.
                        /// </summary>
                        ///
                        /// <param name="oPointF">
                        /// Point to get a Node object for.
                        /// </param>
                        ///
                        /// <param name="oNode">
                        /// Where the Node object gets stored.
                        /// </param>
                        ///
                        /// <returns>
                        ///    true if a Node object was found, false if not.
                        /// </returns>
                        ///
                        /// <remarks>
                        ///    If found, the Node object is stored in oNode and true is returned.
                        /// false is returned otherwise.
                        ///
                        /// <para>
                        /// Do not call this if <see cref="Rectangle" /> has not been set.
                        /// </para>
                        ///
                        /// </remarks>
                        //*************************************************************************
                        Node.prototype.GetNodeFromPoint = function (oPointF) {
                            var oNode;

                            this.AssertValid();

                            if (this.m_oRectangle && this.m_oRectangle.ContainsPoint(oPointF)) {
                                // This node's rectangle contains the point.  Is the point
                                // also contained within a descendent?
                                oNode = this.m_oNodes.GetNodeFromPoint(oPointF);
                                if (oNode == null) {
                                    // No.  Return this node.
                                    oNode = this;
                                }

                                return oNode;
                            }

                            // No node contains the point.
                            return null;
                        };

                        //*************************************************************************
                        //    Method: ValidateSizeMetric()
                        //
                        /// <summary>
                        ///    Throws an exception if iValue is not a valid SizeMetric value.
                        /// </summary>
                        ///
                        /// <param name="fValue">
                        /// Value to validate.
                        /// </param>
                        ///
                        /// <param name="sCaller">
                        /// Name of the caller, used in exception messages.  Sample: "Nodes.Add".
                        /// </param>
                        //*************************************************************************
                        Node.ValidateSizeMetric = function (fValue, sCaller) {
                            if (fValue < 0) {
                                throw new vp.internal.System.ArgumentOutOfRangeException(sCaller, fValue, sCaller + ": SizeMetric must be >= 0.");
                            }
                            // TODO: Is there an upper limit?
                        };

                        //*************************************************************************
                        //    Method: SaveRectangle()
                        //
                        /// <summary>
                        ///    Saves the Rectangle property in an internal variable.
                        /// </summary>
                        ///
                        /// <remarks>
                        ///    The saved value can be restored by calling <see
                        /// cref="RestoreRectangle" />.  These methods are provided as helpers for
                        /// ILayoutEngine objects.
                        /// </remarks>
                        ///
                        /// <seealso cref="Node.RestoreRectangle" />
                        //*************************************************************************
                        Node.prototype.SaveRectangle = function () {
                            this.m_oSavedRectangle = this.m_oRectangle;

                            this.m_bRectangleSaved = true;

                            this.AssertValid();
                        };

                        //*************************************************************************
                        //    Method: RestoreRectangle()
                        //
                        /// <summary>
                        ///    Restores the Rectangle property saved by <see cref="SaveRectangle" />.
                        /// </summary>
                        ///
                        /// <remarks>
                        ///    There can be only one <see cref="RestoreRectangle" /> call for each
                        /// <see cref="SaveRectangle" /> call.
                        /// </remarks>
                        ///
                        /// <seealso cref="Node.SaveRectangle" />
                        //*************************************************************************
                        Node.prototype.RestoreRectangle = function () {
                            Diag.Debug.Assert(this.m_bRectangleSaved);

                            this.m_oRectangle = this.m_oSavedRectangle;

                            this.m_bRectangleSaved = false;

                            this.AssertValid();
                        };

                        //*************************************************************************
                        //    Method: FireRedrawRequired()
                        //
                        /// <summary>
                        ///    Fires the TreemapGenerator.RedrawRequired event if appropriate.
                        /// </summary>
                        ///
                        /// <remarks>
                        /// This should be called when something occurs that affects the treemap's
                        /// appearance.
                        /// </remarks>
                        //*************************************************************************
                        Node.prototype.FireRedrawRequired = function () {
                            this.AssertValid();

                            // This is done by communicating directly with the TreemapGenerator.
                            // It could also be done via an event that gets handled by the
                            // TreemapGenerator, but given the potentially large number of nodes,
                            // that would be inefficient.
                            if (this.m_oTreemapGenerator != null)
                                this.m_oTreemapGenerator.FireRedrawRequired();
                        };

                        // draws rectangle for this node based on size already set and pen/brush passed in
                        Node.prototype.DisplayRectangle = function (displayRoot, iWidthPx, oPenColor, oBrush, iNodeLevel, fAnimDuration) {
                            Diag.Debug.Assert(this.m_bRectangleSet);

                            var oRect = this.RectangleToDraw;

                            // make sure pen width doesn't exceed width or height of rectangle.
                            var widthPen = iWidthPx;
                            if (widthPen * 2 > oRect.Width)
                                widthPen = oRect.Width / 2;
                            if (widthPen * 2 > oRect.Height)
                                widthPen = oRect.Height / 2;

                            // accomodate for border width -- which is drawn outside of the content box
                            oRect.Width -= widthPen * 2;
                            oRect.Height -= widthPen * 2;

                            if (this.m_oShape == null) {
                                this.m_oShape = displayRoot.append("div").css("position", "absolute").bounds(0, 0, oRect.Width, oRect.Height);
                            }

                            this.m_oShape.animate(0); // turn off animation in case one is in progress; colors can't be animated

                            this.m_oShape.css("backgroundColor", this.AbsoluteColor.ToHTML).css("borderColor", oPenColor.ToHTML).css("borderWidth", widthPen + "px").css("borderStyle", "solid").opacity(this.AbsoluteColor.A / 255).css("zIndex", (iNodeLevel * 2).toString());

                            // TODO: oBrush.Color / Linear gradient
                            // TODO: add option do enable/disable animation
                            this.m_oShape.animate(fAnimDuration).bounds(oRect.X, oRect.Y, oRect.Width, oRect.Height);

                            var tooltip = this.tooltip;
                            this.m_oShape.attr("title", tooltip);
                        };

                        Node.prototype.SetToolTip = function (str) {
                            this.tooltip = str;

                            if (this.m_oShape) {
                                this.m_oShape.attr("title", str);
                            }
                        };

                        Node.prototype.SetRectangleFill = function (fill) {
                            if (this.m_oShape) {
                                this.m_oShape.css("backgroundColor", fill.ToHTML).opacity(fill.A / 255);
                            }
                        };

                        Node.prototype.RemoveRectangle = function () {
                            if (this.m_oShape) {
                                this.m_oShape.remove();
                                this.m_oShape = null;
                            }
                        };

                        // default mechanism for text display per node
                        Node.prototype.DisplayText = function (displayRoot, oRect, oFont, oBrush, oStringFormat, iNodeLevel, fAnimDuration) {
                            if (this.m_oText == null) {
                                this.m_oText = displayRoot.append("div").css("position", "absolute").bounds(0, 0, oRect.Width, oRect.Height);
                            }

                            this.m_oText.animate(0); // turn off animation in case one is in progress; colors can't be animated
                            var tt = this.m_oText.text(this.m_sText).css("fontFamily", oFont.Name).css("fontSize", oFont.Size + "pt").css("textAlign", oStringFormat.ToCSSAlignment).css("verticalAlign", oStringFormat.ToCSSLineAlign).css("overflow", "hidden").css("cursor", "default").css("z-index", (iNodeLevel * 2 + 1).toString());

                            if (oBrush) {
                                tt.css("color", oBrush.ToHTML);
                            }

                            this.m_oText.animate(fAnimDuration).bounds(oRect.X, oRect.Y, oRect.Width, oRect.Height);

                            var tooltip = this.tooltip;
                            this.m_oText.attr("title", tooltip);
                        };

                        Node.prototype.SetTextColor = function (color) {
                            //if (this.m_oText)
                            //{
                            //    this.m_oText.css("color", color.ToHTML);
                            //}
                            this.m_oTextColor = color;
                        };

                        Node.prototype.RemoveText = function () {
                            if (this.m_oText) {
                                this.m_oText.remove();
                                this.m_oText = null;
                            }
                        };

                        Object.defineProperty(Node.prototype, "DisplayedElement", {
                            // for owner drawn elements, gets the last displayed element;
                            // the default text drawing and the owner drawn content are never used at the same time
                            get: function () {
                                return this.m_dispelem;
                            },
                            set: function (value) {
                                this.m_dispelem = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        //*************************************************************************
                        //    Method: AssertValid()
                        //
                        /// <summary>
                        ///    Asserts if the object is in an invalid state.  Debug-only.
                        /// </summary>
                        //*************************************************************************
                        Node.prototype.AssertValid = function () {
                            // m_oTreemapGenerator
                            // m_oParentNode
                            // m_sText
                            Diag.Debug.Assert(this.m_fSizeMetric >= 0);

                            // m_oNodeColor
                            // m_oTag
                            // m_sToolTip
                            Diag.Debug.Assert(this.m_oNodes != null);
                            this.m_oNodes.AssertValid();

                            // m_oRectangle
                            // m_oSavedRectangle
                            Diag.Debug.Assert(this.m_iPenWidthPx == -1 || this.m_iPenWidthPx >= 0);

                            // m_bRectangleSet
                            // m_bRectangleSaved
                            // if rectangle is empty, cannot have a shape/text
                            if (this.m_oRectangle && this.m_oRectangle.IsEmpty) {
                                Diag.Debug.Assert(this.m_oShape == null);
                                Diag.Debug.Assert(this.m_oText == null);
                            }
                        };
                        return Node;
                    })();
                    Generator.Node = Node;
                })(Treemap.Generator || (Treemap.Generator = {}));
                var Generator = Treemap.Generator;
            })(Microsoft.Treemap || (Microsoft.Treemap = {}));
            var Treemap = Microsoft.Treemap;
        })(internal.Microsoft || (internal.Microsoft = {}));
        var Microsoft = internal.Microsoft;
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));
//# sourceMappingURL=node.js.map

///----------------------------------------------------------------
/// (from treemap\nodes.js)
///----------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (internal) {
        (function (Microsoft) {
            (function (Treemap) {
                (function (Generator) {
                    var Diag = vp.internal.System.Diagnostics;

                    //*****************************************************************************
                    //    Class: Nodes
                    //
                    /// <summary>
                    /// Collection of <see cref="Node" /> objects.
                    /// </summary>
                    ///
                    /// <remarks>
                    /// The <see cref="ITreemapComponent.Nodes" /> property on <see
                    /// cref="ITreemapComponent" /> returns a Nodes collection containing the
                    /// top-level <see cref="Node" /> objects.  Also, each <see cref="Node" />
                    /// object has a <see cref="Node.Nodes" /> property that returns a Nodes
                    ///    collection containing the node's child <see cref="Node" /> objects.  A leaf
                    /// <see cref="Node" /> object has an empty Nodes collection.
                    /// </remarks>
                    ///
                    ///    <seealso cref="Node" />
                    ///    <seealso cref="ITreemapComponent.Nodes" />
                    ///
                    //  Internally, Nodes uses an ArrayList object to store the Node objects.  It
                    //  does not inherit from ArrayList, because that would expose too much
                    //     functionality to the user.
                    //
                    //*****************************************************************************
                    var Nodes = (function () {
                        //*************************************************************************
                        //    Constructor: Nodes()
                        //
                        /// <summary>
                        /// Initializes a new instance of the Node class.
                        /// </summary>
                        ///
                        /// <param name="oParentNode">
                        /// Node that this collection belongs to, or null if this is the top-level
                        /// nodes collection.
                        /// </param>
                        //*************************************************************************
                        function Nodes(oParentNode) {
                            this.Initialize(oParentNode);
                        }
                        Object.defineProperty(Nodes.prototype, "Count", {
                            //*************************************************************************
                            //    Property: Count
                            //
                            /// <summary>
                            ///    Gets the number of objects in the collection.
                            /// </summary>
                            ///
                            ///    <value>
                            ///    The number of <see cref="Node" /> objects in the <see cref="Nodes" />
                            ///    collection.
                            ///    </value>
                            ///
                            ///    <remarks>
                            ///    Use <see cref="RecursiveCount" /> to get a recursive count.
                            ///    </remarks>
                            ///
                            /// <seealso cref="RecursiveCount"/>
                            /// <seealso cref="Node "/>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oNodes.length);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        Object.defineProperty(Nodes.prototype, "RecursiveCount", {
                            //*************************************************************************
                            //    Property: RecursiveCount
                            //
                            /// <summary>
                            /// Gets the number of objects in the collection, including all descendant
                            ///    objects.
                            /// </summary>
                            ///
                            ///    <value>
                            /// The number of <see cref="Node" /> objects in the <see cref="Nodes" />
                            ///    collection, including all descendant <see cref="Node" /> objects.
                            ///    </value>
                            ///
                            ///    <remarks>
                            ///    Use <see cref="Count" /> to get a non-recursive count.
                            ///    </remarks>
                            ///
                            /// <seealso cref="Count"/>
                            /// <seealso cref="Node" />
                            //*************************************************************************
                            get: function () {
                                var iRecursiveCount = 0;

                                for (var iNode = 0; iNode < this.Count; iNode++) {
                                    var oNode = this.Item(iNode);

                                    iRecursiveCount += 1 + oNode.Nodes.RecursiveCount;
                                }

                                return (iRecursiveCount);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        //*************************************************************************
                        //    Property: Indexer
                        //
                        /// <summary>
                        ///    Gets the object at the specified index.
                        /// </summary>
                        ///
                        /// <value>
                        ///    The <see cref="Node" /> object at the specified index.
                        /// </value>
                        ///
                        /// <param name="zeroBasedIndex">
                        /// Zero-based index of the <see cref="Node" /> to get.
                        /// </param>
                        ///
                        /// <example>
                        /// Node oFirstTopLevelNode = oTreemapGenerator.Nodes[0];
                        /// </example>
                        //*************************************************************************
                        Nodes.prototype.Item = function (zeroBasedIndex) {
                            this.AssertValid();

                            var iCount = this.m_oNodes.length;

                            if (iCount == 0) {
                                throw new vp.internal.System.InvalidOperationException("Nodes[]: There are no" + " nodes in the collection.");
                            }

                            if (zeroBasedIndex < 0 || zeroBasedIndex >= iCount) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("zeroBasedIndex", zeroBasedIndex, "Nodes[]: zeroBasedIndex must be" + " between 0 and Nodes.Count-1.");
                            }

                            return this.m_oNodes[zeroBasedIndex];
                        };

                        Object.defineProperty(Nodes.prototype, "EmptySpace", {
                            //*************************************************************************
                            //    Property: EmptySpace
                            //
                            /// <summary>
                            ///    Gets the object that represents empty space in the parent rectangle.
                            /// </summary>
                            ///
                            /// <value>
                            ///    An <see
                            /// cref="Microsoft.Treemap.Generator.EmptySpace" />
                            ///    object that represents empty space in the parent rectangle.
                            /// </value>
                            ///
                            /// <remarks>
                            /// You can force empty space to appear in a node's rectangle by setting
                            /// the Node.Nodes.EmptySpace.<see
                            /// cref="Microsoft.Treemap.Generator.EmptySpace.
                            /// SizeMetric" /> property to a positive value.  The location of the empty
                            /// space is determined by the <see
                            /// cref="ITreemapComponent.EmptySpaceLocation" /> property.
                            ///
                            /// <para>
                            ///    See <see cref="Node.SizeMetric" /> for details on how the size of each
                            /// node rectangle is computed and how EmptySpace is involved in the
                            ///    computations.
                            /// </para>
                            ///
                            /// </remarks>
                            ///
                            /// <seealso
                            ///    cref="Microsoft.Treemap.Generator.EmptySpace" />
                            ///    <seealso cref="Node.SizeMetric" />
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oEmptySpace);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        //*************************************************************************
                        //    Method: Add()
                        //
                        /// <summary>
                        /// Creates a <see cref="Node" /> object with the specified text, size
                        /// metric, and absolute color, and adds it to the end of a <see
                        /// cref="Nodes" /> collection.
                        /// </summary>
                        ///
                        /// <param name="text">
                        /// Text to display within the node's rectangle.
                        /// </param>
                        ///
                        /// <param name="sizeMetric">
                        /// Determines the size of the node's rectangle.  See
                        ///    <see cref="Node.SizeMetric" />.
                        /// </param>
                        ///
                        /// <param name="absoluteColor">
                        /// Determines the fill color of the node's rectangle.  See
                        /// <see cref="Node.AbsoluteColor" />.
                        /// </param>
                        ///
                        /// <returns>
                        ///    The new <see cref="Node" /> object.
                        /// </returns>
                        ///
                        /// <remarks>
                        /// Use this method when <see
                        /// cref="ITreemapComponent.NodeColorAlgorithm" /> is set to <see
                        /// cref="NodeColorAlgorithm.UseAbsoluteColor" />.
                        /// </remarks>
                        ///
                        ///    <seealso cref="Node" />
                        //*************************************************************************
                        Nodes.prototype.Add1 = function (text, sizeMetric, absoluteColor, tag, toolTip, textColor) {
                            return this.Add(new Generator.Node(text, sizeMetric, absoluteColor, tag, toolTip, textColor));
                        };

                        //*************************************************************************
                        //    Method: Add()
                        //
                        /// <summary>
                        /// Adds an existing <see cref="Node" /> object to the end of a
                        ///    <see cref="Nodes" /> collection.
                        /// </summary>
                        ///
                        /// <param name="node">
                        /// <see cref="Node" /> object to add.
                        /// </param>
                        ///
                        /// <returns>
                        ///    The <paramref name="node" /> object.
                        /// </returns>
                        ///
                        /// <remarks>
                        ///    Do not add the same <see cref="Node" /> object to the node hierarchy
                        /// more than once.
                        /// </remarks>
                        ///
                        ///    <seealso cref="Node" />
                        //*************************************************************************
                        Nodes.prototype.Add = function (oNode) {
                            // Add it to the collection.
                            this.m_oNodes.push(oNode);

                            // Set its parent node.
                            oNode.SetParent(this.m_oParentNode);

                            // Set its owner if possible.
                            if (this.m_oTreemapGenerator != null)
                                oNode.TreemapGenerator = this.m_oTreemapGenerator;

                            // Fire a RedrawRequired event.
                            this.FireRedrawRequired();

                            this.AssertValid();

                            return oNode;
                        };

                        //*************************************************************************
                        //    Method: ToArray()
                        //
                        /// <summary>
                        /// Returns an array of the <see cref="Node" /> objects in the collection.
                        /// </summary>
                        ///
                        /// <returns>
                        ///    Array of references to the <see cref="Node" /> objects in the
                        ///    collection.  (The objects in the collection are not copied.)  If the
                        ///    collection is empty, an empty array is returned.
                        /// </returns>
                        //*************************************************************************
                        Nodes.prototype.ToArray = function () {
                            return this.m_oNodes;
                        };

                        Object.defineProperty(Nodes.prototype, "TreemapGenerator", {
                            //*************************************************************************
                            //  Property: TreemapGenerator
                            //
                            /// <summary>
                            /// Sets the object that owns this object.
                            /// </summary>
                            ///
                            /// <value>
                            /// The TreemapGenerator object that owns this object.
                            /// </value>
                            ///
                            /// <remarks>
                            /// This method must be called after this node object is added to the
                            /// TreemapGenerator.
                            /// </remarks>
                            //*************************************************************************
                            get: function () {
                                return this.m_oTreemapGenerator;
                            },
                            set: function (value) {
                                this.m_oTreemapGenerator = value;
                            },
                            enumerable: true,
                            configurable: true
                        });


                        //*************************************************************************
                        //    Method: Initialize()
                        //
                        /// <summary>
                        /// Initializes the object.
                        /// </summary>
                        ///
                        /// <param name="oParentNode">
                        /// Node that this collection belongs to, or null if this is the top-level
                        /// nodes collection.
                        /// </param>
                        //*************************************************************************
                        Nodes.prototype.Initialize = function (oParentNode) {
                            this.m_oTreemapGenerator = null;
                            this.m_oParentNode = oParentNode;
                            this.m_oNodes = new Array();
                            this.m_oEmptySpace = new Generator.EmptySpace();
                        };

                        //*************************************************************************
                        //    Method: Clear()
                        //
                        /// <summary>
                        ///    Removes all nodes from the collection and sets the SizeMetric property
                        /// on <see cref="EmptySpace" /> to zero.
                        /// </summary>
                        //*************************************************************************
                        Nodes.prototype.Clear = function () {
                            this.AssertValid();

                            this.m_oNodes.length = 0;
                            this.m_oEmptySpace = new Generator.EmptySpace();
                        };

                        //*************************************************************************
                        //    Method: GetNodeFromPoint()
                        //
                        /// <summary>
                        /// GetNodeFromPoint method.
                        /// </summary>
                        ///
                        /// <param name="oPointF">
                        /// PointF.  Point to get a Node object for.
                        /// </param>
                        ///
                        /// <param name="oNode">
                        /// Node.  Where the Node object gets stored.  null is stored if a Node
                        /// object was not found.
                        /// </param>
                        ///
                        /// <returns>
                        ///    Boolean.  true if a Node object was found, false if not.
                        /// </returns>
                        ///
                        /// <remarks>
                        ///    Looks for the innermost node whose rectangle contains the specified
                        ///    point.  If found, the Node object is stored in oNode and true is
                        ///    returned.  false is returned otherwise.
                        /// </remarks>
                        //*************************************************************************
                        Nodes.prototype.GetNodeFromPoint = function (oPointF) {
                            var oNode;

                            for (var iChildNode = 0; iChildNode < this.m_oNodes.length; iChildNode++) {
                                var oChildNode = this.m_oNodes[iChildNode];

                                oNode = oChildNode.GetNodeFromPoint(oPointF);
                                if (oNode)
                                    return oNode;
                            }

                            // No node contains the point.
                            return null;
                        };

                        //*************************************************************************
                        //    Method: ToArraySortedBySizeMetric()
                        //
                        /// <summary>
                        /// ToArraySortedBySizeMetric() method.
                        /// </summary>
                        ///
                        ///    <remarks>
                        ///    Returns an array of Node objects sorted by Node.SizeMetric.
                        ///    </remarks>
                        ///
                        /// <returns>
                        ///    Array of Node objects sorted by Node.SizeMetric in descending order.
                        ///    If this Nodes collection is empty, an empty array is returned.
                        /// </returns>
                        //*************************************************************************
                        Nodes.prototype.ToArraySortedBySizeMetric = function () {
                            // Create an array and copy the Node objects from this collection to
                            // the array.
                            var aoNodes = this.m_oNodes.slice(0);

                            // Sort the array.  The Sort() method will call Node.CompareTo(),
                            // which sorts by Node.SizeMetric.
                            aoNodes.sort(function (a, b) {
                                return b.SizeMetric - a.SizeMetric;
                            });

                            return (aoNodes);
                        };

                        //*************************************************************************
                        //    Method: FireRedrawRequired()
                        //
                        /// <summary>
                        ///    Fires the TreemapGenerator.RedrawRequired event if appropriate.
                        /// </summary>
                        ///
                        /// <remarks>
                        /// This should be called when something occurs that affects the treemap's
                        /// appearance.
                        /// </remarks>
                        //*************************************************************************
                        Nodes.prototype.FireRedrawRequired = function () {
                            // This is done by communicating directly with the TreemapGenerator.
                            // It could also be done via an event that gets handled by the
                            // TreemapGenerator, but given the potentially large number of nodes,
                            // that would be inefficient.
                            if (this.m_oTreemapGenerator != null)
                                this.m_oTreemapGenerator.FireRedrawRequired();
                        };

                        //*************************************************************************
                        //    Method: AssertValid()
                        //
                        /// <summary>
                        ///    Asserts if the object is in an invalid state.  Debug-only.
                        /// </summary>
                        //*************************************************************************
                        Nodes.prototype.AssertValid = function () {
                            Diag.Debug.Assert(this.m_oNodes != null);
                            Diag.Debug.Assert(this.m_oEmptySpace != null);
                            this.m_oEmptySpace.AssertValid();
                        };
                        return Nodes;
                    })();
                    Generator.Nodes = Nodes;
                })(Treemap.Generator || (Treemap.Generator = {}));
                var Generator = Treemap.Generator;
            })(Microsoft.Treemap || (Microsoft.Treemap = {}));
            var Treemap = Microsoft.Treemap;
        })(internal.Microsoft || (internal.Microsoft = {}));
        var Microsoft = internal.Microsoft;
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));
//# sourceMappingURL=nodes.js.map

///----------------------------------------------------------------
/// (from treemap\systemDrawing.js)
///----------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (internal) {
        (function (System) {
            (function (Drawing) {
                //export class Brush
                //{
                //}
                //export class SolidBrush extends Brush
                //{
                //    constructor (color: Color)
                //    {
                //        super();
                //        this.m_color = color;
                //    }
                //    m_color: Color;
                //    get Color(): System.Drawing.Color
                //    {
                //        return this.m_color;
                //    }
                //    set Color(value: System.Drawing.Color)
                //    {
                //        this.m_color = value;
                //    }
                //}
                //export class Brushes
                //{
                //    static get AliceBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.AliceBlue);
                //    }
                //    static get AntiqueWhite(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.AntiqueWhite);
                //    }
                //    static get Aqua(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Aqua);
                //    }
                //    static get Aquamarine(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Aquamarine);
                //    }
                //    static get Azure(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Azure);
                //    }
                //    static get Beige(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Beige);
                //    }
                //    static get Bisque(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Bisque);
                //    }
                //    static get Black(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Black);
                //    }
                //    static get BlanchedAlmond(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.BlanchedAlmond);
                //    }
                //    static get Blue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Blue);
                //    }
                //    static get BlueViolet(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.BlueViolet);
                //    }
                //    static get Brown(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Brown);
                //    }
                //    static get BurlyWood(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.BurlyWood);
                //    }
                //    static get CadetBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.CadetBlue);
                //    }
                //    static get Chartreuse(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Chartreuse);
                //    }
                //    static get Chocolate(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Chocolate);
                //    }
                //    static get Coral(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Coral);
                //    }
                //    static get CornflowerBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.CornflowerBlue);
                //    }
                //    static get Cornsilk(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Cornsilk);
                //    }
                //    static get Crimson(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Crimson);
                //    }
                //    static get Cyan(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Cyan);
                //    }
                //    static get DarkBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkBlue);
                //    }
                //    static get DarkCyan(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkCyan);
                //    }
                //    static get DarkGoldenrod(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkGoldenrod);
                //    }
                //    static get DarkGray(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkGray);
                //    }
                //    static get DarkGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkGreen);
                //    }
                //    static get DarkKhaki(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkKhaki);
                //    }
                //    static get DarkMagenta(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkMagenta);
                //    }
                //    static get DarkOliveGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkOliveGreen);
                //    }
                //    static get DarkOrange(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkOrange);
                //    }
                //    static get DarkOrchid(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkOrchid);
                //    }
                //    static get DarkRed(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkRed);
                //    }
                //    static get DarkSalmon(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkSalmon);
                //    }
                //    static get DarkSeaGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkSeaGreen);
                //    }
                //    static get DarkSlateBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkSlateBlue);
                //    }
                //    static get DarkSlateGray(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkSlateGray);
                //    }
                //    static get DarkTurquoise(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkTurquoise);
                //    }
                //    static get DarkViolet(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DarkViolet);
                //    }
                //    static get DeepPink(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DeepPink);
                //    }
                //    static get DeepSkyBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DeepSkyBlue);
                //    }
                //    static get DimGray(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DimGray);
                //    }
                //    static get DodgerBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.DodgerBlue);
                //    }
                //    static get FireBrick(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.FireBrick);
                //    }
                //    static get FloralWhite(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.FloralWhite);
                //    }
                //    static get ForestGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.ForestGreen);
                //    }
                //    static get Fuchsia(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Fuchsia);
                //    }
                //    static get Gainsboro(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Gainsboro);
                //    }
                //    static get GhostWhite(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.GhostWhite);
                //    }
                //    static get Gold(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Gold);
                //    }
                //    static get Goldenrod(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Goldenrod);
                //    }
                //    static get Gray(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Gray);
                //    }
                //    static get Green(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Green);
                //    }
                //    static get GreenYellow(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.GreenYellow);
                //    }
                //    static get Honeydew(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Honeydew);
                //    }
                //    static get HotPink(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.HotPink);
                //    }
                //    static get IndianRed(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.IndianRed);
                //    }
                //    static get Indigo(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Indigo);
                //    }
                //    static get Ivory(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Ivory);
                //    }
                //    static get Khaki(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Khaki);
                //    }
                //    static get Lavender(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Lavender);
                //    }
                //    static get LavenderBlush(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LavenderBlush);
                //    }
                //    static get LawnGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LawnGreen);
                //    }
                //    static get LemonChiffon(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LemonChiffon);
                //    }
                //    static get LightBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LightBlue);
                //    }
                //    static get LightCoral(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LightCoral);
                //    }
                //    static get LightCyan(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LightCyan);
                //    }
                //    static get LightGoldenrodYellow(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LightGoldenrodYellow);
                //    }
                //    static get LightGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LightGreen);
                //    }
                //    static get LightGray(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LightGray);
                //    }
                //    static get LightPink(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LightPink);
                //    }
                //    static get LightSalmon(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LightSalmon);
                //    }
                //    static get LightSeaGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LightSeaGreen);
                //    }
                //    static get LightSkyBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LightSkyBlue);
                //    }
                //    static get LightSlateGray(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LightSlateGray);
                //    }
                //    static get LightSteelBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LightSteelBlue);
                //    }
                //    static get LightYellow(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LightYellow);
                //    }
                //    static get Lime(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Lime);
                //    }
                //    static get LimeGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.LimeGreen);
                //    }
                //    static get Linen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Linen);
                //    }
                //    static get Magenta(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Magenta);
                //    }
                //    static get Maroon(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Maroon);
                //    }
                //    static get MediumAquamarine(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.MediumAquamarine);
                //    }
                //    static get MediumBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.MediumBlue);
                //    }
                //    static get MediumOrchid(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.MediumOrchid);
                //    }
                //    static get MediumPurple(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.MediumPurple);
                //    }
                //    static get MediumSeaGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.MediumSeaGreen);
                //    }
                //    static get MediumSlateBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.MediumSlateBlue);
                //    }
                //    static get MediumSpringGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.MediumSpringGreen);
                //    }
                //    static get MediumTurquoise(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.MediumTurquoise);
                //    }
                //    static get MediumVioletRed(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.MediumVioletRed);
                //    }
                //    static get MidnightBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.MidnightBlue);
                //    }
                //    static get MintCream(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.MintCream);
                //    }
                //    static get MistyRose(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.MistyRose);
                //    }
                //    static get Moccasin(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Moccasin);
                //    }
                //    static get NavajoWhite(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.NavajoWhite);
                //    }
                //    static get Navy(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Navy);
                //    }
                //    static get OldLace(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.OldLace);
                //    }
                //    static get Olive(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Olive);
                //    }
                //    static get OliveDrab(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.OliveDrab);
                //    }
                //    static get Orange(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Orange);
                //    }
                //    static get OrangeRed(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.OrangeRed);
                //    }
                //    static get Orchid(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Orchid);
                //    }
                //    static get PaleGoldenrod(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.PaleGoldenrod);
                //    }
                //    static get PaleGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.PaleGreen);
                //    }
                //    static get PaleTurquoise(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.PaleTurquoise);
                //    }
                //    static get PaleVioletRed(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.PaleVioletRed);
                //    }
                //    static get PapayaWhip(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.PapayaWhip);
                //    }
                //    static get PeachPuff(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.PeachPuff);
                //    }
                //    static get Peru(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Peru);
                //    }
                //    static get Pink(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Pink);
                //    }
                //    static get Plum(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Plum);
                //    }
                //    static get PowderBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.PowderBlue);
                //    }
                //    static get Purple(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Purple);
                //    }
                //    static get Red(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Red);
                //    }
                //    static get RosyBrown(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.RosyBrown);
                //    }
                //    static get RoyalBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.RoyalBlue);
                //    }
                //    static get SaddleBrown(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.SaddleBrown);
                //    }
                //    static get Salmon(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Salmon);
                //    }
                //    static get SandyBrown(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.SandyBrown);
                //    }
                //    static get SeaGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.SeaGreen);
                //    }
                //    static get Seashell(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Seashell);
                //    }
                //    static get Sienna(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Sienna);
                //    }
                //    static get Silver(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Silver);
                //    }
                //    static get SkyBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.SkyBlue);
                //    }
                //    static get SlateBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.SlateBlue);
                //    }
                //    static get SlateGray(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.SlateGray);
                //    }
                //    static get Snow(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Snow);
                //    }
                //    static get SpringGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.SpringGreen);
                //    }
                //    static get SteelBlue(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.SteelBlue);
                //    }
                //    static get Tan(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Tan);
                //    }
                //    static get Teal(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Teal);
                //    }
                //    static get Thistle(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Thistle);
                //    }
                //    static get Tomato(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Tomato);
                //    }
                //    static get Turquoise(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Turquoise);
                //    }
                //    static get Violet(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Violet);
                //    }
                //    static get Wheat(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Wheat);
                //    }
                //    static get White(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.White);
                //    }
                //    static get WhiteSmoke(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.WhiteSmoke);
                //    }
                //    static get Yellow(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.Yellow);
                //    }
                //    static get YellowGreen(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(Color.YellowGreen);
                //    }
                //}
                var Color = (function () {
                    function Color(alpha, red, green, blue) {
                        this.m_alpha = alpha;
                        this.m_red = red;
                        this.m_green = green;
                        this.m_blue = blue;
                    }
                    Color.FromArgb1 = function (argb) {
                        return new Color((argb & 0xff000000) >> 24, (argb & 0x00ff0000) >> 16, (argb & 0x0000ff00) >> 8, (argb & 0x000000ff));
                    };
                    Color.FromArgb2 = function (alpha, red, green, blue) {
                        return new Color(alpha, red, green, blue);
                    };

                    Color.FromArgb3 = function (alpha, baseColor) {
                        return new Color(alpha, baseColor.m_red, baseColor.m_green, baseColor.m_blue);
                    };

                    Color.FromArgb4 = function (red, green, blue) {
                        return new Color(0xff, red, green, blue);
                    };

                    Color.prototype.GetBrightness = function () {
                        var num = this.m_red / 255;
                        var num2 = this.m_green / 255;
                        var num3 = this.m_blue / 255;
                        var num4 = num;
                        var num5 = num;
                        if (num2 > num4) {
                            num4 = num2;
                        }
                        if (num3 > num4) {
                            num4 = num3;
                        }
                        if (num2 < num5) {
                            num5 = num2;
                        }
                        if (num3 < num5) {
                            num5 = num3;
                        }
                        return ((num4 + num5) / 2);
                    };

                    Color.prototype.GetHue = function () {
                        if ((this.m_red == this.m_green) && (this.m_green == this.m_blue)) {
                            return 0;
                        }

                        var num = this.m_red / 255;
                        var num2 = this.m_green / 255;
                        var num3 = this.m_blue / 255;
                        var num7 = 0;
                        var num4 = num;
                        var num5 = num;
                        if (num2 > num4) {
                            num4 = num2;
                        }
                        if (num3 > num4) {
                            num4 = num3;
                        }
                        if (num2 < num5) {
                            num5 = num2;
                        }
                        if (num3 < num5) {
                            num5 = num3;
                        }
                        var num6 = num4 - num5;
                        if (num == num4) {
                            num7 = (num2 - num3) / num6;
                        } else if (num2 == num4) {
                            num7 = 2 + ((num3 - num) / num6);
                        } else if (num3 == num4) {
                            num7 = 4 + ((num - num2) / num6);
                        }
                        num7 *= 60;
                        if (num7 < 0) {
                            num7 += 360;
                        }
                        return num7;
                    };

                    Color.prototype.GetSaturation = function () {
                        var num = this.m_red / 255;
                        var num2 = this.m_green / 255;
                        var num3 = this.m_blue / 255;
                        var num7 = 0;
                        var num4 = num;
                        var num5 = num;
                        if (num2 > num4) {
                            num4 = num2;
                        }
                        if (num3 > num4) {
                            num4 = num3;
                        }
                        if (num2 < num5) {
                            num5 = num2;
                        }
                        if (num3 < num5) {
                            num5 = num3;
                        }
                        if (num4 == num5) {
                            return num7;
                        }
                        var num6 = (num4 + num5) / 2;
                        if (num6 <= 0.5) {
                            return ((num4 - num5) / (num4 + num5));
                        }
                        return ((num4 - num5) / ((2 - num4) - num5));
                    };

                    Color.prototype.ToArgb = function () {
                        return (this.m_alpha << 24) | (this.m_red << 16) | (this.m_green << 8) | (this.m_blue);
                    };

                    Object.defineProperty(Color.prototype, "ToHTML", {
                        get: function () {
                            var r = "0" + this.m_red.toString(16);
                            var g = "0" + this.m_green.toString(16);
                            var b = "0" + this.m_blue.toString(16);

                            return "#" + r.substring(r.length - 2) + g.substring(g.length - 2) + b.substring(b.length - 2);
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Color.prototype, "A", {
                        get: function () {
                            return this.m_alpha;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Color.prototype, "R", {
                        get: function () {
                            return this.m_red;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Color.prototype, "G", {
                        get: function () {
                            return this.m_green;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Color.prototype, "B", {
                        get: function () {
                            return this.m_blue;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Color, "AliceBlue", {
                        get: function () {
                            return new Color(255, 240, 248, 255);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "AntiqueWhite", {
                        get: function () {
                            return new Color(255, 250, 235, 215);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Aqua", {
                        get: function () {
                            return new Color(255, 0, 255, 255);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Aquamarine", {
                        get: function () {
                            return new Color(255, 127, 255, 212);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Azure", {
                        get: function () {
                            return new Color(255, 240, 255, 255);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Beige", {
                        get: function () {
                            return new Color(255, 245, 245, 220);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Bisque", {
                        get: function () {
                            return new Color(255, 255, 228, 196);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Black", {
                        get: function () {
                            return new Color(255, 0, 0, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "BlanchedAlmond", {
                        get: function () {
                            return new Color(255, 255, 235, 205);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Blue", {
                        get: function () {
                            return new Color(255, 0, 0, 255);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "BlueViolet", {
                        get: function () {
                            return new Color(255, 138, 43, 226);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Brown", {
                        get: function () {
                            return new Color(255, 165, 42, 42);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "BurlyWood", {
                        get: function () {
                            return new Color(255, 222, 184, 135);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "CadetBlue", {
                        get: function () {
                            return new Color(255, 95, 158, 160);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Chartreuse", {
                        get: function () {
                            return new Color(255, 127, 255, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Chocolate", {
                        get: function () {
                            return new Color(255, 210, 105, 30);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Coral", {
                        get: function () {
                            return new Color(255, 255, 127, 80);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "CornflowerBlue", {
                        get: function () {
                            return new Color(255, 100, 149, 237);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Cornsilk", {
                        get: function () {
                            return new Color(255, 255, 248, 220);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Crimson", {
                        get: function () {
                            return new Color(255, 220, 20, 60);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Cyan", {
                        get: function () {
                            return new Color(255, 0, 255, 255);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkBlue", {
                        get: function () {
                            return new Color(255, 0, 0, 139);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkCyan", {
                        get: function () {
                            return new Color(255, 0, 139, 139);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkGoldenrod", {
                        get: function () {
                            return new Color(255, 184, 134, 11);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkGray", {
                        get: function () {
                            return new Color(255, 169, 169, 169);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkGreen", {
                        get: function () {
                            return new Color(255, 0, 100, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkKhaki", {
                        get: function () {
                            return new Color(255, 189, 183, 107);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkMagenta", {
                        get: function () {
                            return new Color(255, 139, 0, 139);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkOliveGreen", {
                        get: function () {
                            return new Color(255, 85, 107, 47);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkOrange", {
                        get: function () {
                            return new Color(255, 255, 140, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkOrchid", {
                        get: function () {
                            return new Color(255, 153, 50, 204);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkRed", {
                        get: function () {
                            return new Color(255, 139, 0, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkSalmon", {
                        get: function () {
                            return new Color(255, 233, 150, 122);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkSeaGreen", {
                        get: function () {
                            return new Color(255, 143, 188, 143);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkSlateBlue", {
                        get: function () {
                            return new Color(255, 72, 61, 139);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkSlateGray", {
                        get: function () {
                            return new Color(255, 47, 79, 79);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkTurquoise", {
                        get: function () {
                            return new Color(255, 0, 206, 209);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DarkViolet", {
                        get: function () {
                            return new Color(255, 148, 0, 211);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DeepPink", {
                        get: function () {
                            return new Color(255, 255, 20, 147);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DeepSkyBlue", {
                        get: function () {
                            return new Color(255, 0, 191, 255);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DimGray", {
                        get: function () {
                            return new Color(255, 105, 105, 105);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "DodgerBlue", {
                        get: function () {
                            return new Color(255, 30, 144, 255);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "FireBrick", {
                        get: function () {
                            return new Color(255, 178, 34, 34);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "FloralWhite", {
                        get: function () {
                            return new Color(255, 255, 250, 240);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "ForestGreen", {
                        get: function () {
                            return new Color(255, 34, 139, 34);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Fuchsia", {
                        get: function () {
                            return new Color(255, 255, 0, 255);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Gainsboro", {
                        get: function () {
                            return new Color(255, 220, 220, 220);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "GhostWhite", {
                        get: function () {
                            return new Color(255, 248, 248, 255);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Gold", {
                        get: function () {
                            return new Color(255, 255, 215, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Goldenrod", {
                        get: function () {
                            return new Color(255, 218, 165, 32);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Gray", {
                        get: function () {
                            return new Color(255, 128, 128, 128);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Green", {
                        get: function () {
                            return new Color(255, 0, 128, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "GreenYellow", {
                        get: function () {
                            return new Color(255, 173, 255, 47);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Honeydew", {
                        get: function () {
                            return new Color(255, 240, 255, 240);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "HotPink", {
                        get: function () {
                            return new Color(255, 255, 105, 180);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "IndianRed", {
                        get: function () {
                            return new Color(255, 205, 92, 92);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Indigo", {
                        get: function () {
                            return new Color(255, 75, 0, 130);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Ivory", {
                        get: function () {
                            return new Color(255, 255, 255, 240);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Khaki", {
                        get: function () {
                            return new Color(255, 240, 230, 140);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Lavender", {
                        get: function () {
                            return new Color(255, 230, 230, 250);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LavenderBlush", {
                        get: function () {
                            return new Color(255, 255, 240, 245);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LawnGreen", {
                        get: function () {
                            return new Color(255, 124, 252, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LemonChiffon", {
                        get: function () {
                            return new Color(255, 255, 250, 205);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LightBlue", {
                        get: function () {
                            return new Color(255, 173, 216, 230);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LightCoral", {
                        get: function () {
                            return new Color(255, 240, 128, 128);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LightCyan", {
                        get: function () {
                            return new Color(255, 224, 255, 255);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LightGoldenrodYellow", {
                        get: function () {
                            return new Color(255, 250, 250, 210);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LightGreen", {
                        get: function () {
                            return new Color(255, 144, 238, 144);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LightGray", {
                        get: function () {
                            return new Color(255, 211, 211, 211);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LightPink", {
                        get: function () {
                            return new Color(255, 255, 182, 193);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LightSalmon", {
                        get: function () {
                            return new Color(255, 255, 160, 122);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LightSeaGreen", {
                        get: function () {
                            return new Color(255, 32, 178, 170);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LightSkyBlue", {
                        get: function () {
                            return new Color(255, 135, 206, 250);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LightSlateGray", {
                        get: function () {
                            return new Color(255, 119, 136, 153);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LightSteelBlue", {
                        get: function () {
                            return new Color(255, 176, 196, 222);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LightYellow", {
                        get: function () {
                            return new Color(255, 255, 255, 224);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Lime", {
                        get: function () {
                            return new Color(255, 0, 255, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "LimeGreen", {
                        get: function () {
                            return new Color(255, 50, 205, 50);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Linen", {
                        get: function () {
                            return new Color(255, 250, 240, 230);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Magenta", {
                        get: function () {
                            return new Color(255, 255, 0, 255);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Maroon", {
                        get: function () {
                            return new Color(255, 128, 0, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "MediumAquamarine", {
                        get: function () {
                            return new Color(255, 102, 205, 170);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "MediumBlue", {
                        get: function () {
                            return new Color(255, 0, 0, 205);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "MediumOrchid", {
                        get: function () {
                            return new Color(255, 186, 85, 211);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "MediumPurple", {
                        get: function () {
                            return new Color(255, 147, 112, 219);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "MediumSeaGreen", {
                        get: function () {
                            return new Color(255, 60, 179, 113);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "MediumSlateBlue", {
                        get: function () {
                            return new Color(255, 123, 104, 238);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "MediumSpringGreen", {
                        get: function () {
                            return new Color(255, 0, 250, 154);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "MediumTurquoise", {
                        get: function () {
                            return new Color(255, 72, 209, 204);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "MediumVioletRed", {
                        get: function () {
                            return new Color(255, 199, 21, 133);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "MidnightBlue", {
                        get: function () {
                            return new Color(255, 25, 25, 112);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "MintCream", {
                        get: function () {
                            return new Color(255, 245, 255, 250);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "MistyRose", {
                        get: function () {
                            return new Color(255, 255, 228, 225);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Moccasin", {
                        get: function () {
                            return new Color(255, 255, 228, 181);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "NavajoWhite", {
                        get: function () {
                            return new Color(255, 255, 222, 173);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Navy", {
                        get: function () {
                            return new Color(255, 0, 0, 128);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "OldLace", {
                        get: function () {
                            return new Color(255, 253, 245, 230);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Olive", {
                        get: function () {
                            return new Color(255, 128, 128, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "OliveDrab", {
                        get: function () {
                            return new Color(255, 107, 142, 35);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Orange", {
                        get: function () {
                            return new Color(255, 255, 165, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "OrangeRed", {
                        get: function () {
                            return new Color(255, 255, 69, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Orchid", {
                        get: function () {
                            return new Color(255, 218, 112, 214);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "PaleGoldenrod", {
                        get: function () {
                            return new Color(255, 238, 232, 170);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "PaleGreen", {
                        get: function () {
                            return new Color(255, 152, 251, 152);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "PaleTurquoise", {
                        get: function () {
                            return new Color(255, 175, 238, 238);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "PaleVioletRed", {
                        get: function () {
                            return new Color(255, 219, 112, 147);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "PapayaWhip", {
                        get: function () {
                            return new Color(255, 255, 239, 213);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "PeachPuff", {
                        get: function () {
                            return new Color(255, 255, 218, 185);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Peru", {
                        get: function () {
                            return new Color(255, 205, 133, 63);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Pink", {
                        get: function () {
                            return new Color(255, 255, 192, 203);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Plum", {
                        get: function () {
                            return new Color(255, 221, 160, 221);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "PowderBlue", {
                        get: function () {
                            return new Color(255, 176, 224, 230);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Purple", {
                        get: function () {
                            return new Color(255, 128, 0, 128);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Red", {
                        get: function () {
                            return new Color(255, 255, 0, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "RosyBrown", {
                        get: function () {
                            return new Color(255, 188, 143, 143);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "RoyalBlue", {
                        get: function () {
                            return new Color(255, 65, 105, 225);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "SaddleBrown", {
                        get: function () {
                            return new Color(255, 139, 69, 19);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Salmon", {
                        get: function () {
                            return new Color(255, 250, 128, 114);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "SandyBrown", {
                        get: function () {
                            return new Color(255, 244, 164, 96);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "SeaGreen", {
                        get: function () {
                            return new Color(255, 46, 139, 87);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Seashell", {
                        get: function () {
                            return new Color(255, 255, 245, 238);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Sienna", {
                        get: function () {
                            return new Color(255, 160, 82, 45);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Silver", {
                        get: function () {
                            return new Color(255, 192, 192, 192);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "SkyBlue", {
                        get: function () {
                            return new Color(255, 135, 206, 235);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "SlateBlue", {
                        get: function () {
                            return new Color(255, 106, 90, 205);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "SlateGray", {
                        get: function () {
                            return new Color(255, 112, 128, 144);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Snow", {
                        get: function () {
                            return new Color(255, 255, 250, 250);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "SpringGreen", {
                        get: function () {
                            return new Color(255, 0, 255, 127);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "SteelBlue", {
                        get: function () {
                            return new Color(255, 70, 130, 180);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Tan", {
                        get: function () {
                            return new Color(255, 210, 180, 140);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Teal", {
                        get: function () {
                            return new Color(255, 0, 128, 128);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Thistle", {
                        get: function () {
                            return new Color(255, 216, 191, 216);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Tomato", {
                        get: function () {
                            return new Color(255, 255, 99, 71);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Turquoise", {
                        get: function () {
                            return new Color(255, 64, 224, 208);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Violet", {
                        get: function () {
                            return new Color(255, 238, 130, 238);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Wheat", {
                        get: function () {
                            return new Color(255, 245, 222, 179);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "White", {
                        get: function () {
                            return new Color(255, 255, 255, 255);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "WhiteSmoke", {
                        get: function () {
                            return new Color(255, 245, 245, 245);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "Yellow", {
                        get: function () {
                            return new Color(255, 255, 255, 0);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Color, "YellowGreen", {
                        get: function () {
                            return new Color(255, 154, 205, 50);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Color.Empty = new Color(0, 0, 0, 0);
                    return Color;
                })();
                Drawing.Color = Color;

                (function (ContentAlignment) {
                    ContentAlignment[ContentAlignment["BottomCenter"] = 0] = "BottomCenter";
                    ContentAlignment[ContentAlignment["BottomLeft"] = 1] = "BottomLeft";
                    ContentAlignment[ContentAlignment["BottomRight"] = 2] = "BottomRight";
                    ContentAlignment[ContentAlignment["MiddleCenter"] = 3] = "MiddleCenter";
                    ContentAlignment[ContentAlignment["MiddleLeft"] = 4] = "MiddleLeft";
                    ContentAlignment[ContentAlignment["MiddleRight"] = 5] = "MiddleRight";
                    ContentAlignment[ContentAlignment["TopCenter"] = 6] = "TopCenter";
                    ContentAlignment[ContentAlignment["TopLeft"] = 7] = "TopLeft";
                    ContentAlignment[ContentAlignment["TopRight"] = 8] = "TopRight";
                })(Drawing.ContentAlignment || (Drawing.ContentAlignment = {}));
                var ContentAlignment = Drawing.ContentAlignment;

                /*
                export enum CopyPixelOperation
                {
                Blackness,
                CaptureBlt,
                DestinationInvert,
                MergeCopy,
                MergePaint,
                NoMirrorBitmap,
                NotSourceCopy,
                NotSourceErase,
                PatCopy,
                PatInvert,
                PatPaint,
                SourceAnd,
                SourceCopy,
                SourceErase,
                SourceInvert,
                SourcePaint,
                Whiteness,
                }
                */
                var Font = (function () {
                    function Font(familyName, emSize) {
                        this.m_familyName = familyName;
                        this.m_emSize = emSize;
                    }
                    Object.defineProperty(Font.prototype, "Bold", {
                        get: function () {
                            // TODO
                            return false;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Font.prototype, "FontFamily", {
                        get: function () {
                            // TODO
                            return new FontFamily(this.m_familyName);
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Font.prototype, "Height", {
                        get: function () {
                            // TODO
                            return 4;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Font.prototype, "Italic", {
                        get: function () {
                            return false;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Font.prototype, "Name", {
                        get: function () {
                            return this.m_familyName;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Font.prototype, "Size", {
                        get: function () {
                            return this.m_emSize;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Font.prototype, "SizeInPoints", {
                        get: function () {
                            return this.m_emSize;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Font.prototype, "Strikeout", {
                        get: function () {
                            return false;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Font.prototype, "Underline", {
                        get: function () {
                            return false;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Font.prototype, "ToHTML", {
                        /*
                        get Unit(): System.Drawing.GraphicsUnit
                        {
                        return GraphicsUnit.Point;
                        }
                        */
                        get: function () {
                            var font = this.m_emSize + "pt " + this.m_familyName;

                            /*
                            if (this.fontWeight != undefined)
                            {
                            font += " " + this.fontWeight;
                            }
                            if (this.fontStyle != undefined)
                            {
                            font += " " + this.fontStyle;
                            }
                            */
                            return font;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return Font;
                })();
                Drawing.Font = Font;

                var FontFamily = (function () {
                    function FontFamily(familyName) {
                        this.m_familyName = familyName;
                    }
                    FontFamily.prototype.GetName = function (language) {
                        return this.m_familyName;
                    };

                    Object.defineProperty(FontFamily.prototype, "Name", {
                        get: function () {
                            return this.m_familyName;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return FontFamily;
                })();
                Drawing.FontFamily = FontFamily;

                (function (FontStyle) {
                    FontStyle[FontStyle["Bold"] = 1] = "Bold";
                    FontStyle[FontStyle["Italic"] = 2] = "Italic";
                    FontStyle[FontStyle["Regular"] = 0] = "Regular";
                    FontStyle[FontStyle["Strikeout"] = 8] = "Strikeout";
                    FontStyle[FontStyle["Underline"] = 4] = "Underline";
                })(Drawing.FontStyle || (Drawing.FontStyle = {}));
                var FontStyle = Drawing.FontStyle;

                /*
                export enum GraphicsUnit
                {
                Display,
                Document,
                Inch,
                Millimeter,
                Pixel,
                Point,
                World,
                }
                */
                /*
                export enum KnownColor
                {
                ActiveBorder,
                ActiveCaption,
                ActiveCaptionText,
                AliceBlue,
                AntiqueWhite,
                AppWorkspace,
                Aqua,
                Aquamarine,
                Azure,
                Beige,
                Bisque,
                Black,
                BlanchedAlmond,
                Blue,
                BlueViolet,
                Brown,
                BurlyWood,
                ButtonFace,
                ButtonHighlight,
                ButtonShadow,
                CadetBlue,
                Chartreuse,
                Chocolate,
                Control,
                ControlDark,
                ControlDarkDark,
                ControlLight,
                ControlLightLight,
                ControlText,
                Coral,
                CornflowerBlue,
                Cornsilk,
                Crimson,
                Cyan,
                DarkBlue,
                DarkCyan,
                DarkGoldenrod,
                DarkGray,
                DarkGreen,
                DarkKhaki,
                DarkMagenta,
                DarkOliveGreen,
                DarkOrange,
                DarkOrchid,
                DarkRed,
                DarkSalmon,
                DarkSeaGreen,
                DarkSlateBlue,
                DarkSlateGray,
                DarkTurquoise,
                DarkViolet,
                DeepPink,
                DeepSkyBlue,
                Desktop,
                DimGray,
                DodgerBlue,
                Firebrick,
                FloralWhite,
                ForestGreen,
                Fuchsia,
                Gainsboro,
                GhostWhite,
                Gold,
                Goldenrod,
                GradientActiveCaption,
                GradientInactiveCaption,
                Gray,
                GrayText,
                Green,
                GreenYellow,
                Highlight,
                HighlightText,
                Honeydew,
                HotPink,
                HotTrack,
                InactiveBorder,
                InactiveCaption,
                InactiveCaptionText,
                IndianRed,
                Indigo,
                Info,
                InfoText,
                Ivory,
                Khaki,
                Lavender,
                LavenderBlush,
                LawnGreen,
                LemonChiffon,
                LightBlue,
                LightCoral,
                LightCyan,
                LightGoldenrodYellow,
                LightGray,
                LightGreen,
                LightPink,
                LightSalmon,
                LightSeaGreen,
                LightSkyBlue,
                LightSlateGray,
                LightSteelBlue,
                LightYellow,
                Lime,
                LimeGreen,
                Linen,
                Magenta,
                Maroon,
                MediumAquamarine,
                MediumBlue,
                MediumOrchid,
                MediumPurple,
                MediumSeaGreen,
                MediumSlateBlue,
                MediumSpringGreen,
                MediumTurquoise,
                MediumVioletRed,
                Menu,
                MenuBar,
                MenuHighlight,
                MenuText,
                MidnightBlue,
                MintCream,
                MistyRose,
                Moccasin,
                NavajoWhite,
                Navy,
                OldLace,
                Olive,
                OliveDrab,
                Orange,
                OrangeRed,
                Orchid,
                PaleGoldenrod,
                PaleGreen,
                PaleTurquoise,
                PaleVioletRed,
                PapayaWhip,
                PeachPuff,
                Peru,
                Pink,
                Plum,
                PowderBlue,
                Purple,
                Red,
                RosyBrown,
                RoyalBlue,
                SaddleBrown,
                Salmon,
                SandyBrown,
                ScrollBar,
                SeaGreen,
                SeaShell,
                Sienna,
                Silver,
                SkyBlue,
                SlateBlue,
                SlateGray,
                Snow,
                SpringGreen,
                SteelBlue,
                Tan,
                Teal,
                Thistle,
                Tomato,
                Transparent,
                Turquoise,
                Violet,
                Wheat,
                White,
                WhiteSmoke,
                Window,
                WindowFrame,
                WindowText,
                Yellow,
                YellowGreen,
                }
                */
                /*
                export class Pen
                {
                constructor
                (
                color: Color,
                width? : number
                )
                {
                this.m_color = color;
                if (width)
                this.m_width = width;
                else
                this.m_width = 1;
                }
                
                m_color: Color;
                m_width: number;
                
                m_alignment: Drawing2D.PenAlignment = Drawing2D.PenAlignment.Left;
                
                get Alignment(): System.Drawing.Drawing2D.PenAlignment
                {
                return this.m_alignment;
                }
                set Alignment(value: System.Drawing.Drawing2D.PenAlignment)
                {
                this.m_alignment = value;
                }
                get Color(): System.Drawing.Color
                {
                return this.m_color;
                }
                set Color(value: System.Drawing.Color)
                {
                this.m_color = value;
                }
                get PenType(): System.Drawing.Drawing2D.PenType
                {
                return Drawing2D.PenType.SolidColor;
                }
                get Width(): number
                {
                return this.m_width;
                }
                set Width(value: number)
                {
                this.m_width = value;
                }
                }*/
                /*
                export class Pens
                {
                static get AliceBlue(): System.Drawing.Pen
                {
                return new Pen(Color.AliceBlue);
                }
                static get AntiqueWhite(): System.Drawing.Pen
                {
                return new Pen(Color.AntiqueWhite);
                }
                static get Aqua(): System.Drawing.Pen
                {
                return new Pen(Color.Aqua);
                }
                static get Aquamarine(): System.Drawing.Pen
                {
                return new Pen(Color.Aquamarine);
                }
                static get Azure(): System.Drawing.Pen
                {
                return new Pen(Color.Azure);
                }
                static get Beige(): System.Drawing.Pen
                {
                return new Pen(Color.Beige);
                }
                static get Bisque(): System.Drawing.Pen
                {
                return new Pen(Color.Bisque);
                }
                static get Black(): System.Drawing.Pen
                {
                return new Pen(Color.Black);
                }
                static get BlanchedAlmond(): System.Drawing.Pen
                {
                return new Pen(Color.BlanchedAlmond);
                }
                static get Blue(): System.Drawing.Pen
                {
                return new Pen(Color.Blue);
                }
                static get BlueViolet(): System.Drawing.Pen
                {
                return new Pen(Color.BlueViolet);
                }
                static get Brown(): System.Drawing.Pen
                {
                return new Pen(Color.Brown);
                }
                static get BurlyWood(): System.Drawing.Pen
                {
                return new Pen(Color.BurlyWood);
                }
                static get CadetBlue(): System.Drawing.Pen
                {
                return new Pen(Color.CadetBlue);
                }
                static get Chartreuse(): System.Drawing.Pen
                {
                return new Pen(Color.Chartreuse);
                }
                static get Chocolate(): System.Drawing.Pen
                {
                return new Pen(Color.Chocolate);
                }
                static get Coral(): System.Drawing.Pen
                {
                return new Pen(Color.Coral);
                }
                static get CornflowerBlue(): System.Drawing.Pen
                {
                return new Pen(Color.CornflowerBlue);
                }
                static get Cornsilk(): System.Drawing.Pen
                {
                return new Pen(Color.Cornsilk);
                }
                static get Crimson(): System.Drawing.Pen
                {
                return new Pen(Color.Crimson);
                }
                static get Cyan(): System.Drawing.Pen
                {
                return new Pen(Color.Cyan);
                }
                static get DarkBlue(): System.Drawing.Pen
                {
                return new Pen(Color.DarkBlue);
                }
                static get DarkCyan(): System.Drawing.Pen
                {
                return new Pen(Color.DarkCyan);
                }
                static get DarkGoldenrod(): System.Drawing.Pen
                {
                return new Pen(Color.DarkGoldenrod);
                }
                static get DarkGray(): System.Drawing.Pen
                {
                return new Pen(Color.DarkGray);
                }
                static get DarkGreen(): System.Drawing.Pen
                {
                return new Pen(Color.DarkGreen);
                }
                static get DarkKhaki(): System.Drawing.Pen
                {
                return new Pen(Color.DarkKhaki);
                }
                static get DarkMagenta(): System.Drawing.Pen
                {
                return new Pen(Color.DarkMagenta);
                }
                static get DarkOliveGreen(): System.Drawing.Pen
                {
                return new Pen(Color.DarkOliveGreen);
                }
                static get DarkOrange(): System.Drawing.Pen
                {
                return new Pen(Color.DarkOrange);
                }
                static get DarkOrchid(): System.Drawing.Pen
                {
                return new Pen(Color.DarkOrchid);
                }
                static get DarkRed(): System.Drawing.Pen
                {
                return new Pen(Color.DarkRed);
                }
                static get DarkSalmon(): System.Drawing.Pen
                {
                return new Pen(Color.DarkSalmon);
                }
                static get DarkSeaGreen(): System.Drawing.Pen
                {
                return new Pen(Color.DarkSeaGreen);
                }
                static get DarkSlateBlue(): System.Drawing.Pen
                {
                return new Pen(Color.DarkSlateBlue);
                }
                static get DarkSlateGray(): System.Drawing.Pen
                {
                return new Pen(Color.DarkSlateGray);
                }
                static get DarkTurquoise(): System.Drawing.Pen
                {
                return new Pen(Color.DarkTurquoise);
                }
                static get DarkViolet(): System.Drawing.Pen
                {
                return new Pen(Color.DarkViolet);
                }
                static get DeepPink(): System.Drawing.Pen
                {
                return new Pen(Color.DeepPink);
                }
                static get DeepSkyBlue(): System.Drawing.Pen
                {
                return new Pen(Color.DeepSkyBlue);
                }
                static get DimGray(): System.Drawing.Pen
                {
                return new Pen(Color.DimGray);
                }
                static get DodgerBlue(): System.Drawing.Pen
                {
                return new Pen(Color.DodgerBlue);
                }
                static get FireBrick(): System.Drawing.Pen
                {
                return new Pen(Color.FireBrick);
                }
                static get FloralWhite(): System.Drawing.Pen
                {
                return new Pen(Color.FloralWhite);
                }
                static get ForestGreen(): System.Drawing.Pen
                {
                return new Pen(Color.ForestGreen);
                }
                static get Fuchsia(): System.Drawing.Pen
                {
                return new Pen(Color.Fuchsia);
                }
                static get Gainsboro(): System.Drawing.Pen
                {
                return new Pen(Color.Gainsboro);
                }
                static get GhostWhite(): System.Drawing.Pen
                {
                return new Pen(Color.GhostWhite);
                }
                static get Gold(): System.Drawing.Pen
                {
                return new Pen(Color.Gold);
                }
                static get Goldenrod(): System.Drawing.Pen
                {
                return new Pen(Color.Goldenrod);
                }
                static get Gray(): System.Drawing.Pen
                {
                return new Pen(Color.Gray);
                }
                static get Green(): System.Drawing.Pen
                {
                return new Pen(Color.Green);
                }
                static get GreenYellow(): System.Drawing.Pen
                {
                return new Pen(Color.GreenYellow);
                }
                static get Honeydew(): System.Drawing.Pen
                {
                return new Pen(Color.Honeydew);
                }
                static get HotPink(): System.Drawing.Pen
                {
                return new Pen(Color.HotPink);
                }
                static get IndianRed(): System.Drawing.Pen
                {
                return new Pen(Color.IndianRed);
                }
                static get Indigo(): System.Drawing.Pen
                {
                return new Pen(Color.Indigo);
                }
                static get Ivory(): System.Drawing.Pen
                {
                return new Pen(Color.Ivory);
                }
                static get Khaki(): System.Drawing.Pen
                {
                return new Pen(Color.Khaki);
                }
                static get Lavender(): System.Drawing.Pen
                {
                return new Pen(Color.Lavender);
                }
                static get LavenderBlush(): System.Drawing.Pen
                {
                return new Pen(Color.LavenderBlush);
                }
                static get LawnGreen(): System.Drawing.Pen
                {
                return new Pen(Color.LawnGreen);
                }
                static get LemonChiffon(): System.Drawing.Pen
                {
                return new Pen(Color.LemonChiffon);
                }
                static get LightBlue(): System.Drawing.Pen
                {
                return new Pen(Color.LightBlue);
                }
                static get LightCoral(): System.Drawing.Pen
                {
                return new Pen(Color.LightCoral);
                }
                static get LightCyan(): System.Drawing.Pen
                {
                return new Pen(Color.LightCyan);
                }
                static get LightGoldenrodYellow(): System.Drawing.Pen
                {
                return new Pen(Color.LightGoldenrodYellow);
                }
                static get LightGreen(): System.Drawing.Pen
                {
                return new Pen(Color.LightGreen);
                }
                static get LightGray(): System.Drawing.Pen
                {
                return new Pen(Color.LightGray);
                }
                static get LightPink(): System.Drawing.Pen
                {
                return new Pen(Color.LightPink);
                }
                static get LightSalmon(): System.Drawing.Pen
                {
                return new Pen(Color.LightSalmon);
                }
                static get LightSeaGreen(): System.Drawing.Pen
                {
                return new Pen(Color.LightSeaGreen);
                }
                static get LightSkyBlue(): System.Drawing.Pen
                {
                return new Pen(Color.LightSkyBlue);
                }
                static get LightSlateGray(): System.Drawing.Pen
                {
                return new Pen(Color.LightSlateGray);
                }
                static get LightSteelBlue(): System.Drawing.Pen
                {
                return new Pen(Color.LightSteelBlue);
                }
                static get LightYellow(): System.Drawing.Pen
                {
                return new Pen(Color.LightYellow);
                }
                static get Lime(): System.Drawing.Pen
                {
                return new Pen(Color.Lime);
                }
                static get LimeGreen(): System.Drawing.Pen
                {
                return new Pen(Color.LimeGreen);
                }
                static get Linen(): System.Drawing.Pen
                {
                return new Pen(Color.Linen);
                }
                static get Magenta(): System.Drawing.Pen
                {
                return new Pen(Color.Magenta);
                }
                static get Maroon(): System.Drawing.Pen
                {
                return new Pen(Color.Maroon);
                }
                static get MediumAquamarine(): System.Drawing.Pen
                {
                return new Pen(Color.MediumAquamarine);
                }
                static get MediumBlue(): System.Drawing.Pen
                {
                return new Pen(Color.MediumBlue);
                }
                static get MediumOrchid(): System.Drawing.Pen
                {
                return new Pen(Color.MediumOrchid);
                }
                static get MediumPurple(): System.Drawing.Pen
                {
                return new Pen(Color.MediumPurple);
                }
                static get MediumSeaGreen(): System.Drawing.Pen
                {
                return new Pen(Color.MediumSeaGreen);
                }
                static get MediumSlateBlue(): System.Drawing.Pen
                {
                return new Pen(Color.MediumSlateBlue);
                }
                static get MediumSpringGreen(): System.Drawing.Pen
                {
                return new Pen(Color.MediumSpringGreen);
                }
                static get MediumTurquoise(): System.Drawing.Pen
                {
                return new Pen(Color.MediumTurquoise);
                }
                static get MediumVioletRed(): System.Drawing.Pen
                {
                return new Pen(Color.MediumVioletRed);
                }
                static get MidnightBlue(): System.Drawing.Pen
                {
                return new Pen(Color.MidnightBlue);
                }
                static get MintCream(): System.Drawing.Pen
                {
                return new Pen(Color.MintCream);
                }
                static get MistyRose(): System.Drawing.Pen
                {
                return new Pen(Color.MistyRose);
                }
                static get Moccasin(): System.Drawing.Pen
                {
                return new Pen(Color.Moccasin);
                }
                static get NavajoWhite(): System.Drawing.Pen
                {
                return new Pen(Color.NavajoWhite);
                }
                static get Navy(): System.Drawing.Pen
                {
                return new Pen(Color.Navy);
                }
                static get OldLace(): System.Drawing.Pen
                {
                return new Pen(Color.OldLace);
                }
                static get Olive(): System.Drawing.Pen
                {
                return new Pen(Color.Olive);
                }
                static get OliveDrab(): System.Drawing.Pen
                {
                return new Pen(Color.OliveDrab);
                }
                static get Orange(): System.Drawing.Pen
                {
                return new Pen(Color.Orange);
                }
                static get OrangeRed(): System.Drawing.Pen
                {
                return new Pen(Color.OrangeRed);
                }
                static get Orchid(): System.Drawing.Pen
                {
                return new Pen(Color.Orchid);
                }
                static get PaleGoldenrod(): System.Drawing.Pen
                {
                return new Pen(Color.PaleGoldenrod);
                }
                static get PaleGreen(): System.Drawing.Pen
                {
                return new Pen(Color.PaleGreen);
                }
                static get PaleTurquoise(): System.Drawing.Pen
                {
                return new Pen(Color.PaleTurquoise);
                }
                static get PaleVioletRed(): System.Drawing.Pen
                {
                return new Pen(Color.PaleVioletRed);
                }
                static get PapayaWhip(): System.Drawing.Pen
                {
                return new Pen(Color.PapayaWhip);
                }
                static get PeachPuff(): System.Drawing.Pen
                {
                return new Pen(Color.PeachPuff);
                }
                static get Peru(): System.Drawing.Pen
                {
                return new Pen(Color.Peru);
                }
                static get Pink(): System.Drawing.Pen
                {
                return new Pen(Color.Pink);
                }
                static get Plum(): System.Drawing.Pen
                {
                return new Pen(Color.Plum);
                }
                static get PowderBlue(): System.Drawing.Pen
                {
                return new Pen(Color.PowderBlue);
                }
                static get Purple(): System.Drawing.Pen
                {
                return new Pen(Color.Purple);
                }
                static get Red(): System.Drawing.Pen
                {
                return new Pen(Color.Red);
                }
                static get RosyBrown(): System.Drawing.Pen
                {
                return new Pen(Color.RosyBrown);
                }
                static get RoyalBlue(): System.Drawing.Pen
                {
                return new Pen(Color.RoyalBlue);
                }
                static get SaddleBrown(): System.Drawing.Pen
                {
                return new Pen(Color.SaddleBrown);
                }
                static get Salmon(): System.Drawing.Pen
                {
                return new Pen(Color.Salmon);
                }
                static get SandyBrown(): System.Drawing.Pen
                {
                return new Pen(Color.SandyBrown);
                }
                static get SeaGreen(): System.Drawing.Pen
                {
                return new Pen(Color.SeaGreen);
                }
                static get Seashell(): System.Drawing.Pen
                {
                return new Pen(Color.Seashell);
                }
                static get Sienna(): System.Drawing.Pen
                {
                return new Pen(Color.Sienna);
                }
                static get Silver(): System.Drawing.Pen
                {
                return new Pen(Color.Silver);
                }
                static get SkyBlue(): System.Drawing.Pen
                {
                return new Pen(Color.SkyBlue);
                }
                static get SlateBlue(): System.Drawing.Pen
                {
                return new Pen(Color.SlateBlue);
                }
                static get SlateGray(): System.Drawing.Pen
                {
                return new Pen(Color.SlateGray);
                }
                static get Snow(): System.Drawing.Pen
                {
                return new Pen(Color.Snow);
                }
                static get SpringGreen(): System.Drawing.Pen
                {
                return new Pen(Color.SpringGreen);
                }
                static get SteelBlue(): System.Drawing.Pen
                {
                return new Pen(Color.SteelBlue);
                }
                static get Tan(): System.Drawing.Pen
                {
                return new Pen(Color.Tan);
                }
                static get Teal(): System.Drawing.Pen
                {
                return new Pen(Color.Teal);
                }
                static get Thistle(): System.Drawing.Pen
                {
                return new Pen(Color.Thistle);
                }
                static get Tomato(): System.Drawing.Pen
                {
                return new Pen(Color.Tomato);
                }
                static get Turquoise(): System.Drawing.Pen
                {
                return new Pen(Color.Turquoise);
                }
                static get Violet(): System.Drawing.Pen
                {
                return new Pen(Color.Violet);
                }
                static get Wheat(): System.Drawing.Pen
                {
                return new Pen(Color.Wheat);
                }
                static get White(): System.Drawing.Pen
                {
                return new Pen(Color.White);
                }
                static get WhiteSmoke(): System.Drawing.Pen
                {
                return new Pen(Color.WhiteSmoke);
                }
                static get Yellow(): System.Drawing.Pen
                {
                return new Pen(Color.Yellow);
                }
                static get YellowGreen(): System.Drawing.Pen
                {
                return new Pen(Color.YellowGreen);
                }
                }
                */
                var Point = (function () {
                    function Point(x, y) {
                        this.m_x = x;
                        this.m_y = y;
                    }
                    Object.defineProperty(Point.prototype, "IsEmpty", {
                        get: function () {
                            return this.m_x == 0 && this.m_y == 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Point.prototype, "X", {
                        get: function () {
                            return this.m_x;
                        },
                        set: function (value) {
                            this.m_x = value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Point.prototype, "Y", {
                        get: function () {
                            return this.m_y;
                        },
                        set: function (value) {
                            this.m_y = value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Point.Empty = new Point(0, 0);
                    return Point;
                })();
                Drawing.Point = Point;

                var Rectangle = (function () {
                    function Rectangle(left, top, right, bottom) {
                        this.m_left = left;
                        this.m_top = top;
                        this.m_right = right;
                        this.m_bottom = bottom;
                    }
                    Rectangle.prototype.Contains = function (rect) {
                        var contains = false;

                        if (rect.Left >= this.Left) {
                            if (rect.Right <= this.Right) {
                                if (rect.Top >= this.Top) {
                                    if (rect.Bottom <= this.Bottom) {
                                        contains = true;
                                    }
                                }
                            }
                        }

                        return contains;
                    };

                    Rectangle.prototype.ContainsPoint = function (pt) {
                        return this.Contains(new Rectangle(pt.X, pt.Y, pt.X, pt.Y));
                    };

                    Rectangle.FromLTRB = function (left, top, right, bottom) {
                        return new Rectangle(left, top, right, bottom);
                    };

                    Rectangle.prototype.Inflate = function (width, height) {
                        this.m_left -= width;
                        this.m_top -= height;
                        this.m_right += width;
                        this.m_bottom += height;
                    };

                    Rectangle.Inflate = function (rect, width, height) {
                        return new Rectangle(rect.m_left - width, rect.m_top - height, rect.m_right + width, rect.m_bottom + height);
                    };

                    Object.defineProperty(Rectangle.prototype, "Bottom", {
                        get: function () {
                            return this.m_bottom;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Rectangle.prototype, "Height", {
                        get: function () {
                            return this.m_bottom - this.m_top;
                        },
                        set: function (value) {
                            this.m_bottom = this.m_top + value;
                        },
                        enumerable: true,
                        configurable: true
                    });


                    Object.defineProperty(Rectangle.prototype, "IsEmpty", {
                        get: function () {
                            return this.Width <= 0 || this.Height <= 0;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Rectangle.prototype, "Left", {
                        get: function () {
                            return this.m_left;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Rectangle.prototype, "Right", {
                        get: function () {
                            return this.m_right;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Rectangle.prototype, "Size", {
                        get: function () {
                            return new Size(this.Width, this.Height);
                        },
                        set: function (value) {
                            this.Width = value.Width;
                            this.Height = value.Height;
                        },
                        enumerable: true,
                        configurable: true
                    });


                    Object.defineProperty(Rectangle.prototype, "Top", {
                        get: function () {
                            return this.m_top;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(Rectangle.prototype, "Width", {
                        get: function () {
                            return this.m_right - this.m_left;
                        },
                        set: function (value) {
                            this.m_right = this.m_left + value;
                        },
                        enumerable: true,
                        configurable: true
                    });


                    Object.defineProperty(Rectangle.prototype, "X", {
                        get: function () {
                            return this.m_left;
                        },
                        set: function (value) {
                            this.m_left = value;
                        },
                        enumerable: true,
                        configurable: true
                    });


                    Object.defineProperty(Rectangle.prototype, "Y", {
                        get: function () {
                            return this.m_top;
                        },
                        set: function (value) {
                            this.m_top = value;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Rectangle.Empty = new Rectangle(0, 0, 0, 0);
                    return Rectangle;
                })();
                Drawing.Rectangle = Rectangle;

                var Size = (function () {
                    function Size(width, height) {
                        this.m_width = width;
                        this.m_height = height;
                    }
                    Size.Ceiling = function (value) {
                        return new Size(Math.ceil(value.Width), Math.ceil(value.Height));
                    };
                    Size.Round = function (value) {
                        return new Size(Math.round(value.Width), Math.round(value.Height));
                    };
                    Object.defineProperty(Size.prototype, "Height", {
                        get: function () {
                            return this.m_height;
                        },
                        set: function (value) {
                            this.m_height = value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Size.prototype, "IsEmpty", {
                        get: function () {
                            return this.m_width <= 0 || this.m_height <= 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Size.prototype, "Width", {
                        get: function () {
                            return this.m_width;
                        },
                        set: function (value) {
                            this.m_width = value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Size.Empty = new Size(0, 0);
                    return Size;
                })();
                Drawing.Size = Size;

                var StringFormat = (function () {
                    function StringFormat() {
                    }
                    Object.defineProperty(StringFormat.prototype, "Alignment", {
                        get: function () {
                            return this.m_alignment;
                        },
                        set: function (value) {
                            this.m_alignment = value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StringFormat.prototype, "LineAlignment", {
                        get: function () {
                            return this.m_linealignment;
                        },
                        set: function (value) {
                            this.m_linealignment = value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(StringFormat.prototype, "Trimming", {
                        get: function () {
                            return this.m_trimming;
                        },
                        set: function (value) {
                            this.m_trimming = value;
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(StringFormat.prototype, "ToSVGTextAnchor", {
                        get: function () {
                            switch (this.m_alignment) {
                                case 2 /* Near */:
                                    return "start";
                                case 0 /* Center */:
                                    return "middle";
                                case 1 /* Far */:
                                    return "end";
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(StringFormat.prototype, "ToCSSAlignment", {
                        get: function () {
                            switch (this.m_alignment) {
                                case 2 /* Near */:
                                    return "left";
                                case 0 /* Center */:
                                    return "center";
                                case 1 /* Far */:
                                    return "right";
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });

                    Object.defineProperty(StringFormat.prototype, "ToCSSLineAlign", {
                        get: function () {
                            switch (this.m_linealignment) {
                                case 2 /* Near */:
                                    return "top";
                                case 0 /* Center */:
                                    return "middle";
                                case 1 /* Far */:
                                    return "bottom";
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return StringFormat;
                })();
                Drawing.StringFormat = StringFormat;

                (function (StringAlignment) {
                    StringAlignment[StringAlignment["Center"] = 0] = "Center";
                    StringAlignment[StringAlignment["Far"] = 1] = "Far";
                    StringAlignment[StringAlignment["Near"] = 2] = "Near";
                })(Drawing.StringAlignment || (Drawing.StringAlignment = {}));
                var StringAlignment = Drawing.StringAlignment;

                (function (StringFormatFlags) {
                    StringFormatFlags[StringFormatFlags["DirectionRightToLeft"] = 0] = "DirectionRightToLeft";
                    StringFormatFlags[StringFormatFlags["DirectionVertical"] = 1] = "DirectionVertical";
                    StringFormatFlags[StringFormatFlags["DisplayFormatControl"] = 2] = "DisplayFormatControl";
                    StringFormatFlags[StringFormatFlags["FitBlackBox"] = 3] = "FitBlackBox";
                    StringFormatFlags[StringFormatFlags["LineLimit"] = 4] = "LineLimit";
                    StringFormatFlags[StringFormatFlags["MeasureTrailingSpaces"] = 5] = "MeasureTrailingSpaces";
                    StringFormatFlags[StringFormatFlags["NoClip"] = 6] = "NoClip";
                    StringFormatFlags[StringFormatFlags["NoFontFallback"] = 7] = "NoFontFallback";
                    StringFormatFlags[StringFormatFlags["NoWrap"] = 8] = "NoWrap";
                })(Drawing.StringFormatFlags || (Drawing.StringFormatFlags = {}));
                var StringFormatFlags = Drawing.StringFormatFlags;
                (function (StringTrimming) {
                    StringTrimming[StringTrimming["Character"] = 0] = "Character";
                    StringTrimming[StringTrimming["EllipsisCharacter"] = 1] = "EllipsisCharacter";
                    StringTrimming[StringTrimming["EllipsisPath"] = 2] = "EllipsisPath";
                    StringTrimming[StringTrimming["EllipsisWord"] = 3] = "EllipsisWord";
                    StringTrimming[StringTrimming["None"] = 4] = "None";
                    StringTrimming[StringTrimming["Word"] = 5] = "Word";
                })(Drawing.StringTrimming || (Drawing.StringTrimming = {}));
                var StringTrimming = Drawing.StringTrimming;
                (function (StringUnit) {
                    StringUnit[StringUnit["Display"] = 0] = "Display";
                    StringUnit[StringUnit["Document"] = 1] = "Document";
                    StringUnit[StringUnit["Em"] = 2] = "Em";
                    StringUnit[StringUnit["Inch"] = 3] = "Inch";
                    StringUnit[StringUnit["Millimeter"] = 4] = "Millimeter";
                    StringUnit[StringUnit["Pixel"] = 5] = "Pixel";
                    StringUnit[StringUnit["Point"] = 6] = "Point";
                    StringUnit[StringUnit["World"] = 7] = "World";
                })(Drawing.StringUnit || (Drawing.StringUnit = {}));
                var StringUnit = Drawing.StringUnit;
                var StructFormat;
                (function (StructFormat) {
                    StructFormat[StructFormat["Ansi"] = 0] = "Ansi";
                    StructFormat[StructFormat["Auto"] = 1] = "Auto";
                    StructFormat[StructFormat["Unicode"] = 2] = "Unicode";
                })(StructFormat || (StructFormat = {}));

                //export class SystemBrushes
                //{
                //    static get Highlight(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(SystemColors.Highlight);
                //    }
                //    static get Window(): System.Drawing.Brush
                //    {
                //        return new SolidBrush(SystemColors.Window);
                //    }
                //}
                // TODO: look up real system colors
                var SystemColors = (function () {
                    function SystemColors() {
                    }
                    Object.defineProperty(SystemColors, "Window", {
                        get: function () {
                            return Color.White;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SystemColors, "WindowFrame", {
                        get: function () {
                            return Color.Gray;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SystemColors, "WindowText", {
                        get: function () {
                            return Color.Black;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SystemColors, "Highlight", {
                        get: function () {
                            return Color.Yellow;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SystemColors, "HighlightText", {
                        get: function () {
                            return Color.White;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return SystemColors;
                })();
                Drawing.SystemColors = SystemColors;
            })(System.Drawing || (System.Drawing = {}));
            var Drawing = System.Drawing;
        })(internal.System || (internal.System = {}));
        var System = internal.System;
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));
//# sourceMappingURL=systemDrawing.js.map

///----------------------------------------------------------------
/// (from treemap\tmUtils.js)
///----------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (internal) {
        (function (Microsoft) {
            (function (Treemap) {
                (function (Util) {
                    Util.TextHeightMultiplier = 1.1;

                    var Diag = vp.internal.System.Diagnostics;

                    //*****************************************************************************
                    //	Class: FontForRectangle
                    //
                    /// <summary>
                    ///	Provides a Font object to use for drawing text inside a rectangle.
                    /// </summary>
                    ///
                    /// <remarks>
                    /// Specify font information in the constructor.  You can then call <see
                    /// cref="CanFitInRectangle" /> or <see cref="CanFitInRectangleTruncate" /> to
                    /// determine whether the font can be used to draw specified text inside a
                    /// specified rectangle without exceeding the rectangle's bounds.
                    ///
                    /// <para>
                    ///	Call <see cref="Dispose()" /> when you are done using the object.
                    /// </para>
                    ///
                    ///	</remarks>
                    //*****************************************************************************
                    var FontForRectangle = (function () {
                        //*************************************************************************
                        //	Constructor: FontForRectangle()
                        //
                        /// <summary>
                        /// Initializes a new instance of the FontForRectangle class.
                        /// </summary>
                        ///
                        /// <param name="sFamily">
                        /// Font family.
                        /// </param>
                        ///
                        /// <param name="fEmSize">
                        /// Font size.
                        /// </param>
                        ///
                        ///	<param name="oGraphics">
                        /// Object that will use the font.
                        /// </param>
                        //*************************************************************************
                        function FontForRectangle(sFamily, fEmSize, displayRoot) {
                            Diag.Debug.AssertNotEmpty(sFamily);
                            Diag.Debug.Assert(fEmSize > 0);
                            Diag.Debug.Assert(displayRoot != null);

                            // Create the font.
                            this.m_oFont = new vp.internal.System.Drawing.Font(sFamily, fEmSize);

                            this.AssertValid();
                        }
                        //*************************************************************************
                        //	Method: CanFitInRectangle()
                        //
                        /// <summary>
                        ///	Determines whether the font can be used to draw the specified text
                        ///	inside the specified rectangle without exceeding the rectangle's
                        ///	bounds.
                        /// </summary>
                        ///
                        /// <param name="sText">
                        /// Text that will be drawn in <paramref name="oRectangle" />.
                        /// </param>
                        ///
                        /// <param name="oRectangle">
                        /// Rectangle that <paramref name="sText" /> will be drawn in.
                        /// </param>
                        ///
                        ///	<param name="oGraphics">
                        /// Object the caller will use to draw the text.
                        /// </param>
                        ///
                        /// <returns>
                        ///	true if the font can be used to draw <paramref name="sText" /> into
                        /// <paramref name="oRectangle" />.
                        /// </returns>
                        //*************************************************************************
                        FontForRectangle.prototype.CanFitInRectangle = function (sText, oRectangle, displayRoot) {
                            Diag.Debug.Assert(sText != null);
                            Diag.Debug.Assert(displayRoot != null);
                            this.AssertValid();

                            var temp = displayRoot.append("text").text(sText).position(oRectangle.X, oRectangle.Y).font(this.m_oFont.Name, this.m_oFont.Size + "pt");

                            var fCanFit = (temp.width() < oRectangle.Width && temp.height() < oRectangle.Height);

                            temp.remove();

                            return fCanFit;
                        };

                        //*************************************************************************
                        //	Method: CanFitInRectangleTruncate()
                        //
                        /// <summary>
                        ///	Determines whether the font can be used to draw the specified text or
                        /// a truncated version of the text inside the specified rectangle without
                        /// exceeding the rectangle's bounds.
                        /// </summary>
                        ///
                        /// <param name="sText">
                        /// Text that will be drawn in <paramref name="oRectangle" />.  This may
                        /// get replaced with a truncated version of the text.
                        /// </param>
                        ///
                        /// <param name="oRectangle">
                        /// Rectangle that <paramref name="sText" /> will be drawn in.
                        /// </param>
                        ///
                        ///	<param name="oGraphics">
                        /// Object the caller will use to draw the text.
                        /// </param>
                        ///
                        /// <returns>
                        ///	true if the font can be used to draw <paramref name="sText" /> or a
                        /// truncated version of <paramref name="sText" /> into <paramref
                        /// name="oRectangle" />.
                        /// </returns>
                        ///
                        /// <remarks>
                        /// If the font can be used to draw <paramref name="sText" /> into
                        /// <paramref name="oRectangle" />, true is returned.  Otherwise, if a
                        /// truncated version of <paramref name="sText" /> fits into <paramref
                        /// name="oRectangle" />, the truncated text is stored at <paramref
                        /// name="sText" /> and true is returned.  Otherwise, false is returned.
                        /// </remarks>
                        //*************************************************************************
                        FontForRectangle.prototype.CanFitInRectangleTruncate = function (sText, oRectangle, displayRoot) {
                            Diag.Debug.Assert(sText != null);
                            Diag.Debug.Assert(displayRoot != null);
                            this.AssertValid();

                            // Try the text as is.
                            if (this.CanFitInRectangle(sText, oRectangle, displayRoot))
                                return sText;

                            // Truncate the text and try again.
                            var sTruncatedText = this.TruncateText(sText);

                            if (this.CanFitInRectangle(sTruncatedText, oRectangle, displayRoot)) {
                                return sTruncatedText;
                            }

                            return null;
                        };

                        Object.defineProperty(FontForRectangle.prototype, "Font", {
                            //*************************************************************************
                            //	Property: Font
                            //
                            /// <summary>
                            /// Gets the font represented by the object.
                            /// </summary>
                            ///
                            /// <value>
                            /// The <see cref="Font" /> represented by the object.
                            /// </value>
                            //*************************************************************************
                            get: function () {
                                this.AssertValid();

                                return (this.m_oFont);
                            },
                            enumerable: true,
                            configurable: true
                        });

                        //*************************************************************************
                        //	Method: TruncateText()
                        //
                        /// <summary>
                        /// Attempts to truncate text.
                        /// </summary>
                        ///
                        /// <param name="sText">
                        /// Text to truncate.
                        /// </param>
                        ///
                        /// <param name="sTruncatedText">
                        /// Where the truncated text gets stored if true is returned.
                        /// </param>
                        ///
                        /// <returns>
                        /// true if the text can be truncated.
                        /// </returns>
                        ///
                        /// <remarks>
                        /// If <paramref name="sText" /> can be truncated, the truncated version is
                        /// stored at <paramref name="sTruncatedText" /> and true is returned.
                        /// false is returned otherwise.
                        /// </remarks>
                        //*************************************************************************
                        FontForRectangle.prototype.TruncateText = function (sText) {
                            Diag.Debug.Assert(sText != null);
                            this.AssertValid();

                            if (sText.length < FontForRectangle.MinTruncatableTextLength) {
                                return null;
                            }

                            var sTruncatedText = sText.substring(0, FontForRectangle.MinTruncatableTextLength - 1) + "...";

                            return sTruncatedText;
                        };

                        //*************************************************************************
                        //	Method: AssertValid()
                        //
                        /// <summary>
                        ///	Asserts if the object is in an invalid state.  Debug-only.
                        /// </summary>
                        //*************************************************************************
                        FontForRectangle.prototype.AssertValid = function () {
                            Diag.Debug.Assert(this.m_oFont != null);
                        };

                        FontForRectangle.MinTruncatableTextLength = 4;
                        return FontForRectangle;
                    })();
                    Util.FontForRectangle = FontForRectangle;

                    

                    

                    

                    //*****************************************************************************
                    //	Class: MaximizingFontMapper
                    //
                    /// <summary>
                    ///	Provides the largest possible Font object to use for drawing a node's text.
                    /// </summary>
                    ///
                    /// <remarks>
                    ///	Specify a range of font sizes to use in the constructor.  You can then call
                    /// <see cref="NodeToFont" /> to get a Font object for drawing a node's text.
                    /// The returned font is the largest within the specified font range that
                    /// doesn't exceed the bounds of the node's rectangle.
                    ///
                    /// <para>
                    ///	Call <see cref="Dispose()" /> when you are done using the object.
                    /// </para>
                    ///
                    ///	</remarks>
                    //*****************************************************************************
                    var MaximizingFontMapper = (function () {
                        //*************************************************************************
                        //	Constructor: MaximizingFontMapper()
                        //
                        /// <summary>
                        /// Initializes a new instance of the MaximizingFontMapper class.
                        /// </summary>
                        ///
                        /// <param name="sFamily">
                        /// Font family.
                        /// </param>
                        ///
                        /// <param name="fMinSizePt">
                        /// Minimum font size, in points.
                        /// </param>
                        ///
                        /// <param name="fMaxSizePt">
                        /// Maximum font size, in points.
                        /// </param>
                        ///
                        /// <param name="fIncrementPt">
                        /// Increment between fonts.
                        /// </param>
                        ///
                        /// <param name="oGraphics">
                        /// Object the caller will use to draw the node's text.
                        /// </param>
                        //*************************************************************************
                        function MaximizingFontMapper(sFamily, fMinSizePt, fMaxSizePt, fIncrementPt, displayRoot) {
                            Diag.Debug.AssertNotEmpty(sFamily);
                            Diag.Debug.Assert(displayRoot != null);

                            // Check the arguments.
                            MaximizingFontMapper.ValidateSizeRange(fMinSizePt, fMaxSizePt, fIncrementPt, "MaximizingFontMapper.Initialize()");

                            // Create an array and add a set of FontForRectangle objects to it,
                            // ordered by decreasing font size.
                            this.m_oFontForRectangles = new Array();

                            for (var fSizePt = fMinSizePt; fSizePt <= fMaxSizePt; fSizePt += fIncrementPt) {
                                var oFontForRectangle = new FontForRectangle(sFamily, fSizePt, displayRoot);

                                this.m_oFontForRectangles.splice(0, 0, oFontForRectangle);
                            }

                            this.m_displayRoot = displayRoot;

                            this.AssertValid();
                        }
                        //*************************************************************************
                        //	Method: NodeToFont()
                        //
                        /// <summary>
                        ///	Returns a Font object to use for drawing a node's text.
                        /// </summary>
                        ///
                        /// <param name="oNode">
                        /// The node that needs to be drawn.
                        /// </param>
                        ///
                        /// <param name="iNodeLevel">
                        /// Node level.  Top-level nodes are at level 0.
                        /// </param>
                        ///
                        /// <param name="oGraphics">
                        /// Object the caller will use to draw the node's text.
                        /// </param>
                        ///
                        /// <param name="oFont">
                        /// Where the font gets stored.  The font is owned by the object
                        /// implementing this interface.  Do not call the font's Dispose() method.
                        /// </param>
                        ///
                        /// <param name="sTextToDraw">
                        /// Where the text to draw gets stored.  This is either the node's text or
                        /// an abbreviated form of the node's text.
                        /// </param>
                        ///
                        /// <returns>
                        /// true if an appropriate font was found, false if not.
                        /// </returns>
                        ///
                        /// <remarks>
                        /// If a Font object suitable for drawing the text for <paramref
                        /// name="oNode" /> is available, the font is stored at <paramref
                        /// name="oFont" />, the text to draw is stored at <paramref
                        /// name="sTextToDraw" />, and true is returned.  false if returned
                        /// otherwise.
                        /// </remarks>
                        //*************************************************************************
                        MaximizingFontMapper.prototype.NodeToFont = function (oNode, oRect, iNodeLevel, sTextToDraw) {
                            Diag.Debug.Assert(oNode != null);
                            Diag.Debug.Assert(iNodeLevel >= 0);
                            this.AssertValid();

                            var sText = oNode.Text;

                            for (var iFontForRectangle = 0; iFontForRectangle < this.m_oFontForRectangles.length; iFontForRectangle++) {
                                var oFontForRectangle = this.m_oFontForRectangles[iFontForRectangle];

                                if (oFontForRectangle.CanFitInRectangle(sText, oRect, this.m_displayRoot)) {
                                    sTextToDraw = sText;

                                    // TODO: fix out parameter
                                    return oFontForRectangle.Font;
                                }
                            }

                            // No font was found.
                            sTextToDraw = null;

                            return null;
                        };

                        //*************************************************************************
                        //	Method: ValidateSizeRange()
                        //
                        /// <summary>
                        ///	Throws an exception if one of the parameters is invalid.
                        /// </summary>
                        ///
                        /// <param name="fMinSizePt">
                        /// Minimum font size, in points.  Must be > 0.
                        /// </param>
                        ///
                        /// <param name="fMaxSizePt">
                        /// Maximum font size, in points.  Must be > 0 and >= fMinSizePt.
                        /// </param>
                        ///
                        /// <param name="fIncrementPt">
                        /// Increment between fonts.  Must be > 0.
                        /// </param>
                        ///
                        /// <param name="sCaller">
                        /// Name of the caller.  Used in exception messages.  Sample:
                        ///	"MaximizingFontMapper.Initialize()".
                        /// </param>
                        //*************************************************************************
                        MaximizingFontMapper.ValidateSizeRange = function (fMinSizePt, fMaxSizePt, fIncrementPt, sCaller) {
                            if (fMinSizePt <= 0) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("fMinSizePt", fMinSizePt, sCaller + ": fMinSizePt must be > 0.");
                            }

                            if (fMaxSizePt <= 0) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("fMaxSizePt", fMaxSizePt, sCaller + ": fMaxSizePt must be > 0.");
                            }

                            if (fMaxSizePt < fMinSizePt) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("fMaxSizePt", fMaxSizePt, sCaller + ": fMaxSizePt must be >= fMinSizePt.");
                            }

                            if (fIncrementPt <= 0) {
                                throw new vp.internal.System.ArgumentOutOfRangeException("fIncrementPt", fIncrementPt, sCaller + ": fIncrementPt must be > 0.");
                            }
                        };

                        //*************************************************************************
                        //	Method: AssertValid()
                        //
                        /// <summary>
                        /// AssertValid method.
                        /// </summary>
                        ///
                        /// <remarks>
                        ///	Asserts if the object is in an invalid state.  Debug-only.
                        /// </remarks>
                        //*************************************************************************
                        MaximizingFontMapper.prototype.AssertValid = function () {
                        };
                        return MaximizingFontMapper;
                    })();
                    Util.MaximizingFontMapper = MaximizingFontMapper;

                    //*****************************************************************************
                    //	Class: PerLevelFontMapper
                    //
                    /// <summary>
                    ///	Provides a Font object to use for drawing a node's text.
                    /// </summary>
                    ///
                    /// <remarks>
                    /// Specify a font family and a treemap rectangle in the constructor, then call
                    /// <see cref="NodeToFont" /> to get a Font object for drawing a node's text.
                    /// The size of the font is determined by the node's level and by the size of
                    /// the treemap rectangle.
                    ///
                    /// <para>
                    ///	Call <see cref="Dispose()" /> when you are done using the object.
                    /// </para>
                    ///
                    ///	</remarks>
                    //*****************************************************************************
                    var PerLevelFontMapper = (function () {
                        //*************************************************************************
                        //	Constructor: PerLevelFontMapper()
                        //
                        /// <summary>
                        /// Initializes a new instance of the PerLevelFontMapper class.
                        /// </summary>
                        ///
                        /// <param name="sFamily">
                        /// Font family.
                        /// </param>
                        ///
                        /// <param name="oTreemapRectangle">
                        /// Treemap's outer rectangle.
                        /// </param>
                        ///
                        /// <param name="fTreemapRectangleDivisor">
                        /// The font size for level 0 is the treemap rectangle height divided by
                        /// fTreemapRectangleDivisor.
                        /// </param>
                        ///
                        /// <param name="fPerLevelDivisor">
                        /// The font size for level N is the font size for level N-1 divided by
                        /// fPerLevelDivisor.
                        /// </param>
                        ///
                        /// <param name="fMinimumFontSize">
                        /// Minimum font size.
                        /// </param>
                        ///
                        /// <param name="oGraphics">
                        /// Object the caller will use to draw the node's text.
                        /// </param>
                        //*************************************************************************
                        function PerLevelFontMapper(sFamily, oTreemapRectangle, fTreemapRectangleDivisor, fPerLevelDivisor, fMinimumFontSize, displayRoot) {
                            Diag.Debug.AssertNotEmpty(sFamily);
                            Diag.Debug.Assert(fTreemapRectangleDivisor > 0);
                            Diag.Debug.Assert(fPerLevelDivisor > 0);
                            Diag.Debug.Assert(fMinimumFontSize > 0);
                            Diag.Debug.Assert(displayRoot != null);

                            // The largest font is determined by the height of the treemap
                            // rectangle.
                            var fFontSize = oTreemapRectangle.Height / fTreemapRectangleDivisor;

                            // Create an array and add a set of FontForRectangle objects to it,
                            // one per treemap level.  Stop when the font gets too small.
                            this.m_oFontForRectangles = new Array();

                            while (fFontSize > fMinimumFontSize) {
                                var oFontForRectangle = new FontForRectangle(sFamily, fFontSize, displayRoot);

                                this.m_oFontForRectangles.push(oFontForRectangle);

                                fFontSize /= fPerLevelDivisor;
                            }

                            this.m_displayRoot = displayRoot;

                            this.AssertValid();
                        }
                        //*************************************************************************
                        //	Method: NodeToFont()
                        //
                        /// <summary>
                        ///	Returns a Font object to use for drawing a node's text.
                        /// </summary>
                        ///
                        /// <param name="oNode">
                        /// The node that needs to be drawn.
                        /// </param>
                        ///
                        /// <param name="iNodeLevel">
                        /// Node level.  Top-level nodes are at level 0.
                        /// </param>
                        ///
                        /// <param name="oGraphics">
                        /// Object the caller will use to draw the node's text.
                        /// </param>
                        ///
                        /// <param name="oFont">
                        /// Where the font gets stored.  The font is owned by the object
                        /// implementing this interface.  Do not call the font's Dispose() method.
                        /// </param>
                        ///
                        /// <param name="sTextToDraw">
                        /// Where the text to draw gets stored.  This is either the node's text or
                        /// an abbreviated form of the node's text.
                        /// </param>
                        ///
                        /// <returns>
                        /// true if an appropriate font was found, false if not.
                        /// </returns>
                        ///
                        /// <remarks>
                        /// If a Font object suitable for drawing the text for <paramref
                        /// name="oNode" /> is available, the font is stored at <paramref
                        /// name="oFont" />, the text to draw is stored at <paramref
                        /// name="sTextToDraw" />, and true is returned.  false if returned
                        /// otherwise.
                        /// </remarks>
                        //*************************************************************************
                        PerLevelFontMapper.prototype.NodeToFont = function (oNode, oRect, iNodeLevel, sTextToDraw) {
                            Diag.Debug.Assert(oNode != null);
                            Diag.Debug.Assert(iNodeLevel >= 0);
                            this.AssertValid();

                            if (iNodeLevel < this.m_oFontForRectangles.length) {
                                // Get the FontForRectangle object for the specified node level.
                                var oFontForRectangle = this.m_oFontForRectangles[iNodeLevel];

                                // Check whether this font can be used to draw the text within the
                                // node's rectangle.
                                var sText = oNode.Text;

                                if (oFontForRectangle.CanFitInRectangle(sText, oRect, this.m_displayRoot)) {
                                    sTextToDraw = sText;

                                    // TODO: fix out param
                                    return oFontForRectangle.Font;
                                }
                            }

                            // There is no appropriate font.
                            sTextToDraw = null;

                            return null;
                        };

                        //*************************************************************************
                        //	Method: AssertValid()
                        //
                        /// <summary>
                        /// Asserts if the object is in an invalid state.  Debug-only.
                        /// </summary>
                        //*************************************************************************
                        PerLevelFontMapper.prototype.AssertValid = function () {
                            Diag.Debug.Assert(this.m_oFontForRectangles != null);
                        };
                        return PerLevelFontMapper;
                    })();
                    Util.PerLevelFontMapper = PerLevelFontMapper;

                    //*****************************************************************************
                    //	Class: LayoutEngineBase
                    //
                    /// <summary>
                    /// Abstract base class for derived classes that lay out the rectangles in a
                    /// treemap.
                    /// </summary>
                    ///
                    /// <remarks>
                    /// This can be used as the base class for a derived class that lays out the
                    /// rectangles in a treemap.  It implements <see
                    /// cref="ILayoutEngine.SetNodeRectanglesToEmpty(Node)" /> but leaves the
                    /// implementation of <see cref="ILayoutEngine.CalculateNodeRectangles" /> to
                    /// the derived class.
                    /// </remarks>
                    //*****************************************************************************
                    var LayoutEngineBase = (function () {
                        function LayoutEngineBase() {
                        }
                        //*************************************************************************
                        //    Method: CalculateNodeRectangles()
                        //
                        /// <summary>
                        /// Calculates and sets the <see cref="Node.Rectangle" /> property on each
                        /// <see cref="Node" /> in a node collection.
                        /// </summary>
                        ///
                        /// <param name="oNodes">
                        /// Collection of sibling <see cref="Node" /> objects.
                        /// </param>
                        ///
                        /// <param name="oParentRectangle">
                        /// Parent rectangle the nodes should be laid out within.  Can't be empty
                        /// -- must have positive width and height.
                        /// </param>
                        ///
                        /// <param name="oParentNode">
                        /// Parent of <paramref name="oNodes" />, or null if <paramref
                        /// name="oNodes" /> is the treemap's top-level node collection.
                        /// </param>
                        ///
                        /// <param name="eEmptySpaceLocation">
                        /// Determines where the empty space is placed within <paramref
                        /// name="oParentRectangle" /> if oNodes.EmptySpace.<see
                        /// cref="EmptySpace.SizeMetric" /> is positive.
                        /// </param>
                        ///
                        /// <remarks>
                        /// This method uses an implementation-specific algorithm to set the <see
                        /// cref="Node.Rectangle" /> property on each <see cref="Node" /> object in
                        /// <paramref name="oNodes" /> so that all the rectangles fit within
                        /// <paramref name="oParentRectangle" /> and do not overlap.  In one call,
                        /// it deals with just one set of sibling nodes and one parent rectangle.
                        /// To create a complete nested treemap, call this method for the treemap's
                        /// top-level nodes, then again for each node's set of child nodes, again
                        /// for their children, and so on.
                        ///
                        /// <para>
                        ///    The calculated rectangles have borders with zero widths.  If oNodeB is
                        /// immediately to the right of oNodeA, for example, then
                        ///    oNodeA.Rectangle.Right == oNodeB.Rectangle.Left.  The rectangles have
                        ///    no padding.
                        /// </para>
                        ///
                        ///    </remarks>
                        //*************************************************************************
                        LayoutEngineBase.prototype.CalculateNodeRectangles = function (oNodes, oParentRectangle, oParentNode, eEmptySpaceLocation) {
                        };

                        //*************************************************************************
                        //    Method: SetNodeRectanglesToEmpty()
                        //
                        /// <summary>
                        /// Sets the <see cref="Node.Rectangle" /> property on a <see
                        /// cref="Node" /> and all its descendants to an empty rectangle.
                        /// </summary>
                        ///
                        /// <param name="oNode">
                        /// <see cref="Node" /> object to set the <see cref="Node.Rectangle" />
                        /// property on.
                        /// </param>
                        //*************************************************************************
                        LayoutEngineBase.prototype.SetNodeRectanglesToEmpty = function (oNode) {
                            Diag.Debug.Assert(oNode != null);

                            this.SetNodeRectangleToEmpty(oNode);
                            this.SetNodesRectanglesToEmpty(oNode.Nodes, true);
                        };

                        //*************************************************************************
                        //    Method: SetNodeRectanglesToEmpty()
                        //
                        /// <overloads>
                        /// Sets the <see cref="Node.Rectangle" /> property on nodes in a node
                        /// collection to an empty rectangle.
                        /// </overloads>
                        ///
                        /// <summary>
                        /// Sets the <see cref="Node.Rectangle" /> property on each <see
                        /// cref="Node" /> in a node collection to an empty rectangle.
                        /// </summary>
                        ///
                        /// <param name="oNodes">
                        /// Collection of sibling <see cref="Node" /> objects.
                        /// </param>
                        ///
                        /// <param name="bRecursive">
                        /// If true, the rectangles for all descendent nodes are also set to empty
                        /// rectangles.
                        /// </param>
                        ///
                        /// <remarks>
                        /// This method sets the <see cref="Node.Rectangle" /> property on each
                        /// <see cref="Node" /> object in <paramref name="oNodes" /> to an empty
                        /// rectangle.  If <paramref name="bRecursive" /> is true, it then does the
                        /// same to all descendent nodes.
                        /// </remarks>
                        //*************************************************************************
                        LayoutEngineBase.prototype.SetNodesRectanglesToEmpty = function (oNodes, bRecursive) {
                            Diag.Debug.Assert(oNodes != null);

                            for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                                var oNode = oNodes.Item(iNode);
                                this.SetNodeRectangleToEmpty(oNode);

                                if (bRecursive)
                                    this.SetNodesRectanglesToEmpty(oNode.Nodes, true);
                            }
                        };

                        //*************************************************************************
                        //  Method: SetNodeRectanglesToEmpty()
                        //
                        /// <summary>
                        /// Sets the <see cref="Node.Rectangle" /> property on specified nodes in
                        /// a node collection to an empty rectangle.
                        /// </summary>
                        ///
                        /// <param name="aoNodes">
                        /// Array of <see cref="Node" /> objects.
                        /// </param>
                        ///
                        ///    <param name="iIndexOfFirstNodeToSet">
                        ///    Index of the first node in <paramref name="aoNodes" /> to set to empty.
                        ///    </param>
                        ///
                        ///    <param name="iIndexOfLastNodeToSet">
                        ///    Index of the last node in <paramref name="aoNodes" /> to set to empty.
                        ///    </param>
                        ///
                        /// <remarks>
                        /// This helper method can be used by derived classes.  It sets the <see
                        /// cref="Node.Rectangle" /> property on each specified node to an empty
                        /// rectangle.  It then does the same for all descendents of the specified
                        /// nodes.
                        /// </remarks>
                        //*************************************************************************
                        LayoutEngineBase.prototype.SetANodeRectanglesToEmpty = function (aoNodes, iIndexOfFirstNodeToSet, iIndexOfLastNodeToSet) {
                            Diag.Debug.Assert(aoNodes != null);
                            Diag.Debug.Assert(iIndexOfFirstNodeToSet >= 0);
                            Diag.Debug.Assert(iIndexOfFirstNodeToSet < aoNodes.length);
                            Diag.Debug.Assert(iIndexOfLastNodeToSet >= 0);
                            Diag.Debug.Assert(iIndexOfLastNodeToSet < aoNodes.length);

                            for (var i = iIndexOfFirstNodeToSet; i <= iIndexOfLastNodeToSet; i++) {
                                var oNode = aoNodes[i];

                                this.SetNodeRectangleToEmpty(oNode);

                                // Recurse into the node's children.
                                this.SetNodesRectanglesToEmpty(oNode.Nodes, true);
                            }
                        };

                        //*************************************************************************
                        //    Method: SetNodeRectangleToEmpty()
                        //
                        /// <summary>
                        /// Sets the <see cref="Node.Rectangle" /> property on a specified node to
                        /// an empty rectangle.
                        /// </summary>
                        ///
                        /// <param name="oNode">
                        /// <see cref="Node" /> object.
                        /// </param>
                        ///
                        /// <remarks>
                        /// This method sets the <see cref="Node.Rectangle" /> property on
                        /// <paramref name="oNode" /> to an empty rectangle.
                        /// </remarks>
                        //*************************************************************************
                        LayoutEngineBase.prototype.SetNodeRectangleToEmpty = function (oNode) {
                            Diag.Debug.Assert(oNode != null);

                            oNode.RemoveRectangle();
                            oNode.RemoveText();
                            var elem = oNode.DisplayedElement;
                            if (elem) {
                                elem.remove();
                                oNode.DisplayedElement = null;
                            }
                            oNode.Rectangle = internal.System.Drawing.Rectangle.FromLTRB(0, 0, 0, 0);
                        };
                        return LayoutEngineBase;
                    })();
                    Util.LayoutEngineBase = LayoutEngineBase;

                    //*****************************************************************************
                    //	Class: SquarifiedLayoutEngine
                    //
                    /// <summary>
                    ///	Lays out the rectangles in a treemap using a squarified algorithm.
                    /// </summary>
                    ///
                    /// <remarks>
                    /// This class lays out a treemap's rectangles so they are as square as
                    /// possible.  The code is based on an algorithm presented in "Squarified
                    /// Treemaps," by Mark Bruls, Kees Huizing, and Jarke J. van Wijk.
                    ///	</remarks>
                    //*****************************************************************************
                    var SquarifiedLayoutEngine = (function (_super) {
                        __extends(SquarifiedLayoutEngine, _super);
                        //*************************************************************************
                        //	Constructor: SquarifiedLayoutEngine()
                        //
                        /// <summary>
                        /// Initializes a new instance of the SquarifiedLayoutEngine class.
                        /// </summary>
                        ///
                        /// <param name="bBottomWeighted">
                        /// If true, larger child nodes are placed in the lower left corner of the
                        /// parent rectangle.  If false, larger child nodes are placed in the upper
                        /// left corner.
                        /// </param>
                        //*************************************************************************
                        function SquarifiedLayoutEngine(bBottomWeighted) {
                            _super.call(this);
                            this.m_bBottomWeighted = bBottomWeighted;
                        }
                        //*************************************************************************
                        //	Method: CalculateNodeRectangles()
                        //
                        /// <summary>
                        /// Calculates and sets the <see cref="Node.Rectangle" /> property on each
                        /// <see cref="Node" /> in a node collection.
                        /// </summary>
                        ///
                        /// <param name="oNodes">
                        /// Collection of sibling <see cref="Node" /> objects.
                        /// </param>
                        ///
                        /// <param name="oParentRectangle">
                        /// Parent rectangle the nodes should be laid out within.  Can't be empty
                        /// -- must have positive width and height.
                        /// </param>
                        ///
                        /// <param name="oParentNode">
                        /// Parent of <paramref name="oNodes" />, or null if <paramref
                        /// name="oNodes" /> is the treemap's top-level node collection.
                        /// </param>
                        ///
                        /// <param name="eEmptySpaceLocation">
                        /// Determines where the empty space is placed within <paramref
                        /// name="oParentRectangle" /> if oNodes.EmptySpace.<see
                        /// cref="EmptySpace.SizeMetric" /> is positive.
                        /// </param>
                        ///
                        /// <remarks>
                        /// This method uses an implementation-specific algorithm to set the <see
                        /// cref="Node.Rectangle" /> property on each <see cref="Node" /> object in
                        /// <paramref name="oNodes" /> so that all the rectangles fit within
                        /// <paramref name="oParentRectangle" /> and do not overlap.  In one call,
                        /// it deals with just one set of sibling nodes and one parent rectangle.
                        /// To create a complete nested treemap, call this method for the treemap's
                        /// top-level nodes, then again for each node's set of child nodes, again
                        /// for their children, and so on.
                        ///
                        /// <para>
                        ///	The calculated rectangles have borders with zero widths.  If oNodeB is
                        /// immediately to the right of oNodeA, for example, then
                        ///	oNodeA.Rectangle.Right == oNodeB.Rectangle.Left.  The rectangles have
                        ///	no padding.
                        /// </para>
                        ///
                        ///	</remarks>
                        //*************************************************************************
                        SquarifiedLayoutEngine.prototype.CalculateNodeRectangles = function (oNodes, oParentRectangle, oParentNode, eEmptySpaceLocation) {
                            Diag.Debug.Assert(oNodes != null);
                            Diag.Debug.Assert(oParentRectangle.Width > 0);
                            Diag.Debug.Assert(oParentRectangle.Height > 0);

                            if (oNodes.Count == 0)
                                return;

                            // Sort the nodes by their SizeMetric property.
                            var aoSortedNodes = oNodes.ToArraySortedBySizeMetric();

                            // Get the area that will be taken up by each SizeMetric unit.
                            var dAreaPerSizeMetric = this.GetAreaPerSizeMetric(oNodes, oParentRectangle, oParentNode);

                            if (dAreaPerSizeMetric == 0) {
                                // The nodes in oNodes should not be drawn.
                                this.SetNodesRectanglesToEmpty(oNodes, true);
                                return;
                            }

                            if (eEmptySpaceLocation == 1 /* Top */ && oNodes.EmptySpace.SizeMetric > 0) {
                                // The caller wants to force the empty space specified by
                                // oNodes.EmptySpace to the top of the parent rectangle.  Figure
                                // out the area and width of the empty space.
                                var dEmptySpaceArea = dAreaPerSizeMetric * oNodes.EmptySpace.SizeMetric;

                                Diag.Debug.Assert(oParentRectangle.Width > 0);

                                var dEmptySpaceHeight = dEmptySpaceArea / oParentRectangle.Width;

                                // Subtract the empty space from the parent rectangle.
                                oParentRectangle = internal.System.Drawing.Rectangle.FromLTRB(oParentRectangle.Left, oParentRectangle.Top + dEmptySpaceHeight, oParentRectangle.Right, oParentRectangle.Bottom);

                                if (oParentRectangle.Height <= 0) {
                                    // The nodes in oNodes should not be drawn.
                                    this.SetNodesRectanglesToEmpty(oNodes, true);
                                    return;
                                }
                            }

                            // Calculate a squarified rectangle for each node.
                            this.CalculateSquarifiedNodeRectangles(aoSortedNodes, oParentRectangle, dAreaPerSizeMetric);

                            for (var iNode = 0; iNode < aoSortedNodes.length; iNode++) {
                                var oNode = aoSortedNodes[iNode];
                                var oRectangle = oNode.Rectangle;

                                Diag.Debug.Assert(oRectangle.Width >= 0);
                                Diag.Debug.Assert(oRectangle.Height >= 0);
                            }
                        };

                        //*************************************************************************
                        //	Method: CalculateSquarifiedNodeRectangles()
                        //
                        /// <summary>
                        ///	This protected method does most of the work for <see
                        /// cref="CalculateNodeRectangles" />.
                        /// </summary>
                        ///
                        /// <param name="aoSortedNodes">
                        /// Array of <see cref="Node" /> objects.  Contains a complete set of
                        /// sibling nodes, sorted by Node.SizeMetric in descending order.
                        /// </param>
                        ///
                        /// <param name="oParentRectangle">
                        /// Parent rectangle the nodes should be laid out within.  Can't be empty
                        /// -- must have positive width and height.
                        /// </param>
                        ///
                        /// <param name="dAreaPerSizeMetric">
                        /// Area that will be taken up by each SizeMetric unit.
                        /// </param>
                        //*************************************************************************
                        SquarifiedLayoutEngine.prototype.CalculateSquarifiedNodeRectangles = function (aoSortedNodes, oParentRectangle, dAreaPerSizeMetric) {
                            Diag.Debug.Assert(aoSortedNodes != null);
                            Diag.Debug.Assert(oParentRectangle.Width > 0);
                            Diag.Debug.Assert(oParentRectangle.Height > 0);
                            Diag.Debug.Assert(dAreaPerSizeMetric >= 0);

                            var iNodes = aoSortedNodes.length;

                            // Indexes of nodes that have already been inserted into
                            // oParentRectangle, or -1 if none have been inserted yet.
                            var iIndexOfFirstInsertedNode = -1;
                            var iIndexOfLastInsertedNode = -1;

                            // Index of the next node to insert.
                            var iIndexOfNodeToInsert = 0;

                            // Sum of the SizeMetric values for the nodes that have already been
                            // inserted and the next node to insert.
                            var dSizeMetricSum = 0;

                            // Worst aspect ratio of the nodes that have already been inserted into
                            // oParentRectangle.  Aspect ratios are 1.0 or greater.  1.0 is ideal.
                            // Initialize this to a large value so that any other value will be
                            // better.
                            var dOldWorstAspectRatio = internal.MAX_VALUE;

                            while (iIndexOfNodeToInsert < iNodes) {
                                if (oParentRectangle.IsEmpty) {
                                    // This shouldn't happen, but because of rounding errors,
                                    // conversions from Doubles to Singles, and use of the
                                    // Rectangle.FromLTRB() method (which has to convert its
                                    // arguments to an internal Point and Size), it occasionally
                                    // does.  Handle it by setting to empty the rectangles for all
                                    // nodes that haven't been inserted yet.
                                    this.SetANodeRectanglesToEmpty(aoSortedNodes, iIndexOfNodeToInsert, iNodes - 1);

                                    return;
                                }

                                var oNodeToInsert = aoSortedNodes[iIndexOfNodeToInsert];
                                var dSizeMetricOfNodeToInsert = oNodeToInsert.SizeMetric;

                                if (dSizeMetricOfNodeToInsert == 0) {
                                    // The node has a zero SizeMetric.  Set its rectangle (and
                                    // descendents) to empty, then move on to the next node.
                                    this.SetANodeRectanglesToEmpty(aoSortedNodes, iIndexOfNodeToInsert, iIndexOfNodeToInsert);

                                    iIndexOfNodeToInsert++;
                                    continue;
                                }

                                var bNodeWasInsertedBefore = (iIndexOfFirstInsertedNode != -1);

                                if (bNodeWasInsertedBefore) {
                                    // Tell all nodes that have already been inserted to save
                                    // their rectangles.  Inserting a new node causes the
                                    // rectangles for the already-inserted nodes to be
                                    // recalculated, and if the new rectangles are worse than the
                                    // old ones, the old ones will have to be restored.
                                    this.SaveInsertedRectangles(aoSortedNodes, iIndexOfFirstInsertedNode, iIndexOfLastInsertedNode);
                                }

                                dSizeMetricSum += dSizeMetricOfNodeToInsert;

                                // Insert the new node above, below, or to the right of the already
                                // inserted nodes.
                                this.InsertNodesInRectangle(aoSortedNodes, oParentRectangle, (bNodeWasInsertedBefore ? iIndexOfFirstInsertedNode : iIndexOfNodeToInsert), iIndexOfNodeToInsert, dSizeMetricSum, dAreaPerSizeMetric);

                                // Compute the new worst aspect ratio.  Since the nodes are sorted
                                // by descending SizeMetric values, the newly inserted node has the
                                // worst one.
                                var dNewWorstAspectRatio = oNodeToInsert.AspectRatio;

                                // Has it improved or at least stayed the same?
                                if (dNewWorstAspectRatio <= dOldWorstAspectRatio) {
                                    // Yes, so leave the newly inserted node where it is and move
                                    // on to the next node.
                                    if (bNodeWasInsertedBefore) {
                                        iIndexOfLastInsertedNode++;
                                    } else {
                                        iIndexOfFirstInsertedNode = iIndexOfLastInsertedNode = iIndexOfNodeToInsert;
                                    }

                                    iIndexOfNodeToInsert++;
                                    dOldWorstAspectRatio = dNewWorstAspectRatio;
                                } else {
                                    // The insertion of the new node made the aspect ratio worse,
                                    // so cancel what we just did.
                                    if (bNodeWasInsertedBefore) {
                                        this.RestoreInsertedRectangles(aoSortedNodes, iIndexOfFirstInsertedNode, iIndexOfLastInsertedNode);
                                    }

                                    // Leave the previously inserted nodes where they are, and get
                                    // a rectangle for the remaining empty space.  The next pass
                                    // through the loop will take the node that just failed and
                                    // insert it into the empty space.
                                    oParentRectangle = this.GetRemainingEmptySpace(aoSortedNodes, oParentRectangle, iIndexOfFirstInsertedNode, iIndexOfLastInsertedNode);

                                    iIndexOfFirstInsertedNode = -1;
                                    iIndexOfLastInsertedNode = -1;
                                    dSizeMetricSum = 0;
                                    dOldWorstAspectRatio = internal.MAX_VALUE;
                                }
                            }
                        };

                        //*************************************************************************
                        //	Method: InsertNodesInRectangle()
                        //
                        /// <summary>
                        ///	Inserts a set of nodes into a rectangle.
                        /// </summary>
                        ///
                        /// <param name="aoSortedNodes">
                        /// Array of Node objects.  Contains a complete set of sibling nodes,
                        /// sorted by Node.SizeMetric in descending order.
                        /// </param>
                        ///
                        /// <param name="oParentRectangle">
                        /// Parent rectangle the nodes should be laid out within.  Can't be empty
                        /// -- must have positive width and height.
                        /// </param>
                        ///
                        /// <param name="iIndexOfFirstNodeToInsert">
                        /// Zero-based index of the first node in <paramref name="aoSortedNodes" />
                        /// to insert.
                        /// </param>
                        ///
                        /// <param name="iIndexOfLastNodeToInsert">
                        /// Zero-based index of the last node in <paramref name="aoSortedNodes" />
                        /// to insert.
                        /// </param>
                        ///
                        /// <param name="dSizeMetricSum">
                        /// Sum of the SizeMetric values for the nodes to be inserted.  Must be
                        /// greater than zero.
                        /// </param>
                        ///
                        /// <param name="dAreaPerSizeMetric">
                        /// Area that will be taken up by each SizeMetric unit.  Must be greater
                        /// than or equal to zero.
                        /// </param>
                        ///
                        /// <remarks>
                        ///	This method inserts the specified nodes in <paramref
                        /// name="aoSortedNodes" /> into <paramref name="oParentRectangle" />.
                        ///
                        /// <para>
                        /// If the rectangle is wider than it is tall, the nodes are inserted on
                        /// top of each other so that they fill the left part of the rectangle
                        /// either from bottom to top (if m_bBottomWeighted is true) or top to
                        /// bottom (if m_bBottomWeighted is false).  That probably leaves some
                        /// space on the right side of the rectangle.
                        /// </para>
                        ///
                        /// <para>
                        /// If the rectangle is taller than it is wide, the nodes are inserted to
                        /// the right of each other so that they fill the bottom (if
                        /// m_bBottomWeighted is true) or top (if m_bBottomWeighted is false) of
                        /// the rectangle, from left to right.  That probably leaves some space at
                        /// the top or bottom of the rectangle.
                        /// </para>
                        ///
                        ///	<para>
                        /// The algorithm presented in "Squarified Treemaps," by Mark Bruls, Kees
                        /// Huizing, and Jarke J. van Wijk, always inserts larger nodes at the
                        /// lower left corner of the parent rectangle.  This method modifies the
                        /// algorithm by adding an option to insert larger nodes at the upper left
                        /// corner.
                        ///	</para>
                        ///
                        ///	<para>
                        ///	Note that the results of this method call may not be optimal.  It's up
                        ///	to the caller to determine whether the results are good and to take
                        ///	corrective action if they are not.
                        ///	</para>
                        ///
                        /// </remarks>
                        //*************************************************************************
                        SquarifiedLayoutEngine.prototype.InsertNodesInRectangle = function (aoSortedNodes, oParentRectangle, iIndexOfFirstNodeToInsert, iIndexOfLastNodeToInsert, dSizeMetricSum, dAreaPerSizeMetric) {
                            Diag.Debug.Assert(aoSortedNodes != null);
                            Diag.Debug.Assert(oParentRectangle.Width > 0);
                            Diag.Debug.Assert(oParentRectangle.Height > 0);
                            Diag.Debug.Assert(iIndexOfFirstNodeToInsert >= 0);
                            Diag.Debug.Assert(iIndexOfLastNodeToInsert >= 0);
                            Diag.Debug.Assert(iIndexOfLastNodeToInsert >= iIndexOfFirstNodeToInsert);
                            Diag.Debug.Assert(iIndexOfLastNodeToInsert < aoSortedNodes.length);
                            Diag.Debug.Assert(dSizeMetricSum > 0);
                            Diag.Debug.Assert(dAreaPerSizeMetric >= 0);

                            var i;

                            // If the rectangle is wider than it is tall, the nodes will get
                            // inserted from bottom to top or top to bottom.  Otherwise, they will
                            // get inserted from left to right.
                            var bInsertVertically = (oParentRectangle.Width >= oParentRectangle.Height);

                            // Get the rectangle's height or width, whichever is shorter.
                            var dParentHeightOrWidth = bInsertVertically ? oParentRectangle.Height : oParentRectangle.Width;

                            Diag.Debug.Assert(dParentHeightOrWidth != 0);

                            // Compute the area that will be taken up by the nodes.
                            var dNodesArea = dAreaPerSizeMetric * dSizeMetricSum;

                            // Compute the width or height of the nodes.  (They all have the same
                            // width or height.)
                            var dNodeWidthOrHeight = dNodesArea / dParentHeightOrWidth;

                            var dNodeLeft = 0;
                            var dNodeRight = 0;
                            var dNodeTop = 0;
                            var dNodeBottom = 0;

                            if (bInsertVertically) {
                                // Compute the left and right edges of the nodes.  These don't
                                // change.
                                dNodeLeft = oParentRectangle.Left;
                                dNodeRight = dNodeLeft + dNodeWidthOrHeight;

                                // The top and bottom edges will be recalculated for each node.
                                dNodeTop = dNodeBottom = (this.m_bBottomWeighted) ? oParentRectangle.Bottom : oParentRectangle.Top;
                            } else {
                                // Compute the top and bottom edges of the nodes.  These don't
                                // change.
                                if (this.m_bBottomWeighted) {
                                    dNodeBottom = oParentRectangle.Bottom;
                                    dNodeTop = dNodeBottom - dNodeWidthOrHeight;
                                } else {
                                    dNodeTop = oParentRectangle.Top;
                                    dNodeBottom = dNodeTop + dNodeWidthOrHeight;
                                }

                                // The left and right edges will be recalculated for each node.
                                dNodeLeft = dNodeRight = oParentRectangle.Left;
                            }

                            for (i = iIndexOfFirstNodeToInsert; i <= iIndexOfLastNodeToInsert; i++) {
                                var oNode = aoSortedNodes[i];

                                // The node's height or width is a fraction of the rectangle's
                                // height or width, where the fraction is determined by the ratio
                                // of the node's SizeMetric value to the sum of values for all the
                                // inserted nodes.
                                Diag.Debug.Assert(dSizeMetricSum != 0);

                                var dNodeHeightOrWidth = dParentHeightOrWidth * (oNode.SizeMetric / dSizeMetricSum);

                                if (bInsertVertically) {
                                    if (this.m_bBottomWeighted) {
                                        dNodeTop = dNodeBottom - dNodeHeightOrWidth;
                                    } else {
                                        dNodeBottom = dNodeTop + dNodeHeightOrWidth;
                                    }
                                } else {
                                    dNodeRight = dNodeLeft + dNodeHeightOrWidth;
                                }

                                oNode.Rectangle = internal.System.Drawing.Rectangle.FromLTRB(dNodeLeft, dNodeTop, dNodeRight, dNodeBottom);

                                Diag.Debug.Assert(oNode.Rectangle.Width >= 0);
                                Diag.Debug.Assert(oNode.Rectangle.Height >= 0);

                                if (bInsertVertically) {
                                    if (this.m_bBottomWeighted) {
                                        // The bottom of the next node should be at the top of this
                                        // node.
                                        dNodeBottom = dNodeTop;
                                    } else {
                                        // The top of the next node should be at the bottom of this
                                        // node.
                                        dNodeTop = dNodeBottom;
                                    }
                                } else {
                                    // The left side of the next node should be to the right of
                                    // this node.
                                    dNodeLeft = dNodeRight;
                                }
                            }
                        };

                        //*************************************************************************
                        //	Method: SaveInsertedRectangles()
                        //
                        /// <summary>
                        ///	Calls <see cref="Node.SaveRectangle" /> for each inserted node.
                        /// </summary>
                        ///
                        /// <param name="aoNodes">
                        /// Array of Node objects.
                        /// </param>
                        ///
                        /// <param name="iIndexOfFirstInsertedNode">
                        /// Zero-based index of the first node that has been inserted.
                        /// </param>
                        ///
                        /// <param name="iIndexOfLastInsertedNode">
                        /// Zero-based index of the last node that has been inserted.
                        /// </param>
                        //*************************************************************************
                        SquarifiedLayoutEngine.prototype.SaveInsertedRectangles = function (aoNodes, iIndexOfFirstInsertedNode, iIndexOfLastInsertedNode) {
                            Diag.Debug.Assert(aoNodes != null);
                            Diag.Debug.Assert(iIndexOfFirstInsertedNode >= 0);
                            Diag.Debug.Assert(iIndexOfLastInsertedNode >= 0);
                            Diag.Debug.Assert(iIndexOfLastInsertedNode >= iIndexOfFirstInsertedNode);
                            Diag.Debug.Assert(iIndexOfLastInsertedNode < aoNodes.length);

                            for (var i = iIndexOfFirstInsertedNode; i <= iIndexOfLastInsertedNode; i++) {
                                aoNodes[i].SaveRectangle();
                            }
                        };

                        //*************************************************************************
                        //	Method: RestoreInsertedRectangles()
                        //
                        /// <summary>
                        ///	Calls <see cref="Node.RestoreRectangle" /> for each inserted node.
                        /// </summary>
                        ///
                        /// <param name="aoNodes">
                        /// Array of Node objects.
                        /// </param>
                        ///
                        /// <param name="iIndexOfFirstInsertedNode">
                        /// Zero-based index of the first node that has been inserted.
                        /// </param>
                        ///
                        /// <param name="iIndexOfLastInsertedNode">
                        /// Zero-based index of the last node that has been inserted.
                        /// </param>
                        //*************************************************************************
                        SquarifiedLayoutEngine.prototype.RestoreInsertedRectangles = function (aoNodes, iIndexOfFirstInsertedNode, iIndexOfLastInsertedNode) {
                            Diag.Debug.Assert(aoNodes != null);
                            Diag.Debug.Assert(iIndexOfFirstInsertedNode >= 0);
                            Diag.Debug.Assert(iIndexOfLastInsertedNode >= 0);
                            Diag.Debug.Assert(iIndexOfLastInsertedNode >= iIndexOfFirstInsertedNode);
                            Diag.Debug.Assert(iIndexOfLastInsertedNode < aoNodes.length);

                            for (var i = iIndexOfFirstInsertedNode; i <= iIndexOfLastInsertedNode; i++) {
                                aoNodes[i].RestoreRectangle();
                            }
                        };

                        //*************************************************************************
                        //	Method: GetAreaPerSizeMetric()
                        //
                        /// <summary>
                        ///	Returns the area within a parent rectangle that will be taken up by
                        /// each SizeMetric unit of the nodes that will be placed into the
                        /// rectangle.
                        /// </summary>
                        ///
                        /// <param name="oNodes">
                        /// Collection of Node objects.
                        /// </param>
                        ///
                        /// <param name="oParentRectangle">
                        /// Parent rectangle the nodes should be laid out within.  Can't be empty
                        /// -- must have positive width and height.
                        /// </param>
                        ///
                        /// <param name="oParentNode">
                        /// Parent of <paramref name="oNodes" />, or null if <paramref
                        /// name="oNodes" /> is the treemap's top-level node collection.
                        /// </param>
                        ///
                        /// <returns>
                        /// Area within oParentRectangle that will be taken up by each <see
                        /// cref="Node.SizeMetric" /> unit.  A return value of zero indicates that
                        /// the nodes in oNodes should not be drawn.
                        /// </returns>
                        //*************************************************************************
                        SquarifiedLayoutEngine.prototype.GetAreaPerSizeMetric = function (oNodes, oParentRectangle, oParentNode) {
                            Diag.Debug.Assert(oNodes != null);
                            Diag.Debug.Assert(oParentRectangle.Width > 0);
                            Diag.Debug.Assert(oParentRectangle.Height > 0);

                            // Compute the total area of the parent.
                            var dTotalArea = oParentRectangle.Width * oParentRectangle.Height;

                            // Get the sum of the child SizeMetric values.
                            var dChildSizeMetricSum = 0;

                            for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                                var oNode = oNodes.Item(iNode);
                                dChildSizeMetricSum += oNode.SizeMetric;
                            }

                            // Add the SizeMetric value of the EmptySpace object that belongs to
                            // the Nodes collection.
                            dChildSizeMetricSum += oNodes.EmptySpace.SizeMetric;

                            // If the sum is zero, the nodes in oNodes should not be drawn.
                            if (dChildSizeMetricSum == 0)
                                return (0);

                            Diag.Debug.Assert(dChildSizeMetricSum != 0);

                            return (dTotalArea / dChildSizeMetricSum);
                        };

                        //*************************************************************************
                        //	Method: GetRemainingEmptySpace()
                        //
                        /// <summary>
                        ///	Returns a rectangle that contains the empty space not already filled by
                        /// a set of inserted nodes.
                        /// </summary>
                        ///
                        /// <param name="aoNodes">
                        /// Array of Node objects.
                        /// </param>
                        ///
                        /// <param name="oParentRectangle">
                        /// Parent rectangle the nodes should be laid out within.  Can't be empty
                        /// -- must have positive width and height.
                        /// </param>
                        ///
                        /// <param name="iIndexOfFirstInsertedNode">
                        /// Zero-based index of the first node that has already been inserted into
                        /// <paramref name="oParentRectangle" />.
                        /// </param>
                        ///
                        /// <param name="iIndexOfLastInsertedNode">
                        /// Zero-based index of the last node that has already been inserted into
                        /// <paramref name="oParentRectangle" />.
                        /// </param>
                        ///
                        /// <returns>
                        /// New rectangle that contains the empty space.  May be empty.
                        /// </returns>
                        ///
                        /// <remarks>
                        ///	If there is no empty space left, an empty rectangle is returned.
                        /// </remarks>
                        //*************************************************************************
                        SquarifiedLayoutEngine.prototype.GetRemainingEmptySpace = function (aoNodes, oParentRectangle, iIndexOfFirstInsertedNode, iIndexOfLastInsertedNode) {
                            Diag.Debug.Assert(aoNodes != null);
                            Diag.Debug.Assert(oParentRectangle.Width > 0);
                            Diag.Debug.Assert(oParentRectangle.Height > 0);
                            Diag.Debug.Assert(iIndexOfFirstInsertedNode >= 0);
                            Diag.Debug.Assert(iIndexOfLastInsertedNode >= 0);
                            Diag.Debug.Assert(iIndexOfLastInsertedNode >= iIndexOfFirstInsertedNode);
                            Diag.Debug.Assert(iIndexOfLastInsertedNode < aoNodes.length);

                            var oRemainingEmptySpace;

                            // Get the most recently inserted rectangle.
                            var oLastInsertedRectangle = aoNodes[iIndexOfLastInsertedNode].Rectangle;

                            if (oParentRectangle.Width >= oParentRectangle.Height) {
                                // Nodes were added from bottom to top or top to bottom.  Move the
                                // left edge of the rectangle to the right of the inserted nodes.
                                oRemainingEmptySpace = internal.System.Drawing.Rectangle.FromLTRB(oLastInsertedRectangle.Right, oParentRectangle.Top, oParentRectangle.Right, oParentRectangle.Bottom);
                            } else {
                                // Nodes were added from left to right.
                                if (this.m_bBottomWeighted) {
                                    // Move the bottom edge of the rectangle to the top of the
                                    // inserted nodes.
                                    oRemainingEmptySpace = internal.System.Drawing.Rectangle.FromLTRB(oParentRectangle.Left, oParentRectangle.Top, oParentRectangle.Right, oLastInsertedRectangle.Top);
                                } else {
                                    // Move the top edge of the rectangle to the bottom of the
                                    // inserted nodes.
                                    oRemainingEmptySpace = internal.System.Drawing.Rectangle.FromLTRB(oParentRectangle.Left, oLastInsertedRectangle.Bottom, oParentRectangle.Right, oParentRectangle.Bottom);
                                }
                            }

                            // If the rectangle's height or width is <= 0, return an empty
                            // rectangle.
                            if (oRemainingEmptySpace.IsEmpty)
                                oRemainingEmptySpace = internal.System.Drawing.Rectangle.FromLTRB(0, 0, 0, 0);

                            return (oRemainingEmptySpace);
                        };
                        return SquarifiedLayoutEngine;
                    })(LayoutEngineBase);
                    Util.SquarifiedLayoutEngine = SquarifiedLayoutEngine;

                    var BottomWeightedSquarifiedLayoutEngine = (function (_super) {
                        __extends(BottomWeightedSquarifiedLayoutEngine, _super);
                        function BottomWeightedSquarifiedLayoutEngine() {
                            _super.call(this, true);
                        }
                        return BottomWeightedSquarifiedLayoutEngine;
                    })(SquarifiedLayoutEngine);
                    Util.BottomWeightedSquarifiedLayoutEngine = BottomWeightedSquarifiedLayoutEngine;

                    var TopWeightedSquarifiedLayoutEngine = (function (_super) {
                        __extends(TopWeightedSquarifiedLayoutEngine, _super);
                        function TopWeightedSquarifiedLayoutEngine() {
                            _super.call(this, false);
                        }
                        return TopWeightedSquarifiedLayoutEngine;
                    })(SquarifiedLayoutEngine);
                    Util.TopWeightedSquarifiedLayoutEngine = TopWeightedSquarifiedLayoutEngine;

                    var TextDrawerBase = (function () {
                        function TextDrawerBase(eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, fAnimDuration) {
                            this.m_eNodeLevelsWithText = eNodeLevelsWithText;
                            this.m_iMinNodeLevelWithText = iMinNodeLevelWithText;
                            this.m_iMaxNodeLevelWithText = iMaxNodeLevelWithText;
                            this.m_fAnimDuration = fAnimDuration;
                            // this.AssertValid();
                        }
                        TextDrawerBase.prototype.AssertValid = function () {
                            // Diag.Debug.Assert( Enum.IsDefined(typeof(NodeLevelsWithText), this.m_eNodeLevelsWithText) );
                            Diag.Debug.Assert(this.m_iMinNodeLevelWithText >= 0);
                            Diag.Debug.Assert(this.m_iMaxNodeLevelWithText >= 0);
                            Diag.Debug.Assert(this.m_iMaxNodeLevelWithText >= this.m_iMinNodeLevelWithText);
                        };

                        TextDrawerBase.prototype.DrawTextForAllNodes = function (displayRoot, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, oNodes) {
                            // abstract
                        };

                        TextDrawerBase.prototype.DrawTextForSelectedNode = function (oSelectedNode) {
                            // abstract
                        };

                        TextDrawerBase.prototype.TextShouldBeDrawnForNode = function (oNode, iNodeLevel) {
                            Diag.Debug.Assert(oNode != null);
                            Diag.Debug.Assert(iNodeLevel >= 0);
                            this.AssertValid();

                            switch (this.m_eNodeLevelsWithText) {
                                case 0 /* All */:
                                    return (true);

                                case 2 /* None */:
                                    return (false);

                                case 1 /* Leaves */:
                                    return (oNode.Nodes.Count == 0);

                                case 3 /* Range */:
                                    return (iNodeLevel >= this.m_iMinNodeLevelWithText && iNodeLevel <= this.m_iMaxNodeLevelWithText);

                                default:
                                    Diag.Debug.Assert(false);
                                    return (false);
                            }
                        };
                        return TextDrawerBase;
                    })();
                    Util.TextDrawerBase = TextDrawerBase;

                    var CenterCenterTextDrawer = (function (_super) {
                        __extends(CenterCenterTextDrawer, _super);
                        function CenterCenterTextDrawer(eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, sFontFamily, fFontNormSizePt, fFontMinSizePt, fFontMaxSizePt, fFontIncrementPt, oFontSolidColor, iFontMinAlpha, iFontMaxAlpha, iFontAlphaIncrementPerLevel, oSelectedFontColor, fAnimDuration) {
                            _super.call(this, eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, fAnimDuration);

                            this.m_sFontFamily = sFontFamily;

                            this.m_fFontNormSizePt = fFontNormSizePt;
                            this.m_fFontMinSizePt = fFontMinSizePt;
                            this.m_fFontMaxSizePt = fFontMaxSizePt;
                            this.m_fFontIncrementPt = fFontIncrementPt;

                            this.m_oFontSolidColor = oFontSolidColor;

                            this.m_iFontMinAlpha = iFontMinAlpha;
                            this.m_iFontMaxAlpha = iFontMaxAlpha;
                            this.m_iFontAlphaIncrementPerLevel = iFontAlphaIncrementPerLevel;

                            this.m_oSelectedFontColor = oSelectedFontColor;
                            this.m_fAnimDuration = fAnimDuration;

                            this.AssertValid();
                        }
                        CenterCenterTextDrawer.prototype.AssertValid = function () {
                            _super.prototype.AssertValid.call(this);

                            Diag.Debug.AssertNotEmpty(this.m_sFontFamily);

                            Diag.Debug.Assert(this.m_fFontNormSizePt > 0);
                            Diag.Debug.Assert(this.m_fFontMinSizePt > 0);
                            Diag.Debug.Assert(this.m_fFontMaxSizePt > 0);
                            Diag.Debug.Assert(this.m_fFontMaxSizePt >= this.m_fFontMinSizePt);
                            Diag.Debug.Assert(this.m_fFontNormSizePt >= this.m_fFontMinSizePt);
                            Diag.Debug.Assert(this.m_fFontNormSizePt <= this.m_fFontMaxSizePt);
                            Diag.Debug.Assert(this.m_fFontIncrementPt > 0);

                            Diag.Debug.Assert(this.m_oFontSolidColor.A == 255);

                            Diag.Debug.Assert(this.m_iFontMinAlpha >= 0 && this.m_iFontMinAlpha <= 255);
                            Diag.Debug.Assert(this.m_iFontMaxAlpha >= 0 && this.m_iFontMaxAlpha <= 255);
                            Diag.Debug.Assert(this.m_iFontMaxAlpha >= this.m_iFontMinAlpha);
                            Diag.Debug.Assert(this.m_iFontAlphaIncrementPerLevel > 0);
                            // m_oSelectedFontColor
                        };

                        CenterCenterTextDrawer.prototype.CreateFontMapper = function (displayRoot) {
                            Diag.Debug.Assert(displayRoot != null);
                            this.AssertValid();

                            // Create a MaximizingFontMapper for now.  Possible future upgrade:
                            // Add an option to use either a MaximizingFontMapper or a
                            // PerLevelFontMapper.
                            var oMaximizingFontMapper = new MaximizingFontMapper(this.m_sFontFamily, this.m_fFontMinSizePt, this.m_fFontMaxSizePt, this.m_fFontIncrementPt, displayRoot);

                            return (oMaximizingFontMapper);
                        };

                        CenterCenterTextDrawer.prototype.CreateStringFormat = function () {
                            // The node text should be centered both vertically and horizontally
                            // within the node's rectangle.
                            var oStringFormat = new vp.internal.System.Drawing.StringFormat();
                            oStringFormat.Alignment = 0 /* Center */;
                            oStringFormat.LineAlignment = 0 /* Center */;

                            return (oStringFormat);
                        };

                        CenterCenterTextDrawer.prototype.CreateTransparentBrushMapper = function () {
                            var oTransparentBrushMapper = new Microsoft.Treemap.GraphicsLib.TransparentBrushMapper();

                            oTransparentBrushMapper.Initialize(this.m_oFontSolidColor, this.m_iFontMinAlpha, this.m_iFontMaxAlpha, this.m_iFontAlphaIncrementPerLevel);

                            return (oTransparentBrushMapper);
                        };

                        CenterCenterTextDrawer.prototype.DrawTextForAllNodes = function (displayRoot, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, oNodes) {
                            Diag.Debug.Assert(displayRoot != null);
                            Diag.Debug.Assert(oNodes != null);
                            this.AssertValid();

                            var oFontMapper = null;
                            var oTransparentBrushMapper = null;

                            // Save the current rendering hint.  This gets modified by
                            // DrawTextForNodes() on a per-node basis.
                            // Create an object that implements IFontMapper.
                            oFontMapper = this.CreateFontMapper(displayRoot);

                            // Create a TransparentBrushMapper object.
                            oTransparentBrushMapper = this.CreateTransparentBrushMapper();

                            // Create the required StringFormat object.
                            var oStringFormat = this.CreateStringFormat();

                            // Draw all the text.
                            this.DrawTextForNodes(oNodes, displayRoot, oFontMapper, oStringFormat, oTransparentBrushMapper, 0, this.m_fAnimDuration);
                        };

                        CenterCenterTextDrawer.prototype.DrawTextForNodes = function (oNodes, displayRoot, oFontMapper, oStringFormat, oTransparentBrushMapper, iNodeLevel, fAnimDuration) {
                            Diag.Debug.Assert(oNodes != null);
                            Diag.Debug.Assert(displayRoot != null);
                            Diag.Debug.Assert(oFontMapper != null);
                            Diag.Debug.Assert(oStringFormat != null);
                            Diag.Debug.Assert(oTransparentBrushMapper != null);
                            Diag.Debug.Assert(iNodeLevel >= 0);

                            for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                                var oNode = oNodes.Item(iNode);
                                var oNodeRectangle = oNode.RectangleToDraw;

                                // Skip over empty rectangles.  An empty rectangle indicates that
                                // a node's calculated rectangle is too small to display.
                                if (oNodeRectangle.IsEmpty)
                                    continue;

                                // Check whether text should be drawn for this node level.
                                if (this.TextShouldBeDrawnForNode(oNode, iNodeLevel)) {
                                    // Get a font to use for the text.
                                    var oFont;
                                    var sTextToDraw = oNode.Text;

                                    oFont = oFontMapper.NodeToFont(oNode, oNodeRectangle, iNodeLevel, sTextToDraw);

                                    if (oFont) {
                                        // Get a transparent brush to use.
                                        var oBrush = oTransparentBrushMapper.LevelToTransparentBrush(iNodeLevel);

                                        // Draw the text.
                                        oNode.DisplayText(displayRoot, oNodeRectangle, oFont, oBrush, oStringFormat, iNodeLevel, fAnimDuration);
                                    } else {
                                        oNode.RemoveText();
                                    }
                                } else {
                                    oNode.RemoveText();
                                }

                                // Repeat for this node's child nodes.
                                this.DrawTextForNodes(oNode.Nodes, displayRoot, oFontMapper, oStringFormat, oTransparentBrushMapper, iNodeLevel + 1, this.m_fAnimDuration);
                            }
                        };

                        CenterCenterTextDrawer.prototype.DrawTextForSelectedNode = function (oSelectedNode) {
                            Diag.Debug.Assert(oSelectedNode != null);
                            this.AssertValid();

                            oSelectedNode.SetTextColor(this.m_oSelectedFontColor);
                        };
                        return CenterCenterTextDrawer;
                    })(TextDrawerBase);
                    Util.CenterCenterTextDrawer = CenterCenterTextDrawer;

                    var TopTextDrawer = (function (_super) {
                        __extends(TopTextDrawer, _super);
                        function TopTextDrawer(eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, sFontFamily, fFontNormSizePt, fFontMinSizePt, iMinimumTextHeight, oTextColor, oSelectedFontColor, oSelectedBackColor, fAnimDuration) {
                            _super.call(this, eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, fAnimDuration);

                            this.m_sFontFamily = sFontFamily;
                            this.m_fFontNormSizePt = fFontNormSizePt;
                            this.m_fFontMinSizePt = fFontMinSizePt;
                            this.m_iMinimumTextHeight = iMinimumTextHeight;
                            this.m_oTextColor = oTextColor;
                            this.m_oSelectedFontColor = oSelectedFontColor;
                            this.m_oSelectedBackColor = oSelectedBackColor;

                            this.AssertValid();
                        }
                        TopTextDrawer.prototype.AssertValid = function () {
                            _super.prototype.AssertValid.call(this);

                            Diag.Debug.AssertNotEmpty(this.m_sFontFamily);
                            Diag.Debug.Assert(this.m_fFontMinSizePt > 0);
                            Diag.Debug.Assert(this.m_fFontNormSizePt > 0);
                            Diag.Debug.Assert(this.m_fFontNormSizePt >= this.m_fFontMinSizePt);
                            Diag.Debug.Assert(this.m_iMinimumTextHeight >= 0);
                            // m_oTextColor
                            // m_oSelectedFontColor
                            // m_oSelectedBackColor
                        };

                        TopTextDrawer.prototype.CreateStringFormat = function (bLeafNode, iTextHeight) {
                            var oStringFormat = new vp.internal.System.Drawing.StringFormat();

                            // For leaf nodes, the text should be left-justified at the top of the
                            // node's rectangle and wrap within the rectangle.
                            //
                            // For non-leaf nodes, the text should be center-justified at the top
                            // of the node's rectangle and limited to a single line.
                            oStringFormat.LineAlignment = oStringFormat.Alignment = bLeafNode ? 2 /* Near */ : 0 /* Center */;

                            // Trim the string with ellipses.
                            oStringFormat.Trimming = 1 /* EllipsisCharacter */;

                            // TODO: trim ourselves since canvas text doesn't do that.
                            return (oStringFormat);
                        };

                        TopTextDrawer.prototype.DrawTextForAllNodes = function (displayRoot, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, oNodes) {
                            Diag.Debug.Assert(displayRoot != null);
                            Diag.Debug.Assert(oNodes != null);
                            this.AssertValid();

                            var oFontForRectangle = null;
                            var oFontForLeaf = null;
                            var oTextBrush = null;

                            // Get a font to use.
                            oFontForRectangle = new FontForRectangle(this.m_sFontFamily, this.m_fFontNormSizePt, displayRoot);

                            if ((this.m_fFontNormSizePt - 2) > this.m_fFontMinSizePt) {
                                oFontForLeaf = new FontForRectangle(this.m_sFontFamily, this.m_fFontNormSizePt - 2, displayRoot);
                            } else {
                                oFontForLeaf = oFontForRectangle;
                            }

                            // Get the height required to draw text.
                            var iTextHeight = TopTextDrawer.GetTextHeight2(displayRoot, oFontForRectangle.Font, this.m_iMinimumTextHeight);

                            // Get a brush to use.
                            oTextBrush = this.m_oTextColor;

                            // Create the required StringFormat objects.
                            var oNonLeafStringFormat = this.CreateStringFormat(false, iTextHeight);
                            var oLeafStringFormat = this.CreateStringFormat(true, iTextHeight);

                            // Draw the text.
                            this.DrawTextForNodes(oNodes, displayRoot, oFontForRectangle, oFontForLeaf, iTextHeight, oTextBrush, null, oNonLeafStringFormat, oLeafStringFormat, 0);
                        };

                        TopTextDrawer.prototype.DrawTextForNode = function (displayRoot, oNode, oFontForRectangle, oFontForLeaf, iTextHeight, oTextBrush, oBackgroundBrush, oNonLeafStringFormat, oLeafStringFormat, iNodeLevel) {
                            Diag.Debug.Assert(displayRoot != null);
                            Diag.Debug.Assert(oNode != null);
                            Diag.Debug.Assert(oFontForRectangle != null);
                            Diag.Debug.Assert(oFontForLeaf != null);
                            Diag.Debug.Assert(iTextHeight >= 0);
                            Diag.Debug.Assert(oTextBrush != null);
                            Diag.Debug.Assert(oNonLeafStringFormat != null);
                            Diag.Debug.Assert(oLeafStringFormat != null);
                            this.AssertValid();

                            var bIsLeaf = (oNode.Nodes.Count == 0);

                            // Get the node's rectangle, then shrink it to accommodate the node's
                            // border.
                            var oInnerBorderRectangle = oNode.RectangleToDraw;
                            var iPenWidthPx = oNode.PenWidthPx;
                            oInnerBorderRectangle.Inflate(-iPenWidthPx, -iPenWidthPx);

                            var oTextRectangle;
                            var oFontForText;

                            if (bIsLeaf) {
                                // The text should wrap within the rectangle.
                                oTextRectangle = internal.System.Drawing.Rectangle.Inflate(oInnerBorderRectangle, -2, -2);
                                oFontForText = oFontForLeaf;
                            } else {
                                // The text should be limited to a single line.
                                oTextRectangle = internal.System.Drawing.Rectangle.FromLTRB(oInnerBorderRectangle.Left, oInnerBorderRectangle.Top, oInnerBorderRectangle.Right, oInnerBorderRectangle.Top + iTextHeight + iPenWidthPx);
                                oFontForText = oFontForRectangle;
                            }

                            // If the text rectangle isn't large enough to contain text, do
                            // nothing.
                            var iTextRectangleWidth = oTextRectangle.Width;
                            var iTextRectangleHeight = oTextRectangle.Height;

                            if (iTextRectangleWidth <= 0 || iTextRectangleHeight <= 0 || iTextRectangleHeight > oInnerBorderRectangle.Height) {
                                oNode.RemoveText();
                                return;
                            }

                            //---- get text color from NODE or GENERATOR ----
                            var tb = oNode.m_oTextColor;
                            if (!tb) {
                                tb = this.m_oTextColor;
                            }

                            if (tb) {
                                oTextBrush = tb;
                            }

                            // Draw the text.
                            oNode.DisplayText(displayRoot, oTextRectangle, oFontForText.Font, oTextBrush, bIsLeaf ? oLeafStringFormat : oNonLeafStringFormat, iNodeLevel, this.m_fAnimDuration);
                            // TODO: use oBackgroundBrush if necessary
                        };

                        TopTextDrawer.prototype.DrawTextForNodes = function (oNodes, displayRoot, oFontForRectangle, oFontForLeaf, iTextHeight, oTextBrush, oBackgroundBrush, oNonLeafStringFormat, oLeafStringFormat, iNodeLevel) {
                            Diag.Debug.Assert(oNodes != null);
                            Diag.Debug.Assert(displayRoot != null);
                            Diag.Debug.Assert(oFontForRectangle != null);
                            Diag.Debug.Assert(iTextHeight >= 0);
                            Diag.Debug.Assert(oTextBrush != null);
                            Diag.Debug.Assert(oNonLeafStringFormat != null);
                            Diag.Debug.Assert(oLeafStringFormat != null);
                            Diag.Debug.Assert(iNodeLevel >= 0);

                            for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                                var oNode = oNodes.Item(iNode);
                                var oNodeRectangle = oNode.Rectangle;

                                // Skip over empty rectangles.  An empty rectangle indicates that
                                // a node's calculated rectangle is too small to display.
                                if (oNodeRectangle.IsEmpty)
                                    continue;

                                // Check whether text should be drawn for this node level.
                                if (this.TextShouldBeDrawnForNode(oNode, iNodeLevel)) {
                                    // Draw the text.
                                    this.DrawTextForNode(displayRoot, oNode, oFontForRectangle, oFontForLeaf, iTextHeight, oTextBrush, oBackgroundBrush, oNonLeafStringFormat, oLeafStringFormat, iNodeLevel);
                                } else {
                                    oNode.RemoveText();
                                }

                                // Repeat for this node's child nodes.
                                this.DrawTextForNodes(oNode.Nodes, displayRoot, oFontForRectangle, oFontForLeaf, iTextHeight, oTextBrush, oBackgroundBrush, oNonLeafStringFormat, oLeafStringFormat, iNodeLevel + 1);
                            }
                        };

                        TopTextDrawer.prototype.DrawTextForSelectedNode = function (oSelectedNode) {
                            Diag.Debug.Assert(oSelectedNode != null);
                            this.AssertValid();

                            oSelectedNode.SetTextColor(this.m_oSelectedFontColor);
                        };

                        TopTextDrawer.GetTextHeight = function (displayRoot, sFontFamily, fFontSizePt, iMinimumTextHeight) {
                            Diag.Debug.Assert(displayRoot != null);
                            Diag.Debug.AssertNotEmpty(sFontFamily);
                            Diag.Debug.Assert(fFontSizePt > 0);
                            Diag.Debug.Assert(iMinimumTextHeight >= 0);

                            var oFontForRectangle = null;
                            var iTextHeight;

                            oFontForRectangle = new FontForRectangle(sFontFamily, fFontSizePt, displayRoot);

                            iTextHeight = TopTextDrawer.GetTextHeight2(displayRoot, oFontForRectangle.Font, iMinimumTextHeight);

                            return (iTextHeight);
                        };
                        TopTextDrawer.GetTextHeight2 = function (displayRoot, oFont, iMinimumTextHeight) {
                            Diag.Debug.Assert(displayRoot != null);
                            Diag.Debug.Assert(oFont != null);
                            Diag.Debug.Assert(iMinimumTextHeight >= 0);

                            // Multiply the text height returned by Font.GetHeight() by a constant
                            // to provide a margin above and below the text.
                            // TODO: this should really be in oFont.GetHeight()
                            var d = document.createElement("span");
                            d.style.font = oFont.ToHTML;
                            d.textContent = "Hg";
                            document.body.appendChild(d);
                            var emHeight = d.offsetHeight;
                            document.body.removeChild(d);

                            // var temp = displayRoot.append("text")
                            //    .text("M")
                            //    .font(oFont.Name, oFont.Size);
                            // temp.remove();
                            var iTextHeight = Math.ceil(Util.TextHeightMultiplier * emHeight);

                            iTextHeight = Math.max(iTextHeight, iMinimumTextHeight);

                            return (iTextHeight);
                        };
                        return TopTextDrawer;
                    })(TextDrawerBase);
                    Util.TopTextDrawer = TopTextDrawer;

                    var OwnerDrawDrawer = (function (_super) {
                        __extends(OwnerDrawDrawer, _super);
                        function OwnerDrawDrawer(ownerDraw, eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, sFontFamily, fFontSizePt, oTextColor, oSelectedFontColor, oSelectedBackColor, fAnimDuration) {
                            _super.call(this, eNodeLevelsWithText, iMinNodeLevelWithText, iMaxNodeLevelWithText, fAnimDuration);

                            this.m_ownerDraw = ownerDraw;

                            this.m_sFontFamily = sFontFamily;
                            this.m_fFontSizePt = fFontSizePt;
                            this.m_oTextColor = oTextColor;
                            this.m_oSelectedFontColor = oSelectedFontColor;
                            this.m_oSelectedBackColor = oSelectedBackColor;

                            this.m_ownerDraw.SetDrawingContext(sFontFamily, fFontSizePt, oTextColor, oSelectedFontColor, oSelectedBackColor);
                            this.AssertValid();
                        }
                        OwnerDrawDrawer.prototype.AssertValid = function () {
                            Diag.Debug.Assert(this.m_ownerDraw != null);

                            Diag.Debug.AssertNotEmpty(this.m_sFontFamily);
                            Diag.Debug.Assert(this.m_fFontSizePt > 0);
                            // m_oTextColor
                            // m_oSelectedFontColor
                            // m_oSelectedBackColor
                        };

                        OwnerDrawDrawer.prototype.DrawTextForAllNodes = function (displayRoot, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, oNodes) {
                            Diag.Debug.Assert(displayRoot != null);
                            Diag.Debug.Assert(oNodes != null);
                            this.AssertValid();

                            // TODO: font mapper, color mapper, etc.
                            this.DrawContentForNodes(displayRoot, oNodes, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, 0);
                        };

                        OwnerDrawDrawer.prototype.DrawContentForNodes = function (displayRoot, oNodes, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, iNodeLevel) {
                            Diag.Debug.Assert(oNodes != null);
                            Diag.Debug.Assert(displayRoot != null);
                            Diag.Debug.Assert(iNodeLevel >= 0);

                            var iTextHeight = this.m_ownerDraw.GetTopHeight(displayRoot);

                            // same as TreemapGenerator.DecrementPadding
                            var iDecrementedLeftRightPaddingPx = Math.max(iLeftRightPaddingPx - iPaddingDecrementPerLevelPx, Microsoft.Treemap.Generator.TreemapGenerator.MinPaddingPx);

                            for (var iNode = 0; iNode < oNodes.Count; iNode++) {
                                var oNode = oNodes.Item(iNode);
                                var oNodeRectangle = oNode.Rectangle;

                                // Skip over empty rectangles.  An empty rectangle indicates that
                                // a node's calculated rectangle is too small to display.
                                if (oNodeRectangle.IsEmpty)
                                    continue;

                                if (this.TextShouldBeDrawnForNode(oNode, iNodeLevel)) {
                                    this.DrawContentForNode(displayRoot, oNode, iTextHeight, iDecrementedLeftRightPaddingPx, iPaddingDecrementPerLevelPx, iNodeLevel);
                                } else {
                                    var elem = oNode.DisplayedElement;
                                    if (elem) {
                                        elem.remove();
                                        oNode.DisplayedElement = null;
                                    }
                                }

                                // Repeat for this node's child nodes.
                                this.DrawContentForNodes(displayRoot, oNode.Nodes, iDecrementedLeftRightPaddingPx, iPaddingDecrementPerLevelPx, iNodeLevel + 1);
                            }
                        };

                        OwnerDrawDrawer.prototype.DrawContentForNode = function (displayRoot, oNode, iTextHeight, iLeftRightPaddingPx, iPaddingDecrementPerLevelPx, iNodeLevel) {
                            Diag.Debug.Assert(displayRoot != null);
                            Diag.Debug.Assert(oNode != null);
                            Diag.Debug.Assert(iTextHeight >= 0);
                            this.AssertValid();

                            var bIsLeaf = (oNode.Nodes.Count == 0);

                            // Get the node's rectangle, then shrink it to accommodate the node's
                            // border.
                            var oInnerBorderRectangle = oNode.RectangleToDraw;
                            var iPenWidthPx = oNode.PenWidthPx;
                            oInnerBorderRectangle.Inflate(-iPenWidthPx, -iPenWidthPx);

                            var oTextRectangle;

                            if (bIsLeaf) {
                                // The text should wrap within the rectangle.
                                oTextRectangle = oInnerBorderRectangle;
                            } else {
                                // The text should be limited to a single line.
                                // passing must be sutracted from left/right so that the rectangle
                                // fits above all children and between the outer and inner borders
                                oTextRectangle = internal.System.Drawing.Rectangle.FromLTRB(oInnerBorderRectangle.Left + iLeftRightPaddingPx, oInnerBorderRectangle.Top, oInnerBorderRectangle.Right - iLeftRightPaddingPx, oInnerBorderRectangle.Top + iTextHeight);

                                if (oTextRectangle.Height > oInnerBorderRectangle.Height) {
                                    oTextRectangle.Height = oInnerBorderRectangle.Height;
                                }
                                if (oTextRectangle.Width > oInnerBorderRectangle.Width) {
                                    oTextRectangle.Width = oInnerBorderRectangle.Width;
                                }
                            }

                            // If the text rectangle isn't large enough to contain text, do
                            // nothing.
                            var iTextRectangleWidth = oTextRectangle.Width;
                            var iTextRectangleHeight = oTextRectangle.Height;

                            if (iTextRectangleWidth <= 0 || iTextRectangleHeight <= 0) {
                                var elem = oNode.DisplayedElement;
                                if (elem) {
                                    elem.remove();
                                    oNode.DisplayedElement = null;
                                }
                                return;
                            }

                            // Draw the content.
                            var elem = this.m_ownerDraw.DisplayContent(displayRoot, oNode.DisplayedElement, oTextRectangle, oNode, bIsLeaf, iNodeLevel);
                            oNode.DisplayedElement = elem;
                        };

                        OwnerDrawDrawer.prototype.DrawTextForSelectedNode = function (oSelectedNode) {
                            Diag.Debug.Assert(oSelectedNode != null);
                            this.AssertValid();

                            this.m_ownerDraw.ShowSelected(oSelectedNode.DisplayedElement, oSelectedNode, true);
                        };
                        return OwnerDrawDrawer;
                    })(TextDrawerBase);
                    Util.OwnerDrawDrawer = OwnerDrawDrawer;
                })(Treemap.Util || (Treemap.Util = {}));
                var Util = Treemap.Util;
            })(Microsoft.Treemap || (Microsoft.Treemap = {}));
            var Treemap = Microsoft.Treemap;
        })(internal.Microsoft || (internal.Microsoft = {}));
        var Microsoft = internal.Microsoft;
    })(vp.internal || (vp.internal = {}));
    var internal = vp.internal;
})(vp || (vp = {}));
//# sourceMappingURL=tmUtils.js.map
///-----------------------------------------------------------------------------------------------------------------
/// changeAgent.js.  Copyright (c) 2012 Microsoft Corporation.
///    - Part of the vuePlot library.
///    - allocated one per view; shares change/state info with changeMgr.
///-----------------------------------------------------------------------------------------------------------------

vp.changeAgentFactory = function (viewName, shareName, appName, externalShare, dataChangedFunc)
{
    //---- private state ----
    var session = null;
    var changeMgr = null;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.session.changeAgent";

    //---- readonly public properties ----
    closure.viewName = viewName;
    closure.shareName = shareName;
    closure.appName = appName;
    closure.externalShare = externalShare;
    closure.processId = new Date();
    closure.callBack = dataChangedFunc;
    
    //---- property: data ----
    closure.data = function (value)
    {
        if (value === undefined)
        {
            return session.data;
        }

        changeMgr.setData(closure, value, session);
        return this;
    };

    closure.unregister = function()
    {
        changeMgr.unregister(closure);
    };

    //---- init code ----
    if (!vp.changeMgr)
    {
        //---- create a global changeMgr that is shared by all views ----
        vp.changeMgr = vp.changeMgrFactory();
    }

    changeMgr = vp.changeMgr;
    session = changeMgr.register(closure);

    return closure;
};

vp.session.changeAgent = function (viewName, shareName, appName, externalShare, dataChangedFunc)
{
    var agent = vp.changeAgentFactory(viewName, shareName, appName, externalShare, dataChangedFunc);
    return agent;
};



///----------------------------------------------------------------
/// (from views\changeMgr.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// changeMgr.js.  Copyright (c) 2012 Microsoft Corporation.
///    - Part of the vuePlot library.
///    - used to share change information between in-process and external/networked views.
///-----------------------------------------------------------------------------------------------------------------
/// How this works:  Let's say we have an HTML based charting app called "xPlot".  It operates on 
/// one set of data tables at a time, but offers multiple views of that data.  Each view in xPlot should call:
///
///     var changeAgent = vp.changeMgr.registerView(shareName, appName, externalShare, onChangedFunc);
///
/// "shareName" is the name of the shared data, e.g., "data1".  Multiple channels of sharing can be established within 
/// or between applicatons using different names.
///
/// "appName" is the friendly name of the application being run.  In the above case, it would be "xPlot".
///
/// "externalShare" controls whether or not the sharing extends outside of the current application.  if set to "true",
/// the ChangeService (running on the hosting server) will be used to relay data between sharing clients.
///
/// "onChangedFunc" is a callback function that is called by the changeMgr whenever a change agent has signaled that
/// something has changed.  Normally, views will closure or rebuild themselves according to the data in the changeAgent.data property.
///
/// Note that "data" being shared (changeAgent.data) can be anything, but is usually a small json object that holds 
/// properties of the data (for example: data source name, selection query, filter query, and highlight query).
///
/// Whenever something in the "data" is changed by a view, it is recommended that each view NOT closure the associated elements
/// directly, but use "changeAgent.ChangeData()" to do so, and then wait for the callback to be called before updating the view.
///-----------------------------------------------------------------------------------------------------------------

vp.changeMgrFactory = function ()
{
    //---- private state ----
    var sessions = [];
    var subscribers = [];
    var serviceUrl = vp.pagePath() + "/Service/ChangeService.asmx";
    var timer = null;
    var updateSpan = 500;       // 500 ms

    //---- closure: ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.changeMgr";

    closure.register = function (agent)
    {
        var session = sessions[agent.shareName];
        if (session === undefined)
        {
            //---- its a new session ----
            session =
            {
                name: agent.shareName, data: null, sourceViewName: null, sourceTimeStamp: null,
                serviceChangeNum: 0, subscribers: [], subscribersChangeNumber: 0,
                tellService: agent.externalShare
            };

            sessions[agent.shareName] = session;

            if (agent.externalShare)
            {
                registerSessionWithService(session, agent.appName, agent.processId);
            }
        }

        session.subscribers.push(agent);
        return session;
    };

    var setDataCore = function (session, value, changeTime, agent, viewName, appName, computerName, userName)
    {
        session.data = value;
        session.sourceTimeStamp = changeTime;
        session.sourceViewName = viewName;

        //---- notify all subscribers ----
        for (var i = 0; i < session.subscribers.length; i++)
        {
            var subscriber = session.subscribers[i];

            if (subscriber != agent)        // don't sent to agent who made the change
            {
                var changeInfo = {
                    time: changeTime, view: viewName, app: appName,
                    computer: computerName, user: userName
                };

                subscriber.callBack(value, changeInfo);
            }
        }
    }

    //---- property: data ----
    closure.setData = function (agent, value, session)
    {
        setDataCore(session, value, new Date(), agent, agent.viewName, agent.appName, null, null);

        if (session.tellService)
        {
            sendDataChange(session, agent);
        }
    };

    /// private. registers the specified session name with the service 
    var registerSessionWithService = function (session, appName, processId)
    {
        var url = serviceUrl + "/RegisterSession?sessionName=" + session.name + "&processName=" + appName + "&processId="
           + processId;

        vp.file.httpRead(url, true, function (xmlhttp)
        {
            var success = 0;
        },
        function (xmlhttp)
        {
            var error = 0;
        });
    };

    var sendDataChange = function (session, agent)
    {
        var data = session.data;
        var jsonData = JSON.stringify(data);
        //var jsonEncodedData = encodeURIComponent(jsonData);

        var changedTime = new Date();

        var url = serviceUrl + "/UpdateData?sessionName=" + session.name +   // "&data=" + jsonData +
            "&processName=" + agent.appName + "&processId=" + agent.processId + "&timeChanged=" + changedTime + 
            "&viewName=" + agent.viewName;

        var safeUrl = encodeURI(url);

        //---- create the xmlHttp object ----
        var xmlhttp = vp.createXMLHttpRequest();
        var callAsync = true;
        xmlhttp.open("GET", url, callAsync);

        //---- send the potentially very long data string via a custom header ----
        xmlhttp.setRequestHeader("dataParam", jsonData);

        vp.utils.debug("changeMgr.sendDataChange: data.length=" + jsonData.length);

        //---- set up sucess / failure handlers ----
        xmlhttp.onreadystatechange = function ()
        {
            if ((xmlhttp.readyState == 4) && (xmlhttp.status != 0))
            {
                if (xmlhttp.status == 200)
                {
                    //---- SUCCESS ----
                    var data = vp.getJsonFromResponseXml(xmlhttp.responseXML);
                    session.serviceChangeNum = data.newChangeNum;

                    var dummy = 9;
                }
                else
                {
                    //---- FAILURE ----
                    var error = 9;
                }
            }
        };

        //---- start it now ----
        xmlhttp.send();
    };

    var getDataChanges = function ()
    {
        var requestArray = [];
        var keys = vp.utils.keys(sessions);

        for (var i = 0; i < keys.length; i++)
        {
            var session = sessions[keys[i]];
            var request = { sessionName: session.name, lastChangeNum: session.serviceChangeNum };

            requestArray.push(request);
        }

        var json = JSON.stringify(requestArray);
        var jsonEncoded = encodeURIComponent(json);

        var url = serviceUrl + "/GetDataChanges?jsonRequestList=" + jsonEncoded;

        vp.file.httpRead(url, true, function (xmlhttp)
        {
            var data = vp.getJsonFromResponseXml(xmlhttp.responseXML);
            var changeArray = data;
            for (var i = 0; i < changeArray.length; i++)
            {
                var change = changeArray[i];

                var session = sessions[change.sessionName];
                if (session)
                {
                    session.serviceChangeNum = change.lastChangeNum;
                    var data = JSON.parse(change.data);     // eval("(" + change.data + ")");
                    var time = new Date(change.changedTime);

                    setDataCore(session, data, time, null, change.viewName, change.appName, change.computerName, change.userName);
                }
            }

            var dummy = 9;
        },
        function (xmlhttp)
        {
            var error = 9;
        });
    };

    closure.unregister = function(agent)
    {
        var session = sessions[agent.shareName];
        if (session)
        {
            session.subscribers.remove(agent);
        }
    };

    //---- init code for changeMgr ----
    timer = setInterval(getDataChanges, updateSpan);      // read data changes from service every one second

    return closure;
};



///----------------------------------------------------------------
/// (from views\query.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// query.js.  Copyright (c) 2014 Microsoft Corporation.
///    - Part of the vuePlot library.
///    - implements a query object composed of query terms and operators
///    - support query-based views that implement highlighting, selection, and filtering
///    - used by "changeAgent" to support "selection", "filter", and "highlight" objects
///
///    - functions:
///         - reset()
///         - test(data)            // returns TRUE if data is "in" the query 
///
///         - orWith(exp)           // exp OR prev            (shift-key highlight/select)
///         - invert()              // NOT prev               (invert of select/filter)
///         - toggleTo(exp)         // toggle "exp" in prev   (ctrl-key highlight/select)
///         - boundsQuery(exp)      // select elems from bounds query  (draw rectangle around elements)
///
///         - addGroup(fromQUery, invert)   // adds terms from another query as a grouped set of terms
///-----------------------------------------------------------------------------------------------------------------
/// testing: see query.html
///-----------------------------------------------------------------------------------------------------------------

vp.session.nextQueryNum = 1;

vp.session.query = function ()
{
    //---- private state ----
    var terms = [];
    var newTestNeeded = true;
    var funcHolder = null;
    var usesGroups = false;

    var myId = vp.session.nextQueryNum++;
    var generatedTestName = "generatedTest" + myId;

    //---- closure() ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.session.query";

    //---- public: reset() ----
    closure.reset = function (value)
    {
        terms = [];
        usesGroups = false;
        markNewTestNeeded();

        return this;
    };

    var generateTermEval = function(opCode, exp, indent)
    {
        var func = "";

        if (opCode == "orWith")
        {
            func += indent + "prev = prev || (" + exp + ");\n";
        }
        else if (opCode == "andWith")
        {
            func += indent + "prev = prev && (" + exp + ");\n";
        }
        else if (opCode == "invert")
        {
            func += indent + "prev = (! prev);\n";
        }
        else if (opCode == "toggleTo")
        {
            func += indent + "var isIn = (" + exp + ");\n";
            func += indent + "prev = (isIn) ? (! prev) : (prev) ;\n";
        }
        else if (opCode == "boundsQuery")
        {
            func += indent + "prev = (" + exp + ");\n"; 
        }
        else if (opCode == "andWithInvert")
        {
            func += indent + "var isIn = (" + exp + ");\n";
            func += indent + "prev = prev && (! isIn);\n";
        }

        return func;
    };

    //---- private: generateSeriesTest() ----
    var generateSeriesTest = function ()
    {
        newTestNeeded = false;

        var func = "function " + generatedTestName + "(data1) \n";
        func += "{ \n";

        func += "  var count = arguments.length;    // series count \n";
        func += "  var topPrev = undefined;   \n";

        for (var i = 0; i < terms.length; i++)
        {
            //---- we only expect group objects here ----
            var group = terms[i];

            var gterms = group.terms;
            var useInvert = group.invert;

            func += "\n";

            func += "  //---- start code for group " + i + " ---- \n";

            if (gterms.length > 0)
            {
                func += "  var prev = false;    // prev for this group \n";
                func += "  for(var i=0; i < count; i++) // for each series\n";
                func += "  { \n";
                func += "    var data = arguments[i]; \n";

                //---- generate code for this group's terms ----
                for (var g = 0; g < gterms.length; g++)
                {
                    var innerTerm = gterms[g];
                    func += generateTermEval(innerTerm.op, innerTerm.exp, "    ");
                }

                if (useInvert)
                {
                    func += "    prev = (! prev);    // apply TOGGLE\n";
                }

                func += "    if (prev)      // break on first TRUE \n";
                func += "    { \n";
                func += "        break; \n";
                func += "    } \n";
                func += "  } \n\n";

                func += "  if (topPrev)     // combine with prior groups result \n";
                func += "  { \n";
                func += "    prev = (topPrev || prev); \n";
                func += "  } \n";
                func += "  topPrev = prev; \n";
            }
            else
            {
                if (useInvert)
                {
                    func += "    topPrev = (! topPrev);    // apply TOGGLE to prev group\n";
                }
            }
            func += "  //---- end of code for group ---- \n\n";
        }

        func += "\n  return topPrev;\n";
        func += "}\n";

        addDynamicScript(func);
    }

    //---- private: generateTest() ----
    var generateTest = function ()
    {
        newTestNeeded = false;

        var func = "function " + generatedTestName + "(data)\n";
        func += "{\n";

        func += "  var prev = false;\n";

        for (var i = 0; i < terms.length; i++)
        {
            var term = terms[i];
            func += generateTermEval(term.op, term.exp, "  ");
        }

        func += "\n  return prev;\n";
        func += "}\n";

        addDynamicScript(func);
    }

    var addDynamicScript = function(func)
    {
        //---- it seems we need to re-append it each time to make this work (overwrites last script?) ----
        if (funcHolder)
        {
            document.body.removeChild(funcHolder[0]);
        }

        funcHolder = vp.select(document.body).append("script")
            .text(func);
    }

    var generateTestNow = function ()
    {
        if (usesGroups)
        {
            generateSeriesTest();
        }
        else
        {
            generateTest();
        }
    }

    closure.termsAreEqual = function (terms1, terms2)
    {
        var diff = (terms1.length != terms2.length);
        if (!diff)
        {
            //---- compare each term ----
            for (var i = 0; i < terms1.length; i++)
            {
                var t1 = terms1[i];
                var t2 = terms2[i];

                if (vp.utils.isDefined(t1.terms))
                {
                    diff = vp.utils.isNotDefined(t2.terms);
                    if (!diff)
                    {
                        //---- comparing 2 GROUP terms ----
                        diff = (t1.invertResult != t2.invertResult);
                        if (!diff)
                        {
                            diff = (!closure.termsAreEqual(t1.terms, t2.terms));
                        }
                    }
                }
                else
                {
                    diff = vp.utils.isDefined(t2.terms);
                    if (!diff)
                    {
                        //---- comparing 2 SIMPLE terms ----
                        diff = (t1 != t2);
                    }
                }

                if (diff)
                {
                    break;
                }
            }
        }

        return diff;
    };

    //---- public: test(data) ----
    closure.test = function (data)
    {
        if (newTestNeeded)
        {
            generateTestNow();
        }

        var callExp = generatedTestName + "(data)"
        var isIn = eval(callExp);
        return isIn;
    };

    /// call should pass all series data items, one per param.
    /// expected to operate on term groups and reduce results to single T/F for each group.
    closure.testSeries = function (data1)
    {
        if (newTestNeeded)
        {
            generateTestNow();
        }

        var callExp = generatedTestName + "(data1)"
        var isIn = eval(callExp);
        return isIn;
    };

    var markNewTestNeeded = function()
    {
        newTestNeeded = true;
    }

    //---- public: orWith(exp) ----
    closure.orWith = function (exp)
    {
        var term = { op: "orWith", exp: exp };
        terms.push(term);
        markNewTestNeeded();

        return this;
    };

    //---- public: andWith(exp) ----
    closure.andWith = function (exp)
    {
        var term = { op: "andWith", exp: exp };
        terms.push(term);
        markNewTestNeeded();

        return this;
    };

    //---- public: invert() ----
    closure.invert = function ()
    {
        var addIt = true;

        //---- can we cancel the last INVERT cmd? ----
        if (terms.length > 0)
        {
            var lastIndex = terms.length - 1;
            if (terms[lastIndex].op == "invert")
            {
                terms.removeAt(lastIndex);
                addIt = false;
            }
        }

        if (addIt)
        {
            var term = { op: "invert", exp: null };
            terms.push(term);
        }

        markNewTestNeeded();

        return this;
    };

    //---- public: toggleTo(exp) ----
    closure.toggleTo = function (exp)
    {
        var term = { op: "toggleTo", exp: exp };
        terms.push(term);
        markNewTestNeeded();

        return this;
    };

    //---- public: boundsQuery(exp) ----
    closure.boundsQuery = function (exp)
    {
        var term = { op: "boundsQuery", exp: exp };
        terms.push(term);
        markNewTestNeeded();

        return this;
    };

    //---- public: andWithInvert(exp) ----
    closure.andWithInvert = function (exp)
    {
        var term = { op: "andWithInvert", exp: exp };
        terms.push(term);
        markNewTestNeeded();

        return this;
    };

    //---- add terms from another query as a group object with an associated "invert" flag.
    closure.addGroup = function (fromQuery, invertResult)
    {
        var groupTerms = [];
        usesGroups = true;
        var addIt = true;

        if (fromQuery)
        {
            var fromTerms = fromQuery.terms();
            for (var i = 0; i < fromTerms.length; i++)
            {
                //---- replace the shape test in "exp" with a data test ----
                var fromTerm = fromTerms[i];
                var newExp = (fromTerm.exp) ? fromTerm.exp.replace("vp.queryShapeTest(", "vp.queryDataTest(") : null;

                var term = {op: fromTerm.op, exp: newExp};
                groupTerms.push(term);
            }
        }
        else if (invertResult)
        {
            //---- this is an INVERT cmd (with no from terms) ----
            //---- can we cancel the last INVERT cmd? ----
            if (terms.length > 0)
            {
                var lastIndex = terms.length - 1;
                if ((terms[lastIndex].invert) && (terms[lastIndex].terms.length == 0))   
                {
                    terms.removeAt(lastIndex);
                    addIt = false;
                }
            }
        }

        if (addIt)
        {
            var groupObj = { terms: groupTerms, invert: invertResult };
            terms.push(groupObj);
        }

        markNewTestNeeded();

        return this;
    };

    /// public property: terms()
    closure.terms = function (value)
    {
        if (arguments.length == 0)
        {
            return terms;
        }

        terms = value;
        markNewTestNeeded();

        return this;
    };

    //---- init code ----

    return closure;
};


//---- this function called by generated code (to make generated code a bit simpler) ----
//---- used to query 1 or more data records ----
vp.queryDataTest = function (data, exp, dataId, shapeId)
{
    return (exp) && (data.dataId == dataId);
};

///---- used to query 1 or more shapes ----
vp.queryShapeTest = function (data, exp, dataId, shapeId)
{
    return (exp) && (data.dataId == dataId) && (data.shapeId == shapeId);
};

///---- used to query 1 or more shapes within a 2 value bounds ----
//----- keep this as hard-code function for easier debugging ----
vp.boundsQueryTest = function (data, exp)
{
    return (exp);
};
///-----------------------------------------------------------------------------------------------------------------
/// dataGrid.ts.  Copyright (c) 2012 Microsoft Corporation.
///    Part of the vuePlot library - creates an HTML-based dataGrid control.  The current implementation is readonly.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        /// signature: vp.visuals.createDataGrid()
        ///     summary: creates an HTML readonly data grid (table) for the specified data
        ///     snippet: _aray = [-5, 3, 0, 3];
        ///     snippet: _myGrid = vp.visuals.createDataGrid().data(aray);
        ///     returns: the newly created data grid parent element.
        /** Builds an HTML table that displays the rows & cols in "data".  returns the control that can be used
        to configure properties and hook events.  The root HTML element can be accessed thru "control.element()". */
        var dataGridClass = (function (_super) {
            __extends(dataGridClass, _super);
            function dataGridClass() {
                _super.call(this, null);
                this.ctr = "vp.visuals.dataGrid";
                //---- property variables ----
                this._showHdr = true;
                this._showAltLines = true;
                this._showDividers = true;
                this._boldFirstCol = false;
                this._isHeaderLocked = false;
                this._data = null;
                this._columnNames = null;
                this._buildNeeded = false;
                this._timer = null;
                this._dividerColor = "#ccc";
                this._headerRow = null;
                this._lockedHeaderRow = null;
                this._divTableHolder = null;
                this._fillCellCallback = null;
                // public method to rebuild the datagrid synchronously ----
                this.buildNow = function () {
                    this.build();
                };
                this.rootElement = function () {
                    //---- ensure element is ready when we give it to caller ----
                    if (this._buildNeeded) {
                        this.build();
                    }

                    return this._rootElement;
                };
                this.markRebuildNeeded = function () {
                    var _this = this;
                    if (!this._buildNeeded) {
                        this._buildNeeded = true;
                        this._timer = setTimeout(function (e) {
                            return _this.build();
                        }, 1);
                    }
                };
                //---- property: showHeader ----
                this.showHeader = function (value) {
                    if (value === undefined) {
                        return this._showHdr;
                    }

                    this._showHdr = value;
                    this.markRebuildNeeded();

                    return this;
                };
                //---- property: showAltLines ----
                this.showAltLines = function (value) {
                    if (value === undefined) {
                        return this._showAltLines;
                    }

                    this._showAltLines = value;
                    this.markRebuildNeeded();

                    return this;
                };
                //---- property: showDividers ----
                this.showDividers = function (value) {
                    if (value === undefined) {
                        return this._showDividers;
                    }

                    this._showDividers = value;
                    this.markRebuildNeeded();

                    return this;
                };
                //---- property: boldFirstColumn ----
                this.boldFirstColumn = function (value) {
                    if (value === undefined) {
                        return this._boldFirstCol;
                    }

                    this._boldFirstCol = value;
                    this.markRebuildNeeded();

                    return this;
                };
                //---- property: isHeaderLocked ----
                this.isHeaderLocked = function (value) {
                    if (value === undefined) {
                        return this._isHeaderLocked;
                    }

                    this._isHeaderLocked = value;
                    this.markRebuildNeeded();

                    return this;
                };
                //---- property: columnNames ----
                this.columnNames = function (value) {
                    if (value === undefined) {
                        return this._columnNames;
                    }

                    this._columnNames = value;
                    this.markRebuildNeeded();

                    return this;
                };
                //---- property: fillCellCallback ----
                this.fillCellCallback = function (value) {
                    if (value === undefined) {
                        return this._fillCellCallback;
                    }

                    this._fillCellCallback = value;
                    this.markRebuildNeeded();

                    return this;
                };
                /// internal.
                this.addDataGridCol = function (row, record, dataItem, showDividers, rowNum, colNum, boldFirstCol) {
                    var td = document.createElement("td");

                    row.appendChild(td);
                    vp.dom.setClass(td, "dataGridCell");

                    var doStyling = true;

                    if (this._fillCellCallback) {
                        var result = this._fillCellCallback(td, record, dataItem, rowNum, colNum, showDividers, boldFirstCol);
                        if (result !== undefined) {
                            doStyling = result;
                        }
                    } else {
                        td.textContent = dataItem.toString();
                    }

                    if (doStyling) {
                        if ((colNum == 0) && (boldFirstCol)) {
                            //vp.dom.css(td, "font-weight", "bold");
                            vp.dom.css(td, "color", "#808080");
                        } else {
                            //vp.dom.css(td, "color", "black");     // let styleSheet specify this
                        }

                        if (!showDividers) {
                            vp.dom.css(td, "border", "none");
                        } else {
                            vp.dom.css(td, "border", "1px solid " + this._dividerColor);
                        }

                        vp.dom.css(td, "padding-left", "4px");
                        vp.dom.css(td, "padding-right", "4px");
                    }
                };

                var rootElem = vp.dom.createHtml("div");
                this._rootElement = rootElem;
                this._root = vp.select(this._rootElement);

                rootElem.control = this;

                //element = rootElem;
                this.element(rootElem); // set wrapper root element
                //this.build();
                //this._rootElement.control = this;;
            }
            dataGridClass.prototype.build = function () {
                if (this._timer) {
                    clearTimeout(this._timer);
                    this._timer = null;
                }
                this._buildNeeded = false;

                this._root.clear();

                var table = this._root.append("table")[0];
                vp.dom.setClass(table, "dataGrid");

                if (!this._showDividers) {
                    vp.dom.css(table, "border", "none");
                    vp.dom.attr(table, "rules", "none");
                }

                if (this._data && this._data.length) {
                    var data = this._data;
                    var colNames = ["col1"];

                    for (var i = 0; i < data.length; i++) {
                        var row = document.createElement("tr");
                        table.appendChild(row);

                        if (!this._showDividers) {
                            vp.dom.css(row, "border", "none");
                        }

                        if ((!this._showAltLines) || (i % 2 == 0)) {
                            vp.dom.setClass(row, "dataGrid");
                        } else {
                            vp.dom.setClass(row, "dataGrid altRow");
                        }

                        var dataRow = data[i];

                        if (dataRow.length != null) {
                            for (var c = 0; c < dataRow.length; c++) {
                                this.addDataGridCol(row, dataRow, dataRow[c], this._showDividers, i, c, this._boldFirstCol);

                                if ((this._showHdr) && (i == 0)) {
                                    //---- build column names from first row ----
                                    colNames[c] = "col" + (c + 1);
                                }
                            }

                            var colCount = Math.max(colCount, dataRow.length);
                        } else if (vp.utils.isNumber(dataRow)) {
                            //---- single column ----
                            this.addDataGridCol(row, dataRow, dataRow, this._showDividers, i, 0, this._boldFirstCol);
                        } else {
                            var atCount = 0;

                            for (var atName in dataRow) {
                                this.addDataGridCol(row, dataRow, dataRow[atName], this._showDividers, i, atCount, this._boldFirstCol);

                                if ((this._showHdr) && (i == 0)) {
                                    //---- build column names from first row ----
                                    colNames[atCount] = atName;
                                }

                                atCount++;
                            }
                        }
                    }

                    //---- after all records processed (and all cols seen), add COL HEADERS ----
                    if (this._showHdr) {
                        this.buildHeader(colNames, table);
                    }
                }

                //table.setAttribute("cellspacing", 15);
                //table.setAttribute("cellpadding", 4);
                vp.dom.setClass(table, "dataGrid");
            };

            dataGridClass.prototype.buildHeader = function (colNames, table) {
                //---- create row to hold headers ----
                var headerRow = document.createElement("tr");
                var lockedHeaderRow = null;

                if (table.childNodes.length) {
                    table.insertBefore(headerRow, table.childNodes[0]);
                } else {
                    table.appendChild(headerRow);
                }

                if (this._columnNames) {
                    colNames = this._columnNames;
                }

                if (this._isHeaderLocked) {
                    //---- create a separate table for the headers so it doesn't scroll with the table ----
                    var headerOnlyTable = this._root.append("table")[0];
                    vp.dom.setClass(headerOnlyTable, "dataGridLockedHeader");

                    //this._root.css("background", "#f0f0f0")
                    //---- create a div to hold our main table ----
                    var divTableHolder = this._root.append("div").css("overflow-y", "scroll").css("display", "inline-block").css("width", "100%");

                    this._divTableHolder = divTableHolder;

                    divTableHolder.append(table);
                    vp.select(table).css("width", "100%");

                    //---- will need to create a 2nd header row ----
                    lockedHeaderRow = document.createElement("tr");
                    headerOnlyTable.appendChild(lockedHeaderRow);

                    //---- make headerRow collapsed so that it doesn't show (but still helps calc col widths) ----
                    vp.dom.css(headerRow, "visibility", "collapse");
                }

                for (var i = 0; i < colNames.length; i++) {
                    this.addHeaderCol(headerRow, colNames[i]);

                    if (lockedHeaderRow) {
                        this.addHeaderCol(lockedHeaderRow, colNames[i]);
                    }
                }

                if (this._isHeaderLocked) {
                    this.addHeaderCol(lockedHeaderRow, ""); // add filler column at end
                    vp.dom.css(headerOnlyTable, "width", "100%");

                    this._headerRow = headerRow;
                    this._lockedHeaderRow = lockedHeaderRow;

                    this.scheduleResize();
                    this.resizeHeaderColsAndTable();

                    //---- when we are resized, match columns sizes & table height ----
                    vp.events.attach(this.elem, "resize", vp.utils.cb(this, this.scheduleResize));
                }
            };

            dataGridClass.prototype.scheduleResize = function () {
                var _this = this;
                setTimeout(function (e) {
                    return _this.resizeHeaderColsAndTable();
                }, 1000);
            };

            dataGridClass.prototype.addHeaderCol = function (headerRow, colName) {
                var th = document.createElement("th");
                th.setAttribute("align", "left");

                if (!this._showDividers) {
                    vp.dom.css(th, "border", "none");
                } else {
                    vp.dom.css(th, "border", "1px solid " + this._dividerColor);
                }

                headerRow.appendChild(th);

                th.textContent = colName;
            };

            dataGridClass.prototype.resizeHeaderColsAndTable = function () {
                //---- use hdrRow to set column widths in lockedHeaderRow ----
                var hdrRow = vp.select(this._headerRow).kids();
                var lockedRow = vp.select(this._lockedHeaderRow).kids();

                for (var i = 0; i < hdrRow.length; i++) {
                    var w = vp.select(hdrRow[i]).width();
                    w = Math.max(0, w - 3); // adjust for padding, border
                    vp.select(lockedRow[i]).width(w);
                }

                //---- also, size divTableHolder" as table height ----
                var rootHeight = this._root.height();
                if (rootHeight > 0) {
                    var headerHeight = vp.dom.height(this._lockedHeaderRow);
                    var tableHeight = Math.max(0, rootHeight - headerHeight);

                    this._divTableHolder.height(tableHeight - 0);
                }
            };

            dataGridClass.prototype.data = function (value) {
                if (value === undefined) {
                    return this._data;
                }

                this._data = value;
                this.markRebuildNeeded();
                return this;
            };
            return dataGridClass;
        })(vp.dom.singleWrapperSuperClass);
        visuals.dataGridClass = dataGridClass;

        function createDataGrid() {
            return new dataGridClass();
        }
        visuals.createDataGrid = createDataGrid;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=dataGrid.js.map

///----------------------------------------------------------------
/// (from visuals\fastDataGrid.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// fastDataGrid.ts.  Copyright (c) 2012 Microsoft Corporation.
///    Part of the vuePlot library - creates a Canvas-based virtual dataGrid control.  The current implementation is readonly.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        /// signature: vp.visuals.createFastDataGrid()
        ///     summary: creates a Canvas-based virtual readonly data grid for the specified data
        ///     snippet: _aray = [-5, 3, 0, 3];
        ///     snippet: _myGrid = vp.visuals.createFastDataGrid().data(aray);
        ///     returns: the newly created data grid parent element.
        /** Builds a Canvas-based virtual data grid that displays the data found in a JSON array of records.  returns the control that can be used
        to configure properties and hook events.  The root HTML element can be accessed thru "control.element()". */
        var fastDataGridClass = (function (_super) {
            __extends(fastDataGridClass, _super);
            function fastDataGridClass() {
                var _this = this;
                _super.call(this, null);
                this.ctr = "vp.visuals.fastDataGrid";
                //---- property variables ----
                this._showHeader = true;
                this._showAltLines = true;
                this._showColDividers = true;
                this._showRowDividers = true;
                this._boldFirstCol = false;
                this._useMaxColWidths = false;
                this._maxColWidth = undefined;
                this._data = null;
                //---- other variables ----
                this._buildNeeded = false;
                this._timer = null;
                this._textHeight = 0;
                this._charWidth = 0;
                this._topRow = -1;
                this._numRowsVisible = 0;
                this._canvasWidth = 0;
                this._canvasHeight = 0;
                this._divWidth = 0;
                this._buildTimer = null;
                this._ignoreScrollBarChanges = false;
                this._padding = 2;
                this._drawTimer = null;
                this._usingVerticalScroll = false;
                this.rootElement = function () {
                    //---- ensure element is ready when we give it to caller ----
                    //if (this._buildNeeded)
                    //{
                    //    this.build();
                    //}
                    return this._rootElement;
                };
                //---- property: showHdr ----
                this.showHeader = function (value) {
                    if (value === undefined) {
                        return this._showHeader;
                    }

                    this._showHeader = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: showAltLines ----
                this.showAltLines = function (value) {
                    if (value === undefined) {
                        return this._showAltLines;
                    }

                    this._showAltLines = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: showColDividers ----
                this.showColumnDividers = function (value) {
                    if (value === undefined) {
                        return this._showColDividers;
                    }

                    this._showColDividers = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: showRowDividers ----
                this.showRowDividers = function (value) {
                    if (value === undefined) {
                        return this._showRowDividers;
                    }

                    this._showRowDividers = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: boldFirstCol ----
                this.boldFirstColumn = function (value) {
                    if (value === undefined) {
                        return this._boldFirstCol;
                    }

                    this._boldFirstCol = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: useMaxColWidths ----
                this.useMaxColumnWidths = function (value) {
                    if (value === undefined) {
                        return this._useMaxColWidths;
                    }

                    this._useMaxColWidths = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: maxColWidth ----
                this.maxColumnWidth = function (value) {
                    if (value === undefined) {
                        return this._maxColWidth;
                    }

                    this._maxColWidth = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: colInfo ----
                this.columnInfo = function (value) {
                    if (value === undefined) {
                        return this._colInfo;
                    }

                    this._colInfo = value;
                    this.markBuildNeeded();

                    return this;
                };

                //---- create CONTROLS ----
                var rootElem = vp.dom.createHtml("div");
                this._rootElement = rootElem;

                var foo = this._root = vp.select(this._rootElement).setClass("dataGrid").css("position", "absolute");

                rootElem.control = this;
                this.element(rootElem); // set wrapper root element

                var canvasDiv = vp.dom.createHtml("div");
                this._canvasDiv = canvasDiv;
                rootElem.appendChild(canvasDiv);

                var canvas = vp.dom.createHtml("canvas");
                this._canvas = canvas;
                canvasDiv.appendChild(canvas);

                vp.select(canvasDiv).css("position", "absolute");

                this._ctx = canvas.getContext("2d");

                var scrollBar = vp.visuals.verticalScrollBar();
                rootElem.appendChild(scrollBar);
                this._scrollBar = vp.select(scrollBar).css("position", "absolute").css("display", "none");

                this._scrollBar.attach("change", function (e) {
                    return _this.onScrollChange();
                });

                vp.events.attach(rootElem, "resize", function (e) {
                    return _this.markBuildNeeded();
                });

                //---- get initial size, etc. ----
                this.markBuildNeeded();
            }
            fastDataGridClass.prototype.onScrollChange = function () {
                if (!this._ignoreScrollBarChanges) {
                    var value = this._scrollBar.value();
                    this.setTopRow(value);
                }
            };

            fastDataGridClass.prototype.markBuildNeeded = function () {
                var _this = this;
                if (this._buildTimer) {
                    clearTimeout(this._buildTimer);
                }

                this._buildTimer = setTimeout(function (e) {
                    return _this.build();
                }, 25);
            };

            fastDataGridClass.prototype.computeX = function (left, right, spacing, align) {
                var x = left + spacing;

                if (align == "center") {
                    x = (right + left) / 2;
                } else if (align == "right") {
                    x = right - spacing;
                }

                return x;
            };

            fastDataGridClass.prototype.drawGridRow = function (ctx, maxRight, y, isOdd, record) {
                var colInfo = this._colInfo;
                var left = 2;
                var padding = this._padding;
                var textHeight = this._textHeight;

                //---- read relevent attributes from current theme ----
                var daHdrRow = vp.session.currentTheme().getDrawingAttributes("fastDataGrid.hdrRow");
                var daDataRow = vp.session.currentTheme().getDrawingAttributes("fastDataGrid.dataRow");
                var daAltRow = vp.session.currentTheme().getDrawingAttributes("fastDataGrid.altRow");
                var daDivider = vp.session.currentTheme().getDrawingAttributes("fastDataGrid.divider");

                var hdrFont = daHdrRow.font;
                var dataFont = daDataRow.font;
                var altFont = daAltRow.font;

                ctx.font = (record) ? dataFont : hdrFont;
                ctx.fillStyle = (record) ? daDataRow.fill : daHdrRow.fill;

                //---- draw alt background color, if odd ----
                if (this._showAltLines) {
                    if (isOdd) {
                        //---- alt row background ----
                        ctx.save();
                        ctx.fillStyle = daAltRow.background;
                        ctx.fillRect(0, y - textHeight + .5, this._canvasWidth, textHeight - 1);
                        ctx.restore();

                        ctx.fillStyle = daAltRow.fill;
                        ctx.font = altFont;
                    } else if (!record) {
                        //---- hdr background ----
                        ctx.save();
                        ctx.fillStyle = daHdrRow.background;
                        ctx.fillRect(0, y - textHeight - .5, this._canvasWidth, textHeight + 1);
                        ctx.restore();
                    }
                }

                for (var k = 0; k < colInfo.length; k++) {
                    if (this._boldFirstCol && record) {
                        if (k == 0) {
                            ctx.font = daDataRow.boldFont;
                        } else if (k == 1) {
                            ctx.font = dataFont;
                        }
                    }

                    var ci = colInfo[k];

                    //---- note: ci.actualWidth includes padding and border ----
                    var right = Math.min(maxRight, left + ci.actualWidth - 2 * padding - 1);

                    //---- clip text so that it doesn't spill over into padding or next field ----
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(left, y - textHeight, ci.actualWidth, textHeight); //  right - left, textHeight);
                    ctx.clip();

                    if (record) {
                        //---- drawing data row ----
                        ctx.textAlign = ci.dataAlign;
                        var x = this.computeX(left, right, padding, ctx.textAlign);
                        var value = record[ci.dataName];
                        ctx.fillText(value, x, y);
                    } else {
                        //---- drawing hdr row ----
                        ctx.textAlign = ci.hdrAlign;
                        var x = this.computeX(left, right, padding, ctx.textAlign);
                        ctx.fillText(ci.hdrName, x, y);
                    }

                    ctx.restore();
                    left = (right + 1 + 2 * padding);
                }

                if (this._showRowDividers) {
                    //---- draw bottom line ----
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(this._canvasWidth, y);
                    ctx.strokeStyle = daDivider.stroke; // "#a0a0a0";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            };

            fastDataGridClass.prototype.draw = function () {
                if (this._drawTimer) {
                    //cancelAnimationFrame(this._drawTimer);
                    this._drawTimer = null;
                }

                //---- clear the canvas ----
                var ctx = this._ctx;
                var data = this._data;

                //---- clear client area using color of data row background ----
                var daDataRow = vp.session.currentTheme().getDrawingAttributes("fastDataGrid.dataRow");
                ctx.fillStyle = daDataRow.background;
                ctx.fillRect(0, 0, this._canvasWidth, this._canvasHeight);

                ctx.textBaseline = "bottom";

                var clientWidth = this._canvasWidth;
                var padding = this._padding;
                var maxRight = clientWidth - padding;
                var colInfo = this._colInfo;

                if (this._colInfo && data && data.length) {
                    var y = .5;

                    if (this._showHeader) {
                        y += this._textHeight;
                        this.drawGridRow(ctx, maxRight, y, false, null);
                    }

                    //---- draw rows ----
                    ctx.fillStyle = "gray";
                    var isOdd = true;

                    for (var r = 0; r < this._numRowsVisible; r++) {
                        var index = this._topRow + r;
                        if (index >= data.length) {
                            //---- past last record ----
                        } else {
                            y += this._textHeight;
                            this.drawGridRow(ctx, maxRight, y, isOdd, data[index]);
                        }

                        isOdd = (!isOdd);
                    }

                    if (this._showColDividers) {
                        var x = 0;
                        var daDivider = vp.session.currentTheme().getDrawingAttributes("fastDataGrid.divider");

                        for (var k = 0; k < colInfo.length; k++) {
                            //---- don't draw right-most border if there is no vertical scrollbar ----
                            if ((!this._usingVerticalScroll) && (k == colInfo.length - 1)) {
                                break;
                            }

                            //---- draw right border ----
                            var ci = colInfo[k];

                            //---- note: ci.actualWidth includes padding & border space ----
                            x += ci.actualWidth;

                            ctx.beginPath();
                            ctx.moveTo(x, 0);
                            ctx.lineTo(x, this._canvasHeight);
                            ctx.strokeStyle = daDivider.stroke; // "#a0a0a0";
                            ctx.stroke();
                        }
                    }
                }
            };

            fastDataGridClass.prototype.layoutControls = function (canvasWidth, omitCalcCols) {
                var w = this._root.width();
                var h = this._root.height();

                var usingVerticalScroll = (this._data && this._data.length > this._numRowsVisible);

                var sw = (usingVerticalScroll) ? 20 : 5;
                var divWidth = Math.max(0, w - sw);
                var canvasDiv = vp.select(this._canvasDiv);

                if (canvasWidth === undefined) {
                    canvasWidth = divWidth;
                }

                if (canvasWidth > divWidth) {
                    canvasDiv.css("overflow-x", "scroll").css("overflow-y", "hidden");
                } else {
                    canvasDiv.css("overflow-x", "hidden").css("overflow-y", "hidden");
                }

                //---- layout CANVAS ----
                vp.select(this._canvas).attr("width", canvasWidth).attr("height", h);

                //---- layout CANVAS DIV ----
                var foo = vp.select(this._canvasDiv).css("width", divWidth + "px").css("height", h);

                //---- layout vertical SCROLLBAR ----
                if (usingVerticalScroll) {
                    this._scrollBar.bounds(divWidth, 0, sw, h).css("display", "inline-block");
                } else {
                    this._scrollBar.css("display", "none");
                }

                this._usingVerticalScroll = usingVerticalScroll;

                this._canvasWidth = canvasWidth;
                this._divWidth = divWidth;
                this._canvasHeight = h;

                if (!omitCalcCols) {
                    this.calcColumnWidths(divWidth);
                }
            };

            /** Called primarily after RESIZE of dataGrid control has occured. */
            fastDataGridClass.prototype.build = function () {
                this._buildTimer = null;
                var h = this._root.height();

                //---- calc number of rows visible in canvas ----
                var sz = vp.utils.measureText("W", "fastDataGrid");
                var height = Math.ceil(sz.height);
                this._textHeight = height;

                //---- get max accuracy for char width ----
                this._charWidth = this._ctx.measureText("W").width;
                this._charWidth *= 1.05; // add 5% to get better results  (measureText() doesn't seem to be totally accurate)

                this._numRowsVisible = Math.floor(h / height);
                if (this._showHeader) {
                    this._numRowsVisible--;
                }

                this.layoutControls();

                this.configScrollbar();

                this.markDrawNeeded();
            };

            fastDataGridClass.prototype.markDrawNeeded = function () {
                var _this = this;
                if (!this._drawTimer) {
                    //this._drawTimer = vp.requestAnimationFrame((e) => this.draw());
                    this._drawTimer = setTimeout(function (e) {
                        return _this.draw();
                    }, 125);
                }
            };

            fastDataGridClass.prototype.configScrollbar = function () {
                var data = this._data;
                if (data && data.length) {
                    var count = data.length;
                    var lastTopRecord = Math.max(0, count - this._numRowsVisible);

                    //---- set up scrollbar ----
                    this._scrollBar.min(0).max(lastTopRecord).value(0).smallChange(1).largeChange(Math.max(1, this._numRowsVisible));
                }
            };

            fastDataGridClass.prototype.onNewData = function () {
                this.configScrollbar();

                this._colInfo = null;

                this.setUpColInfo();

                this.setTopRow(0);
            };

            fastDataGridClass.prototype.setTopRow = function (value) {
                this._topRow = value;
                this._ignoreScrollBarChanges = true;

                this._scrollBar.value(value);

                this._ignoreScrollBarChanges = false;

                this.markDrawNeeded();
            };

            fastDataGridClass.prototype.setUpColInfo = function () {
                var colInfo = this._colInfo;
                var data = this._data;
                var clientWidth = this._root.width();

                if (data && data.length) {
                    if (!colInfo) {
                        colInfo = [];

                        //---- build default column info ----
                        var firstRec = data[0];
                        var keys = vp.utils.keys(firstRec);

                        for (var k = 0; k < keys.length; k++) {
                            var key = keys[k];

                            var col = {
                                hdrName: key, dataName: key, hdrAlign: "left", dataAlign: "left", requestedWidth: undefined, actualWidth: undefined
                            };
                            colInfo[k] = col;
                        }

                        this._colInfo = colInfo;
                    }

                    this.calcColumnWidths(clientWidth);
                }
            };

            /** calc the largest string for hdr/data rows of col "index". */
            fastDataGridClass.prototype.getMaxColWidth = function (index) {
                var maxLen = 0;
                var data = this._data;

                if (this._colInfo) {
                    maxLen = this._colInfo[index].hdrName.length;
                    var colName = this._colInfo[index].dataName;

                    if (data && data.length) {
                        for (var i = 0; i < data.length; i++) {
                            var record = data[i];
                            var len = (record[colName] + "").length;
                            if (len > maxLen) {
                                maxLen = len;
                            }
                        }
                    }
                }

                var width = 1 + 2 * this._padding + (maxLen * this._charWidth);
                vp.utils.debug("getMaxColWidth: maxLen=" + maxLen + ", width=" + width);

                return width;
            };

            fastDataGridClass.prototype.calcColumnWidths = function (clientWidth) {
                var colInfo = this._colInfo;
                if (colInfo && colInfo.length) {
                    var cw = clientWidth / colInfo.length;
                    var cwTotal = 0;

                    for (var k = 0; k < colInfo.length; k++) {
                        if (colInfo[k].requestedWidth === undefined) {
                            if (this._useMaxColWidths) {
                                cw = this.getMaxColWidth(k);
                            }
                        } else {
                            cw = colInfo[k].requestedWidth;
                        }

                        if ((this._maxColWidth !== undefined) && (cw > this._maxColWidth)) {
                            cw = this._maxColWidth;
                        }

                        colInfo[k].actualWidth = cw;
                        cwTotal += cw;
                    }

                    var availWidth = this._divWidth;

                    if ((this._useMaxColWidths) && (cwTotal < availWidth)) {
                        var delta = (availWidth - cwTotal);
                        var perCol = delta / colInfo.length;

                        for (var k = 0; k < colInfo.length; k++) {
                            colInfo[k].actualWidth += perCol;
                        }

                        cwTotal += delta;
                    }

                    cwTotal = Math.max(this._canvasWidth, cwTotal);

                    //---- make canvas wider than original, if needed ----
                    this.layoutControls(cwTotal, true);
                }
            };

            fastDataGridClass.prototype.data = function (value) {
                if (value === undefined) {
                    return this._data;
                }

                this._data = value;
                this.onNewData();

                return this;
            };
            return fastDataGridClass;
        })(vp.dom.singleWrapperSuperClass);
        visuals.fastDataGridClass = fastDataGridClass;

        function createFastDataGrid() {
            return new fastDataGridClass();
        }
        visuals.createFastDataGrid = createFastDataGrid;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=fastDataGrid.js.map

///----------------------------------------------------------------
/// (from visuals\gridContainer.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// gridContainer.ts.  Copyright (c) 2014 Microsoft Corporation.
///     - part of the VuePlot library.
///     - a visual control that contains HTML and SVG elements and lays them out in a fixed M x N grid
///-----------------------------------------------------------------------------------------------------------------
/// testing: see gridContainer.html
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        var gridContainerClass = (function (_super) {
            __extends(gridContainerClass, _super);
            function gridContainerClass(rootElem) {
                _super.call(this, rootElem);
                this.ctr = "vp.visuals.gridContainer";
                //---- private state ----
                this._layout = null;
                this._timer = null;
                this._colCount = undefined;
                this._rowCount = undefined;
                this._cellMargin = undefined;

                if (!rootElem) {
                    rootElem = vp.dom.createHtml("div");
                }

                this._rootElement = rootElem;

                //this.elem = rootElem;
                //this[0] = rootElem;
                this.element(rootElem); // set wrapper root element

                rootElem.control = this;
                this._root = vp.select(rootElem);

                //---- init code ----
                this.initialBuild();
            }
            gridContainerClass.prototype.layout = function () {
                //vp.utils.debug("gridContainer.layout: width=" + root.width() + ", height=" + root.height());
                if (this._timer) {
                    clearTimeout(this._timer);
                    this._timer = null;
                }

                var kids = this._root.kids();
                var width = this._root.width();
                var height = this._root.height();

                var cm = this._cellMargin;
                if (cm === undefined) {
                    cm = [0, 0, 0, 0];
                } else if (vp.utils.isNumber(cm)) {
                    cm = [cm, cm, cm, cm];
                }

                var gridLayout = vp.layouts.createGrid().width(width).height(height).count(kids.length);

                gridLayout.colCount(this._colCount).rowCount(this._rowCount);

                //---- layout children ----
                kids.each(function (index, unwrappedElem) {
                    //---- temp: wrap until all callbacks pass elems as wrapped ----
                    var elem = (unwrappedElem.length) ? unwrappedElem : vp.select(unwrappedElem);

                    var sizes = elem.elementSizes();

                    var borderWidth = sizes.borderWidth;
                    var borderHeight = sizes.borderHeight;

                    var paddingWidth = sizes.paddingWidth;
                    var paddingHeight = sizes.paddingHeight;

                    var marginWidth = sizes.marginWidth;
                    var marginHeight = sizes.marginHeight;

                    //---- HTML is confusing here: ----
                    //---- RETURNED size includes padding but NOT border ----
                    var elemWidth = sizes.width;
                    var elemHeight = sizes.height;

                    //---- get BOUNDS from layout for this item (by index) ----
                    var bounds = gridLayout.getBoundsByIndex(index);

                    //---- set BOUNDS ----
                    //---- SETTING size does not include padding or border ----
                    var x = bounds.x + cm[0];
                    var y = bounds.y + cm[1];
                    var w = (bounds.width - paddingWidth - borderWidth - marginWidth) - (cm[0] + cm[2]);
                    var h = (bounds.height - paddingHeight - borderHeight - marginHeight) - (cm[1] + cm[3]);

                    elem.absPosition(x, y).width(w).height(h);
                });
            };

            gridContainerClass.prototype.initialBuild = function () {
                var _this = this;
                this._root.setClass("gridContainer").css("position", "relative").attach("resize", function (e) {
                    _this.markLayoutNeeded();
                }).attach("DOMNodeInserted", function (e) {
                    _this.nodeAddOrDelete(e);
                }).attach("DOMNodeRemoved", function (e) {
                    _this.nodeAddOrDelete(e);
                });

                this.markLayoutNeeded();
            };

            gridContainerClass.prototype.nodeAddOrDelete = function (e) {
                if (e.relatedNode == this._rootElement) {
                    this.markLayoutNeeded();
                }
            };

            gridContainerClass.prototype.markLayoutNeeded = function () {
                //vp.utils.debug("gridContainer.markLayoutNeeded");
                var _this = this;
                if (!this._timer) {
                    this._timer = setTimeout(function (e) {
                        _this.layout();
                    }, 1);
                }
            };

            gridContainerClass.prototype.colCount = function (value) {
                if (arguments.length === 0) {
                    return this._colCount;
                } else {
                    this._colCount = value;
                    return this;
                }
            };

            gridContainerClass.prototype.rowCount = function (value) {
                if (arguments.length === 0) {
                    return this._rowCount;
                } else {
                    this._rowCount = value;
                    return this;
                }
            };

            gridContainerClass.prototype.cellMargin = function (value) {
                if (arguments.length === 0) {
                    return this._cellMargin;
                } else {
                    this._cellMargin = value;
                    return this;
                }
            };
            return gridContainerClass;
        })(vp.dom.singleWrapperSuperClass);
        visuals.gridContainerClass = gridContainerClass;

        /** returns a grid container object that can host multiple controls in a N x M container of grid cells. */
        function createGridContainer(rootElem) {
            return new gridContainerClass(rootElem);
        }
        visuals.createGridContainer = createGridContainer;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=gridContainer.js.map

///----------------------------------------------------------------
/// (from visuals\plot.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// plot.ts.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - this implements a standard chart, with support for this._title, legend, axes, and ribbon.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        //declare var vpx: any;
        var nextPlotId = 1;

        /** implements a standard chart, with support for this._title, legend, axes, and ribbon. */
        var plotClass = (function (_super) {
            __extends(plotClass, _super);
            function plotClass() {
                _super.call(this, null);
                this.ctr = "vp.visuals.plotClass";
                //---- private state (from vvPlot) ----
                this._layers = [];
                //---- plot-only property variables ----
                this._plotId = nextPlotId++;
                this._isAnimEnabled = true;
                this._animDuration = 700;
                this._isUiEnabled = true;
                this._isHoverEnabled = true;
                this._isSelectionEnabled = true;
                this._isTooltipEnabled = true;
                this._isXAxisVisible = true;
                this._isXGridVisible = true;
                this._isYAxisVisible = true;
                this._isYGridVisible = true;
                this._isTitleVisible = true;
                this._isAxisBoxVisible = true;
                this._xLabelFit = undefined;
                this._onError = undefined;
                this._gridLineType = 1;
                this._showBoxTicks = false;
                this._drawTicksOnInside = false;
                //_toolTipFormatter = undefined;        // for now, use the layer.toolTipFormatter()
                this._isLegendVisible = undefined;
                this._isLegendBoxVisible = false;
                this._useLayersForLegend = false;
                this._legendLabels = [];
                this._shapesEnterFromBottom = null;
                this._showRibbon = false;
                this._title = "";
                this._xLimit = undefined;
                this._yLimit = undefined;
                //_xLabel = undefined;      // moved to attribute as "title" property
                //_yLabel = undefined;
                this._titleSize = 14;
                this._ribbonBar = null;
                this._frameMargins = null;
                this._selectCallback = null;
                this._rebuildCallback = null;
                this._tooltip = null;
                this._chartFrame = null;
                this._plotShapes = null;
                this._useStdTooltips = true;
                this._rcShapes = null;
                this._htmlShapesGroup = null;
                this._postCreateCallback = null;
                this._hoverCallback = null;
                //---- should these properties be in vvMappings? ----
                //_toolTipCols = true;             // defaults to "all columns"
                this._nextDataId = 3;
                this._rootElement = null;
                this._rootDiv = null;
                this._svgDoc = null;
                //---- these variables hold the parts of the chart we have built ----
                this._chartFrameGroup = null;
                this._shapesGroup = null;
                this._tooltipDiv = null;
                //---- removed use of "_spacesDoc" as of 8/7/2013.  at the time, thought it was causing mouse event ----
                //---- problems (but it was not).  Left it out since it complicates things (design, debugging) ----
                //---- Note: we now do clipping using "clip-path". ----
                //_shapesDoc = null;                 // nested SVG document (wrapped, parent: this._svgDoc)
                this._uiStateMgr = null;
                this._chartType = undefined;
                this._xScale = null;
                this._yScale = null;
                this._timer = null;
                this._xMin = 0;
                this._xMax = 0;
                this._yMin = 0;
                this._yMax = 0;

                var rootElem = vp.dom.createHtml("div");
                this._rootElement = rootElem;
                this._rootDiv = vp.select(rootElem);

                //---- keep invisible for a while to prevent flashing of wrong size ----
                //this._rootDiv
                //    .css("opacity", 0)
                rootElem.control = this;

                //element = rootElem;
                this.element(rootElem); // set wrapper root element

                this.initialBuild();
            }
            //---- property: rootElement ----
            plotClass.prototype.rootElement = function () {
                return this._rootElement;
            };

            plotClass.prototype.getNextDataId = function () {
                var id = this._nextDataId;
                this._nextDataId++;

                return id;
            };

            plotClass.prototype.clearLayers = function () {
                this._uiStateMgr.plotShapes([]);
                this._layers = [];

                //---- this is the only time is OK to directly clear the shapesGroup ----
                this._shapesGroup.clear();

                if (this._rcShapes) {
                    this.addOrUpdateClipPath(this._shapesGroup, this._rcShapes.width, this._rcShapes.height);
                }

                this.markRebuildNeeded();
            };

            plotClass.prototype.append = function (strOrLayer) {
                return this.appendLayer(strOrLayer);
            };

            plotClass.prototype.appendLayer = function (strOrLayer) {
                var layer = null;

                if ((strOrLayer) && (strOrLayer.ctr) && (strOrLayer.ctr.startsWith("vp.layers"))) {
                    layer = strOrLayer;

                    layer.vvParent(this);

                    //---- append an existing layer object ----
                    this._layers.push(layer);
                    //layer.onPlotDataChanged(true);
                } else {
                    //---- obsolete?  rfernand, 06/21/2014 ----
                    //if (strOrLayer.startsWith("layer"))
                    //{
                    //    var layerType = strOrLayer.substr(4).toLowerCase();
                    //    layer = vp.vvLayer();
                    //    this._layers.push(layer);
                    //    layer.layerType(layerType);
                    //    layer.vvParent(this);
                    //}
                    //else if (strOrLayer.startsWith("stat"))
                    //{
                    //    var statType = strOrLayer.substr(4).toLowerCase();
                    //    layer = vp.vvLayer();
                    //    this._layers.push(layer);
                    //    layer.statType(statType);
                    //    layer.vvParent(this);
                    //}
                    if (layer) {
                        //layer.onPlotDataChanged(true);
                    }
                }

                this.onAnimationOrLayersChanged();
                this.markRebuildNeeded();

                return layer;
            };

            plotClass.prototype.removeLayer = function (layer) {
                this._layers.remove(layer);

                //---- remove each shape drawn by this layer (from this._shapesGroup and from this._uiStateMgr) ----
                if (layer._drawnShapes) {
                    var shapes = layer._drawnShapes;
                    this._plotShapes = this._uiStateMgr.plotShapes().toArray();

                    for (var i = 0; i < shapes.length; i++) {
                        var shape = shapes[i];
                        vp.dom.remove(shape); // remove it from this._shapesGroup

                        this._plotShapes.remove(shape);
                    }

                    var ps = vp.dom.wrapElements(this._plotShapes);
                    this._uiStateMgr.plotShapes(ps);
                }

                layer.vvParent(null);

                this.markRebuildNeeded();
            };

            plotClass.prototype.layers = function () {
                return this._layers;
            };

            //---- property: this._showRibbon ----
            plotClass.prototype.showRibbon = function (value) {
                if (arguments.length == 0) {
                    return this._showRibbon;
                }

                this._showRibbon = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: shapesEnterFromBottom ----
            plotClass.prototype.shapesEnterFromBottom = function (value) {
                if (arguments.length == 0) {
                    return this._shapesEnterFromBottom;
                }

                if (this._shapesEnterFromBottom != value) {
                    this._shapesEnterFromBottom = value;
                    //---- don't rebuild just to see enter effect a different way ----
                    //this.markRebuildNeeded();
                }

                return this;
            };

            plotClass.prototype.title = function (value) {
                if (arguments.length == 0) {
                    return this._title;
                }

                this._title = value;
                this.markRebuildNeeded();

                return this;
            };

            plotClass.prototype.isAnimEnabled = function (value) {
                vp.utils.argCheck(arguments, "isAnimEnabled", 0, 1, ['bool']);

                if (arguments.length == 0) {
                    return this._isAnimEnabled;
                }

                this._isAnimEnabled = value;
                this.onAnimationOrLayersChanged();

                return this;
            };

            plotClass.prototype.animDuration = function (value) {
                vp.utils.argCheck(arguments, "animDuration", 0, 1, ['number']);

                if (arguments.length == 0) {
                    return this._animDuration;
                }

                this._animDuration = value;
                this.onAnimationOrLayersChanged();

                return this;
            };

            plotClass.prototype.onAnimationOrLayersChanged = function () {
                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];
                    layer.isAnimEnabled(this._isAnimEnabled);
                    layer.animDuration(this._animDuration);
                }
            };

            plotClass.prototype.onToolTipsChanged = function () {
                if (this._tooltip) {
                    var enabled = ((this._isTooltipEnabled) && (!this._useStdTooltips));
                    this._tooltip.isEnabled(enabled);
                }
            };

            //---- property: this._useStdTooltips ----
            plotClass.prototype.useStdTooltips = function (value) {
                if (arguments.length == 0) {
                    return this._useStdTooltips;
                }

                this._useStdTooltips = value;
                this.onToolTipsChanged();

                return this;
            };

            //---- property: this._postCreateCallback ----
            plotClass.prototype.postCreateCallback = function (value) {
                if (arguments.length == 0) {
                    return this._postCreateCallback;
                }

                this._postCreateCallback = value;

                return this;
            };

            //---- property: this._uiStateMgr ----
            plotClass.prototype.uiStateMgr = function (value) {
                return this._uiStateMgr;
            };

            //---- property: this._isUiEnabled ----
            plotClass.prototype.isUiEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isUiEnabled;
                }

                this._isUiEnabled = value;
                if (this._uiStateMgr) {
                    this._uiStateMgr.isUiEnabled(value);
                }

                this.markRebuildNeeded();

                return this;
            };

            //---- property: onError ----
            /** optional callback to record errors and return corrected values, when applicable. */
            plotClass.prototype.onError = function (value) {
                if (arguments.length == 0) {
                    return this._onError;
                }

                this._onError = value;
                return this;
            };

            //---- property: this._isHoverEnabled ----
            plotClass.prototype.isHoverEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isHoverEnabled;
                }

                this._isHoverEnabled = value;
                return this;
            };

            //---- property: this._isSelectionEnabled ----
            plotClass.prototype.isSelectionEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isSelectionEnabled;
                }

                this._isSelectionEnabled = value;
                if (this._uiStateMgr) {
                    this._uiStateMgr.isSelectionEnabled(value);
                }

                return this;
            };

            //---- property: this._isTooltipEnabled ----
            plotClass.prototype.isTooltipEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isTooltipEnabled;
                }

                this._isTooltipEnabled = value;
                this.onToolTipsChanged();

                return this;
            };

            //---- property: this._xLimit ----
            plotClass.prototype.xLimit = function (value) {
                if (arguments.length == 0) {
                    return this._xLimit;
                }

                if (arguments.length > 1) {
                    this._xLimit = vp.utils.argumentsAsArray(arguments);
                } else {
                    this._xLimit = value;
                }

                this.markRebuildNeeded();

                return this;
            };

            //---- property: this._yLimit ----
            plotClass.prototype.yLimit = function (value) {
                if (arguments.length == 0) {
                    return this._yLimit;
                }

                if (arguments.length > 1) {
                    this._yLimit = vp.utils.argumentsAsArray(arguments);
                } else {
                    this._yLimit = value;
                }

                this.markRebuildNeeded();

                return this;
            };

            ////---- property: this._xLabel ----
            //xLabel(value?: string)
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._xLabel;
            //    }
            //    this._xLabel = value;
            //    this.markRebuildNeeded();
            //    return this;
            //}
            ////---- property: this._yLabel ----
            //yLabel(value?: string)
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._yLabel;
            //    }
            //    this._yLabel = value;
            //    this.markRebuildNeeded();
            //    return this;
            //}
            //---- property: this._isXAxisVisible ----
            plotClass.prototype.isXAxisVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isXAxisVisible;
                }

                this._isXAxisVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: this._isYAxisVisible ----
            plotClass.prototype.isYAxisVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isYAxisVisible;
                }

                this._isYAxisVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: gridLineType ----
            plotClass.prototype.gridLineType = function (value) {
                if (arguments.length == 0) {
                    return this._gridLineType;
                }

                this._gridLineType = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: isXGridVisible ----
            plotClass.prototype.isXGridVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isXGridVisible;
                }

                this._isXGridVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: isYGridVisible ----
            plotClass.prototype.isYGridVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isYGridVisible;
                }

                this._isYGridVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: this._isTitleVisible ----
            plotClass.prototype.isTitleVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isTitleVisible;
                }

                this._isTitleVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            ////---- property: toolTipFormatter ----
            //toolTipFormatter(value?: boolean): any
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._toolTipFormatter;
            //    }
            //    this._toolTipFormatter = value;
            //    this.markRebuildNeeded();
            //    return this;
            //}
            //---- property: drawTicksOnInside ----
            plotClass.prototype.drawTicksOnInside = function (value) {
                if (arguments.length == 0) {
                    return this._drawTicksOnInside;
                }

                this._drawTicksOnInside = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: showBoxTicks ----
            plotClass.prototype.showBoxTicks = function (value) {
                if (arguments.length == 0) {
                    return this._showBoxTicks;
                }

                this._showBoxTicks = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: isAxisBoxVisible ----
            plotClass.prototype.isAxisBoxVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isAxisBoxVisible;
                }

                this._isAxisBoxVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: isLegendVisible ----
            plotClass.prototype.isLegendVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isLegendVisible;
                }

                this._isLegendVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: isLegendBoxVisible ----
            plotClass.prototype.isLegendBoxVisible = function (value) {
                if (arguments.length == 0) {
                    return this._isLegendBoxVisible;
                }

                this._isLegendBoxVisible = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: useLayersForLegend ----
            plotClass.prototype.useLayersForLegend = function (value) {
                if (arguments.length == 0) {
                    return this._useLayersForLegend;
                }

                this._useLayersForLegend = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: legendLabels ----
            plotClass.prototype.legendLabels = function (value) {
                if (arguments.length == 0) {
                    return this._legendLabels;
                }

                this._legendLabels = value;
                this.markRebuildNeeded();

                return this;
            };

            //---- property: this.xLabelFit ----
            plotClass.prototype.xLabelFit = function (value) {
                if (arguments.length == 0) {
                    return this._xLabelFit;
                }

                this._xLabelFit = value;
                this.markRebuildNeeded();

                return this;
            };

            /// public: this._titleSize.
            plotClass.prototype.titleSize = function (value) {
                if (arguments.length == 0) {
                    return this._titleSize;
                }

                this._titleSize = value;
                this.markRebuildNeeded();

                return this;
            };

            //shapeRoot(value)
            //{
            //    if (arguments.length == 0)
            //    {
            //        return shapeRoot;
            //    }
            //    shapeRoot = value;
            //    return this;
            //}
            /// private.
            plotClass.prototype.onShareNameChanged = function () {
                var shareName = vp.select("#tbShareName").value();
                this._uiStateMgr.shareName(shareName);
            };

            /// public: selectByKeys(keys)
            plotClass.prototype.selectByKeys = function (keys) {
                this._uiStateMgr.selectByKeys(keys);
            };

            /// public: onFilterChanged().
            plotClass.prototype.onFilterChanged = function () {
                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];

                    layer.applyFilter(this._uiStateMgr.filter(), false, true);
                }

                //rebuildScales();
                this.markRebuildNeeded();
            };

            plotClass.prototype.markRebuildNeeded = function () {
                if (!this._timer) {
                    //vp.utils.debug("plot.markBuildNeeded");
                    this._timer = setTimeout(vp.utils.cb(this, this.rebuildChart), 10); // "1" causes too many rebuilds..?
                }
            };

            /// private: initialBuild().
            plotClass.prototype.initialBuild = function () {
                //this._mappings = vp.layers.createMappings()
                //    .vvParent(this);
                var _this = this;
                this._rootDiv.css("position", "relative");

                //---- disable browser menu on right click (in prep for our own local menu) ----
                document.oncontextmenu = function () {
                    return false;
                };

                this._svgDoc = this._rootDiv.append("svg").attr("overflow", "hidden").attr("width", 1).attr("height", 1);

                //---- create these 2 early so we can pass them off to this._uiStateMgr here ----
                //this._shapesDoc = this._svgDoc.append("svg")      // make this a nested SVG doc so we can control the "overflow" on it (clip shapes within this rect)
                //            .id("shapesDoc")
                //this._shapesGroup = this._shapesDoc.append("g")
                //            .id("shapesGroup")
                this._shapesGroup = this._svgDoc.append("g").id("shapesGroup");

                //shapesDiv = vp.select(document.body).append("div")
                //    .css("position", "absolute")
                //    .id("shapesDiv")
                //var rubberBandGroup = this._svgDoc.append("g")
                //            .id("rubberBandGroup")
                this._uiStateMgr = vp.events.createUiStateMgr("plotClass", "vuePlot", this._svgDoc, this._shapesGroup, vp.utils.cb(this, this.updateShapeVisuals), vp.utils.cb(this, this.onFilterChanged));

                //---- build dynamic, rich this._tooltip ----
                this._tooltipDiv = vp.select(document.body).append("div").id("vvPlotTooltip").setClass("vpToolTip").css("padding", "5px").css("display", "none");

                //---- build rich tooltips on-demand, using "buildToolTip" function ----
                this._tooltip = new vp.visuals.toolTip(this._tooltipDiv[0], vp.utils.cb(this, this.buildToolTipHelper));

                this._chartFrame = vp.visuals.createChartFrame();

                //---- when our ROOT DIV is resized using the vuePlot "width()" or "height()" functions, we rebuild the plot ----
                this._rootDiv.setClass("vpVvPlot").attach("resize", function () {
                    _this.markRebuildNeeded();
                });

                this.markRebuildNeeded();
            };

            // public READONLY property: this._shapesDoc
            plotClass.prototype.shapesDoc = function () {
                //return this._shapesDoc;
                return this._shapesGroup;
            };

            plotClass.prototype.plotBounds = function () {
                return this._rcShapes;
            };

            /// public READONLY property: this._shapesGroup
            plotClass.prototype.shapesGroup = function () {
                return this._shapesGroup;
            };

            /// public READONLY property: shapeRoot
            plotClass.prototype.svgRoot = function () {
                return this._svgDoc;
            };

            /// public: updateShapeVisuals().
            plotClass.prototype.updateShapeVisuals = function (selectionCount) {
                var daSelected = vp.session.currentTheme().getDrawingAttributes("selected");
                var daUnselected = vp.session.currentTheme().getDrawingAttributes("unselected");
                var daHover = vp.session.currentTheme().getDrawingAttributes("hover");

                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];

                    layer.updateShapeVisuals(selectionCount, daSelected, daUnselected, daHover);
                }
            };

            plotClass.prototype.getUnmappedData = function (attr, length) {
                var value = (attr) ? attr.value() : undefined;
                var data = [];

                if (value !== undefined) {
                    if (vp.utils.isArray(value)) {
                        data = value;
                    } else {
                        data = vp.data.dataRepeat(value, Math.max(1, length));
                    }
                } else {
                    data = vp.utils.range(1, length); // Math.max(1, length));
                }

                return data;
            };

            /// private: buildRecordDescriptors(layer)
            /// build:
            ///    - xRecords   - array of x data streams
            ///    - yRecords   - array of y data streams
            ///    - plotRecords    - points to xRecords or yRecords (that one that has multiple streams or is non-category)
            ///    - byRecords      - points to the other (a single stream of category/numeric/date data)
            plotClass.prototype.buildRecordDescriptors = function (layer) {
                var dataRecords = layer.data();

                //var xScaleOverride = null;
                //var yScaleOverride = null;
                //---- filter records ----
                //var filteredData = this._uiStateMgr.filterData(dataRecords, keyFunc);
                var filteredData = dataRecords;

                var xColList = layer.xAfterStat();
                var yColList = layer.yAfterStat();

                //---- extract X data streams from records ----
                var xRecords = [];

                if ((!xColList) || (!xColList.length) || (!xColList[0])) {
                    //---- experiment: try supplying "index" as the x stream ----
                    var colName = "x";

                    //---- for bar-type columns, colName must be empty to denote an empty series ----
                    if (layer._seriesAxis == "x") {
                        colName = "";
                    }

                    var xData = this.getUnmappedData(layer.x(), dataRecords.length);
                    xRecords.push({ data: xData, name: colName, title: colName, tooltip: colName, autoGenerated: true });

                    //xScaleOverride = "category";
                    xColList = [];
                } else {
                    for (var i = 0; i < xColList.length; i++) {
                        var colName = xColList[i];
                        var xxData = vp.data.dataSelect(filteredData, colName);
                        xRecords.push({ data: xxData, name: colName, title: colName, tooltip: colName });
                    }
                }

                if (!yColList) {
                    yColList = [];
                }

                //---- extract Y data arrays from records ----
                var yRecords = [];

                if ((!yColList) || (yColList.length == 0)) {
                    //---- experiment: try supplying "index" as the y data ----
                    var colName = "";
                    var yData = this.getUnmappedData(layer.y(), dataRecords.length);
                    yRecords.push({ data: yData, name: colName, title: colName, tooltip: colName, autoGenerated: true });
                    // yScaleOverride = "category";
                } else {
                    for (var i = 0; i < yColList.length; i++) {
                        var colName = yColList[i];
                        var yyData = vp.data.dataSelect(filteredData, colName);
                        yRecords.push({ data: yyData, name: colName, title: colName, tooltip: colName });
                    }
                }

                var seriesCount = Math.max(1, Math.max(xColList.length, yColList.length));
                var layerType = layer.layerType();

                if ((layerType == "boxPlot") || (layerType == "graph")) {
                    //---- these are not real series ----
                    seriesCount = 1;
                }

                //var firstSeries = this.getFirstSeries(yRecords);
                var yScaleType = this.getScaleTypeForData(yRecords[0].data);
                var byRecords = xRecords;
                var plotRecords = yRecords;

                var xIsSeriesAxis = (layer.seriesAxis() == "x");

                if (xIsSeriesAxis) {
                    byRecords = yRecords;
                    plotRecords = xRecords;
                }

                if (filteredData.length == 0) {
                    //---- use primary data records (created from axis value) as the filteredData ----
                    filteredData = (plotRecords && plotRecords.length && plotRecords[0].data.length) ? plotRecords[0].data : byRecords[0].data;

                    //---- tell layer's DAM that data changed ----
                    layer.dataAnimMgr().setData(filteredData);
                }

                var keyFunc = layer.key();
                if (!keyFunc) {
                    //---- fallback: use index as the primary key ----
                    keyFunc = vp.utils.indexKeyFunc;
                }

                //---- store info on layer ----
                layer.info = {
                    xSeriesCount: xColList.length,
                    ySeriesCount: yColList.length,
                    seriesNames: (xIsSeriesAxis) ? xColList : yColList,
                    dataRecords: dataRecords,
                    seriesCount: seriesCount,
                    filteredData: filteredData,
                    keyFunc: keyFunc,
                    stackType: this.getStackType(layer),
                    xRecords: xRecords,
                    yRecords: yRecords,
                    byRecords: byRecords,
                    plotRecords: plotRecords,
                    swapAxes: false,
                    htmlShapesGroup: null,
                    chartType: "",
                    //---- these are set in drawLayers() with latest values ----
                    width: 0,
                    height: 0
                };
            };

            //---- calculate the range of the "by" data (usually the x data) ----
            plotClass.prototype.calcByRange = function (descRecords, scaleName, stat, layer) {
                if (descRecords.length > 0) {
                    var descRecord = descRecords[0];
                    var dd = descRecord.data;

                    //---- start with category-style min/max ---
                    var thisMin = 0;
                    var thisMax = dd.length;

                    //---- give STAT the option of calculating this layer's min/max for this scale ----
                    var result = null;
                    if (scaleName == "x") {
                        result = (layer.calcXScaleForLayer) ? layer.calcXScaleForLayer(descRecord) : null;
                        if (!result) {
                            result = (stat.calcXScaleForLayer) ? stat.calcXScaleForLayer(layer) : null;
                        }
                    } else {
                        result = (layer.calcYScaleForLayer) ? layer.calcYScaleForLayer(descRecord) : null;
                        if (!result) {
                            result = (stat.calcYScaleForLayer) ? stat.calcYScaleForLayer(layer) : null;
                        }
                    }

                    if (result) {
                        thisMin = result.min;
                        thisMax = result.max;
                    } else {
                        var dataIsNumeric = vp.utils.isDataNumeric(dd);

                        if (dataIsNumeric) {
                            for (var a = 0; a < descRecords.length; a++) {
                                var dd = descRecords[a].data;
                                if ((dd) && (dd.length > 0)) {
                                    //---- min/max for this series ----
                                    var smin = dd.min();
                                    var smax = dd.max();

                                    //---- combine with previous series ----
                                    if (!isNaN(smin)) {
                                        thisMin = (a == 0) ? smin : Math.min(smin, thisMin);
                                    }

                                    if (!isNaN(smax)) {
                                        thisMax = (a == 0) ? smax : Math.min(smax, thisMax);
                                    }
                                }
                            }
                        }
                    }
                }

                return { min: thisMin, max: thisMax };
            };

            //---- calculate the range of the "plot" data (usually the y data) ----
            plotClass.prototype.calcPlotRange = function (descRecords, scaleName, stat, stackType, layer) {
                if (descRecords.length > 0) {
                    var descRecord = descRecords[0];

                    var thisMin = +9999999;
                    var thisMax = -9999999;

                    //---- give LAYER/STAT the option of calculating this layer's this._yMin/this._yMax ----
                    var result = null;
                    if (scaleName == "x") {
                        result = (layer.calcXScaleForLayer) ? layer.calcXScaleForLayer(descRecord) : null;
                        if (!result) {
                            result = (stat.calcXScaleForLayer) ? stat.calcXScaleForLayer(layer) : null;
                        }
                    } else {
                        result = (layer.calcYScaleForLayer) ? layer.calcYScaleForLayer(descRecord) : null;
                        if (!result) {
                            result = (stat.calcYScaleForLayer) ? stat.calcYScaleForLayer(layer) : null;
                        }
                    }

                    var layerType = layer.layerType();

                    if (result) {
                        thisMin = result.min;
                        thisMax = result.max;
                    } else if (stackType == "stack" || stackType == "fill") {
                        //---- find min/max of each ITEM (as summed across all series) ----
                        var itemCount = descRecord.data.length;
                        var isColOrBar = (layerType == "bar" || layerType == "column");
                        var result;

                        if (isColOrBar) {
                            result = this.getColumnBarRange(descRecords, thisMin, thisMax, stackType, itemCount);
                        } else {
                            result = this.getNormalLayerRange(descRecords, thisMin, thisMax, stackType, itemCount);
                        }

                        thisMin = result.thisMin;
                        thisMax = result.thisMax;
                    } else {
                        for (var a = 0; a < descRecords.length; a++) {
                            var dd = descRecords[a].data;
                            if ((dd) && (dd.length > 0)) {
                                //---- min/max for this series ----
                                var smin = dd.min();
                                var smax = dd.max();

                                //---- combine with previous series ----
                                if (!isNaN(smin)) {
                                    thisMin = Math.min(smin, thisMin);
                                }

                                if (!isNaN(smax)) {
                                    thisMax = Math.max(smax, thisMax);
                                }
                            }
                        }
                    }
                }

                return { min: thisMin, max: thisMax };
            };

            plotClass.prototype.getColumnBarRange = function (descRecords, thisMin, thisMax, stackType, itemCount) {
                for (var i = 0; i < itemCount; i++) {
                    var itemTotalPos = 0;
                    var itemTotalNeg = 0;

                    for (var a = 0; a < descRecords.length; a++) {
                        var dd = descRecords[a].data;
                        var value = +dd[i];

                        //---- prevent exceptions for bad data here ----
                        if (isNaN(+value)) {
                            if (this._onError) {
                                value = this._onError("NaN", { msg: "scaling input value", value: value, rowIndex: i, colName: descRecords[a].name });
                            } else {
                                value = 0;
                            }
                        }

                        if (value < 0) {
                            itemTotalNeg += value;
                        } else {
                            itemTotalPos += value;
                        }
                    }

                    //---- combine with running min/max from previous items ----
                    if (stackType == "stack") {
                        thisMin = Math.min(thisMin, itemTotalNeg);
                        thisMax = Math.max(thisMax, itemTotalPos);
                    } else {
                        var itemMin = itemTotalNeg / (itemTotalPos - itemTotalNeg);
                        var itemMax = itemTotalPos / (itemTotalPos - itemTotalNeg);

                        thisMin = Math.min(thisMin, itemMin);
                        thisMax = Math.max(thisMax, itemMax);
                    }
                }

                return { thisMin: thisMin, thisMax: thisMax };
            };

            plotClass.prototype.getNormalLayerRange = function (descRecords, thisMin, thisMax, stackType, itemCount) {
                for (var i = 0; i < itemCount; i++) {
                    var itemTotalMixed = 0;
                    var itemTotalPos = 0;
                    var itemTotalNeg = 0;

                    for (var a = 0; a < descRecords.length; a++) {
                        var dd = descRecords[a].data;
                        var value = +dd[i];
                        itemTotalMixed += value;

                        //---- prevent exceptions for bad data here ----
                        if (isNaN(+value)) {
                            if (this._onError) {
                                value = this._onError("NaN", { msg: "scaling input value", value: value, rowIndex: i, colName: descRecords[a].name });
                            } else {
                                value = 0;
                            }
                        }

                        if (value < 0) {
                            itemTotalNeg += value;
                        } else {
                            itemTotalPos += value;
                        }
                    }

                    //---- combine with running min/max from previous items ----
                    if (stackType == "stack") {
                        thisMin = Math.min(thisMin, itemTotalMixed);
                        thisMax = Math.max(thisMax, itemTotalMixed);
                    } else {
                        var total = itemTotalPos + (-itemTotalNeg);
                        var itemPercent = (total == 0) ? 0 : (itemTotalMixed / total);

                        thisMin = Math.min(thisMin, itemPercent);
                        thisMax = Math.max(thisMax, itemPercent);
                    }
                }

                return { thisMin: thisMin, thisMax: thisMax };
            };

            /// private: calculate the range of X and Y data (which might involve multiple series).
            plotClass.prototype.calcXYRanges = function () {
                this._xMin = +9999999;
                this._xMax = -9999999;

                this._yMin = +9999999;
                this._yMax = -9999999;

                for (var j = 0; j < this._layers.length; j++) {
                    var layer = this._layers[j];
                    var stackType = this.getStackType(layer);
                    var stat = layer.stat();

                    //---- find X and Y min/max over this._layers ----
                    this.buildRecordDescriptors(layer);

                    var layInfo = layer.info;
                    var seriesCount = layInfo.seriesCount;

                    var xRecords = layInfo.xRecords;
                    var yRecords = layInfo.yRecords;
                    var byRecords = layInfo.byRecords;
                    var plotRecords = layInfo.plotRecords;

                    //----- set the series colList for the layer ----
                    //---- reply on "plotRecords", unless "seriesAxis" has been set for this layer by user ----
                    var seriesColList = null;

                    if (layer._isSeriesLayer) {
                        var records = plotRecords;
                        var seriesAxis = layer.seriesAxis();
                        if (seriesAxis) {
                            records = (seriesAxis == "x") ? xRecords : yRecords;
                        }

                        if (records) {
                            seriesColList = records.map(function (data, index) {
                                return data.name;
                            });
                        }
                    }

                    layer.setSeriesNamesForAnimation(seriesColList);

                    layInfo.chartType = layer.chartName();

                    //---- allow layer (layer) to make adjustments to chart options ----
                    if (layer.adjustChartOptions) {
                        layer.adjustChartOptions();
                    }

                    //---- CALC X ----
                    var xRange = null;
                    if (xRecords == byRecords) {
                        xRange = this.calcByRange(xRecords, "x", stat, layer);
                    } else {
                        xRange = this.calcPlotRange(xRecords, "x", stat, stackType, layer);
                    }

                    //---- merge with prev layer ----
                    this._xMin = Math.min(this._xMin, xRange.min);
                    this._xMax = Math.max(this._xMax, xRange.max);

                    //---- CALC Y ----
                    var yRange = null;
                    if (yRecords == byRecords) {
                        yRange = this.calcByRange(yRecords, "y", stat, layer);
                    } else {
                        yRange = this.calcPlotRange(yRecords, "y", stat, stackType, layer);
                    }

                    //---- merge with prev layer ----
                    this._yMin = Math.min(this._yMin, yRange.min);
                    this._yMax = Math.max(this._yMax, yRange.max);
                }
            };

            /// TODO: change this to look at all rows of the data and
            /// return numeric only for all numeric values.  also, we should pass
            /// a flag, numericMustBeIncreasing - when true, we only pass back "numeric"
            /// if all values are numeric and increasing from row to row.  This is needed
            /// for X axis in many layer types (bar, column, line, area, ...).
            plotClass.prototype.getScaleTypeForData = function (dd) {
                var scaleType = undefined;

                if ((dd) && (dd.length > 0)) {
                    var value = dd[0];

                    //---- issue: Date.parse(216828) ==> NAN on IE9, but Date on Chrome ----
                    //---- so for now, never do auto date detection - let user specify it ----
                    if (false) {
                        scaleType = "date";
                    } else if (isNaN(Number(value))) {
                        scaleType = "category";
                    } else {
                        scaleType = "numeric";
                    }
                }

                return scaleType;
            };

            plotClass.prototype.adjustScale = function (attribute, myData, limit, dataMin, dataMax, seriesCount, scaleName) {
                var defaults = attribute.layerDefaults;
                var scale = attribute.scale();

                attribute.plotDefaults.isDiscrete = undefined;

                var isDiscrete = attribute.isDiscrete();
                if (isDiscrete === undefined) {
                    isDiscrete = attribute.layerDefaults.isDiscrete;
                    if (isDiscrete === undefined) {
                        var scaleType = this.getScaleTypeForData(myData);
                        if (scaleType !== undefined) {
                            isDiscrete = (scaleType == "category");
                            attribute.plotDefaults.isDiscrete = isDiscrete;
                        }
                    }
                }

                var callerMin = undefined;
                var callerMax = undefined;
                var callerTicks = undefined;

                //---- set min/max of all layer's scales according to the primary layer? ----
                attribute.layerDefaults.dataMin = dataMin;
                attribute.layerDefaults.dataMax = dataMax;
                attribute.layerDefaults.isMinMaxSoft = true;

                attribute.needsSetUp(true);

                //---- attribute should really have 2 level system for breaks but it doesn't ----
                //---- so for now, let the LAYER options take priority (to fix histogram gridlines) ----
                //var breaks = attribute.defaults.breaks;
                //if ((!breaks) || (!breaks.length))
                //{
                //    breaks = attribute.breaks();
                //}
                //if (breaks && breaks.length)
                //{
                //    //attribute.breaks(breaks);
                //    attribute.useNiceNumbers(false);
                //}
                //---- note: "limit" is a USER setting ----
                if ((limit) && (limit.length > 0)) {
                    if (limit[0] != Infinity && limit[0] != -Infinity && limit[0] !== undefined) {
                        callerMin = limit[0];
                        attribute.domainMin(callerMin);
                    } else {
                        attribute.domainMin(undefined);
                    }
                }

                if ((limit) && (limit.length > 1)) {
                    if (limit[1] != Infinity && limit[1] != -Infinity && limit[1] !== undefined) {
                        callerMax = limit[1];
                        attribute.domainMax(callerMax);
                    } else {
                        attribute.domainMax(undefined);
                    }
                }

                if ((limit) && (limit.length > 2)) {
                    if (limit[2] != Infinity && limit[2] != -Infinity && limit[2] !== undefined) {
                        callerTicks = limit[2];
                        attribute.tickCount(callerTicks);
                    } else {
                        attribute.tickCount(undefined);
                    }
                }

                if (isDiscrete) {
                    //---- create CATEGORY scale ----
                    attribute;
                    //.isDiscrete(true)
                    //.treatInputAsDates(false)
                    //.dataOverride(myData)
                    //.values(myData)
                    //.data(myData)
                    //.seriesCount(seriesCount)
                    //.callerTickCount(callerTicks)
                } else {
                    //attribute
                    //.isDiscrete(false)
                    if (false) {
                        //attribute
                        //    .useNiceNumbers(false);
                        //attribute
                        //    .treatInputAsDates(true)
                        //    .useNiceNumbers(false)
                        //    .useZeroForDomainMin(false)
                        //scale = vp.scales.date()
                    } else {
                        //attribute
                        //    .treatInputAsDates(false)
                        //    .useNiceNumbers(addMaxHeadroom)
                        //scale = vp.scales.linear()
                        //.snapResult(true)
                    }
                    //if (! breaks)
                    //{
                    //    if (callerMin !== undefined)
                    //    {
                    //        dataMin = callerMin;
                    //    }
                    //    if (callerMax !== undefined)
                    //    {
                    //        dataMax = callerMax;
                    //    }
                    //    if (callerTicks)
                    //    {
                    //        attribute.tickCount(callerTicks);
                    //    }
                    //}
                }

                return scale;
            };

            plotClass.prototype.updateAutoRangeScale = function (scale, scaleName) {
                //---- set the WIDTH / HEIGHT of the scale, if needed ----
                var spaceScale = scale;

                if (spaceScale.autoRange()) {
                    var size = 0;

                    if (scaleName == "x") {
                        size = this._rcShapes.width;
                    } else {
                        size = this._rcShapes.height;
                    }

                    spaceScale.rangeMin(0).rangeMax(size);
                }
            };

            /// private: adjustScales()
            plotClass.prototype.adjustScales = function (layer) {
                var layInfo = layer.info;

                var xRecords = layInfo.xRecords;
                var yRecords = layInfo.yRecords;
                var byRecords = layInfo.byRecords;
                var plotRecords = layInfo.plotRecords;

                var seriesCount = layInfo.seriesCount;

                if (layInfo.stackType == "fill") {
                    var ai = (plotRecords == xRecords) ? layer._xDefaults : layer._yDefaults;
                    ai.addMaxHeadroom = false;
                }

                var xAttr = layer.x();
                var yAttr = layer.y();

                //---- adjust X-SCALE -----
                var xData1 = (xAttr.layerDefaults.dataOverride) ? xAttr.layerDefaults.dataOverride : xRecords[0].data;

                this.adjustScale(xAttr, xData1, this._xLimit, this._xMin, this._xMax, seriesCount, "x");

                //---- adjust Y-SCALE -----
                var yData1 = (yAttr.layerDefaults.dataOverride) ? yAttr.layerDefaults.dataOverride : yRecords[0].data;

                this.adjustScale(yAttr, yData1, this._yLimit, this._yMin, this._yMax, seriesCount, "y");
            };

            /// private: getStackType()
            plotClass.prototype.getStackType = function (layer) {
                var stackType = layer.stackType();

                if (!stackType) {
                    stackType = layer.defaultStackType();
                }

                return stackType;
            };

            /// structure of plotClass
            ///     div             this._rootDiv
            ///       - div         ribbonDiv
            ///       - svg         this._svgDoc
            ///         - g         this._chartFrameGroup
            ///           - g       titleGroup
            ///           - g       legendGroup
            ///           - g       xaxisGroup
            ///           - g       yaxisGroup
            ///           - g       plotAreaGroup
            ///         - svg      this._shapesDoc   (this has been obsoleted and removed)
            ///         - g        this._shapesGroup
            /// private: rebuildChart()
            plotClass.prototype.rebuildChart = function () {
                //---- prevent flashing by setting root opacity to 0 until we get here ----
                //this._rootDiv
                //    .css("opacity", 1)
                vp.utils.debug("----------- plot.rebuildChart: width=" + this._rootDiv.width() + ", height=" + this._rootDiv.height() + " --------");

                var start = +Date.now();
                var startTime = start;

                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];
                    layer.onPlotDataChanged(false);
                }

                //---- clearing the this._timer must happen AFTER the layer.onPlotDataChanged() because it triggers a rebuild ----
                if (this._timer) {
                    clearTimeout(this._timer);
                    this._timer = null;
                }

                this._rootDiv.clear();
                this._svgDoc.clear();

                //---- do NOT clear "shapesGroup" (since we animate changes using existing shapes) ----
                //this._shapesGroup.clear();
                //---- todo: hook when this._isUiEnabled changes and reflect into this._uiStateMgr ----
                this._uiStateMgr.isUiEnabled(this._isUiEnabled);
                this._uiStateMgr.isSelectionEnabled(this._isSelectionEnabled);

                var prelimElapsed = +Date.now() - start;
                start = +Date.now();

                if (this._layers.length > 0) {
                    var hideRibbon = (!this._showRibbon);

                    this.calcXYRanges();

                    var calcRangesElapsed = +Date.now() - start;
                    start = +Date.now();

                    //---- for now, base some building on the first layer ----
                    var primaryLayer = this._layers[0];
                    var layInfo = primaryLayer.info;
                    var seriesCount = layInfo.seriesCount;

                    this._xScale = primaryLayer._xAttr.scale();
                    this._yScale = primaryLayer._yAttr.scale();

                    var xRecords = layInfo.xRecords;
                    var yRecords = layInfo.yRecords;
                    var byRecords = layInfo.byRecords;
                    var plotRecords = layInfo.plotRecords;

                    var xRecord = xRecords[0];
                    var yRecord = yRecords[0];

                    var xAttr = primaryLayer.x();
                    var yAttr = primaryLayer.y();

                    var plotDefaults = primaryLayer._plotDefaults;

                    if (plotDefaults.shapesEnterFromBottom) {
                        this.shapesEnterFromBottom(true);
                    }

                    //---- add RIBBON at top ----
                    this._ribbonBar = null;

                    if (!hideRibbon) {
                        this.buildRibbon(this._chartType);
                    }

                    //---- now that we know height of ribbon, position this._svgDoc correctly ----
                    var height = this._rootDiv.height();

                    //---- we can't rely on HTML to set the height of this._svgDoc correctly ----
                    if (this._ribbonBar) {
                        height -= this._ribbonBar.height();
                    }

                    this._svgDoc.css("height", height);

                    //---- add SVG DOC below ribbon ----
                    this._rootDiv.append(this._svgDoc).css("width", "100%");

                    this._htmlShapesGroup = this._rootDiv.append("div").id("htmlShapesGroup").css("position", "absolute").css("display", "none");

                    for (var i = 0; i < this._layers.length; i++) {
                        var layer = this._layers[i];
                        this.adjustScales(layer);
                    }

                    var mytitle = (this._isTitleVisible) ? this._title : null;

                    //var fontSize = this._titleSize;
                    //buildAxisTitles(options, xRecord, yRecord);
                    var showXAxis = ((this._isXAxisVisible) && (plotDefaults.showXAxis));
                    var showYAxis = ((this._isYAxisVisible) && (plotDefaults.showYAxis));

                    //buildAxes(primaryLayer, options, xRecord, yRecord);
                    //---- build this._xLabel ----
                    var myxLabel = xAttr.title();
                    var showXLabel = ((plotDefaults.showXTitle) && (myxLabel) && (myxLabel != ""));

                    //this._xScale.scaleName(myxLabel);
                    primaryLayer.x().title(myxLabel);

                    //---- build this._yLabel ----
                    var myyLabel = yAttr.title();
                    var showYLabel = ((plotDefaults.showYTitle) && (myyLabel) && (myyLabel != ""));

                    //this._yScale.scaleName(myyLabel);
                    primaryLayer.y().title(myyLabel);

                    var showXGrid = (this._isXGridVisible && plotDefaults.showXGridLines);
                    var showYGrid = (this._isYGridVisible && plotDefaults.showYGridLines);

                    var showBoxTicks = this._showBoxTicks;
                    var drawTicksOnInside = this._drawTicksOnInside;

                    var beforeFrameElapsed = +Date.now() - start;
                    start = +Date.now();

                    if (!this._isAxisBoxVisible) {
                        showXAxis = false;
                        showXLabel = false;
                        showXGrid = false;

                        showYAxis = false;
                        showYLabel = false;
                        showYGrid = false;

                        showBoxTicks = false;
                    }

                    //---- build the chart frame and its group parts ----
                    this._chartFrame.xAttribute(primaryLayer.x()).yAttribute(primaryLayer.y()).showLeftAxis(showYAxis).showBottomAxis(showXAxis).showLeftLabel(showYLabel).showBottomLabel(showXLabel).showXGridLines(showXGrid).showYGridLines(showYGrid).showBoxTicks(showBoxTicks).drawTicksOnInside(drawTicksOnInside).gridLineType(this._gridLineType).xLabelFit(this._xLabelFit).isLegendVisible(this._isLegendVisible).isLegendBoxVisible(this._isLegendBoxVisible).useLayersForLegend(this._useLayersForLegend).legendLabels(this._legendLabels).title(mytitle).titleSize(this._titleSize);

                    for (var i = 0; i < this._layers.length; i++) {
                        var layer = this._layers[i];
                        var attrs = layer.getActiveAttributes();

                        if (i == 0) {
                            this._chartFrame.attributes(attrs);
                        }
                    }

                    //---- this may change the scales (which will effect the legends), so call ----
                    //---- before we draw the frame. ----
                    if (this._rebuildCallback) {
                        this._rebuildCallback();
                    }

                    //---- add margins together for frame ----
                    var margins = vp.session.currentTheme().getDrawingAttributes("chartFrame.margins");
                    var fm = this._frameMargins;

                    if ((fm) && (fm.left !== undefined)) {
                        margins.left += fm.left;
                        margins.top += fm.top;
                        margins.right += fm.right;
                        margins.bottom += fm.bottom;
                    }

                    //---- build the chart FRAME now ----
                    this._chartFrame.build(this._svgDoc, margins, 0, this._layers, seriesCount); // this will add this._title, legend, axes, and this._shapesGroup

                    var afterFrameElapsed = +Date.now() - start;
                    start = +Date.now();

                    this._rcShapes = this._chartFrame.plotAreaRect();

                    for (var i = 0; i < this._layers.length; i++) {
                        var layer = this._layers[i];
                        var xScale = layer.x().scale();
                        var yScale = layer.y().scale();

                        this.updateAutoRangeScale(xScale, "x");
                        this.updateAutoRangeScale(yScale, "y");
                    }

                    this._svgDoc.append(this._shapesGroup);

                    //this._svgDoc.append(this._shapesDoc)
                    if (plotDefaults.gridLinesOnTop) {
                        //--- move SVG group of gridLines from this._chartFrame group to be on top of shapes ----
                        var glGroup = this._chartFrame.gridLinesGroup();
                        glGroup.remove(); // from parent

                        this._svgDoc.append(glGroup);
                    }

                    this._shapesGroup.translate(this._rcShapes.left, this._rcShapes.top).customAttr("assignedWidth", this._rcShapes.width).customAttr("assignedHeight", this._rcShapes.height);

                    //this._shapesDoc
                    //    .attr("x", this._rcShapes.left)
                    //    .attr("y", this._rcShapes.top)
                    //    .attr("width", this._rcShapes.width)
                    //    .attr("height", this._rcShapes.height)
                    /// write the WIDTH/HEIGHT also to ShapesGroup so layer's can get this info.
                    this._shapesGroup.attr("width", this._rcShapes.width).attr("height", this._rcShapes.height);

                    //vp.utils.debug("plotId=" + this._nextPlotId + ", shapesGroup.width set to: " + this._rcShapes.width);
                    //---- create clipPath with correct bounds ----
                    this.addOrUpdateClipPath(this._shapesGroup, this._rcShapes.width, this._rcShapes.height);

                    ////---- clipPath debugging ----
                    //this._shapesGroup.append("rect")
                    //    .attr("fill", "yellow")
                    //    .bounds(0, 0, this._rcShapes.width, this._rcShapes.height)
                    this._uiStateMgr.dragToKidsOffset({ left: -this._rcShapes.left, top: -this._rcShapes.top });

                    //---- position our drag surface ----
                    var off = vp.dom.docOffset(this._svgDoc[0]);

                    var beforeDrawLayersElapsed = +Date.now() - start;
                    start = +Date.now();

                    //shapesDiv
                    //    .css("left", off.left + this._rcShapes.left)
                    //    .css("top", off.top + this._rcShapes.top)
                    //    .css("width", this._rcShapes.width)
                    //    .css("height", this._rcShapes.height)
                    //---- draw SHAPES now ----
                    this.drawLayers();

                    var afterDrawLayersElapsed = +Date.now() - start;
                    start = +Date.now();
                }

                var selCount = this._uiStateMgr.selectionCount();
                if (selCount) {
                    //---- this is needed to update selection/hover/filter settings after chart redraw ----
                    //updateShapeVisuals(selCount);
                    this._uiStateMgr.onSelectionChanged(true);
                }

                var selectionElapsed = +Date.now() - start;

                var elapsed = +Date.now() - startTime;
                var a = 9;
                //alert("Elapsed=" + elapsed + " ms");
            };

            plotClass.prototype.attachClipPathToShapesGroup = function () {
                ////---- attach a clip path to "shapesGroup" to keep shapes within their boundary (without having to do scale-level clipping, which looks wrong) ----
            };

            plotClass.prototype.addOrUpdateClipPath = function (group, width, height) {
                var clipId = "shapesClipPath_" + this._plotId;
                var clipPath = document.getElementById(clipId);

                if (clipPath) {
                    //---- already created - just update bounds of child RECT ----
                    vp.select(clipPath.firstChild).bounds(0, 0, width, height);
                } else {
                    //---- define a CLIPPING PATH for use by shapes group ----
                    var defs = group.append("defs");

                    clipPath = defs.append("clipPath").attr("id", clipId).attr("clipPathUnits", "userSpaceOnUse").append("rect").bounds(0, 0, width, height);

                    group.attr("clip-path", "url(#" + clipId + ")");
                }
            };

            /// public: drawLayers()
            plotClass.prototype.drawLayers = function () {
                var start = +Date.now();

                //shapeRoot.clear();
                this._plotShapes = vp.select();

                this._htmlShapesGroup.width(this._rcShapes.width).height(this._rcShapes.height).top(this._rcShapes.top).left(this._rcShapes.left);

                var beforeDrawLayersElapsed = +Date.now() - start;
                start = +Date.now();

                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];

                    layer.info.width = this._rcShapes.width;
                    layer.info.height = this._rcShapes.height;
                    layer.info.htmlShapesGroup = this._htmlShapesGroup;

                    this.drawLayer(layer);
                }

                var afterDrawLayersElapsed = +Date.now() - start;
                start = +Date.now();

                if (this._postCreateCallback) {
                    this._postCreateCallback();
                }

                var afterPostCreateElapsed = +Date.now() - start;
                start = +Date.now();
            };

            /// private: drawLayer()
            plotClass.prototype.drawLayer = function (layer) {
                var start = +Date.now();

                var layInfo = layer.info;

                var xRecords = layInfo.xRecords;
                var yRecords = layInfo.yRecords;
                var byRecords = layInfo.byRecords;
                var plotRecords = layInfo.plotRecords;

                var allShapes = vp.select();
                var stackType = layInfo.stackType;
                var itemTotals = [];
                var byRecord = byRecords[0];

                //---- build position info ----
                ///   itemAccums[] is the running total of positive values for an item as each series is drawn (for stacking)
                ///   itemAccumsNeg[] is the running total of negative values for an item as each series is drawn (for stacking)
                var pi = { stackType: stackType, itemAccums: [], itemAccumsNeg: [], itemTotals: [] };

                if ((pi.stackType == "stack") || (pi.stackType == "fill")) {
                    pi.itemAccums = [];

                    for (var i = 0; i < byRecord.data.length; i++) {
                        pi.itemAccums[i] = 0;
                        pi.itemAccumsNeg[i] = 0;
                    }
                }

                var layerNeedsTotals = (pi.stackType == "fill" || layInfo.seriesCount > 1 || layer.layerType() == "streamGraph");
                layerNeedsTotals = true; // for now, always do this since we need them for any negative values that might be found

                if (layerNeedsTotals) {
                    var itemCount = plotRecords[0].data.length;
                    pi.itemTotals = [];

                    for (var i = 0; i < itemCount; i++) {
                        var itemTotalPos = 0;
                        var itemTotalNeg = 0;

                        for (var s = 0; s < plotRecords.length; s++) {
                            var plotData = plotRecords[s].data;

                            if (plotData[i] >= 0) {
                                itemTotalPos += plotData[i];
                            } else {
                                itemTotalNeg += plotData[i];
                            }
                        }

                        pi.itemTotals[i] = itemTotalPos - itemTotalNeg;

                        pi.itemAccumsNeg[i] = itemTotalNeg;
                    }
                }

                layer.container(this._shapesGroup);

                var beforeLayerDrawElapsed = +Date.now() - start;
                var start = +Date.now();

                if (yRecords.length == 0) {
                    //---- draw by-only data ----
                    var yRecord = null;
                    var seriesIndex = 0;

                    //--- draw series and return a selected set of shapes ----
                    var shapes = layer.drawShapes(this._shapesGroup, xRecords[0], yRecord, seriesIndex, pi, layer, this._xScale, this._yScale, this);

                    if (shapes) {
                        this.addDrawnShapes(layer, shapes, seriesIndex);
                    }
                } else {
                    for (var s = 0; s < plotRecords.length; s++) {
                        var xRecord = xRecords[0];
                        var yRecord = yRecords[0];

                        //---- allow both X and Y to have multiple series (pointLayer, barLayer, etc) ----
                        if (yRecords.length > 1) {
                            yRecord = yRecords[s];
                        }

                        if (xRecords.length > 1) {
                            xRecord = xRecords[s];
                        }

                        //--- draw series and return a selected set of shapes ----
                        var shapes = layer.drawShapes(this._shapesGroup, xRecord, yRecord, s, pi, layer, this._xScale, this._yScale, this);

                        var afterLayerDrawElapsed = +Date.now() - start;
                        var start = +Date.now();

                        if (shapes) {
                            this.addDrawnShapes(layer, shapes, s);
                        }

                        var afterAddShapesElapsed = +Date.now() - start;
                        var start = +Date.now();
                    }
                }

                layer.postDraw(layInfo, shapes);
            };

            /// public: addDrawnShapes()
            plotClass.prototype.addDrawnShapes = function (layer, shapes, seriesIndex) {
                var ttCols = layer.toolTipCols();
                if ((ttCols === true) && (layer.info.seriesCount > 1)) {
                    if (layer.ctr != "vp.layerGraph") {
                        var byRecords = layer.info.byRecords;
                        var plotRecords = layer.info.plotRecords;

                        var plotRecord = plotRecords[seriesIndex];
                        var byRecord = (seriesIndex < byRecords.length) ? byRecords[seriesIndex] : byRecords[0];

                        ttCols = plotRecord.name + "," + byRecord.name;
                    }
                }

                //---- add chart properties to each shape ----
                shapes.customAttr("isSelected", false).customAttr("isFilteredOut", false).customAttr("isHighlighted", false).attach("mouseover", vp.utils.cb(this, this.onMouseOver)).attach("mouseout", vp.utils.cb(this, this.onMouseOut));

                //.attach("click", onClick)
                shapes.customAttr("toolTipContext", ttCols).toolTipEnabled(true);

                if ((this._isTooltipEnabled) && (this._useStdTooltips)) {
                    for (var i = 0; i < shapes.length; i++) {
                        this.buildToolTip(shapes[i], layer, seriesIndex);
                    }
                }

                this._plotShapes = this._plotShapes.merge(shapes);

                this._uiStateMgr.plotShapes(this._plotShapes);
            };

            /// private: buildChartTypeCombo()
            plotClass.prototype.buildChartTypeCombo = function (group) {
                this._chartType = "Column";
                if (this._layers.length > 0) {
                    var layer = this._layers[0];
                    this._chartType = layer.chartName();
                }

                var cbChartType = group.append("select").setClass("groupCombo").attach("change", vp.utils.cb(this, this.onChartTypeChanged));

                var chartTypes = ["Bar", "BoxPlot", "Column", "Scatter"];

                chartTypes.map(function (data, index) {
                    cbChartType.append("option").value(data).text(data);
                });

                //---- set this AFTER adding options ----
                var index = chartTypes.indexOf(this._chartType);

                cbChartType.customAttr("selectedIndex", index);

                if (this._title === undefined) {
                    this._title = this._chartType + " Chart";
                }
            };

            plotClass.prototype.makeGroupCheckbox = function (group, text, isEnabled, clickFunc) {
                var cb = group.append("span").addClass("groupCheckbox").text(text).attach("click", function (e) {
                    var cb = e.target;
                    vp.dom.toggleClass(cb, "groupCheckboxChecked");

                    clickFunc(e);
                });

                if (isEnabled) {
                    cb.addClass("groupCheckboxChecked");
                }

                return cb;
            };

            /// private: buildRibbon()
            plotClass.prototype.buildRibbon = function (chartType) {
                var _this = this;
                this._ribbonBar = this._rootDiv.append(vp.visuals.ribbonBar());

                //---- CHART TYPE group ----
                var group = this._ribbonBar.append(vp.visuals.ribbonGroup()).text("Chart type");

                //--- CHARTTYPE COMBO ----
                this.buildChartTypeCombo(group);

                //---- FILTER group ----
                var group1 = this._ribbonBar.append(vp.visuals.ribbonGroup()).text("Filter");

                //--- ISOLATE button ----
                group1.append("span").setClass("groupButton").text("Isolate").attach("click", vp.utils.cb(this, this._uiStateMgr.isolateFilter));

                //--- HIDE button ----
                group1.append("span").setClass("groupButton").text("Hide").attach("click", vp.utils.cb(this, this._uiStateMgr.hideFilter));

                //group.startNewRow();
                //--- RESET button ----
                group1.append("span").setClass("groupButton").text("Reset").attach("click", vp.utils.cb(this, this._uiStateMgr.resetFilter));

                //--- INVERT button ----
                group1.append("span").setClass("groupButton").text("Invert").attach("click", vp.utils.cb(this, this._uiStateMgr.invertFilter));

                //---- SELECTION group ----
                var group2 = this._ribbonBar.append(vp.visuals.ribbonGroup()).text("Selection");

                //--- RESET button ----
                group2.append("span").setClass("groupButton").text("Reset").attach("click", function (e) {
                    _this._uiStateMgr.resetSelection();
                });

                //---- INVERT button ----
                group2.append("span").setClass("groupButton").text("Invert").attach("click", vp.utils.cb(this, this._uiStateMgr.toggleSelection));

                ////---- ZOOM group ----
                //var group3 = this._ribbonBar.append(vp.visuals.ribbonGroup())
                //    .name("Zoom");
                ////--- RESET button ----
                //group3.append("span")
                //  .setClass("groupButton")
                //  .text("Zoom");
                ////---- INVERT button ----
                //group3.append("span")
                //  .setClass("groupButton")
                //  .text("Reset");
                //---- SHARING group ----
                var group3 = this._ribbonBar.append(vp.visuals.ribbonGroup()).text("Sharing");

                //--- CHANNEL text input ----
                var shareName = this._uiStateMgr.shareName();

                group3.append("input").attr("type", "text").setClass("groupText").width(50).id("tbShareName").attr("title", "Channel name").value(shareName).attach("keydown", function (e) {
                    if (e.keyCode == vp.events.keyCodes.enter) {
                        //plotBox.focus();
                        _this.onShareNameChanged();
                    }
                });

                //---- OPTIONS group ----
                var group4 = this._ribbonBar.append(vp.visuals.ribbonGroup()).text("Options");

                //---- ANIMATION button ----
                this.makeGroupCheckbox(group4, "Animation", this._isAnimEnabled, function () {
                    var toggle = (!_this._isAnimEnabled);
                    _this.isAnimEnabled(toggle);
                });

                //--- TOOLTIPS button ----
                this.makeGroupCheckbox(group4, "Tooltips", this._isTooltipEnabled, function () {
                    var toggle = (!_this._isTooltipEnabled);
                    _this.isTooltipEnabled(toggle);
                });

                //---- HOVER button ----
                this.makeGroupCheckbox(group4, "Hover", this._isHoverEnabled, function () {
                    var toggle = (!_this._isHoverEnabled);
                    _this.isHoverEnabled(toggle);
                });

                //---- ACTIONS group ----
                var group5 = this._ribbonBar.append(vp.visuals.ribbonGroup()).text("Actions");

                //--- RESET button ----
                group5.append("span").setClass("groupButton").text("Print").attach("click", function () {
                    _this.printChart(false);
                });
            };

            plotClass.prototype.printChart = function (includeRibbon) {
                var _this = this;
                this._ribbonBar = vp.select(".vpRibbonBar");
                var saveAll = document.body.innerHTML;

                if ((!includeRibbon) && (this._ribbonBar.length > 0)) {
                    //---- so far, no good way to remove this._ribbonBar from layout... ----
                    this.showRibbon(false);
                    this.isAnimEnabled(false);
                    this.isHoverEnabled(false);

                    this.rebuildChart();

                    setTimeout(function () {
                        try  {
                            document.body.innerHTML = _this._rootElement.innerHTML;
                            window.print();
                        } finally {
                            document.body.innerHTML = saveAll;
                            _this.rebuildChart();
                        }
                    }, 500); // wait 500 ms for layout to complete
                } else {
                    try  {
                        document.body.innerHTML = this._rootElement.innerHTML;
                        window.print();
                    } finally {
                        document.body.innerHTML = saveAll;
                        this.rebuildChart();
                    }
                }
            };

            /// private: onChartTypeChanged()
            plotClass.prototype.onChartTypeChanged = function (e) {
                this._chartType = e.currentTarget.value;

                //---- CAREFULLY modify plot to match requested this._chartType (keep all this._mappings) ----
                this.clearLayers();
                this.shapesEnterFromBottom(false);

                if (this._chartType == "Column") {
                    this.appendLayer(vp.layers.createColumn());
                } else if (this._chartType == "Bar") {
                    this.shapesEnterFromBottom(true);
                    this.appendLayer(vp.layers.createBar());
                } else if (this._chartType == "Scatter") {
                    this.appendLayer(vp.layers.createPoint());
                } else if (this._chartType == "BoxPlot") {
                    this.appendLayer(vp.layers.createBoxPlot());
                }

                this.rebuildChart();
            };

            /// private: onMouseOver(e)
            plotClass.prototype.onMouseOver = function (e) {
                if (this._isHoverEnabled) {
                    var elem = e.target;
                    this._uiStateMgr.highlightShape(elem);

                    if (this._hoverCallback) {
                        var shapeId = elem.dataItem.key;
                        this._hoverCallback(shapeId);
                    }
                }
            };

            /// private: onMouseOut(e)
            plotClass.prototype.onMouseOut = function (e) {
                if (this._isHoverEnabled) {
                    this._uiStateMgr.resetHighlight();

                    if (this._hoverCallback) {
                        this._hoverCallback(-1);
                    }
                }
            };

            plotClass.prototype.onKeyChanged = function () {
                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];
                    layer.onKeyChanged();
                }
            };

            plotClass.prototype.onKey2Changed = function () {
                for (var i = 0; i < this._layers.length; i++) {
                    var layer = this._layers[i];
                    layer.onKey2Changed();
                }
            };

            plotClass.prototype.formatCol = function (record, colName, layer, seriesIndex) {
                //---- if "colName" is not a category-related column, apply default formatting ----
                var value = record[colName];

                if (layer) {
                    value = layer.formatValue(value, colName, seriesIndex);
                }

                return value;
            };

            //---- expand substrings of the form "@xxx@" (where "xxx" is a colName) using "record" ----
            plotClass.prototype.expandColumns = function (str, record, layer, seriesIndex) {
                var newStr = "";
                var startIndex = 0;

                var index = str.indexOf("@", startIndex);
                while (index > -1) {
                    //---- find end of symbol ----
                    var index2 = str.indexOf("@", index + 1);
                    if (index2 == -1) {
                        break;
                    }

                    var colName = str.substr(index + 1, index2 - (index + 1));
                    var value = record[colName];

                    var value = this.formatCol(record, colName, layer, seriesIndex);

                    //---- copy string between startIndex and index ----
                    var beforeStr = str.substr(startIndex, index - startIndex);

                    newStr += beforeStr;
                    newStr += value;

                    startIndex = index2 + 1;
                    index = str.indexOf("@", startIndex);
                }

                //---- copy remainder of string ----
                newStr += str.substr(startIndex);

                return newStr;
            };

            plotClass.prototype.buildToolTipHelper = function (elem) {
                var layer = (this._layers.length) ? this._layers[0] : null;
                var seriesIndex = vp.dom.shapeId(elem);

                return this.buildToolTip(elem, layer, seriesIndex);
            };

            /// private: buildToolTip(elem, layer, seriesIndex)
            ///
            /// this builds a this._tooltip for the plot by interpreting "tooltipContext" in one of the following forms:
            ///     undefined    => no this._tooltip content to be shown
            ///     null         => build a list of all name/value pairs for each column
            ///     string (comma separate list of col names)   => build list of name/value pairs
            ///     array of name/value objects   => build list of name/value pairs (expanding @xxx@ as values of a colName)
            ///
            /// the column names correspond to the record in elem.dataItem.record
            ///
            /// TOOLTIP DESIGN:
            ///     "tooltipContext" is built by plotClass from the layer's "toolTipCols" property.  Most this._layers default
            ///     this value to "undefined".  The caller can set this property on the layer
            ///     to explictly control the name/value content of the this._tooltip.
            ///
            ///     Note that this name/value formatting of the information in a dataGrid visual component
            ///     cannot currently be overridden (caller can control the content but not the format).
            ///
            ///     TODO: we should allow the caller to specify a callback function that completely
            ///     builds the HTML content to be shown.
            ///
            ///     The this._tooltip processing code looks for an element (or one of its parents) with the property
            ///     "toolTipContext" defined.  This context (see above) is used with the element's data
            ///     (defined in elem.dataItem), to build the contents of the this._tooltip.
            ///
            ///     note that "elem.dataItem" is normally set by the dataAnimMgr component, when it creates each element.
            ///
            plotClass.prototype.buildToolTip = function (elem, layer, seriesIndex) {
                var showIt = false;

                if (this._isUiEnabled) {
                    if (vp.utils.isDefined(elem.toolTipContext)) {
                        //---- in new scheme, we look for a string of column numbers to display ----
                        //---- empty string means, display all columns.  data comes from elem.dataItem ----
                        if ((elem.dataItem) && (elem.dataItem.data)) {
                            var context = elem.toolTipContext;
                            var record = elem.dataItem.data;
                            var rows = [];

                            if (false) {
                                ////---- caller takes over the complete tooltip contents ----
                                //var str = this._toolTipFormatter(record, layer, seriesIndex);
                                //vp.dom.title(elem, str);
                            } else if ((context === null) || (context == true) || (vp.utils.isString(context))) {
                                var parts = (vp.utils.isString(context)) ? context.split(",") : vp.utils.keys(record);

                                for (var p = 0; p < parts.length; p++) {
                                    var part = parts[p].trim();

                                    if (vp.utils.isDefined(record[part])) {
                                        //---- include this field ----
                                        var value = this.formatCol(record, part, layer, seriesIndex);

                                        rows.push({ name: part + ":", value: value });
                                    }
                                }
                            } else if (vp.utils.isArray(context)) {
                                for (var i = 0; i < context.length; i++) {
                                    var pair = context[i];

                                    var newName = this.expandColumns(pair.name, record, layer, seriesIndex);
                                    var newValue = this.expandColumns(pair.value, record, layer, seriesIndex);

                                    var newPair = { name: newName, value: newValue };
                                    rows.push(newPair);
                                }
                            }

                            if (true) {
                                if (this._useStdTooltips) {
                                    //---- build the element's TITLE (STD this._tooltip)
                                    var str = "";
                                    for (var i = 0; i < rows.length; i++) {
                                        var pair = rows[i];

                                        if (str != "") {
                                            if ((vp.utils.isIE) && (vp.utils.isSvgElement(elem))) {
                                                str += ", "; // IE doesn't support line breaks for SVG elements
                                            } else {
                                                str += "\n"; // add a line break between each pair
                                            }
                                        }
                                        str += pair.name + " " + pair.value;
                                    }

                                    vp.dom.title(elem, str);
                                } else {
                                    //---- build the dataGrid (RICH this._tooltip) ----
                                    var dataGrid = this._tooltipDiv.clear().append(vp.visuals.createDataGrid());

                                    dataGrid.data(rows).showHdr(false).showDividers(false).showAltLines(false).boldFirstCol(true);
                                }
                            }

                            showIt = (!this._useStdTooltips);
                        }
                    }
                }

                return showIt;
            };

            ///// READONLY property: plotCanvas
            //plotCanvas()
            //{
            //    return vp.select(shapesDiv);
            //}
            /// public: this._frameMargins
            plotClass.prototype.frameMargins = function (value) {
                if (arguments.length == 0) {
                    return this._frameMargins;
                }

                this._frameMargins = value;
                this.markRebuildNeeded();

                return this;
            };

            /// public: this._selectCallback
            plotClass.prototype.selectCallback = function (value) {
                if (arguments.length == 0) {
                    return this._selectCallback;
                }

                this._selectCallback = value;
                if (this._uiStateMgr) {
                    this._uiStateMgr.selectCallback(value);
                }

                return this;
            };

            /// public: hoverCallback
            plotClass.prototype.hoverCallback = function (value) {
                if (arguments.length == 0) {
                    return this._hoverCallback;
                }

                this._hoverCallback = value;

                return this;
            };

            /// public: this._rebuildCallback
            plotClass.prototype.rebuildCallback = function (value) {
                if (arguments.length == 0) {
                    return this._rebuildCallback;
                }

                this._rebuildCallback = value;

                return this;
            };
            return plotClass;
        })(vp.dom.singleWrapperSuperClass);
        visuals.plotClass = plotClass;

        function createPlot() {
            return new plotClass();
        }
        visuals.createPlot = createPlot;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//enum LabelFit
//{
//    /** Just draw all labels and let any overlaps happen */
//    drawAll,        // 0
//    /** Skip 0-N labels, as needed, to make the others fit without overlap */
//    skip,           // 1
//    /** Truncate labels, as needed, so that they don't exceed their available space. */
//    truncate,       // 2
//    /** If all labels cannot be drawn without overlap, rotate the labels 45 degrees to allow them to fit better. */
//    rotate45,       // 3
//    /** If all labels cannot be drawn without overlap, rotate the labels 90 degrees to allow them to fit better. */
//    rotate90,       // 4
//    /** If all labels cannot be drawn without overlap, rotate the labels 45 or 90 degrees to allow them to fit better. */
//    rotateAuto,     // 5
//    /** If all labels cannot be drawn without overlap, hide them all. */
//    hideAll,        // 6
//};
//# sourceMappingURL=plot.js.map

///----------------------------------------------------------------
/// (from visuals\slider.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// slider.ts.  Copyright (c) 2012 Microsoft Corporation.
///             Part of the vuePlot library - a slider control.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see slider.html
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        /** A slider control.  The slider slides between min and max values, by increment. */
        var sliderClass = (function (_super) {
            __extends(sliderClass, _super);
            function sliderClass(isVertical) {
                _super.call(this, null);
                this.ctr = "vp.visuals.slider";
                //---- private state ----
                this._min = 0;
                this._max = 100;
                this._increment = undefined;
                //_actualIncrement = undefined;
                this._value = undefined;
                this._domElement = null;
                this._sliderTrack = null;
                this._sliderThumb = null;
                this._isVertical = false;
                //---- proxies for capture/release ----
                this._cbMouseUp = null;
                this._cbMouseMove = null;
                this._changeListeners = [];
                this._toggleListeners = [];
                this._mouseDownX = 0;
                this._mouseDownY = 0;
                this._isMovingThumb = false;
                this._isMouseDown = false;
                this._mouseDownTime = 0;
                this._lastMouseDoc = { x: 0, y: 0 };
                this._movedByUser = false;
                this._valueChangedDuringTouch = null;
                this._trackHeight = 0;
                this._trackWidth = 0;
                this._thumbWidth = 0;
                this._thumbHeight = 0;
                this._timer = null;
                this._changingSizes = false;
                this._isEnabled = true;

                this._isVertical = isVertical;

                this.build();
            }
            sliderClass.prototype.update = function () {
                if (this._timer != null) {
                    clearTimeout(this._timer);
                    this._timer = null;
                }

                this.setValue(this._value, true);
            };

            //---- private: build() ----
            sliderClass.prototype.build = function () {
                var _this = this;
                if (!this._domElement) {
                    this._domElement = vp.dom.createSvg("svg");
                    this.elem = this._domElement;

                    //---- add a property on element to get access to control (closure object) ----
                    this._domElement.control = this;

                    vp.events.attach(this._domElement, "resize", vp.utils.cb(this, this.onBoundariesChanged));
                }

                /// Note: non-IE browsers don't like SVG elements that go outside the boundaries of the SVG document
                /// (they get chopped off), so make sure we layout everything WITHIN the {0, 0, width, height} bounds.
                if (this._value === undefined) {
                    this._value = this._min;
                }

                var root = vp.select(this._domElement).clear();

                this._sliderTrack = root.append("rect").addClass("sliderTrack").id("sliderTrack").bounds(0, 0, 50, 4).attr("rx", 3).attr("ry", 3);

                this._sliderThumb = root.append("rect").addClass("sliderThumb").id("sliderThumb").bounds(0, 0, 8, 16).attr("rx", 2).attr("ry", 2);

                if (this._isVertical) {
                    this.setThumbSize(16, 8);
                    this.setTrackHeight(50);
                    this.setTrackWidth(4);
                } else {
                    this.setThumbSize(8, 16);
                    this.setTrackHeight(4);
                }

                //---- event strategy: hook mouseenter/exit to know when to enable the "mousedown" event handler, using
                //---- the "capture" flag of event listener to get priority access (during capture phase) to event.  ----
                root.attach("mouseover", function (e) {
                    if (_this._isEnabled) {
                        root.attach("mousedown", vp.utils.cb(_this, _this.onMouseDown), true);
                    }
                });

                root.attach("mouseout", function (e) {
                    if (_this._isEnabled) {
                        root.detach("mousedown", vp.utils.cb(_this, _this.onMouseDown), true);
                    }
                });
                //if (this._increment === undefined)
                //{
                //    var diff = this._max - this._min;
                //    this._actualIncrement = (diff == 0) ? 0 : diff / 100;
                //}
                //else
                //{
                //    this._actualIncrement = this._increment;
                //}
                //---- use "touch" instead of "mouse" events (works better across devices) ----
                //---- in order to approximate "capture" behavior, we hook the document & ensure mousedown is on sliderThumb ----
                //vp.touchEventHandler(document.body, onMouseDown, onMouseMove, onMouseUp);
                //vp.touchEventHandler(domElement, onMouseDown, null, null);
            };

            sliderClass.prototype.element = function () {
                return this._domElement;
            };

            sliderClass.prototype.sliderThumb = function () {
                return this._sliderThumb;
            };

            sliderClass.prototype.sliderTrack = function () {
                return this._sliderTrack;
            };

            /// private: setValue().
            sliderClass.prototype.setValue = function (newValue, force) {
                //---- round value to nearest increment ----
                if (this._increment !== undefined) {
                    newValue = this._increment * Math.round(newValue / this._increment);
                }

                //---- adjust value so its within limits ----
                if (this._min < this._max) {
                    if (newValue < this._min) {
                        newValue = this._min;
                    } else if (newValue > this._max) {
                        newValue = this._max;
                    }
                } else {
                    if (newValue > this._min) {
                        newValue = this._min;
                    } else if (newValue < this._max) {
                        newValue = this._max;
                    }
                }

                if ((force) || (newValue != this._value)) {
                    //vp.utils.debug("sliderValue=" + newValue);
                    this._value = newValue;

                    if (force) {
                        if (this._isVertical) {
                            var top = 0;
                            var trackHeight = this._sliderTrack.height();
                            var bottom = trackHeight - this._thumbHeight;

                            var yValue = vp.utils.mapValue(this._value, this._min, this._max, top, bottom);

                            //---- move thumb ----
                            this._sliderThumb.attr("y", yValue);
                        } else {
                            var left = 0;
                            var trackWidth = this._sliderTrack.width();
                            var right = trackWidth - this._thumbWidth;

                            var xValue = vp.utils.mapValue(this._value, this._min, this._max, left, right);

                            //---- move thumb ----
                            this._sliderThumb.attr("x", xValue);
                        }
                    }

                    //---- call event listeners ----
                    this.onChange();
                }
            };

            /// private: markUpdateNeeded().
            sliderClass.prototype.markUpdateNeeded = function () {
                if (this._timer == null) {
                    setTimeout(vp.utils.cb(this, this.update), 1);
                }
            };

            /// private: onChange().
            sliderClass.prototype.onChange = function () {
                //---- create a simplified event object ----
                var evt = { src: this, value: this._value };

                for (var i = 0; i < this._changeListeners.length; i++) {
                    var callback = this._changeListeners[i];

                    callback(evt);
                }
            };

            /// private: onToggle().
            sliderClass.prototype.onToggle = function () {
                //---- create a simplified event object ----
                var evt = { src: this, value: this._value };

                for (var i = 0; i < this._toggleListeners.length; i++) {
                    var callback = this._toggleListeners[i];

                    callback(evt);
                }
            };

            //---- function: attach() ----
            sliderClass.prototype.attach = function (eventName, callback, useCapture) {
                if (eventName.toLowerCase() == "change") {
                    this._changeListeners.push(callback);
                } else if (eventName.toLowerCase() == "toggle") {
                    this._toggleListeners.push(callback);
                } else {
                    //---- defer to the domElement for other events ----
                    // CHW: delegate to global attach function
                    vp.events.attach(this._domElement, eventName, callback, useCapture);
                }

                return this;
            };

            //---- function: detach() ----
            sliderClass.prototype.detach = function (eventName, callback) {
                if (eventName.toLowerCase() == "change") {
                    this._changeListeners.remove(callback);
                } else if (eventName.toLowerCase() == "toggle") {
                    this._toggleListeners.remove(callback);
                } else {
                    //---- defer to the domElement for other events ----
                    // CHW: delegate to global deattach function
                    vp.events.detach(this._domElement, eventName, callback);
                }

                return this;
            };

            /// private: onMouseMove().
            sliderClass.prototype.onMouseMove = function (e) {
                //vp.utils.debug("vpslider.onMouseMove: e.type=" + e.type);
                //vp.utils.debug("onMouseMove: isMouseDown=" + isMouseDown);
                var mouseDoc = vp.events.mousePosition(e);

                if (this._isMouseDown) {
                    if (!this._isMovingThumb) {
                        //---- have we gone far enough or waited long enough? ----
                        var delta = Date.now() - this._mouseDownTime;
                        if (delta > 100) {
                            this._isMovingThumb = true;
                        } else {
                            var xdiff = Math.abs(mouseDoc.x - this._lastMouseDoc.x);
                            var ydiff = Math.abs(mouseDoc.y - this._lastMouseDoc.y);

                            if ((xdiff >= 4) || (ydiff >= 4)) {
                                this._isMovingThumb = true;
                            }
                        }
                    }

                    if (this._isMovingThumb) {
                        this._movedByUser = true;
                        this._valueChangedDuringTouch = true;

                        //---- goal is to set new X location for THUMB (relative to our local svg document) ----
                        //---- "doc" variables here refer to coordinates relative to main document origin ----
                        //---- "svg" variables here refer to coordinates relative to local svg document ----
                        //---- compute mouse location relative to my svg document ----
                        var newValue = 0;

                        if (this._isVertical) {
                            var mouseYDoc = mouseDoc.y;

                            var newYDoc = mouseYDoc - this._mouseDownY;
                            var newYSvg = newYDoc - vp.dom.docOffset(this._sliderTrack[0]).top;

                            var topSvg = 0;
                            var trackHeighth = this._sliderTrack.height();
                            var bottomSvg = topSvg + this._trackHeight - this._thumbHeight;

                            if (newYSvg < topSvg) {
                                newYSvg = topSvg;
                            } else if (newYSvg > bottomSvg) {
                                newYSvg = bottomSvg;
                            }

                            //---- move thumb ----
                            this._sliderThumb.attr("y", newYSvg);

                            newValue = vp.utils.mapValue(newYSvg, topSvg, bottomSvg, this._min, this._max);
                        } else {
                            var mouseXDoc = mouseDoc.x;

                            var newXDoc = mouseXDoc - this._mouseDownX;
                            var newXSvg = newXDoc - vp.dom.docOffset(this._sliderTrack[0]).left;

                            var leftSvg = 0;
                            var trackWidth = this._sliderTrack.width();
                            var rightSvg = leftSvg + trackWidth - this._thumbWidth;

                            if (newXSvg < leftSvg) {
                                newXSvg = leftSvg;
                            } else if (newXSvg > rightSvg) {
                                newXSvg = rightSvg;
                            }

                            //---- move thumb ----
                            this._sliderThumb.attr("x", newXSvg);

                            newValue = vp.utils.mapValue(newXSvg, leftSvg, rightSvg, this._min, this._max);
                        }

                        this.setValue(newValue, false);
                        //                e.cancelBubble = true;
                        //                e.stopPropagation();
                        //                e.returnValue = false;
                    }
                }

                this._lastMouseDoc = mouseDoc;
            };

            /// private: onMouseUp().
            sliderClass.prototype.onMouseUp = function (e) {
                this._isMovingThumb = false;
                this._isMouseDown = false;

                vp.events.releaseCapture(document.body, e, this._cbMouseMove, this._cbMouseUp);

                if (this._valueChangedDuringTouch === false) {
                    //---- trigger the TOGGLE event ----
                    this.onToggle();
                }
            };

            /// private: onMouseDown().
            sliderClass.prototype.onMouseDown = function (e) {
                var pos = vp.events.mousePosition(e);
                var elem = vp.events.elementFromPoint(pos.x, pos.y);
                var captureMouseForMove = false;

                if (elem === this._sliderThumb[0]) {
                    this._isMouseDown = true;
                    this._mouseDownTime = Date.now();

                    vp.utils.debug("onMouseDown: isMouseDown=" + this._isMouseDown);

                    //---- compute mouse location relative to my the THUMB ----
                    var thumbXRelToDoc = vp.dom.docOffset(elem).left;
                    var thumbYRelToDoc = vp.dom.docOffset(elem).top;

                    var mouseXRelToDoc = vp.events.mousePosition(e).x;
                    var mouseYRelToDoc = vp.events.mousePosition(e).y;

                    this._mouseDownX = mouseXRelToDoc - thumbXRelToDoc;
                    this._mouseDownY = mouseYRelToDoc - thumbYRelToDoc;

                    this._valueChangedDuringTouch = false;

                    this._cbMouseMove = vp.utils.cb(this, this.onMouseMove);
                    this._cbMouseUp = vp.utils.cb(this, this.onMouseUp);

                    vp.events.setCapture(document.body, e, this._cbMouseMove, this._cbMouseUp);
                } else if (elem == this._sliderTrack) {
                    this._valueChangedDuringTouch = false;
                } else {
                    //---- do not trigger a TOGGLE event if outside of our slider ----
                    this._valueChangedDuringTouch = true;
                }

                return false;
            };

            /// private: setThumbSize().
            sliderClass.prototype.setThumbSize = function (width, height) {
                this._thumbWidth = width;
                this._thumbHeight = height;

                this._sliderThumb.width(width).height(height);

                this.onSizesChanged();
            };

            /// private setTrackHeight().
            sliderClass.prototype.setTrackHeight = function (value) {
                this._trackHeight = value;
                this._sliderTrack.attr("height", value);
                this._domElement.setAttribute("height", value + 4); // for Safari (wants width/height)

                this.onSizesChanged();
            };

            /// private setTrackWidth().
            sliderClass.prototype.setTrackWidth = function (value) {
                this._trackWidth = value;
                this._sliderTrack.attr("width", value);
                this._domElement.setAttribute("width", value + 4); // for Safari (wants width/height)

                this.onSizesChanged();
            };

            sliderClass.prototype.onBoundariesChanged = function () {
                if (!this._changingSizes) {
                    if (this._isVertical) {
                        var height = vp.dom.height(this._domElement);
                        this.setTrackHeight(height);
                    } else {
                        var width = vp.dom.width(this._domElement);
                        this.setTrackWidth(width);
                    }
                }
            };

            //---- private: onSizesChanged().
            sliderClass.prototype.onSizesChanged = function () {
                this._changingSizes = true;

                if (this._isVertical) {
                    this._sliderTrack.attr("x", this._thumbWidth / 2 - this._trackWidth / 2);

                    this._sliderThumb.attr("x", 0);
                } else {
                    this._sliderTrack.attr("y", this._thumbHeight / 2 - this._trackHeight / 2);

                    this._sliderThumb.attr("y", 0);
                }

                if (this._isVertical) {
                    var w = Math.max(this._trackWidth, this._thumbWidth);

                    //---- add +1 to avoid truncation due to pixel misalignment ----
                    vp.dom.width(this._domElement, w + 1);
                    vp.dom.height(this._domElement, this._trackHeight + 1);
                } else {
                    var h = Math.max(this._trackHeight, this._thumbHeight);

                    //---- add +1 to avoid truncation due to pixel misalignment ----
                    vp.dom.width(this._domElement, this._trackWidth + 1);
                    vp.dom.height(this._domElement, h + 1);
                }

                this._changingSizes = false;
            };

            //---- property: min ----
            sliderClass.prototype.min = function (value) {
                if (value === undefined) {
                    return this._min;
                }

                this._min = value;
                this.markUpdateNeeded();
                return this;
            };

            //---- property: max ----
            sliderClass.prototype.max = function (value) {
                if (value === undefined) {
                    return this._max;
                }

                this._max = value;
                this.markUpdateNeeded();
                return this;
            };

            sliderClass.prototype.value = function (actualValue) {
                if (actualValue === undefined) {
                    return this._value;
                }

                //value = actualValue;
                //markUpdateNeeded();
                this.setValue(actualValue, true);
                return this;
            };

            //---- property: increment ----
            sliderClass.prototype.increment = function (value) {
                if (value === undefined) {
                    return this._increment;
                }

                this._increment = value;
                this.markUpdateNeeded();
                return this;
            };

            //---- property: isEnabled ----
            sliderClass.prototype.isEnabled = function (value) {
                if (value === undefined) {
                    return this._isEnabled;
                }

                this._isEnabled = value;

                if (this._isEnabled) {
                    this._domElement.style.opacity = "1";
                } else {
                    this._domElement.style.opacity = ".5";
                }

                this.markUpdateNeeded();
                return this;
            };

            //---- property: trackHeight ----
            sliderClass.prototype.trackHeight = function (value) {
                if (value === undefined) {
                    return this._trackHeight;
                }

                this.setTrackHeight(value);
                return this;
            };

            //---- property: trackWidth ----
            sliderClass.prototype.trackWidth = function (value) {
                if (value === undefined) {
                    return this._trackWidth;
                }

                this.setTrackWidth(value);
                return this;
            };

            //---- property: thumbWidth ----
            sliderClass.prototype.thumbWidth = function (value) {
                if (value === undefined) {
                    return this._thumbWidth;
                }

                this.setThumbSize(value, this._thumbHeight);
                return this;
            };

            //---- property: thumbHeight ----
            sliderClass.prototype.thumbHeight = function (value) {
                if (value === undefined) {
                    return this._thumbHeight;
                }

                this.setThumbSize(this._thumbWidth, value);
                return this;
            };
            return sliderClass;
        })(vp.dom.singleWrapperSuperClass);
        visuals.sliderClass = sliderClass;

        function createVerticalSlider() {
            return new sliderClass(true);
        }
        visuals.createVerticalSlider = createVerticalSlider;

        function createHorizontalSlider() {
            return new sliderClass(false);
        }
        visuals.createHorizontalSlider = createHorizontalSlider;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=slider.js.map

///----------------------------------------------------------------
/// (from visuals\timeSlicer.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// timeSlicer.ts.  Copyright (c) 2012 Microsoft Corporation.
///    Part of the vuePlot library - creates a control to cut data into "slices" that can be scrolled thru or played back.
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var vp;
(function (vp) {
    (function (visuals) {
        /** Creates a control to cut data into "slices" that can be scrolled thru or played back. */
        var timeSlicerClass = (function (_super) {
            __extends(timeSlicerClass, _super);
            function timeSlicerClass() {
                var _this = this;
                _super.call(this, null);
                this.ctr = "vp.visuals.timeSlicerClass";
                //---- other variables ----
                this._buildNeeded = false;
                this._buildTimer = null;
                this._padding = 2;
                this._sliceIndex = -1;
                this._ignoreSliderChanges = true;
                this._sliceDuration = 1000;
                this._playTimer = null;
                //---- constants ----
                this._stoppedImage = "../images/RightArrowFilled.png";
                this._playingImage = "../images/RightArrowEmpty.png";
                this.rootElement = function () {
                    //---- ensure element is ready when we give it to caller ----
                    //if (this._buildNeeded)
                    //{
                    //    this.build();
                    //}
                    return this._rootElement;
                };
                //---- property: timeColumn ----
                this.timeColumn = function (value) {
                    if (value === undefined) {
                        return this._timeColumn;
                    }

                    this._timeColumn = value;
                    this.markBuildNeeded();

                    return this;
                };
                //---- property: sliceDuration ----
                this.sliceDuration = function (value) {
                    if (value === undefined) {
                        return this._timeSlice;
                    }

                    this._timeSlice = value;
                    this.markBuildNeeded();

                    return this;
                };

                //---- create CONTROLS ----
                var rootElem = vp.dom.createHtml("div");
                this._rootElement = rootElem;

                this._root = vp.select(this._rootElement).setClass("timeSlicer").css("position", "relative");

                rootElem.control = this;
                this.element(rootElem); // set wrapper root element

                vp.events.attach(rootElem, "resize", function (e) {
                    return _this.markBuildNeeded();
                });

                this._image = this._root.append("img").attach("click", function (e) {
                    return _this.togglePlay();
                });

                this._image.setClass("timeSlicerPlay").attr("src", this._stoppedImage);

                this._slider = this._root.append(vp.visuals.createHorizontalSlider()).setClass("timeSlicerSlider").thumbHeight(26).thumbWidth(16).trackHeight(4).width(60).attach("change", function (e) {
                    return _this.onSliderChanged();
                });

                this._keySpan = this._root.append("span").setClass("timeSlicerLabel");

                //---- get initial size, etc. ----
                this.markBuildNeeded();
            }
            timeSlicerClass.prototype.onSliderChanged = function () {
                if (!this._ignoreSliderChanges) {
                    var index = +this._slider.value();
                    this.setDataSlice(index);
                }
            };

            timeSlicerClass.prototype.togglePlay = function () {
                if (this._slices) {
                    if (this._playTimer) {
                        this.stop();
                    } else {
                        if (this._sliceIndex == this._slices.length - 1) {
                            this._sliceIndex = -1;
                        }

                        this.play();
                    }
                }
            };

            timeSlicerClass.prototype.play = function () {
                var _this = this;
                if (this._slices && this._slices.length) {
                    var index = this._sliceIndex + 1;
                    if (index < this._slices.length) {
                        this.setDataSlice(index);

                        this._playTimer = setTimeout(function (e) {
                            return _this.play();
                        }, this._sliceDuration);
                        this._image.attr("src", this._playingImage);
                    }
                }

                return this;
            };

            timeSlicerClass.prototype.stop = function () {
                if (this._playTimer) {
                    clearTimeout(this._playTimer);
                    this._playTimer = null;

                    this._image.attr("src", this._stoppedImage);
                }

                return this;
            };

            timeSlicerClass.prototype.markBuildNeeded = function () {
                var _this = this;
                if (this._buildTimer) {
                    clearTimeout(this._buildTimer);
                }

                this._buildTimer = setTimeout(function (e) {
                    return _this.build();
                }, 25);
            };

            timeSlicerClass.prototype.hookOnChange = function (callback) {
                this._onChangeCallback = callback;
                return this;
            };

            timeSlicerClass.prototype.getDataSlice = function () {
                return this._dataSlice;
            };

            timeSlicerClass.prototype.getDataKey = function () {
                return this._sliceKey;
            };

            /** Called primarily after RESIZE of dataGrid control has occured. */
            timeSlicerClass.prototype.build = function () {
                this._buildTimer = null;
                this._slices = null;
                this._sliceIndex = -1;
                this._dataSlice = null;

                var data = this._data;
                var colName = this._timeColumn;

                if (data && data.length && colName && colName.length) {
                    this._slices = data.groupBy(colName);
                    var sliceCount = this._slices.length;

                    this._slider.min(0).max(sliceCount - 1).increment(1);
                }

                this.setDataSlice(0);
            };

            timeSlicerClass.prototype.setDataSlice = function (index) {
                this._ignoreSliderChanges = true;

                this._sliceIndex = index;
                this._dataSlice = this._slices[index].values;
                this._sliceKey = this._slices[index].key;

                this._keySpan.text(this._sliceKey);

                if (this._onChangeCallback) {
                    this._onChangeCallback(this);
                }

                if (this._playTimer) {
                    //---- move the slider ----
                    this._slider.value(index);
                }

                this._ignoreSliderChanges = false;
            };

            timeSlicerClass.prototype.data = function (value) {
                if (value === undefined) {
                    return this._data;
                }

                this._data = value;
                this.markBuildNeeded();

                return this;
            };
            return timeSlicerClass;
        })(vp.dom.singleWrapperSuperClass);
        visuals.timeSlicerClass = timeSlicerClass;

        function createTimeSlicer() {
            return new timeSlicerClass();
        }
        visuals.createTimeSlicer = createTimeSlicer;
    })(vp.visuals || (vp.visuals = {}));
    var visuals = vp.visuals;
})(vp || (vp = {}));
//# sourceMappingURL=timeSlicer.js.map
///-----------------------------------------------------------------------------------------------------------------
/// alignBox.js.  Copyright (c) 2012 Microsoft Corporation.
///    This file is part of the VuePlot library.  It aligns and rotate its child correctly (vs. HTML)
///    according to these custom properties:
///
///         - halign
///         - valign
///         - rotation
///-----------------------------------------------------------------------------------------------------------------
/// testing: see alignBox.html
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.alignBox = function ()
{
    //---- private state ----
    var halign = "center";
    var valign = "center";
    var rotation = 0;
    var applyChildWidth = false;

    var rootElement = vp.dom.createHtml("div");
    var root = vp.select(rootElement);
    var timer = null;
    var firstChild = null;

    //---- closure ----
    var closure = function()
    {
    }

    closure.layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }

        var kids = root.kids();
        var rootWidth = root.width();
        var rootHeight = root.height();
        
        //---- layout single child ----
        if (kids.length > 0)
        {
            var unwrappedElem = kids[0];
            var elem = (unwrappedElem.length) ? unwrappedElem : vp.select(unwrappedElem);

            var sizes = elem.elementSizes();

            var borderWidth = sizes.borderWidth;
            var borderHeight = sizes.borderHeight;

            var paddingWidth = sizes.paddingWidth;
            var paddingHeight = sizes.paddingHeight;

            var marginWidth = sizes.marginWidth;
            var marginHeighth = sizes.marginHeight;

            //---- HTML is confusing here: ----
            //---- RETURNED size includes padding but NOT border ----
            var elemWidth = sizes.width;        // + borderWidth;
            var elemHeight = sizes.height;  //  + borderHeight;

            //---- calc LEFT ----
            var left = 0;
            if ((halign == "center") || (halign == "middle"))
            {
                left = rootWidth / 2 - elemWidth / 2;
            }
            else if (halign == "right")
            {
                left = rootWidth - elemWidth;
            }

            //---- calc TOP ----
            var top = 0;
            if ((valign == "center") || (valign == "middle"))
            {
                top = rootHeight / 2 - elemHeight / 2;
            }
            else if (valign == "bottom")
            {
                top = rootHeight - elemHeight;
            }

            //---- set LEFT, TOP ----
            elem.absPosition(left, top);

            //---- pass rotation thru to elem ----
            elem.transform("rotate(" + rotation + "deg)");
        }

        //applyChildWidthNow();

    };

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "valign");
        vp.makeControlProperty(wrapper, "halign");
        vp.makeControlProperty(wrapper, "rotation");
        vp.makeControlProperty(wrapper, "applyChildWidth");
    };

    var initFirstChild = function ()
    {
        var elem = null;

        var kids = root.kids();
        if (kids.length > 0)
        {
            elem = kids[0];
        }

        if (elem != firstChild)     // changed
        {
            if (firstChild)
            {
                vp.events.detach(firstChild, "resize", applyChildWidthNow);
            }

            firstChild = elem;

            if (firstChild)
            {
                vp.events.attach(firstChild, "resize", applyChildWidthNow);
            }
        }
    }

    var applyChildWidthNow = function()
    {
        initFirstChild();

        if ((applyChildWidth) && (firstChild))
        {
            var sizes = vp.elementSizes(firstChild);

            //---- include marginWidth + border + padding ----
            var width =  sizes.width + sizes.borderWidth + sizes.paddingWidth;        // + marginWidth);

            //---- set width of alignBox to width of first child ----
            root.width(width);
        }
    };

    var initialBuild = function()
    {
        root
            .setClass("alignBox")
            .css("position", "relative")    // so it can hold absolute position elements
            .attach("resize", markLayoutNeeded)
            .attach("DOMNodeInserted", nodeAddOrDelete)
            .attach("DOMNodeRemoved", nodeAddOrDelete);

        markLayoutNeeded();
    }

    closure.ctr = "vp.visuals.alignBox";
    rootElement.control = closure;

    var nodeAddOrDelete = function (e)
    {
        applyChildWidthNow();

        markLayoutNeeded();
    };

    var markLayoutNeeded = function()
    {
        if (!timer)
        {
            timer = setTimeout(closure.layout, 1);
        }

        closure.layout();
    }

    closure.element = function ()
    {
        //---- ensure element is ready when we give it to caller ----
        if (timer)
        {
            closure.layout();
        }

        return rootElement;
    };

    //---- property: halign ----
    closure.halign = function (value)
    {
        if (value === undefined)
        {
            return halign;
        }

        halign = value;
        markLayoutNeeded();

        return this;
    };

    //---- property: valign ----
    closure.valign = function (value)
    {
        if (value === undefined)
        {
            return valign;
        }

        valign = value;
        markLayoutNeeded();

        return this;
    };

    //---- property: rotation ----
    closure.rotation = function (value)
    {
        if (value === undefined)
        {
            return rotation;
        }

        rotation = value;
        markLayoutNeeded();

        return this;
    };

    //---- property: applyChildWidth ----
    closure.applyChildWidth = function (value)
    {
        if (value === undefined)
        {
            return applyChildWidth;
        }

        applyChildWidth = value;
        markLayoutNeeded();

        return this;
    };

    //---- init code ----
    initialBuild();

    //---- for controls, we return the HTML root ----
    return rootElement;
}



///----------------------------------------------------------------
/// (from visualParts\categoryAxis.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// categoryAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///                  Part of the vuePlot library - a category axis.  Can be used for left, top, right, bottom of plot.
///-----------------------------------------------------------------------------------------------------------------
/// create an SVG-based category axis control and return a closure object for it.
///
/// This represents a axis:
///     - axis line
///     - tick marks
///     - tick labels
///
/// Requirements:
///     - stretch to specified height
///     - output a minimum width
///     - base tickmarks & labels on its member scale
///     - hide tick marks if they exceed a maximum
///     - hide labels if not enough room
///     - provide optional label rotation
///
/// Css style-able elements:
///     - label: font, color
///     - tick mark: tickWidth, strokeWidth, stroke, strokeStyle
///     - axis line: strokeWidth, stroke, strokeStyle
///-----------------------------------------------------------------------------------------------------------------
/// testing: see categoryAxis.html
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.categoryAxis = function ()
{
    //---- private state ----
    var tickLength = 4;     // length of a tick mark
    var labelSpace = 3;     // space between tick and label
    var labelSizes = [];
    var labelStrings = [];
    var axisLocation = vp.axisLocation.left;
    var totalLabelWidths = 0;
    var totalLabelHeights = 0;
    var dataCount = 0;
    var isAxisVisible = true;

    var maxStringWidth = 0;
    var maxStringHeight = 0;
    var timer = null;
    var scale = vp.scales.createCategory();    // default
    var values = [];
    var changingSize = false;
    var formatter = undefined;

    //---- HTML elements ----
    var rootElem = null;
    var axisLine = null;
    var tickMarks = null;
    var labels = null;


    /// closure
    var closure = function ()
    {
    };

    closure.ctr = "vp.visuals.categoryAxis";

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "scale");
        vp.makeControlProperty(wrapper, "axisLocation");
        vp.makeControlProperty(wrapper, "values");
        vp.makeControlProperty(wrapper, "formatter");
        vp.makeControlProperty(wrapper, "isAxisVisible");
    };

    /// private: onDataChanged().
    var onDataChanged = function()
    {
        onTextChanged();
    }

    /// private: onTextChanged().
    var onTextChanged = function()
    {
        //buildLabelStringsAndSizes();
        markRebuildNeeded();
    }

    /// private.
    var markRebuildNeeded = function ()
    {
        if (timer == null)
        {
            timer = setTimeout(closure.build, 1);
        }
    };

    /// private.
    var pixelAlign = function (value)
    {
        //return Math.round(value);
        return value;   
    };

    /// private.
    var buildLabelStringsAndSizes = function (data)
    {
        labelSizes = [];
        labelStrings = [];
        maxStringWidth = 0;
        maxStringHeight = 0;
        totalLabelWidths = 0;
        totalLabelHeights = 0;
        dataCount = 0;

        //---- create a TEXT element for measuring strings ----
        var fakeLabel = vp.select(document.body)
            .append("span")
            .setClass("vpCategoryAxis_label");
            
        data.map(function (value, index)
        {
            var formatFunc = (formatter === undefined) ? vp.formatters.string : formatter;

            var labelStr = formatFunc(value);

            labelStrings.push(labelStr);

            //---- set up for measuring "labelStr" ----
            fakeLabel.text(labelStr);

            var width = Math.ceil(fakeLabel.width());
            var height = Math.ceil(fakeLabel.height());

            if (width > maxStringWidth)
            {
                maxStringWidth = width;
            }

            if (height > maxStringHeight)
            {
                maxStringHeight = height;
            }

            var sz = { width: width, height: height };
            labelSizes.push(sz);

            dataCount++;
        });

        totalLabelWidths = maxStringWidth * dataCount;
        totalLabelHeights = maxStringHeight * dataCount;

        //---- remove temp label created above ----
        fakeLabel.remove();
    }

    //---- private: build() ----
    closure.build = function ()
    {
        if (timer != null)
        {
            clearTimeout(timer);
            timer = null;
        }

        if (rootElem == null)
        {
            rootElem = vp.dom.createHtml("div");
            rootElem.control = closure;

            vp.dom.setClass(rootElem, "vpCategoryAxis");
            vp.events.attach(rootElem, "resize", elementResized);
        }

        var root = vp.select(rootElem)
            .clear();

        if ((isAxisVisible) && (scale != null) && (scale.count))
        {
            var min = 0;
            var max = scale.count();            // note this is count+1 for extra tick at the end
            var tickData = vp.utils.range(min, max, 1);

            var values = scale.values();
            var labelData = (values) ? values : vp.utils.range(min + 1, max, 1);     // labels have 1 less than ticks

            buildLabelStringsAndSizes(labelData);

            if ((axisLocation == vp.axisLocation.left) || (axisLocation == "left"))
            {
                buildLeftElements(root, min, max, tickData);
            }
            else if ((axisLocation == vp.axisLocation.right) || (axisLocation == "right"))
            {
                buildRightElements(root, min, max, tickData);
            }
            else if ((axisLocation == vp.axisLocation.top) || (axisLocation == "top"))
            {
                buildTopElements(root, min, max, tickData);
            }
            else if ((axisLocation == vp.axisLocation.bottom) || (axisLocation == "bottom"))
            {
                buildBottomElements(root, min, max, tickData);
            }
        }
    };

    var elementResized = function (e)
    {
        if (!changingSize)
        {
            //---- update auto range scale so dependent parts get correct scaling ----
            updateAutoRangeScale();
        }
    };

    var updateAutoRangeScale = function ()
    {
        var root = vp.select(rootElem);

        if ((axisLocation == vp.axisLocation.left) || (axisLocation == "left"))
        {
            calcHeightFromScale(root);
        }
        else if ((axisLocation == vp.axisLocation.right) || (axisLocation == "right"))
        {
            calcHeightFromScale(root);
        }
        else if ((axisLocation == vp.axisLocation.top) || (axisLocation == "top"))
        {
            calcWidthFromScale(root);
        }
        else if ((axisLocation == vp.axisLocation.bottom) || (axisLocation == "bottom"))
        {
            calcWidthFromScale(root);
        }

        markRebuildNeeded();
    };

    var setRootWidth = function (value)
    {
        changingSize = true;

        vp.dom.width(rootElem, value);

        changingSize = false;
    };

    var setRootHeight = function (value)
    {
        changingSize = true;

        vp.dom.height(rootElem, value);

        changingSize = false;
    };

    var calcHeightFromScale = function (root)
    {
        var height = 0;
        if (scale.autoRange())
        {
            height = root.height();

            scale.rangeMin(0);
            scale.rangeMax(height - 1);
        }
        else
        {
            height = scale.rangeMax() - scale.rangeMin();
        }

        return height;
    }

    var calcWidthFromScale = function (root)
    {
        var width = 0;
        if (scale.autoRange())
        {
            width = root.width();

            scale.rangeMin(0);
            scale.rangeMax(width - 1);
        }
        else
        {
            width = scale.rangeMax() - scale.rangeMin();
        }

        return width;
    }

    /// private: buildLeftElements()
    var buildLeftElements = function (root, min, max, data)
    {
        //---- HEIGHT ----
        var height = calcHeightFromScale(root);

        var showLabels = (totalLabelHeights < height);
        var showTicks = (scale.count() * 3 < height);

        //---- WIDTH ----
        var width = (showLabels) ? 1 + labelSpace + maxStringWidth + tickLength : 1 + tickLength;
        setRootWidth(width);

        var perHeight = (height-1) / scale.count();

        var x = pixelAlign(width - 1);
        var y1 = 0;
        var y2 = height - 1;

        //---- create the vertical axis line (for LEFT CATEGORY axis) ----
        axisLine = root.append("span")
                .absPosition(x, y1)
                .width(1)
                .height(y2 - y1 + 1)
                .setClass("vpCategoryAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.map(function (data, index)
            {
                var y = scale.tickOffset(index);

                var x1 = pixelAlign(width - tickLength - 1);
                var x2 = pixelAlign(width - 1);

                var tm = root.append("span")
                         .absPosition(x1, y)
                         .height(1)
                         .width(Math.abs(x2 - x1 + 1))
                         .setClass("vpCategoryAxis_tickMark");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            labels = labelStrings.map(function (data, index)
            {
                var labelWidth = labelSizes[index].width;

                var x = pixelAlign(width - tickLength - labelSpace - 1 - labelWidth);
                var y = scale.flipScale(index, -1);
                var dy = (scale.itemWidth() - maxStringHeight)/2 - 1;

                var labelStr = labelStrings[index];

                var span = root.append("span")
                         .absPosition(x, y + dy)
                         .text(labelStr)
                         .setClass("vpCategoryAxis_label");

                y += perHeight;

                return span;
            });
        }
    };

    /// private: buildRightElements()
    var buildRightElements = function (root, min, max, data)
    {
        //---- HEIGHT ----
        var height = calcHeightFromScale(root);

        var showLabels = (totalLabelHeights < height);
        var showTicks = (scale.count() * 3 < height);

        //---- WIDTH ----
        var width = (showLabels) ? 1 + labelSpace + maxStringWidth + tickLength : 1 + tickLength;
        setRootWidth(width);

        var perHeight = (height - 1) / scale.count();

        //---- create the vertical axis line ----
        axisLine = root.append("span")
                 .absPosition(0, 0)
                 .width(1)
                 .height(height)
                 .setClass("vpCategoryAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.map(function (data, index)
            {
                var y = scale.tickOffset(index);

                var x1 = pixelAlign(0);
                var x2 = pixelAlign(tickLength);

                var tm = root.append("span")
                         .absPosition(x1, y)
                         .height(1)
                         .width(Math.abs(x2 - x1 + 1))
                         .setClass("vpCategoryAxis_tickMark");

                var len = tm.css("tick-length");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            labels = labelStrings.map(function (data, index)
            {
                var x = tickLength + labelSpace;
                var y = scale.flipScale(index, -1);
                var dy = (scale.itemWidth() - maxStringHeight) / 2 - 1;

                var labelStr = labelStrings[index];

                var span = root.append("span")
                       .absPosition(x, y + dy)
                       .text(labelStr)
                       .setClass("vpCategoryAxis_label");

                return span;
            });
        }
    };

    /// private: buildTopElements()
    var buildTopElements = function (root, min, max, data)
    {
        //---- WIDTH ----
        var width = calcWidthFromScale(root);

        var showLabels = (totalLabelWidths < width);
        var showTicks = (scale.count() * 3 < width);

        //---- HEIGHT ----
        var fudgeFactor = 3;

        //---- for now, avoid "axis wars" by keeping top/bottom axis heights constants ----
        //var height = (showLabels) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;
        var height = (true) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;

        setRootHeight(height);

        var perWidth = (width-1) / scale.count();

        //---- create the horizontal axis line ----
        var x1 = 0;
        var x2 = width - 1;
        var y = height - 1;

        axisLine = root.append("span")
                .absPosition(x1, y)
                .height(1)
                .width(x2 - x1 + 1)
                .setClass("vpCategoryAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.map(function (data, index)
            {
                var x = scale.tickOffset(index);

                var y = height - 1;
                var y2 = height - tickLength - 1;

                var tm = root.append("span")
                        .absPosition(x, y2)
                        .width(1)
                        .height(y - y2 + 1)
                        .setClass("vpCategoryAxis_tickMark");

                var len = tm.css("tick-length");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            var x = perWidth / 2;
            labels = labelStrings.map(function (data, index)
            {
                var y = 0;
                var dx = labelSizes[index].width / 2;

                var labelStr = labelStrings[index];

                var span = root.append("span")
                       .absPosition(x - dx, y)
                       .text(labelStr)
                       .setClass("vpCategoryAxis_label");

                x += perWidth;

                return span;
            });
        }
    };

    /// private: buildBottomElements()
    var buildBottomElements = function (root, min, max, data)
    {
        //---- WIDTH ----
        var width = calcWidthFromScale(root);

        var showLabels = (totalLabelWidths < width);
        var showTicks = (scale.count() * 3 < width);

        //---- HEIGHT ----
        var fudgeFactor = 3;

        //---- for now, avoid "axis wars" by keeping top/bottom axis heights constants ----
        //var height = (showLabels) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;
        var height = (true) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;

        setRootHeight(height);

        var perWidth = (width - 1) / scale.count();

        //---- create the horizontal axis line ----
        var x1 = 0;
        var x2 = width - 1;
        var y = 0;

        axisLine = root.append("span")
               .absPosition(x1, y)
               .height(1)
               .width(x2 - x1 + 1)
               .setClass("vpCategoryAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.map(function (data, index)
            {
                var x = scale.tickOffset(index);

                var y = 0;
                var y2 = tickLength;

                var tm = root.append("span")
                    .absPosition(x, y)
                    .width(1)
                    .height(y2 - y + 1)
                    .setClass("vpCategoryAxis_tickMark");

                var len = tm.css("tick-length");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            var x = perWidth / 2;
            labels = labelStrings.map(function (data, index)
            {
                var y = 0 + tickLength + 2;
                var dx = labelSizes[index].width / 2;

                var labelStr = labelStrings[index];

                var span = root.append("span")
                       .absPosition(x - dx, y - 2)
                       .text(labelStr)
                       .setClass("vpCategoryAxis_label");

                x += perWidth;

                return span;
            });
        }
    };

    closure.element = function ()
    {
        return rootElem;
    };

    //---- property: scale ----
    closure.scale = function (value)
    {
        if (value === undefined)
        {
            return scale;
        }

        scale = value;
        updateAutoRangeScale();

        return closure;
    };

    //---- property: axisLocation ----
    closure.axisLocation = function (value)
    {
        if (value === undefined)
        {
            return axisLocation;
        }

        axisLocation = value;
        markRebuildNeeded();

        return closure;
    };

    //---- property: values ----
    closure.values = function (value)
    {
        if (value === undefined)
        {
            return values;
        }

        values = value;
        markRebuildNeeded();

        return closure;
    };

    //---- property: formatter ----
    closure.formatter = function (value)
    {
        if (value === undefined)
        {
            return formatter;
        }

        formatter = value;
        markRebuildNeeded();

        return closure;
    };

    //---- property: isAxisVisible ----
    closure.isAxisVisible = function (value)
    {
        if (value === undefined)
        {
            return isAxisVisible;
        }

        isAxisVisible = value;
        markRebuildNeeded();

        return this;
    };

    closure.build();            // create "rootElem" now so we have something to return

    return rootElem;
};

///----------------------------------------------------------------
/// (from visualParts\dockPanel.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// dockPanel.js.  Copyright (c) 2012 Microsoft Corporation.
///    This file is part of the VuePlot library.  It implements a docking container.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see colorPalette.html
///-----------------------------------------------------------------------------------------------------------------

/// dockPanel - a container whose children have a docType (top/left/right/bottom/fill) attribute.
vp.visuals.dockPanelFactory = function ()
{
    //---- private state ----
    var data = null;
    var rootElement = vp.dom.createHtml("div");
    var root = vp.select(rootElement);
    var layoutNeeded = false;
    var dockLayout = null;
    var legendData = [];
    var timer = null;
    var layoutListeners = [];
    var conseqLayoutCount = 0;
    var isLayingOut = false;

    //---- closure ----
    var closure = function ()
    {
    };

    /// public: layout()
    closure.layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }
        layoutNeeded = false;
        isLayingOut = true;

        var kids = root.kids();

        var width = root.width();
        var height = root.height();

        dockLayout = vp.layouts.createDock()
             .width(width)
             .height(height)

        vp.utils.debug("dockPanel: layout of children");

        //---- FIRST PASS - add each child to layout ----
        kids.each(function (index, unwrappedElem)
        {
            //---- temp: wrap until all callbacks pass elems as wrapped ----
            var elem = (unwrappedElem.length) ? unwrappedElem : vp.select(unwrappedElem);

            var sizes = elem.elementSizes();

            var borderWidth = sizes.borderWidth;
            var borderHeight = sizes.borderHeight;

            //---- HTML is confusing here: ----
            //---- RETURNED size includes padding but NOT border ----
            var totalWidth = sizes.width + borderWidth;
            var totalHeight = sizes.height + borderHeight;

            var dockType = elem.attr("dockType");
            var isAxis = elem.attr("isAxis");

            var isVisible = (elem.css("display") != "none");

            //dockLayout.addChild(totalWidth, totalHeight, dockType, isAxis, isVisible);
        //});

        ////---- SECOND PASS: now get and APPLY layout bounds for each child ----
        //kids.each(function (index, unwrappedElem)
        //{
            //---- temp: wrap until all callbacks pass elems as wrapped ----
            var elem = (unwrappedElem.length) ? unwrappedElem : vp.select(unwrappedElem);

            //---- skip the invisible elements ----
            var isVisible = (elem.css("display") != "none");
            if (isVisible)
            {
                //var bounds = dockLayout.getBoundsByIndex(index);
                var bounds = dockLayout.getBounds(totalWidth, totalHeight, dockType);
                var sizes = elem.elementSizes();

                var borderWidth = sizes.borderWidth;
                var borderHeight = sizes.borderHeight;

                var paddingWidth = sizes.paddingWidth;
                var paddingHeight = sizes.paddingHeight;

                //---- mark as absolute positioning ----
                elem.css("position", "absolute");

                elem.css("left", bounds.x);
                elem.css("top", bounds.y);

                //---- SETTING size does not include padding or border ----

                //---- don't change the width/height to zero (will "erase" intended size early in layout) ----
                if (bounds.width != 0)
                {
                    elem.width(bounds.width - borderWidth - paddingWidth);
                }

                if (bounds.height != 0)
                {
                    elem.height(bounds.height - borderHeight - paddingHeight);
                }

                //elem.show();
            }
            else
            {
                //elem.hide();
            }
        });

        if (!layoutNeeded)
        {
            closure.triggerOnLayout();

            //---- normally, our layout stabilizes after 3-4 iterations ----
            root.show();
        }
        else
        {
            conseqLayoutCount++;

            if (conseqLayoutCount > 5)
            {
                //---- something is wrong - workaround is to force it to stop ----
                //---- at certain sizes, this can be caused by "battling x/y axes" that gain/lose their labels in vicious cycle ----
                if (timer)
                {
                    clearTimeout(timer);
                    timer = null;
                }
                layoutNeeded = false;
                conseqLayoutCount = 0;

                closure.triggerOnLayout();

                root.show();
            }
        }

        isLayingOut = false;
    };

    closure.triggerOnLayout = function ()
    {
        //---- create a simplified event object ----
        var evt = { target: closure };

        for (var i = 0; i < layoutListeners.length; i++)
        {
            var listener = layoutListeners[i];

            listener.call(null, evt);
        }
    };

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "legendData");

        vp.makeControlFunc(wrapper, "attach");
        vp.makeControlFunc(wrapper, "detach");
        vp.makeControlFunc(wrapper, "layout");
    };

    var initialBuild = function ()
    {
        root
            .setClass("vpdockPanel")
            .css("position", "relative")    // so it can hold absolute position elements
            .css("overflow", "hidden")
            .attach("resize", dockPanelResized)
            .attach("DOMNodeInserted", nodeAdded)
            .attach("DOMNodeRemoved", nodeRemoved);

        markLayoutNeeded();
    }

    closure.ctr = "vp.visuals.dockPanel";
    rootElement.control = closure;

    var dockPanelResized = function (e)
    {
        markLayoutNeeded();
    };

    var nodeAdded = function (e)
    {
        if (e.target.parentNode == rootElement)
        {
            markLayoutNeeded();

            var elem = e.target;
            vp.events.attach(elem, "resize", function ()
            {
                if (!isLayingOut)
                {
                    markLayoutNeeded();
                }
            });
        }
    };


    var nodeRemoved = function (e)
    {
        //---- todo: verify that parent is still set when this event is called ----
        if (e.target.parentNode == rootElement)
        {
            markLayoutNeeded();

            var elem = e.target;
            vp.events.detach(elem, "resize", markLayoutNeeded);
        }
    };

    var markLayoutNeeded = function ()
    {
        if (!layoutNeeded)
        {
            layoutNeeded = true;
            timer = setTimeout(closure.layout, 1);
        }
    }

    closure.element = function ()
    {
        //---- ensure element is ready when we give it to caller ----
        if (layoutNeeded)
        {
            closure.layout();
        }

        return rootElement;
    };

    //---- property: data ----
    closure.data = function (value)
    {
        if (value === undefined)
        {
            return data;
        }

        data = value;
        markLayoutNeeded();

        return this;
    };

    //---- property: legendData ----
    closure.legendData = function (value)
    {
        if (value === undefined)
        {
            return legendData;
        }

        legendData = value;
        markLayoutNeeded();

        return this;
    };

    closure.attach = function (eventName, callBack)
    {
        if (eventName == "layout")
        {
            layoutListeners.push(callBack);
        }
        else
        {
            vp.events.attach(rootElement, eventName, callBack);
        }
    };

    closure.detach = function (eventName, callBack)
    {
        if (eventName == "layout")
        {
            layoutListeners.remove(callBack);
        }
        else
        {
            vp.events.detach(rootElement, eventName, callBack);
        }
    };

    //---- init code ----
    initialBuild();

    return closure;
};

vp.visuals.dockPanel = function ()
{
    //---- closures must return their closure to work correctly, we we want to return the HTML ----
    //---- element to the caller, so we use this wrapper on the factory ----
    var control = vp.visuals.dockPanelFactory();
    return control.element();
};

///----------------------------------------------------------------
/// (from visualParts\gridLines.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// gridLines.js.  Copyright (c) 2012 Microsoft Corporation.
///    This file is part of the VuePlot library.  It implements 2D gridlines for a plot.
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.gridLines = function ()
{
    //---- private state ----
    var verticalScale = null;
    var horizontalScale = null;

    var rootElement = vp.dom.createHtml("div");
    var root = vp.select(rootElement);
    var timer = null;

    //---- closure: layout() ----
    var layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }

        root.clear();

        var width = root.width();
        var height = root.height();

        if (horizontalScale)
        {
            //---- draw horizontal lines ----
            var count = horizontalScale.tickCount();

            if (count < height)          // don't draw if too close together
            {
                vp.utils.range(count).generate(root, "span", function (elem, dataItem, index)
                {
                    if ((index > 0) && (index < count - 1))     // don't overwrite axes
                    {
                        var y = horizontalScale.tickOffset(index);

                        //---- adjust for the fact we are undersized by 1 on all 4 sides ----
                        elem
                            .setClass("vpHorizontalGridLine")
                            .absPosition(0, y - 1)
                            .width(width)
                            .height(1)
                    }
                });
            }
        }

        if (verticalScale)
        {
            //---- draw vertical lines ----
            var count = verticalScale.tickCount();

            if (count < width)          // don't draw if too close together
            {

                vp.utils.range(count).generate(root, "span", function (elem, dataItem, index)
                {
                    if ((index > 0) && (index < count - 1))     // don't overwrite axes
                    {
                        var x = verticalScale.tickOffset(index);

                        //---- adjust for the fact we are undersized by 1 on all 4 sides ----
                        elem
                            .setClass("vpVerticalGridLine")
                            .absPosition(x - 1, 0)
                            .height(height)
                            .width(1)
                    }
                });
            }
        }

    };

    layout.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "verticalScale");
        vp.makeControlProperty(wrapper, "horizontalScale");
    };

    var initialBuild = function()
    {
        root
            .setClass("vpGridLines")
            .css("background", "yellow")
            .css("position", "relative")    // so it can hold absolute position elements
            .css("overflow", "hidden")   
            .attach("resize", markLayoutNeeded)

        markLayoutNeeded();
    }

    layout.ctr = "vp.visuals.gridLines";
    rootElement.control = layout;

    var markLayoutNeeded = function()
    {
        if (!timer)
        {
            timer = setTimeout(layout, 1);
        }
    }

    layout.element = function ()
    {
        return rootElement;
    };

    //---- property: verticalScale ----
    layout.verticalScale = function (value)
    {
        if (value === undefined)
        {
            return verticalScale;
        }

        verticalScale = value;
        markLayoutNeeded();

        return this;
    };

    //---- property: horizontalScale ----
    layout.horizontalScale = function (value)
    {
        if (value === undefined)
        {
            return horizontalScale;
        }

        horizontalScale = value;
        markLayoutNeeded();

        return this;
    };

    //---- init code ----
    initialBuild();

    //---- for controls, we return the HTML root ----
    return rootElement;
}



///----------------------------------------------------------------
/// (from visualParts\legend.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// legend.js.  Copyright (c) 2012 Microsoft Corporation.
///    This file is part of the VuePlot library.  It implements a simple chart legend.
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.legend = function ()
{
    //---- private state ----
    var legendData = null;

    var rootElement = vp.dom.createHtml("div");
    var root = vp.select(rootElement);
    var timer = null;

    //---- closure: layout() ----
    var layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }

        root.clear();

        var width = root.width();
        var height = root.height();

        if (legendData)
        {
            var table = root.append("table")
                .setClass("legendTable")

            for (var i = 0; i < legendData.length; i++)
            {
                var legendRecord = legendData[i];

                var row = table.append("tr");
                
                //---- color sample ----
                row.append("td")
                    .append("div")
                        .setClass("legendEntryColor")
                        .background(legendRecord.color)

                //---- name ----
                row.append("td")
                     .append("span")
                        .setClass("legendEntryName")
                        .text(legendRecord.name)
                        .attr("title", legendRecord.toolTip);

            }
        }

    };

    layout.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "legendData");
    };

    var initialBuild = function()
    {
        root
            .setClass("legend")
            .css("position", "relative")    // so it can hold absolute position elements
            .css("overflow", "hidden")
            .css("display", "inline-table")
            .attach("resize", markLayoutNeeded)

        markLayoutNeeded();
    }

    layout.ctr = "vp.visuals.legend";
    rootElement.control = layout;

    var markLayoutNeeded = function()
    {
        if (!timer)
        {
            timer = setTimeout(layout, 1);
        }
    }

    layout.element = function ()
    {
        return rootElement;
    };

    //---- property: legendData ----
    layout.legendData = function (value)
    {
        if (value === undefined)
        {
            return legendData;
        }

        legendData = value;
        markLayoutNeeded();

        return this;
    };

    //---- init code ----
    initialBuild();

    //---- for controls, we return the HTML root ----
    return rootElement;
}



///----------------------------------------------------------------
/// (from visualParts\numericAxis.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// numericAxis.js.  Copyright (c) 2012 Microsoft Corporation.
///                  Part of the vuePlot library - a numeric axis.  Can be used for left, top, right, bottom of plot.
///-----------------------------------------------------------------------------------------------------------------
/// create an HTML-based numeric axis control and return a closure object for it.
///
/// This represents a axis:
///     - axis line
///     - tick marks
///     - tick labels
///
/// Requirements:
///     - stretch to specified height
///     - output a minimum width
///     - base tickmarks & labels on its member scale
///     - hide tick marks if they exceed a maximum
///     - hide labels if not enough room
///     - provide optional label rotation
///
/// Css style-able elements:
///     - label: font, color
///     - tick mark: tickWidth, strokeWidth, stroke, strokeStyle
///     - axis line: strokeWidth, stroke, strokeStyle
///-----------------------------------------------------------------------------------------------------------------
/// testing: see numericAxis.html
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.numericAxis = function ()
{
    //---- private state ----
    var tickLength = 4;     // length of a tick mark
    var labelSpace = 3;     // space between tick and label
    var labelStrings = [];
    var labelWidths = [];
    var axisLocation = vp.axisLocation.left;
    var totalLabelWidths = 0;
    var totalLabelHeights = 0;
    var dataCount = 0;
    var isAxisVisible = true;

    var maxStringWidth = 0;
    var maxStringHeight = 0;
    var timer = null;
    var myScale = vp.scales.createSpace();        // linear();     // default
    var formatter = undefined;
    var changingSize = false;

    //---- HTML elements ----
    var rootElem = null;
    var axisLine = null;
    var tickMarks = null;
    var labels = null;

    /// closure
    var closure = function ()
    {
    };

    closure.ctr = "vp.visuals.numericAxis";

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "scale");
        vp.makeControlProperty(wrapper, "axisLocation");
        vp.makeControlProperty(wrapper, "formatter");
        vp.makeControlProperty(wrapper, "isAxisVisible");
    };

    /// private: onDataChanged().
    var onDataChanged = function()
    {
        onTextChanged();
    }

    /// private: onTextChanged().
    var onTextChanged = function()
    {
        //buildLabelStringsAndSizes();
        markRebuildNeeded();
    }

    /// private.
    var markRebuildNeeded = function ()
    {
        if (timer == null)
        {
            timer = setTimeout(build, 1);
        }
    };

    /// private.
    var pixelAlign = function (value)
    {
        return Math.round(value);
    };

    /// private.
    var buildLabelStringsAndSizes = function (data)
    {
        labelStrings = [];
        labelWidths = [];

        maxStringWidth = 0;
        maxStringHeight = 0;
        totalLabelWidths = 0;
        totalLabelHeights = 0;
        dataCount = 0;

        //---- create a TEXT element for measuring strings ----
        var fakeLabel = vp.select(document.body)
            .append("span")
            .setClass("vpNumericAxis_label");

        data.map(function (value, index)
        {
            var formatFunc = (formatter === undefined) ? vp.formatters.comma : formatter;

            var labelStr = formatFunc(value);
            labelStrings.push(labelStr);

            //---- set up for measuring "labelStr" ----
            fakeLabel.text(labelStr);

            var width = Math.ceil(fakeLabel.width());
            var height = Math.ceil(fakeLabel.height());

            if (width > maxStringWidth)
            {
                maxStringWidth = width;
            }

            if (height > maxStringHeight)
            {
                maxStringHeight = height;
            }

            labelWidths.push(width);
            dataCount++;
        });

        totalLabelWidths = maxStringWidth * dataCount;
        totalLabelHeights = maxStringHeight * dataCount;

        //---- remove temp label created above ----
        fakeLabel.remove();
    }

    //---- private: build() ----
    var build = function ()
    {
        if (timer != null)
        {
            clearTimeout(timer);
            timer = null;
        }

        if (rootElem == null)
        {
            //---- first build ----
            rootElem = vp.dom.createHtml("div");
            vp.dom.setClass(rootElem, "numericAxis");
            vp.events.attach(rootElem, "resize", elementResized);
            vp.dom.css(rootElem, "position", "relative")
            vp.dom.css(rootElem, "overflow", "visible");            // let labels overlap the boundaries of the axis

            rootElem.control = closure;
        }

        var root = vp.select(rootElem)
            .clear();

        if ((isAxisVisible) && (myScale != null))
        {
            var min = myScale.domainMin();
            var max = myScale.domainMax();
            var tickCount = myScale.tickCount();

            var incr = (max - min) / (tickCount - 1);
            var data = vp.utils.range(min, max, incr);

            buildLabelStringsAndSizes(data);

            if ((axisLocation == vp.axisLocation.left) || (axisLocation == "left"))
            {
                buildLeftElements(root, min, max, data);
            } 
            else if ((axisLocation == vp.axisLocation.right) || (axisLocation == "right"))
            {
                buildRightElements(root, min, max, data);
            }
            else if ((axisLocation == vp.axisLocation.top) || (axisLocation == "top"))
            {
                buildTopElements(root, min, max, data);
            }
            else if ((axisLocation == vp.axisLocation.bottom) || (axisLocation == "bottom"))
            {
                buildBottomElements(root, min, max, data);
            }
        }
    };
    
    var elementResized = function (e)
    {
        if (!changingSize)
        {
            //---- update auto range scale so dependent parts get correct scaling ----
            updateAutoRangeScale();
        }
    };

    var updateAutoRangeScale = function ()
    {
        var root = vp.select(rootElem);

        if ((axisLocation == vp.axisLocation.left) || (axisLocation == "left"))
        {
            calcHeightFromScale(root);
        }
        else if ((axisLocation == vp.axisLocation.right) || (axisLocation == "right"))
        {
            calcHeightFromScale(root);
        }
        else if ((axisLocation == vp.axisLocation.top) || (axisLocation == "top"))
        {
            calcWidthFromScale(root);
        }
        else if ((axisLocation == vp.axisLocation.bottom) || (axisLocation == "bottom"))
        {
            calcWidthFromScale(root);
        }

        markRebuildNeeded();
    };

    var setRootWidth = function (value)
    {
        changingSize = true;

        vp.dom.width(rootElem, value);

        changingSize = false;
    };

    var setRootHeight = function (value)
    {
        changingSize = true;

        vp.dom.height(rootElem, value);

        changingSize = false;
    };

    var calcHeightFromScale = function (root)
    {
        var height = 0;
        if (myScale.autoRange())
        {
            height = root.height();

            myScale.rangeMin(0);
            myScale.rangeMax(height - 1);
        }
        else
        {
            height = myScale.rangeMax() - myScale.rangeMin();
        }

        return height;
    }

    var calcWidthFromScale = function (root)
    {
        var width = 0;
        if (myScale.autoRange())
        {
            width = root.width();

            myScale.rangeMin(0);
            myScale.rangeMax(width - 1);
        }
        else
        {
            width = myScale.rangeMax() - myScale.rangeMin();
        }

        return width;
    }

    /// private: buildLeftElements()
    var buildLeftElements = function (root, min, max, data)
    {
        //---- HEIGHT ----
        var height = calcHeightFromScale(root);

        var showLabels = (totalLabelHeights < height);
        var showTicks = (dataCount * 3 < height);

        //---- WIDTH ----
        var width = (showLabels) ? 1 + labelSpace + maxStringWidth + tickLength : 1 + tickLength;
        setRootWidth(width);

        var x = pixelAlign(width - 1);
        var y1 = pixelAlign(myScale.flipScale(min));
        var y2 = pixelAlign(myScale.flipScale(max));

        //---- create the vertical axis line ----
        axisLine = root.append("span")
                .absPosition(x, y2)
                .width(1)
                .height(y1 - y2 + 1)
                .setClass("vpNumericAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.map(function (data, index)
            {
                var x1 = pixelAlign(width - tickLength - 1);
                var x2 = pixelAlign(width - 1);

                var y = myScale.tickOffset(index);

                var tm = root.append("span")
                        .absPosition(x1, y)
                        .height(1)
                        .width(Math.abs(x2 - x1 + 1))
                        .setClass("vpNumericAxis_tickMark");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            labels = data.map(function (data, index)
            {
                var labelSize = labelWidths[index];
                var x = pixelAlign(width - tickLength - labelSpace - 1 - labelSize);

                var y = pixelAlign(myScale.flipScale(data));
                var dy = pixelAlign(maxStringHeight / 2);

                var labelStr = labelStrings[index];

                var span = root.append("span")
                        .absPosition(x + 1, y - dy)
                        .text(labelStr)
                        .setClass("vpNumericAxis_label");

                return span;
            });
        }
    };

    /// private: buildRightElements()
    var buildRightElements = function (root, min, max, data)
    {
        //---- HEIGHT ----
        var height = calcHeightFromScale(root);

        var showLabels = (totalLabelHeights < height);
        var showTicks = (dataCount * 3 < height);

        //---- WIDTH ----
        var width = (showLabels) ? 1 + labelSpace + maxStringWidth + tickLength : 1 + tickLength;
        setRootWidth(width);

        //---- create the vertical axis line ----
        var y1 = myScale.flipScale(min);
        var y2 = myScale.flipScale(max);

        axisLine = root.append("span")
                .absPosition(0, y2)
                .width(1)
                .height(y1 - y2 + 1)
                .setClass("vpNumericAxis");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.map(function (data, index)
            {
                var y = myScale.tickOffset(index);

                var x1 = pixelAlign(0);
                var x2 = pixelAlign(tickLength);

                var tm = root.append("span")
                        .absPosition(x1, y)
                        .height(1)
                        .width(Math.abs(x2 - x1 + 1))
                        .setClass("vpNumericAxis_tickMark");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            labels = data.map(function (data, index)
            {
                var y = myScale.flipScale(data);
                var x = tickLength + labelSpace;
                var dy = pixelAlign(maxStringHeight / 2);

                var labelStr = labelStrings[index];

                var span = root.append("span")
                       .absPosition(x, y - dy)
                       .text(labelStr)
                       .setClass("vpNumericAxis_label");

                return span;
            });
        }
    };

    /// private: buildTopElements()
    var buildTopElements = function (root, min, max, data)
    {
        //---- WIDTH ----
        var width = calcWidthFromScale(root);

        var showLabels = (totalLabelWidths < width);
        var showTicks = (dataCount * 3 < width);

        //---- HEIGHT ----
        var fudgeFactor = 3;

        //---- for now, avoid "axis wars" by keeping top/bottom axis heights constants ----
        //var height = (showLabels) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;
        var height = (true) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;

        setRootHeight(height);

        //---- create the horizontal axis line ----
        var x1 = myScale.scale(min);
        var x2 = myScale.scale(max);
        var y = height-1;

        axisLine = root.append("span")
                .absPosition(x1, y)
                .height(1)
                .width(x2 - x1 + 1)
                .setClass("vpNumericAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.map(function (data, index)
            {
                var x = myScale.tickOffset(index);

                var y = height - 1;
                var y2 = height - tickLength - 1;

                var tm = root.append("span")
                        .absPosition(x, y2)
                        .width(1)
                        .height(y - y2 + 1)
                        .setClass("vpNumericAxis_tickMark");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            labels = data.map(function (data, index)
            {
                var x = myScale.scale(data);
                var y = 0;
                var dx = labelWidths[index] / 2;

                var labelStr = labelStrings[index];

                var span = root.append("span")
                       .absPosition(x - dx, y - 1)
                       .text(labelStr)
                       .setClass("vpNumericAxis_label");

                return span;
            });
        }
    };

    /// private: buildBottomElements()
    var buildBottomElements = function (root, min, max, data)
    {
        //---- WIDTH ----
        var width = calcWidthFromScale(root);

        var showLabels = (totalLabelWidths < width);
        var showTicks = (dataCount * 3 < width);

        //---- HEIGHT ----
        var fudgeFactor = 3;

        //---- for now, avoid "axis wars" by keeping top/bottom axis heights constants ----
        //var height = (showLabels) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;
        var height = (true) ? 1 + labelSpace + maxStringHeight + tickLength + fudgeFactor : 1 + tickLength;

        setRootHeight(height);

        //---- create the horizontal axis line ----
        //---- y coordinates here are SVG std (grow from top) ----
        var x1 = myScale.scale(min);
        var x2 = myScale.scale(max);
        var y = 0;

        axisLine = root.append("span")
               .absPosition(x1, y)
               .height(1)
               .width(x2 - x1 + 1)
               .setClass("vpNumericAxis_axisLine");

        //---- create the tick marks ----
        if (showTicks)
        {
            tickMarks = data.map(function (data, index)
            {
                var x = myScale.tickOffset(index);

                var y = 0;
                var y2 = tickLength;

                var tm = root.append("span")
                        .absPosition(x, y)
                        .width(1)
                        .height(y2 - y + 1)
                        .setClass("vpNumericAxis_tickMark");

                return tm;
            });
        }

        //---- create the labels -----
        if (showLabels)
        {
            labels = data.map(function (data, index)
            {
                var x = myScale.scale(data);
                var y = tickLength + 1;
                var dx = labelWidths[index] / 2;

                var labelStr = labelStrings[index];

                var span = root.append("span")
                       .absPosition(x - dx, y - 2)
                       .text(labelStr)
                       .setClass("vpNumericAxis_label");

                return span;
            });
        }
    };

    closure.element = function ()
    {
        return rootElem;
    };

    //---- property: scale ----
    closure.scale = function (value)
    {
        if (value === undefined)
        {
            return myScale;
        }

        myScale = value;
        updateAutoRangeScale();

        if (formatter === undefined)
        {
            if ((myScale) && (myscale.scaleName == "date"))
            {
                formatter = vp.formatters.date;
            }
            else
            {
                formatter = vp.formatters.comma;
            }
        }

        markRebuildNeeded();

        return closure;
    };

    //---- property: axisLocation ----
    closure.axisLocation = function (value)
    {
        if (value === undefined)
        {
            return axisLocation;
        }

        axisLocation = value;
        markRebuildNeeded();

        return closure;
    };

    //---- property: formatter ----
    closure.formatter = function (value)
    {
        if (value === undefined)
        {
            return formatter;
        }

        formatter = value;
        markRebuildNeeded();

        return closure;
    };

    //---- property: isAxisVisible ----
    closure.isAxisVisible = function (value)
    {
        if (value === undefined)
        {
            return isAxisVisible;
        }

        isAxisVisible = value;
        markRebuildNeeded();

        return closure;
    };

    build();        // so "rootElem" is set before we return

    return rootElem;
};

//---- enum: axisLocation ----
vp.axisLocation = { left: 0, top: 1, right: 2, bottom: 3 };

///----------------------------------------------------------------
/// (from visualParts\plotBox.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// plotBox.js.  Copyright (c) 2012 Microsoft Corporation.
///    This file is part of the VuePlot library.  It implements a docking container that can be used to build a variety of plots.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see plotBox.html
///-----------------------------------------------------------------------------------------------------------------

/// plotBox is basically a DOCK layout container with the special ability to properly size contiguous axes.
vp.visuals.plotBoxFactory = function ()
{
    //---- private state ----
    var data = null;
    var rootElement = vq.createHtml("div");
    var root = vq.select(rootElement);
    var layoutNeeded = false;
    var dockLayout = null;
    var legendData = [];
    var timer = null;
    var layoutListeners = [];
    var conseqLayoutCount = 0;
    var isLayingOut = false;

    //---- closure ----
    var closure = function ()
    {
    };

    /// public: layout()
    closure.layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }
        layoutNeeded = false;
        isLayingOut = true;

        var kids = root.kids();

        var width = root.width();
        var height = root.height();

        dockLayout = vp.layouts.dockForAxes()
             .width(width)
             .height(height)

        vq.debug("plotBox: layout of children");

        //---- FIRST PASS - add each child to layout ----
        kids.each(function (index, unwrappedElem)
        {
            //---- temp: wrap until all callbacks pass elems as wrapped ----
            var elem = (unwrappedElem.length) ? unwrappedElem : vq.select(unwrappedElem);

            var sizes = elem.elementSizes();

            var borderWidth = sizes.borderWidth;
            var borderHeight = sizes.borderHeight;

            //---- HTML is confusing here: ----
            //---- RETURNED size includes padding but NOT border ----
            var totalWidth = sizes.width + borderWidth;
            var totalHeight = sizes.height + borderHeight;

            var dockType = elem.attr("dockType");
            var isAxis = elem.attr("isAxis");

            var isVisible = (elem.css("display") != "none");

            dockLayout.addChild(totalWidth, totalHeight, dockType, isAxis, isVisible);
        });

        //---- SECOND PASS: now get and APPLY layout bounds for each child ----
        kids.each(function (index, unwrappedElem)
        {
            //---- temp: wrap until all callbacks pass elems as wrapped ----
            var elem = (unwrappedElem.length) ? unwrappedElem : vq.select(unwrappedElem);

            //---- skip the invisible elements ----
            var isVisible = (elem.css("display") != "none");
            if (isVisible)
            {
                var bounds = dockLayout.getBounds(index);
                var sizes = elem.elementSizes();

                var borderWidth = sizes.borderWidth;
                var borderHeight = sizes.borderHeight;

                var paddingWidth = sizes.paddingWidth;
                var paddingHeight = sizes.paddingHeight;

                //---- mark as absolute positioning ----
                elem.css("position", "absolute");

                elem.css("left", bounds.x);
                elem.css("top", bounds.y);

                //---- SETTING size does not include padding or border ----

                //---- don't change the width/height to zero (will "erase" intended size early in layout) ----
                if (bounds.width != 0)
                {
                    elem.width(bounds.width - borderWidth - paddingWidth);
                }

                if (bounds.height != 0)
                {
                    elem.height(bounds.height - borderHeight - paddingHeight);
                }

                //elem.show();
            }
            else
            {
                //elem.hide();
            }
        });

        if (!layoutNeeded)
        {
            closure.triggerOnLayout();

            //---- normally, our layout stabilizes after 3-4 iterations ----
            root.show();
        }
        else
        {
            conseqLayoutCount++;

            if (conseqLayoutCount > 5)
            {
                //---- something is wrong - workaround is to force it to stop ----
                //---- at certain sizes, this can be caused by "battling x/y axes" that gain/lose their labels in vicious cycle ----
                if (timer)
                {
                    clearTimeout(timer);
                    timer = null;
                }
                layoutNeeded = false;
                conseqLayoutCount = 0;

                closure.triggerOnLayout();

                root.show();
            }
        }

        isLayingOut = false;
    };

    closure.triggerOnLayout = function ()
    {
        //---- create a simplified event object ----
        var evt = { target: closure };

        for (var i = 0; i < layoutListeners.length; i++)
        {
            var listener = layoutListeners[i];

            listener.call(null, evt);
        }
    };

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "legendData");

        vp.makeControlFunc(wrapper, "attach");
        vp.makeControlFunc(wrapper, "detach");
        vp.makeControlFunc(wrapper, "layout");
    };

    var initialBuild = function ()
    {
        root
            .setClass("vpPlotBox")
            .css("position", "relative")    // so it can hold absolute position elements
            .css("overflow", "hidden")
            .attach("resize", plotBoxResized)
            .attach("DOMNodeInserted", nodeAdded)
            .attach("DOMNodeRemoved", nodeRemoved);

        markLayoutNeeded();
    }

    closure.ctr = "vp.visuals.plotBox";
    rootElement.control = closure;

    var plotBoxResized = function (e)
    {
        markLayoutNeeded();
    };

    var nodeAdded = function (e)
    {
        if (e.target.parentNode == rootElement)
        {
            markLayoutNeeded();

            var elem = e.target;
            vq.attach(elem, "resize", function ()
            {
                if (!isLayingOut)
                {
                    markLayoutNeeded();
                }
            });
        }
    };


    var nodeRemoved = function (e)
    {
        //---- todo: verify that parent is still set when this event is called ----
        if (e.target.parentNode == rootElement)
        {
            markLayoutNeeded();

            var elem = e.target;
            vq.detach(elem, "resize", markLayoutNeeded);
        }
    };

    var markLayoutNeeded = function ()
    {
        if (!layoutNeeded)
        {
            layoutNeeded = true;
            timer = setTimeout(closure.layout, 1);
        }
    }

    closure.element = function ()
    {
        //---- ensure element is ready when we give it to caller ----
        if (layoutNeeded)
        {
            closure.layout();
        }

        return rootElement;
    };

    //---- property: data ----
    closure.data = function (value)
    {
        if (value === undefined)
        {
            return data;
        }

        data = value;
        markLayoutNeeded();

        return this;
    };

    //---- property: legendData ----
    closure.legendData = function (value)
    {
        if (value === undefined)
        {
            return legendData;
        }

        legendData = value;
        markLayoutNeeded();

        return this;
    };

    closure.attach = function (eventName, callBack)
    {
        if (eventName == "layout")
        {
            layoutListeners.push(callBack);
        }
        else
        {
            vq.attach(rootElement, eventName, callBack);
        }
    };

    closure.detach = function (eventName, callBack)
    {
        if (eventName == "layout")
        {
            layoutListeners.remove(callBack);
        }
        else
        {
            vq.detach(rootElement, eventName, callBack);
        }
    };

    //---- init code ----
    initialBuild();

    return closure;
};

vp.visuals.plotBox = function ()
{
    //---- closures must return their closure to work correctly, we we want to return the HTML ----
    //---- element to the caller, so we use this wrapper on the factory ----
    var control = vp.visuals.plotBoxFactory();
    return control.element();
};

///----------------------------------------------------------------
/// (from visualParts\ribbonBar.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// ribbonBar.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the VuePlot library.
///     - a ribbon-like toolbar for containing controls (buttons, checkboxes, textboxes, etc).
///-----------------------------------------------------------------------------------------------------------------
/// testing: ribbonBar.html
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.ribbonBar = function ()
{
    //---- private state ----
    var rootElement = vp.dom.createHtml("div");     // vp.visuals.createGridContainer();
    var root = vp.select(rootElement);
    var timer = null;
    var groups = [];

    //---- closure ----
    var closure = function()
    {
    }

    closure.layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }
    };

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "name");
        //vp.makeControlProperty(wrapper, "halign");
        //vp.makeControlProperty(wrapper, "rotation");
    };

    var initialBuild = function()
    {
        root
            .setClass("vpRibbonBar")
            .css("overflow", "hidden") 
    }

    closure.ctr = "vp.visuals.ribbonBar";
    rootElement.control = closure;

    var markLayoutNeeded = function()
    {
        if (!timer)
        {
            timer = setTimeout(closure.layout, 1);
        }
    }

    closure.element = function ()
    {
        return rootElement;
    };

    //---- init code ----
    initialBuild();

    //---- for controls, we return the HTML root ----
    return rootElement;
}



///----------------------------------------------------------------
/// (from visualParts\ribbonGroup.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// ribbonGroup.js.  Copyright (c) 2012 Microsoft Corporation.
///     - part of the VuePlot library.
///     - a ribbon-like group containing controls (buttons, checkboxes, textboxes, etc).
///     - typically, is appended to a ribbonBar container.
///-----------------------------------------------------------------------------------------------------------------
/// testing: ribbonBar.html
///-----------------------------------------------------------------------------------------------------------------

vp.visuals.ribbonGroup = function ()
{
    //---- private state ----
    var rootElement = vp.dom.createHtml("div");
    var root = vp.select(rootElement);
    var timer = null;
    var rows = [];
    var nextRow = 0;
    var nameElem = null;
    var text = "Group";
    var rowCount = 2;       // for controls

    //---- closure ----
    var closure = function()
    {
    }

    /// add the content as a new "td" element in either row[0] or row[1].
    closure.append = function (content)
    {
        if (nextRow >= rowCount)
        {
            nextRow = 0;
        }

        var row = rows[nextRow++];
        var td = row.append("td")
            .setClass("ribbonGroupEntry")

        var elem = vp.dom.append(td[0], content);
        return elem;
    };

    closure.layout = function ()
    {
        if (timer)
        {
            clearTimeout(timer);
            timer = null;
        }
    };

    closure.extendWrapper = function (wrapper)
    {
        //vp.makeControlProperty(wrapper, "valign");

        vp.makeControlProperty(wrapper, "text");
        vp.makeControlFunc(wrapper, "startNewRow");
        vp.makeControlFuncWithReturnValue(wrapper, "append");
    };

    closure.startNewRow = function ()
    {
        nextRow = 0;
    };

    var initialBuild = function()
    {
        root
            .setClass("ribbonGroup")
        //.css("position", "relative")    // so it can hold absolute position elements
            //.attach("resize", markLayoutNeeded)
            //.attach("DOMNodeInserted", nodeAddOrDelete)
            //.attach("DOMNodeRemoved", nodeAddOrDelete);

        var table = root.append("table")
            .attr("cellspacing", 0)
            .attr("cellpadding", 0)
            .setClass("ribbonGroupTable");

        rows = [];      // for row1-row3

        for (var j = 0; j < rowCount; j++)
        {
            var row = table.append("tr")
                .setClass("ribbonBarRow");

            rows.push(row);
        }

        //---- add the group name in a 3rd row, spanning all columns defined for the group ----
        nameElem = table.append("tr")
            .append("td")
                .attr("colSpan", "999")
                .setClass("ribbonGroupNameTd")
                .append("span")
                .setClass("ribbonGroupName")
                    .text("Group");

        nextRow = 0;
    }

    closure.ctr = "vp.visuals.ribbonGroup";
    rootElement.control = closure;

    var markLayoutNeeded = function()
    {
        if (!timer)
        {
            timer = setTimeout(closure.layout, 1);
        }
    }

    closure.element = function ()
    {
        return rootElement;
    };

    //---- property: text ----
    closure.text = function (value)
    {
        if (arguments.length == 0)
        {
            return text;
        }

        text = value;
        nameElem.text(value);

        return closure;
    };

    //---- init code ----
    initialBuild();

    //---- for controls, we return the HTML root ----
    return rootElement;
}



///----------------------------------------------------------------
/// (from visualParts\routeFuncCalls.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// routeFuncCalls.js.  Copyright (c) 2012 Microsoft Corporation.
///                part of the vuePlot library - misc utility functions.
///-----------------------------------------------------------------------------------------------------------------

vp.makeControlProperty = function (wrapper, propName)
{
    var propFunc = function (value)
    {
        //---- GET value ----
        if (arguments.length == 0)
        {
            var value = null;
            if (wrapper.length > 0)
            {
                var f = wrapper[0].control[propName];
                value = f.call();
            }

            return value;
        }
        else
        {
            var args = arguments; 

            //---- SET value ----
            return wrapper.each(function (index, element)
            {
                //---- control stored on actual element, not wrapper ----
                var f = element[0].control[propName];
                f.apply(null, args);
            });
        }
    };

    wrapper[propName] = propFunc;
};

vp.makeControlFunc = function (wrapper, funcName)
{
    var func = function ()
    {
        var args = arguments;

        return wrapper.each(function (index, element)
        {
            //---- control stored on actual element, not wrapper ----
            var control = element[0].control;

            var f = control[funcName];
            f.apply(control, args);
        });
    };

    wrapper[funcName] = func;
};

vp.makeControlFuncWithReturnValue = function (wrapper, funcName)
{
    var func = function ()
    {
        var args = arguments;
        var returnValue = undefined;

        wrapper.each(function (index, element)
        {
            //---- control stored on actual element, not wrapper ----
            var control = element[0].control;

            var f = control[funcName];
            returnValue = f.apply(control, args);
        });

        return returnValue;
    };

    wrapper[funcName] = func;
};


///----------------------------------------------------------------
/// (from visualParts\scrollbar.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// scrollbar.js.  Copyright (c) 2012 Microsoft Corporation.
///      - part of the vuePlot library.
///      - implements a horizontal or vertical scrollbar.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see scrollBars.html
///-----------------------------------------------------------------------------------------------------------------

/// create a customizable scrollbar control.
vp.scrollBarFactory = function (isVertical)
{
    //---- private state ----
    var min = 0;
    var max = 100;
    var value = 0;
    var domElement = null;
    var svgElement = null;
    var root = null;
    var scrollTrack = null;
    var scrollThumb = null;
    var box1 = null;
    var box2 = null;
    var smallChange = 1;
    var largeChange = 10;
    var isProportional = false;
    var contentSize = 0;
    var scrollBarId = vp.nextScrollBarId++;     // unique id for all scrollbars (helps debugging)

    var changeListeners = [];
    var toggleListeners = [];
    var mouseDownX = 0;
    var mouseDownY = 0;
    var isMovingThumb = false;
    var isMouseDown = false;
    var mouseDownTime = 0;
    var lastMouseDoc = { x: 0, y: 0 };
    var movedByUser = false;
    var valueChangedDuringTouch = null;
    var trackHeight = 0;
    var trackWidth = 0;
    var thumbWidth = 0;
    var thumbHeight = 0;
    var timer = null;
    var autoRepeatTimer = null;
    var autoRepeatCmd = null;
    var defaultScrollBarSize = 16;
    var thumbMargin = 1;            // for hsb, space on top/bottom of thumb; for vsb, space on left/right

    var closure = function ()
    {
    };

    //---- public: update() ----
    closure.update = function ()
    {
        setValue(value, true);
    };

    closure.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "scrollThumb");
        vp.makeControlProperty(wrapper, "scrollTrack");
        vp.makeControlProperty(wrapper, "min");
        vp.makeControlProperty(wrapper, "max");
        vp.makeControlProperty(wrapper, "value");
        vp.makeControlProperty(wrapper, "box1");
        vp.makeControlProperty(wrapper, "box2");
        vp.makeControlProperty(wrapper, "isProportional");
        vp.makeControlProperty(wrapper, "smallChange");
        vp.makeControlProperty(wrapper, "largeChange");
        vp.makeControlProperty(wrapper, "contentSize");
        vp.makeControlProperty(wrapper, "getTrackWidth");
        vp.makeControlProperty(wrapper, "getTrackHeight");

        vp.makeControlFunc(wrapper, "attach");
        vp.makeControlFunc(wrapper, "detach");
        vp.makeControlFunc(wrapper, "scrollTo");
        vp.makeControlFunc(wrapper, "layout");
        vp.makeControlFunc(wrapper, "processMouseWheelEvent");
    };

    //---- private: build() ----
    var build = function ()
    {
        /// Note: non-IE browsers don't like SVG elements with negative coordinates (they get chopped off), so make sure
        /// we layout everything at >= 0,0.
        value = min;

        if (domElement == null)
        {
            //---- create a DIV to hold the SVG so that we can hook keyboard events thru the DIV ----
            domElement = vp.dom.createHtml("div");
            vp.dom.setClass(domElement, "scrollBar");

            svgElement = vp.dom.append(domElement, "svg")[0];

            root = vp.select(svgElement)
                .css("display", "block")
                .css("cursor", "default");

            if (isVertical)
            {
                closure.ctr = "vp.visuals.verticalScrollbar";
            }
            else
            {
                closure.ctr = "vp.visuals.horizontalScrollbar";
            }

            //---- add a property on element to get access to control (closure object) ----
            domElement.control = closure;
        }

        root.clear();

        scrollTrack = root.append("rect")
            .addClass("scrollTrack")
            .id("scrollTrack")
            .bounds(0, 0, 50, defaultScrollBarSize);

        scrollThumb = root.append("rect")
            .addClass("scrollThumb")
            .id("scrollThumb")
            .bounds(0, 0, 8, 16)
            //.attr("rx", 2)
            //.attr("ry", 2);

        box1 = appendBox(root, defaultScrollBarSize, true)
            .addClass("scrollBox")
            .id("box1")

        box2 = appendBox(root, defaultScrollBarSize, false)
            .addClass("scrollBox")
            .id("box2")

        if (isVertical)
        {
            setTrackHeight(50);
            setTrackWidth(defaultScrollBarSize);
        }
        else
        {
            setTrackHeight(defaultScrollBarSize);
            setTrackWidth(50);
        }

        //---- set up RESIZE, MOUSE, KEYBOARD, and TOUCH event handling ----
        vp.events.attach(domElement, "resize", function (e)
        {
            var width = vp.dom.width(domElement);
            var height = vp.dom.height(domElement);

            setTrackWidth(width);
            setTrackHeight(height);
        });

        vp.events.attach(domElement, "keyup", function (e)
        {
            cancelAutoRepeat();
        });

        vp.events.attach(domElement, "mousewheel", function (e)
        {
            closure.processMouseWheelEvent(e);
        });

        vp.events.attach(domElement, "keydown", function (e)
        {
            if (isVertical)
            {
                if (e.keyCode == vp.events.keyCodes.up)
                {
                    closure.scrollTo(vp.scrollCmds.smallDecrement);
                    initAutoRepeat(vp.scrollCmds.largeDecrement);
                }
                else if (e.keyCode == vp.events.keyCodes.down)
                {
                    closure.scrollTo(vp.scrollCmds.smallIncrement);
                    initAutoRepeat(vp.scrollCmds.largeIncrement);
                }
                else if (e.keyCode == vp.events.keyCodes.pageUp)
                {
                    closure.scrollTo(vp.scrollCmds.largeDecrement);
                    initAutoRepeat(vp.scrollCmds.largeDecrement);
                }
                else if (e.keyCode == vp.events.keyCodes.pageDown)
                {
                    closure.scrollTo(vp.scrollCmds.largeIncrement);
                    initAutoRepeat(vp.scrollCmds.largeIncrement);
                }
                    // CHW: two extra cases
                else if (e.keyCode == vp.events.keyCodes.home)
                {
                    closure.scrollTo(vp.scrollCmds.home);
                }
                else if (e.keyCode == vp.events.keyCodes.end)
                {
                    closure.scrollTo(vp.scrollCmds.end);
                }
            }
            else
            {
                if (e.keyCode == vp.events.keyCodes.left)
                {
                    closure.scrollTo(vp.scrollCmds.smallDecrement);
                    initAutoRepeat(vp.scrollCmds.largeDecrement);
                }
                else if (e.keyCode == vp.events.keyCodes.right)
                {
                    closure.scrollTo(vp.scrollCmds.smallIncrement);
                    initAutoRepeat(vp.scrollCmds.largeIncrement);
                }
                else if (e.keyCode == vp.events.keyCodes.pageUp)
                {
                    closure.scrollTo(vp.scrollCmds.largeDecrement);
                    initAutoRepeat(vp.scrollCmds.largeDecrement);
                }
                else if (e.keyCode == vp.events.keyCodes.pageDown)
                {
                    closure.scrollTo(vp.scrollCmds.largeIncrement);
                    initAutoRepeat(vp.scrollCmds.largeIncrement);
                }
            }
        });

        //---- event strategy: hook mouseenter/exit to know when to enable the "mousedown" event handler, using
        //---- the "capture" flag of event listener to get priority access (during capture phase) to event.  ----
        root.attach("mouseover", function (e)
        {
            root.attach("mousedown", onMouseDown, true);
        });

        root.attach("mouseout", function (e)
        {
            root.detach("mousedown", onMouseDown, true);
        });

        //---- use "touch" instead of "mouse" events (works better across devices) ----
        //---- in order to approximate "capture" behavior, we hook the document & ensure mousedown is on scrollThumb ----
        //vp.touchEventHandler(document.body, onTouchDown, onTouchMove, onTouchUp);
    };

    /// private.
    closure.processMouseWheelEvent = function (e)
    {
        if (vp.dom.visibility(domElement) == "visible")
        {
            if (e.wheelDelta < 0)
            {
                closure.scrollTo(vp.scrollCmds.smallIncrement, 3);
            }
            else
            {
                closure.scrollTo(vp.scrollCmds.smallDecrement, 3);
            }
        }
    };

    /// private.
    var appendBox = function (root, size, isFirst)
    {
        //---- create a compound shape: triangle within a rect ----
        var group = root.append("g")

        //---- create a background rect to easily detect box vs. track mousedown ----
        group
            .append("rect")
                .bounds(0, 0, size, size)

        var path = group.append("path")

        setBoxUpClass(group);

        if (isFirst)
        {
            if (isVertical)
            {
                //---- down pointing triangle ----
                path.attr("d", "M 4 12 L 12 12 L 8 4 z");
            }
            else
            {
                //---- right pointing triangle ----
                path.attr("d", "M 12 4 L 12 12 L 4 8 z");
            }
        }
        else
        {
            if (isVertical)
            {
                //---- up pointing triangle ----
                path.attr("d", "M 4 4 L 12 4 L 8 12 z");
            }
            else
            {
                //---- left pointing triangle ----
                path.attr("d", "M 4 4 L 4 12 L 12 8 z");
            }
        }

        return group;
    };

    closure.element = function ()
    {
        return domElement;
    };

    closure.scrollThumb = function ()
    {
        return scrollThumb;
    };

    closure.scrollTrack = function ()
    {
        return scrollTrack;
    };

    closure.box1 = function ()
    {
        return box1;
    };

    closure.box2 = function ()
    {
        return box2;
    };

    /// private: setValue().
    var setValue = function (newValue, force)
    {
        //---- round value to nearest "smallChange" ----
        //newValue = smallChange * Math.round(newValue / smallChange);

        newValue = Math.round(newValue);        // round to whole pixel

        //---- adjust value so its within limits ----
        if (newValue < min)
        {
            newValue = min;
        }
        else if (newValue > max)
        {
            newValue = max;
        }

        if ((force) || (newValue != value))
        {
            value = newValue;

            if (force)
            {
                if (isVertical)
                {
                    var top = 0 + trackWidth;;
                    var bottom = trackHeight - (trackWidth + thumbHeight);

                    var yValue = vp.utils.mapValue(value, min, max, top, bottom);

                    //---- move thumb ----
                    scrollThumb.attr("y", yValue);
                }
                else
                {
                    var left = 0 + trackHeight;
                    var right = trackWidth - (trackHeight + thumbWidth);

                    var xValue = vp.utils.mapValue(value, min, max, left, right);

                    //---- move thumb ----
                    scrollThumb.attr("x", xValue);
                }
            }

            //---- call event listeners ----
            onChange();
        }
    };

    /// private: markLayoutNeeded().
    var markLayoutNeeded = function ()
    {
        if (timer == null)
        {
            //---- caution: do not use an inline function here - causes us to call the wrong closure instance ----
            //---- under certain (unknown) conditions. ----
            timer = setTimeout(closure.layout, 1);
        }
    };

    /// private: onChange().
    var onChange = function ()
    {
        //---- create a simplified event object ----
        var evt = { target: closure, value: value };

        for (var i = 0; i < changeListeners.length; i++)
        {
            var callback = changeListeners[i];

            callback(evt);
        }
    };

    /// private: onToggle().
    var onToggle = function ()
    {
        //---- create a simplified event object ----
        var evt = { src: closure, value: value };

        for (var i = 0; i < toggleListeners.length; i++)
        {
            var callback = toggleListeners[i];

            callback(evt);
        }
    };

    //---- function: attach() ----
    closure.attach = function (eventName, callback)
    {
        if (eventName.toLowerCase() == "change")
        {
            changeListeners.push(callback);
        }
        else if (eventName.toLowerCase() == "toggle")
        {
            toggleListeners.push(callback);
        }
        else
        {
            //---- defer to the domElement for other events ----
            // CHW: delegate to global attach function
            vp.events.attach(domElement, eventName, callback);
        }

        return this;
    };

    //---- function: detach() ----
    closure.detach = function (eventName, callback)
    {
        if (eventName.toLowerCase() == "change")
        {
            changeListeners.remove(callback);
        }
        else if (eventName.toLowerCase() == "toggle")
        {
            toggleListeners.remove(callback);
        }
        else
        {
            //---- defer to the domElement for other events ----
            // CHW: delegate to global deattach function
            vp.events.detach(domElement, eventName, callback);
        }

        return closure;
    };

    /// private: onMouseMove().
    var onMouseMove = function (e)
    {
        document.body.style.cursor = "default";

        //vp.utils.debug("vpslider.onTouchMove: e.type=" + e.type);
        //vp.utils.debug("onTouchMove: isMouseDown=" + isMouseDown);

        var mouseDoc = vp.events.mousePosition(e);

        if (isMouseDown)
        {
            if (!isMovingThumb)
            {
                //---- have we gone far enough or waited long enough? ----
                var delta = new Date() - mouseDownTime;
                if (delta > 100)
                {
                    isMovingThumb = true;
                }
                else
                {
                    var xdiff = Math.abs(mouseDoc.x - lastMouseDoc.x);
                    var ydiff = Math.abs(mouseDoc.y - lastMouseDoc.y);

                    if ((xdiff >= 4) || (ydiff >= 4))
                    {
                        isMovingThumb = true;
                    }
                }
            }

            if (isMovingThumb)
            {
                movedByUser = true;
                valueChangedDuringTouch = true;

                //---- goal is to set new X location for THUMB (relative to our local svg document) ----
                //---- "doc" variables here refer to coordinates relative to main document origin ----
                //---- "svg" variables here refer to coordinates relative to local svg document ----

                //---- compute mouse location relative to my svg document ----
                var newValue = 0;

                //var trackHeighth = scrollTrack.height();
                //var trackWidth = scrollTrack.width();

                if (isVertical)
                {
                    var mouseYDoc = mouseDoc.y;

                    var newYDoc = mouseYDoc - mouseDownY;
                    var newYSvg = newYDoc - vp.dom.docOffset(scrollTrack[0]).top;

                    var topSvg = 0 + trackWidth;
                    var bottomSvg = trackHeight - (trackWidth + thumbHeight);

                    if (newYSvg < topSvg)
                    {
                        newYSvg = topSvg;
                    }
                    else if (newYSvg > bottomSvg)
                    {
                        newYSvg = bottomSvg;
                    }

                    //---- move thumb ----
                    scrollThumb.attr("y", newYSvg);

                    newValue = vp.utils.mapValue(newYSvg, topSvg, bottomSvg, min, max);
                }
                else
                {
                    var mouseXDoc = mouseDoc.x;

                    var newXDoc = mouseXDoc - mouseDownX;
                    var newXSvg = newXDoc - vp.dom.docOffset(scrollTrack[0]).left;

                    var leftSvg = 0 + trackHeight;
                    var rightSvg = trackWidth - (trackHeight + thumbWidth);

                    if (newXSvg < leftSvg)
                    {
                        newXSvg = leftSvg;
                    }
                    else if (newXSvg > rightSvg)
                    {
                        newXSvg = rightSvg;
                    }

                    //---- move thumb ----
                    scrollThumb.attr("x", newXSvg);

                    newValue = vp.utils.mapValue(newXSvg, leftSvg, rightSvg, min, max);
                }

                setValue(newValue, false);

                //---- cancel the event to stop system from selecting text, etc. on non-IE browsers ----
                e.cancelBubble = true;
                e.stopPropagation();
                e.returnValue = false;
            }
        }

        lastMouseDoc = mouseDoc;
    };

    /// private.
    var setBoxUpClass = function (box)
    {
        var kids = box[0].childNodes;

        vp.dom.setClass(kids[0], "scrollBox");
        vp.dom.setClass(kids[1], "scrollBoxShape");
    };

    /// private.
    var setBoxDownClass = function (box)
    {
        var kids = box[0].childNodes;

        vp.dom.setClass(kids[0], "scrollBoxDown");
        vp.dom.setClass(kids[1], "scrollBoxShapeDown");
    };

    /// private: onMouseUp().
    var onMouseUp = function (e)
    {
        cancelAutoRepeat();

        isMovingThumb = false;
        isMouseDown = false;

        setBoxUpClass(box1);
        setBoxUpClass(box2);

        vp.events.releaseCapture(document.body, e, onMouseMove, onMouseUp);

        if (valueChangedDuringTouch === false)
        {
            //---- trigger the TOGGLE event ----
            onToggle();
        }
    };

    /// private: cancelAutoRepeat()
    var cancelAutoRepeat = function ()
    {
        if (autoRepeatTimer)
        {
            clearTimeout(autoRepeatTimer);
            autoRepeatTimer = null;
        }
    };

    /// private: autoRepeat()
    var autoRepeat = function ()
    {
        closure.scrollTo(autoRepeatCmd);

        //---- set up next timer ----
        autoRepeatTimer = setTimeout(autoRepeat, 80);      // 12.5 per second
    };

    /// private: initAutoRepeat()
    var initAutoRepeat = function (cmd)
    {
        //---- cancel existing auto repeat, if any ----
        cancelAutoRepeat();

        autoRepeatTimer = setTimeout(autoRepeat, 500);      // initial delay
        autoRepeatCmd = cmd;
    };

    /// private: onMouseDown().
    var onMouseDown = function (e) 
    {
        var pos = vp.events.mousePosition(e);
        var elem = vp.events.elementFromPoint(pos.x, pos.y);

        var captureMouseForMove = true;         // default value
        valueChangedDuringTouch = false;        // default value

        if (elem === scrollThumb[0])
        {
            isMouseDown = true;
            mouseDownTime = new Date();

            //---- save mouse location relative to my the THUMB ----
            var relPos = vp.events.mousePosition(e, elem);
            mouseDownX = relPos.x;
            mouseDownY = relPos.y;

            // CHW: do below: vp.events.setCapture(document.body, e, onMouseMove, onMouseUp);

        }
        else if (elem == scrollTrack[0])
        {
            //---- did we click BEFORE or AFTER the thumb? ----
            var relPos = vp.events.mousePosition(e, domElement);
            var before = false;

            if (isVertical)
            {
                var y = scrollThumb.attr("y");
                before = (relPos.y <= y);
            }
            else
            {
                var x = scrollThumb.attr("x");
                before = (relPos.x <= x);
            }

            if (before)
            {
                closure.scrollTo(vp.scrollCmds.largeDecrement);
                initAutoRepeat(vp.scrollCmds.largeDecrement);
            }
            else
            {
                closure.scrollTo(vp.scrollCmds.largeIncrement);
                initAutoRepeat(vp.scrollCmds.largeIncrement);
            }
        }
        else if (elemInBox(elem, box1))
        {
            setBoxDownClass(box1);

            closure.scrollTo(vp.scrollCmds.smallDecrement);
            initAutoRepeat(vp.scrollCmds.smallDecrement);
        }
        else if (elemInBox(elem, box2))
        {
            setBoxDownClass(box2);

            closure.scrollTo(vp.scrollCmds.smallIncrement);
            initAutoRepeat(vp.scrollCmds.smallIncrement);
        }
        else
        {
            captureMouseForMove = false;

            //---- do not trigger a TOGGLE event if outside of our slider ----
            valueChangedDuringTouch = true;
        }

        if (captureMouseForMove)
        {
            // CHW: must capture mouse up even if not scrolling thumb
            vp.events.setCapture(document.body, e, isMouseDown ? onMouseMove : null, onMouseUp);

            vp.events.setFocus(domElement);
        }

        return false;
    };

    /// private.
    var elemInBox = function (elem, box)
    {
        var kids = box[0].childNodes;
        var inBox = ((elem == kids[0]) || (elem == kids[1]));

        return inBox;
    }

    /// public: scrollTo()
    closure.scrollTo = function (cmd, cmdValue)
    {
        if (cmdValue === undefined)
        {
            cmdValue = 1;
        }

        if (cmd == vp.scrollCmds.home)
        {
            setValue(min, true);
        }
        else if (cmd == vp.scrollCmds.smallIncrement)
        {
            setValue(value + (cmdValue * smallChange), true);
        }
        else if (cmd == vp.scrollCmds.smallDecrement)
        {
            setValue(value - (cmdValue * smallChange), true);
        }
        else if (cmd == vp.scrollCmds.largeIncrement)
        {
            setValue(value + (cmdValue * largeChange), true);
        }
        else if (cmd == vp.scrollCmds.largeDecrement)
        {
            setValue(value - (cmdValue * largeChange), true);
        }
        else if (cmd == vp.scrollCmds.thumbPosition)
        {
            setValue(thumbValue, true);
        }
        else if (cmd == vp.scrollCmds.end)
        {
            setValue(max, true);
        }
    };

    /// private setTrackHeight().
    var setTrackHeight = function (value)
    {
        trackHeight = value;
        scrollTrack.attr("height", value);
        svgElement.setAttribute("height", value);       // for Safari (wants width/height set on SVG doc)

        markLayoutNeeded();
    }

    /// private setTrackWidth().
    var setTrackWidth = function (value)
    {
        if (value == 0)
        {
            var breakPointDummy = 0;
        }

        trackWidth = value;
        scrollTrack.attr("width", value);
        svgElement.setAttribute("width", value);       // for Safari (wants width/height set on SVG doc)

        markLayoutNeeded();
    }

    /// private.
    var calcProportionalSize = function (viewSize)
    {
        //---- size of "buttons" on each end of scrollbar ----
        var boxSize = (isVertical) ? trackWidth : trackHeight;
        var ps = 0;

        if (!isProportional)
        {
            ps = boxSize;
        }
        else
        {
            ps = (viewSize / contentSize) * viewSize;
        }

        var maxSize = viewSize - (2 * boxSize);

        if (ps < 12)
        {
            ps = 12;
        }
        else if (ps >= maxSize)
        {
            ps = .95 * maxSize;
        }

        return ps;
    };

    //---- public: layout().
    closure.layout = function ()
    {
        //---- cancel and clear timer ----
        if (timer != null)
        {
            clearTimeout(timer);
            timer = null;
        }

        //---- calc thumb size ----
        if ((trackWidth) && (trackHeight))
        {
            // CHW: adjusted thumb sizing

            if (isVertical)
            {
                thumbWidth = trackWidth - 2*thumbMargin;
                thumbHeight = calcProportionalSize(trackHeight);
            }
            else
            {
                thumbWidth = calcProportionalSize(trackWidth);
                thumbHeight = trackHeight - 2*thumbMargin;
            }

            //---- apply thumb size ----
            scrollThumb
                .width(thumbWidth)
                .height(thumbHeight);

            //---- layout rest of parts ----
            if (isVertical)
            {
                //scrollTrack
                //    .attr("x", 0);

                scrollThumb
                    .attr("x", thumbMargin);

                //box1.transform("offset(0px, 0px");

                var y2 = trackHeight - trackWidth;
                var scale = trackWidth / defaultScrollBarSize;

                setBoxTransform(box1, 0, 0, scale);
                setBoxTransform(box2, 0, y2, scale);
            }
            else
            {
                scrollTrack
                    .attr("y", 0);

                scrollThumb
                    .attr("y", thumbMargin);

                var x2 = trackWidth - trackHeight;
                var scale = trackHeight / defaultScrollBarSize;

                setBoxTransform(box1, 0, 0, scale);
                setBoxTransform(box2, x2, 0, scale);
            }
        }

        closure.update();
    };

    /// private.
    var setBoxTransform = function (box, x, y, scale)
    {
        var str = "translate(" + x + ", " + y + ") scale(" + scale + ")";        // no "px" allowed for SVG transforms
        box.transform(str);
    }

    //---- property: min ----
    closure.min = function (value)
    {
        if (value === undefined)
        {
            return min;
        }

        min = value;
        markLayoutNeeded();

        return closure;
    };

    //---- property: max ----
    closure.max = function (value)
    {
        if (value === undefined)
        {
            return max;
        }

        max = value;
        markLayoutNeeded();

        return closure;
    };

    //---- property: isProportional ----
    closure.isProportional = function (value)
    {
        if (value === undefined)
        {
            return isProportional;
        }

        isProportional = value;
        markLayoutNeeded();

        return closure;
    };

    //---- property: value ----
    closure.value = function (actualValue)
    {
        if (actualValue === undefined)
        {
            return value;
        }

        setValue(actualValue, true);
        return closure;
    };

    //---- property: smallChange ----
    closure.smallChange = function (value)
    {
        if (value === undefined)
        {
            return smallChange;
        }

        smallChange = value;
        return closure;
    };

    //---- property: largeChange ----
    closure.largeChange = function (value)
    {
        if (value === undefined)
        {
            return largeChange;
        }

        largeChange = value;
        return closure;
    };

    //---- property: contentSize ----
    /// used to calculate proportional scrollbar thumb length.
    closure.contentSize = function (value)
    {
        if (value === undefined)
        {
            return contentSize;
        }

        contentSize = value;
        markLayoutNeeded();

        return closure;
    };

    closure.getTrackWidth = function ()
    {
        return trackWidth;
    };

    closure.getTrackHeight = function ()
    {
        return trackHeight;
    };

    build();    // build now

    return domElement;

};

vp.nextScrollBarId = 1;

vp.visuals.verticalScrollBar = function ()
{
    return vp.scrollBarFactory(true);
};

vp.visuals.horizontalScrollBar = function ()
{
    return vp.scrollBarFactory(false);
};

vp.scrollCmds = { home: 0, smallIncrement: 1, largeIncrement: 2, smallDecrement: 3, largeDecrement: 4, thumpPosition: 5, end: 6 };


///----------------------------------------------------------------
/// (from visualParts\scrollViewer.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// scrollViewer.js.  Copyright (c) 2012 Microsoft Corporation.
///      - part of the vuePlot library.
///      - implements a customizable scrollViewer control.
///-----------------------------------------------------------------------------------------------------------------
/// testing: see scrollViewer.html
///-----------------------------------------------------------------------------------------------------------------

/// create a customizable scrollbar control.
vp.scrollViewer = function ()
{
    //---- private state ----
    var hsbVisibility = vp.scrollVisiblity.visible;
    var vsbVisibility = vp.scrollVisiblity.visible;
    var domElement = null;
    var hsb = null;
    var vsb = null;
    var lowerRightBox = null;           // for when both hsb and vsb are visible

    var timer = null;
    var scrollListeners = [];
    var content = null;
    var root = null;
    var preContentCount = 0;

    //---- closure: layout() ----
    var layout = function ()
    {
        if (timer != null)
        {
            clearTimeout(timer);
            timer = null;
        }

        var hsbVis = false;
        var vsbVis = false;

        var width = root.width();
        var height = root.height();

        if (domElement.childNodes.length > preContentCount)
        {
            var newContent = vp.select(domElement.childNodes[preContentCount]);

            if (!compareWrapperContent(content, newContent))
            {
                //---- content changed ----
                if (content)
                {
                    //---- detach our event handler on previous content ----
                    vp.events.detach(content, "resize", markLayoutNeeded);
                }

                content = newContent;

                if (content)
                {
                    //---- attach new event handler ----
                    content.attach("resize", markLayoutNeeded);

                    //---- set position to "absolute" to prevent the content from changing our size ----
                    content.css("position", "absolute");
                    content.css("zIndex", "1");
                }
            }
        }

        var contentHeight = (content) ? content.totalHeight() : 0;
        var contentWidth = (content) ? content.totalWidth() : 0;

        if (hsbVisibility == vp.scrollVisiblity.visible)
        {
            hsbVis = true;
        }
        else if (hsbVisibility == vp.scrollVisiblity.auto)
        {
            hsbVis = ((content) && (contentWidth > width));
        }

        if (vsbVisibility == vp.scrollVisiblity.visible)
        {
            vsbVis = true;
        }
        else if (vsbVisibility == vp.scrollVisiblity.auto)
        {
            vsbVis = ((content) && (contentHeight > height));
        }

        hsb.show(hsbVis);
        vsb.show(vsbVis);

        // CHW: move layout later and make sure bounds height and width don't go to 0
        // When hsb or vsb is invisible, the only change below is in the ?sbVis???? 
        // variables which simply determines the length of the scroll bar.  

        var hsbTrackHeight = hsb.getTrackHeight();
        var hsbVisHeight = (hsbVis) ? hsbTrackHeight : 0;
        var vsbTrackWidth = vsb.getTrackWidth();
        var vsbVisWidth = (vsbVis) ? vsbTrackWidth : 0;

        //---- layout hsb ----
        var hsbWidth = width - vsbVisWidth;

        //---- why does content show thru on last row? ----
        //---- it appears the HSB is being drawn on 1/2 pixel boundaries, so it only shades the last row (not covers) ----
        hsb.bounds(0, height - hsbTrackHeight, hsbWidth, hsbTrackHeight);

        var max = (content) ? contentWidth - hsbWidth + 1 : 0;
        max = Math.max(0, max);

        var pageSizeH = Math.round(.9 * hsbWidth);
        var lineSizeH = Math.round(pageSizeH / 15);

        hsb
            .min(0)
            .max(max)
            .smallChange(lineSizeH)
            .largeChange(pageSizeH);

        hsb.contentSize(contentWidth);

        hsb.layout();      // update layout; this will reset the scroll value based on the new content size

        //---- layout vsb ----
        var vsbHeight = height - hsbVisHeight;

        vsb.bounds(width - vsbTrackWidth, 0, vsbTrackWidth, vsbHeight);

        var max = (content) ? contentHeight - vsbHeight + 1 : 0;
        max = Math.max(0, max);

        var pageSize = Math.round(.9 * vsbHeight);
        var lineSize = Math.round(pageSize / 15);

        vsb
            .min(0)
            .max(max)
            .smallChange(lineSize)
            .largeChange(pageSize);

        vsb.contentSize(contentHeight);

        vsb.layout();      // update layout; this will reset the scroll value based on the new content size

        applyScrolling({ target: vsb });        // TODO: the new code only calls applyScrolling once; what should the target be?

        if ((hsbVis) && (vsbVis))
        {
            lowerRightBox
                .bounds(width - vsbVisWidth, height - hsbVisHeight, vsbVisWidth, hsbVisHeight)
                .show();
        }
        else
        {
            lowerRightBox
                .hide();
        }
    };

    layout.ctr = "vp.visuals.scrollViewer";

    layout.extendWrapper = function (wrapper)
    {
        vp.makeControlProperty(wrapper, "hsb");
        vp.makeControlProperty(wrapper, "vsb");
        vp.makeControlProperty(wrapper, "min");
        vp.makeControlProperty(wrapper, "max");
        vp.makeControlProperty(wrapper, "value");
        vp.makeControlProperty(wrapper, "smallChange");
        vp.makeControlProperty(wrapper, "largeChange");
        vp.makeControlProperty(wrapper, "hsbVisibility");
        vp.makeControlProperty(wrapper, "vsbVisibility");

        vp.makeControlFunc(wrapper, "attach");
        vp.makeControlFunc(wrapper, "detach");
    };

    /// private.
    var compareWrapperContent = function (ss1, ss2)
    {
        var e1 = (ss1 != null) ? ss1[0] : null;
        var e2 = (ss2 != null) ? ss2[0] : null;

        return (e1 == e2);
    };

    /// private.
    var applyScrolling = function (e)
    {
        if (content)
        {
            var xOffset = -hsb.value();
            var yOffset = -vsb.value();

            //content.css("left", xOffset);
            //content.css("top", yOffset);

            //---- using a SPAN around text - need to add topBorder offset (not calculated correctly by browser layout) ----
            //var cs = window.getComputedStyle(content[0]);
            //var bs = parseFloat(cs["borderTopWidth"]);
            //yOffset += bs;

            var offset = "translate(" + xOffset + "px, " + yOffset + "px)";

            content.transform(offset);
        }

        onScroll(e);
    };

    //---- private: build() ----
    var build = function ()
    {
        if (!domElement)
        {
            domElement = vp.dom.createHtml("div");

            //---- add a property on element to get access to control (closure object) ----
            domElement.control = layout;

            root = vp.select(domElement)
                //.css("zIndex", -2)     // setting this to -2 breaks elementFromPoint() on Chrome
                .css("position", "relative")
                .css("overflow", "hidden")
                .setClass("scrollViewer")
                .attach("resize", markLayoutNeeded);
        }
        else
        {
            root.clear();
        }

        //---- add a background IMG so that can catch all mouse wheel events ----
        root
            .append("img")
            //.attr("src", "/images/SmallWhiteRect.png")   // don't tie to images dir
            .css("visibility", "hidden")    // will still receive events
            //.css("background", "purple")     // debug
            .css("position", "absolute")
            .css("zIndex", "-3")
            .width("100%")
            .height("100%")
            .attach("mousewheel", function (e)
            {
                if (vsb)
                {
                    vsb.processMouseWheelEvent(e);
                }
            });
        preContentCount++;

        vp.events.attach(domElement, "mousewheel", function (e)
        {
            if (vsb)
            {
                vsb.processMouseWheelEvent(e);
            }
        });

        // CHW: add isProportional(true)

        //---- add HORIZONTAL SB ----
        hsb = root.append(vp.visuals.horizontalScrollBar())
          .id("horizontalScrollBar")
          .css("zIndex", 2)
          .css("position", "absolute")
          .attach("change", applyScrolling)
          .isProportional(true);

        //---- add VERTICAL SB ----
        vsb = root.append(vp.visuals.verticalScrollBar())
            .id("verticalScrollBar")
            .css("zIndex", 2)
            .css("position", "absolute")
            .attach("change", applyScrolling)
            .isProportional(true);

        //---- add lower/right box to hide content underneath where scrollbars stop ----
        lowerRightBox = root.append("div")
            .setClass("scrollLowerRightBox")
            .css("zIndex", 2)
            .css("position", "absolute");

        preContentCount += 3;

        root.attach("DOMNodeInserted", function (e)
        {
            markLayoutNeeded();
        });
    };

    /// pubilc: element().
    layout.element = function ()
    {
        return domElement;
    };

    /// pubilc: hsb()
    layout.hsb = function ()
    {
        return hsb;
    };

    /// pubilc: vsb().
    layout.vsb = function ()
    {
        return vsb;
    };

    /// private: markLayoutNeeded().
    var markLayoutNeeded = function ()
    {
        if (timer == null)
        {
            timer = setTimeout(layout, 1);
        }
    };

    /// private: onScroll().
    var onScroll = function (e)
    {
        //---- create a simplified event object ----
        for (var i = 0; i < scrollListeners.length; i++)
        {
            var callback = scrollListeners[i];

            callback(e);
        }
    };

    //---- function: attach() ----
    layout.attach = function (eventName, callback)
    {
        if (eventName.toLowerCase() == "scroll")
        {
            scrollListeners.push(callback);
        }
        else
        {
            //---- defer to the domElement for other events ----
            // CHW: delegate to global attach function
            vp.events.attach(domElement, eventName, callback);
        }

        return this;
    };

    //---- function: detach() ----
    layout.detach = function (eventName, callback)
    {
        if (eventName.toLowerCase() == "scroll")
        {
            scrollListeners.remove(callback);
        }
        else
        {
            //---- defer to the domElement for other events ----
            // CHW: delegate to global deattach function
            vp.events.detach(domElement, eventName, callback);
        }

        return this;
    };

    //---- private: onSizesChanged().
    var onSizesChanged = function ()
    {
        markLayoutNeeded();
    };

    //---- property: hsbVisibility ----
    layout.hsbVisibility = function (value)
    {
        if (value === undefined)
        {
            return hsbVisibility;
        }

        hsbVisibility = value;
        onSizesChanged();
        markLayoutNeeded();

        return this;
    };

    //---- property: vsbVisibility ----
    layout.vsbVisibility = function (value)
    {
        if (value === undefined)
        {
            return vsbVisibility;
        }

        vsbVisibility = value;
        markLayoutNeeded();
        onSizesChanged();

        return this;
    };

    //---- init code ----
    build();    // build now

    return domElement;

};

vp.scrollVisiblity = { hidden: 0, visible: 1, auto: 2 };

///----------------------------------------------------------------
/// (from visualParts\visUtils.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// visUtils.js.  Copyright (c) 2012 Microsoft Corporation.
///    This file is part of the VuePlot library.  It implements various 
///    visual utility functions.
///-----------------------------------------------------------------------------------------------------------------

vp.makeControlProperty = function (wrapper, propName)
{
    var propFunc = function (value)
    {
        //---- GET value ----
        if (arguments.length == 0)
        {
            var value = null;
            if (wrapper.length > 0)
            {
                var f = wrapper[0].control[propName];
                value = f.call();
            }

            return value;
        }
        else
        {
            //---- SET value ----
            var origValue = value;

            return wrapper.each(function (index, element)
            {
                //if (vp.isFunction(origValue))
                //{
                //    value = origValue(index, element);
                //}

                //---- control stored on actual element, not wrapper ----
                var f = element[0].control[propName];
                f.call(null, value);
            });
        }
    };

    wrapper[propName] = propFunc;
};

vp.makeControlFunc = function (wrapper, funcName)
{
    var func = function ()
    {
        var args = arguments;

        return wrapper.each(function (index, element)
        {
            //---- control stored on actual element, not wrapper ----
            var control = element[0].control;

            var f = control[funcName];
            f.apply(control, args);
        });
    };

    wrapper[funcName] = func;
};

vp.makeControlFuncWithReturnValue = function (wrapper, funcName)
{
    var func = function ()
    {
        var args = arguments;
        var returnValue = undefined;

        wrapper.each(function (index, element)
        {
            //---- control stored on actual element, not wrapper ----
            var control = element[0].control;

            var f = control[funcName];
            returnValue = f.apply(control, args);
        });

        return returnValue;
    };

    wrapper[funcName] = func;
};
///-----------------------------------------------------------------------------------------------------------------
/// shapeData.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - provides path data for different shape types.
///-----------------------------------------------------------------------------------------------------------------
/// layer responsibilities: see layerBar.js
///-----------------------------------------------------------------------------------------------------------------
vp.getPathDataForShape = function (shapeType, x, y, w, h)
{
    var move = function (str, x, y)
    {
        str += " M " + x + " " + y;
        return str;
    }

    var line = function (str, x, y)
    {
        str += " L " + x + " " + y;
        return str;
    }

    var circle = function (str, cx, cy, r)
    {
        str += " M " + (cx - r) + " " + cy +
            " a " + r + " " + r + " 0 1 0 " + (2 * r) + " 0" +
            " a " + r + " " + r + " 0 1 0 " + (-2 * r) + " 0";

        return str;
        
    }

    var close = function (str)
    {
        str += " z";
        return str;
    }

    var d = "";

    //---- scale our 0..1 vars as per the desired bounds ----
    var x0 = x - w / 2;
    var x1 = x + w / 2;
    var x5 = x;

    var y0 = y - h / 2;
    var y1 = y + h / 2;
    var y5 = y;

    switch (shapeType)
    {
        case 2:
        case 17:
        case 24:
            {
                //---- triangle ----
                d = move(d, x0, y1);
                d = line(d, x5, y0);
                d = line(d, x1, y1);
                d = close(d);
                break;
            }

        case 3:
            {
                //---- plus sign ----
                d = move(d, x0, y5);
                d = line(d, x1, y5);
                d = move(d, x5, y1);
                d = line(d, x5, y0);
                break;
            }

        case 4:
            {
                //---- big X ----
                d = move(d, x0, y0);
                d = line(d, x1, y1);
                d = move(d, x1, y0);
                d = line(d, x0, y1);
                break;
            }

        case 5:
        case 18:
        case 23:
            {
                //---- diamond ----
                d = move(d, x5, y0);
                d = line(d, x0, y5);
                d = line(d, x5, y1);
                d = line(d, x1, y5);
                d = line(d, x5, y0);
                d = close(d);
                break;
            }

        case 6:
        case 25:
            {
                //---- upside down triangle ----
                d = move(d, x0, y0);
                d = line(d, x5, y1);
                d = line(d, x1, y0);
                d = close(d);
                break;
            }

        case 30:
            {
                //---- left pointing triangle ----
                d = move(d, x5, y0);
                d = line(d, x5, y1);
                d = line(d, x0, y5);
                d = close(d);
                break;
            }

        case 31:
            {
                //---- left pointing triangle ----
                d = move(d, x5, y0);
                d = line(d, x5, y1);
                d = line(d, x1, y5);
                d = close(d);
                break;
            }

        case 32:
            {
                //---- for pentagram ----
                var y3 = y0 + .36 * h;
                var y6 = y0 + .62 * h;
                var y7 = y0 + .76 * h;

                var x2 = x0 + .19 * w;
                var x3 = x0 + .31 * w;
                var x4 = x0 + .37 * w;
                var x6 = x0 + .63 * w;
                var x7 = x0 + .69 * w;
                var x8 = x0 + .85 * w;

                //---- 5 point star ----
                d = move(d, x5, y0);
                d = line(d, x6, y3);
                d = line(d, x1, y3);
                d = line(d, x7, y6);
                d = line(d, x8, y1);
                d = line(d, x5, y7);
                d = line(d, x2, y1);
                d = line(d, x3, y6);
                d = line(d, x0, y3);
                d = line(d, x4, y3);
                d = close(d);
                break;
            }

        case 33:
            {
                //---- for hexagram ----
                var y2 = y0 + .25 * h;
                var y7 = y0 + .75 * h;

                var x2 = x0 + .21 * w;
                var x3 = x0 + .36 * w;
                var x6 = x0 + .64 * w;
                var x8 = x0 + .80 * w;

                //---- 5 point star ----
                d = move(d, x5, y0);
                d = line(d, x6, y2);
                d = line(d, x1, y2);
                d = line(d, x8, y5);
                d = line(d, x1, y7);
                d = line(d, x6, y7);
                d = line(d, x5, y1);
                d = line(d, x3, y7);
                d = line(d, x0, y7);
                d = line(d, x2, y5);
                d = line(d, x0, y2);
                d = line(d, x3, y2);
                d = close(d);
                break;
            }

        case 7:
            {
                //---- X in square ----
                //---- X-part ----
                d = move(d, x0, y0);
                d = line(d, x1, y1);
                d = move(d, x1, y0);
                d = line(d, x0, y1);

                //---- square-part ----
                d = move(d, x0, y0);
                d = line(d, x0, y1);
                d = line(d, x1, y1);
                d = line(d, x1, y0);
                d = close(d);
                break;
            }

        case 8:
            {
                //---- asterisk ----

                //---- make diagonals a bit smaller ----
                var x2 = x0 + .2 * w;
                var x8 = x1 - .2 * w;

                var y2 = y0 + .2 * h;
                var y8 = y1 - .2 * h;

                d = move(d, x5, y0);
                d = line(d, x5, y1);

                d = move(d, x8, y2);
                d = line(d, x2, y8);

                d = move(d, x1, y5);
                d = line(d, x0, y5);

                d = move(d, x8, y8);
                d = line(d, x2, y2);
                break;
            }


        case 9:
            {
                //---- diamond with a plus inside ----
                //---- diamond-part ----
                d = move(d, x5, y0);
                d = line(d, x0, y5);
                d = line(d, x5, y1);
                d = line(d, x1, y5);
                d = line(d, x5, y0);
                d = close(d);

                //---- plus-part ----
                d = move(d, x0, y5);
                d = line(d, x1, y5);
                d = move(d, x5, y1);
                d = line(d, x5, y0);
                break;
            }

        case 10:
            {
                //---- plus in a circle ----
                //---- circle-part ----
                d = circle(d, x5, y5, w/2);

                //---- plus-part ----
                d = move(d, x0, y5);
                d = line(d, x1, y5);
                d = move(d, x5, y1);
                d = line(d, x5, y0);
                break;
            }

        case 11:
            {
                //---- 2 triangles ----
                //---- triangle-part ----
                d = move(d, x0, y1);
                d = line(d, x5, y0);
                d = line(d, x1, y1);
                d = close(d);
                //---- down-triangle-part ----
                d = move(d, x0, y0);
                d = line(d, x5, y1);
                d = line(d, x1, y0);
                d = close(d);
                break;
            }

        case 12:
            {
                //---- square with plus ----
                //---- square-part ----
                d = move(d, x0, y0);
                d = line(d, x0, y1);
                d = line(d, x1, y1);
                d = line(d, x1, y0);
                d = close(d);
                //---- plus-part ----
                d = move(d, x0, y5);
                d = line(d, x1, y5);
                d = move(d, x5, y1);
                d = line(d, x5, y0);
                break;
            }

        case 13:
            {
                //---- X in a circle ----
                //---- circle-part ----
                d = circle(d, x5, y5, w / 2);

                //---- X-part ----
                d = move(d, x0, y0);
                d = line(d, x1, y1);
                d = move(d, x1, y0);
                d = line(d, x0, y1);
                break;
            }

        case 14:
            {
                //---- triangle in a square ----
                //---- triangle-part ----
                //---- triangle-part ----
                d = move(d, x0, y1);
                d = line(d, x5, y0);
                d = line(d, x1, y1);
                d = close(d);

                //---- square-part ----
                d = move(d, x0, y0);
                d = line(d, x0, y1);
                d = line(d, x1, y1);
                d = line(d, x1, y0);
                d = close(d);
                break;
            }
    }

    return d;
}


///----------------------------------------------------------------
/// (from vvPlot\statBin.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// statBin.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - bins the data as a vvPlot stat.
///-----------------------------------------------------------------------------------------------------------------
/// stat responsibilities (informal contract/API):
///     - statX()   - optional; return new "x" column name
///     - statY()   - optional; return new "y" column names
///     - calcXScaleForLayer() - optional; take over responsiblity for calculating yMin, yMax for this layer.
///     - calcYScaleForLayer() - optional; take over responsiblity for calculating yMin, yMax for this layer.
///-----------------------------------------------------------------------------------------------------------------
vp.stats.statBin = function ()
{
    //---- private state ----
    var binPercent = .3;
    var forceCategory = false;
    var usePercent = false;
    var isCategory = false;
    var dataUsed = null;
    var niceBuckets = false;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.stats.statBin";

    closure.isCategory = function()
    {
        return isCategory;
    }

    closure.data = function ()
    {
        return dataUsed;
    }

    //---- property: forceCategory ----
    closure.forceCategory = function (value)
    {
        if (arguments.length == 0)
        {
            return forceCategory;
        }

        forceCategory = value;

        return closure;
    };

    //---- property: usePercent ----
    closure.usePercent = function (value)
    {
        if (arguments.length == 0)
        {
            return usePercent;
        }

        usePercent = value;

        return closure;
    };

    //---- property: binPercent ----
    closure.binPercent = function (value)
    {
        if (arguments.length == 0)
        {
            return binPercent;
        }

        binPercent = value;

        return closure;
    };

    //---- property: niceBuckets ----
    closure.niceBuckets = function (value)
    {
        if (arguments.length == 0)
        {
            return niceBuckets;
        }

        niceBuckets = value;

        return closure;
    };

    closure.runStatOnData = function (xCol, yCols, data, layer)
    {
        var xColName = ["name"];

        if ((data) && (data.length > 0))
        {
            if (xCol)
            {
                //---- if array, get first element ----
                //xCol = (xCol.length) ? (xCol[0]) : xCol;

                var xdata = data.map(function (data, index) { return data[xCol]; });
                var isNumeric = ((!forceCategory) && (vp.utils.isDataNumeric(xdata)));

                var binCount = Math.max(1, Math.round(1 / binPercent));

                if (isNumeric)
                {
                    //---- compute min/max for our properties ----
                    dataUsed = xdata;

                    //---- numeric bin ----
                    data = vp.createBins(xdata, binCount, false, niceBuckets);
                    isCategory = false;
                    xColName = ["min"];
                }
                else
                {
                    //---- category bin ----
                    data = vp.createCategoryBins(xdata, xCol);
                    isCategory = true;

                    xColName = xCol;
                }
            }
        }

        var yColName = (usePercent) ? "density" : "count";

        return { xCol: xColName, yCols: [yColName], data: data };

    };

    return closure;
};


///----------------------------------------------------------------
/// (from vvPlot\statBin2d.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// statBin2d.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - bins the data in both X and Y data.
///-----------------------------------------------------------------------------------------------------------------

/// a struct to hold bin parameters.
vp.stats.binParams = function (binCount, forceCategory, usePercent, niceBuckets)
{
    this.binCount = binCount;
    this.forceCategory = forceCategory;
    this.usePercent = usePercent;
    this.niceBuckets = niceBuckets;
};

vp.stats.statBin2d = function ()
{
    //---- private state ----
    var xBinParams = new vp.stats.binParams(9, false, false, false);
    var yBinParams = new vp.stats.binParams(9, false, false, false);
    var dataUsed = null;

    //---- values after running bin ----
    var xIsCategory = false;
    var yIsCategory = false;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.stats.statBin2d";

    closure.xIsCategory = function ()
    {
        return xIsCategory;
    }

    closure.yIsCategory = function ()
    {
        return yIsCategory;
    }

    closure.data = function ()
    {
        return dataUsed;
    }

    //---- property: xBinParams ----
    closure.xBinParams = function (value)
    {
        if (arguments.length == 0)
        {
            return xBinParams;
        }

        xBinParams = value;

        return closure;
    };

    //---- property: yBinParams ----
    closure.yBinParams = function (value)
    {
        if (arguments.length == 0)
        {
            return yBinParams;
        }

        yBinParams = value;

        return closure;
    };

    var binCol = function (data, colName, binParams)
    {
        var vector = data.map(function (data, index) { return data[colName]; });
        var newData = null;
        var xColName = ["name"];

        var isNumeric = ((! binParams.forceCategory) && (vp.utils.isDataNumeric(vector)));

        var binCount = Math.max(1, Math.round(binParams.binCount));
        var isCategory = false;

        if (isNumeric)
        {
            //---- compute min/max for our properties ----
            dataUsed = vector;

            //---- numeric bin ----
            newData = vp.createBins(vector, binCount, false, binParams.niceBuckets, true);
            isCategory = false;
            xColName = ["min"];
        }
        else
        {
            //---- category bin ----
            newData = vp.createCategoryBins(vector, colName, true);
            isCategory = true;

            xColName = colName;
        }

        var yColName = (binParams.usePercent) ? "density" : "count";

        return { xCol: xColName, yCols: [yColName], data: newData, isCategory: isCategory };
    }

    closure.runStatOnData = function (xCol, yCols, data, layer)
    {
        var result = { rowCount: 0, colCount: 0, data: null };

        if ((data) && (data.length > 0))
        {
            var dataCount = data.length;

            if ((xCol) && (yCols.length > 0))
            {
                var yCol = yCols[0];

                //---- if array, get first element ----
                xCol = (xCol.length) ? (xCol[0]) : xCol;

                var xResult = binCol(data, xCol, xBinParams);
                xIsCategory = xResult.isCategory;

                var yResult = binCol(data, yCol, yBinParams);
                yIsCategory = yResult.isCategory;

                //---- set up counters for each row/col bucket ----
                var colCount = xResult.data.length;
                var rowCount = yResult.data.length;
                var gridTotals = [];

                for (var r = 0; r < rowCount; r++)
                {
                    var row = [];

                    for (var c = 0; c < colCount; c++)
                    {
                        row.push(0);
                    }

                    gridTotals.push(row);
                }

                var xAssignments = xResult.data.assignments;
                var yAssignments = yResult.data.assignments;

                //---- now, count the number of data items in "data" in each row/col bucket ----
                for (var i = 0; i < data.length; i++)
                {
                    var colIndex = xAssignments[i];
                    var rowIndex = yAssignments[i];

                    gridTotals[rowIndex][colIndex]++;
                }

                //---- build data from gridTotals, centered in X and Y data spaces ----
                if (xIsCategory)
                {
                    xMin = 0;;
                    xMax = colCount - 1;
                }
                else
                {
                    var xMin = xResult.data[0].min;
                    var xMax = xResult.data[colCount - 1].max;
                    var xSize = xResult.data[0].max - xResult.data[0].min;

                    //---- center points ----
                    xMin += xSize / 2;
                    xMax -= xSize / 2;
                }

                if (yIsCategory)
                {
                    yMin = 0;
                    yMax = rowCount - 1;
                }
                else
                {
                    var yMin = yResult.data[0].min;
                    var yMax = yResult.data[rowCount - 1].max;
                    var ySize = yResult.data[0].max - yResult.data[0].min;

                    //---- center points ----
                    yMin += ySize / 2;
                    yMax -= ySize / 2;
                }

                var newData = [];
                var x, y;

                for (var r = 0; r < rowCount; r++)
                {
                    if (yIsCategory)
                    {
                        y = yResult.data[r][yCol];
                    }
                    else
                    {
                        y = yResult.data[r].name;
                    }

                    for (var c = 0; c < colCount; c++)
                    {
                        //---- center the tiles in the data X and Y spaces ----
                        //var x = vp.utils.mapValue(c, 0, colCount - 1, xMin, xMax);
                        //var y = vp.utils.mapValue(r, 0, rowCount - 1, yMin, yMax);

                        if (xIsCategory)
                        {
                            x = xResult.data[c][xCol];
                        }
                        else
                        {
                            x = xResult.data[c].name;
                        }

                        var value = gridTotals[r][c];

                        var record = { x: x, y:y, value: value, percent: 100*value/dataCount };
                        newData.push(record);
                    }
                }

                newData.xResult = xResult;
                newData.yResult = yResult;

                result =
                {
                    rowCount: rowCount, colCount: colCount,
                    totals: gridTotals, data: newData, xCol: "x", yCols: ["y"]
                };
            }
        }

        return result;
    };


    return closure;
};


///----------------------------------------------------------------
/// (from vvPlot\statBoxPlot.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// statBoxPlot.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - a vvPlot stat object that creates boxPlot quartile data 
///-----------------------------------------------------------------------------------------------------------------
/// stat responsibilities (informal contract/API):
///     see statBin.js
///-----------------------------------------------------------------------------------------------------------------
vp.stats.statBoxPlot = function ()
{
    //---- private state ----
    var whiskerType = 0;        // default is tukey

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.stats.statBoxPlot";

    /// calcYScaleForLayer()
    closure.calcYScaleForLayer = function (layer)
    {
        var thisMin = +9999999;
        var thisMax = -9999999;
        var layInfo = layer.info;

        //---- compute ymin/ymax from "yMin", "yMax" fields on each data record ----
        var records = layInfo.filteredData;

        //---- special min/max requirements ----
        for (var i = 0; i < records.length; i++)
        {
            var record = records[i];

            thisMin = Math.min(thisMin, record.yMin);
            thisMax = Math.max(thisMax, record.yMax);
        }

        return { min: thisMin, max: thisMax };
    }

    closure.setWhiskerType = function(whiskerTypeArg)
    {
        whiskerType = whiskerTypeArg;
    }

    closure.runStatOnData = function (xCol, yCols, data, layer)
    {
        if ((data) && (data.length > 0))
        {
            if ((xCol) && (yCols.length > 0))
            {
                data = vp.createBoxPlotData(data, xCol, yCols[0], whiskerType);
            }
        };

        return {
            xCol: ["name"],
            yCols: ["lower", "middle", "upper", "yMin", "yMax", "lowFence", "highFence", "outliers"],
            data: data };
    }

    return closure;
};


///----------------------------------------------------------------
/// (from vvPlot\statContour.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// statContour.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - converts a flat set of records (with fields x, y, z) into a set of from/to point records (x1, y1, x2, y2).
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (stats) {
        /** settings for an attribute (value, scaling, and legend data). */
        var statContourClass = (function () {
            function statContourClass() {
                //---- private state ----
                this._contourCount = 5;
                this._colCount = undefined;
                this._xColName = "";
                this._yColName = "";
                this._zColName = "";
                this.runStatOnData = function (xCol, yCols, data, layer) {
                    var lineRecords = [];
                    var result = { data: lineRecords, xCol: [], yCol: ["x1", "y1", "x2", "y2"] };

                    if ((xCol) && (yCols.length > 1)) {
                        var rows = data;
                        var count = rows.length;

                        var colCount = this._colCount;
                        if (colCount === undefined) {
                            colCount = Math.floor(Math.sqrt(count));
                        }

                        var rowCount = Math.ceil(count / colCount);
                        var contourCount = this._contourCount;

                        this._xColName = (xCol.length) ? (xCol[0]) : xCol;
                        this._yColName = yCols[0];
                        this._zColName = yCols[1];
                        var zColName = this._zColName;

                        //---- find ZMIN and ZMAX ----
                        var zMin = Number.MAX_VALUE;
                        var zMax = -zMin;
                        var index = 0;

                        for (var r = 0; r < rowCount - 1; r++) {
                            for (var c = 0; c < colCount - 1; c++) {
                                var z = rows[index++][zColName];
                                if (z < zMin) {
                                    zMin = z;
                                }

                                if (z > zMax) {
                                    zMax = z;
                                }
                            }
                        }

                        //---- build contour heights ----
                        var contourHeights = [];
                        var zRange = zMax - zMin;

                        for (var k = 0; k < contourCount; k++) {
                            contourHeights[k] = zMin + k * zRange / (contourCount - 1);
                        }

                        var index = 0;

                        for (var r = 0; r < rowCount - 1; r++) {
                            for (var c = 0; c < colCount - 1; c++) {
                                var pt1 = rows[index];
                                var pt2 = rows[index + 1];
                                var pt3 = rows[index + colCount];
                                var pt4 = rows[index + colCount + 1];

                                for (var k = 0; k < contourCount; k++) {
                                    this.addLineDataForLeftTriangle(lineRecords, contourHeights[k], pt1, pt3, pt4);

                                    this.addLineDataForRightTriangle(lineRecords, contourHeights[k], pt1, pt2, pt4);
                                }

                                index++;
                            }
                        }
                    }

                    return result;
                };
            }
            statContourClass.prototype.contourCount = function (value) {
                if (arguments.length == 0) {
                    return this._contourCount;
                }

                this._contourCount = value;
                return this;
            };

            statContourClass.prototype.isBetween = function (k, pt1, pt2) {
                var zCol = this._zColName;

                var isBet = ((k >= pt1[zCol] && k < pt2[zCol]) || (k >= pt2[zCol] && k < pt1[zCol]));
                return isBet;
            };

            statContourClass.prototype.zFactor = function (k, pt1, pt2) {
                var zCol = this._zColName;

                var zfactor = (k - pt1[zCol]) / (pt2[zCol] - pt1[zCol]);
                return zfactor;
            };

            statContourClass.prototype.addLine = function (lineRecords, x1, y1, x2, y2) {
                var record = { x1: x1, y1: y1, x2: x2, y2: y2 };
                lineRecords.push(record);
            };

            statContourClass.prototype.lerp = function (percent, a, b) {
                return a + percent * (b - a);
            };

            /// "k" is the coutour level.
            statContourClass.prototype.addLineDataForLeftTriangle = function (lineRecords, k, pt0, pt1, pt2) {
                var xCol = this._xColName;
                var yCol = this._yColName;

                //--- left triangle ----
                var isBet01 = this.isBetween(k, pt0, pt1);
                var isBet12 = this.isBetween(k, pt1, pt2);
                var isBet02 = this.isBetween(k, pt0, pt2);

                if (isBet01 && isBet12) {
                    //---- case c: DIAGONAL line in left triangle ----
                    var percent1 = this.zFactor(k, pt0, pt1);
                    var percent2 = this.zFactor(k, pt1, pt2);

                    var x1 = pt0[xCol];
                    var y1 = this.lerp(percent1, pt0[yCol], pt1[yCol]);
                    var x2 = this.lerp(percent2, pt1[xCol], pt2[xCol]);
                    var y2 = pt1[yCol];

                    this.addLine(lineRecords, x1, y1, x2, y2);
                } else if (isBet02 && isBet12) {
                    //---- case b: VERTICAL line in left triangle ----
                    var percent1 = this.zFactor(k, pt0, pt2);
                    var percent2 = this.zFactor(k, pt1, pt2);

                    var x1 = this.lerp(percent1, pt0[xCol], pt2[xCol]);
                    var y1 = this.lerp(percent1, pt0[yCol], pt2[yCol]);
                    var x2 = this.lerp(percent2, pt1[xCol], pt2[xCol]);
                    var y2 = pt1[yCol];

                    this.addLine(lineRecords, x1, y1, x2, y2);
                } else if (isBet01 && isBet02) {
                    //---- case a: HORIZONTAL line in left triangle ---
                    var percent1 = this.zFactor(k, pt0, pt1);
                    var percent2 = this.zFactor(k, pt0, pt2);

                    var x1 = pt0[xCol];
                    var y1 = this.lerp(percent1, pt0[yCol], pt1[yCol]);
                    var x2 = this.lerp(percent2, pt0[xCol], pt2[xCol]);
                    var y2 = this.lerp(percent2, pt0[yCol], pt2[yCol]);

                    this.addLine(lineRecords, x1, y1, x2, y2);
                }
            };

            /// "k" is the coutour level.
            statContourClass.prototype.addLineDataForRightTriangle = function (lineRecords, k, pt0, pt1, pt2) {
                var xCol = this._xColName;
                var yCol = this._yColName;

                //--- right triangle ----
                var isBet01 = this.isBetween(k, pt0, pt1);
                var isBet12 = this.isBetween(k, pt1, pt2);
                var isBet02 = this.isBetween(k, pt0, pt2);

                if (isBet01 && isBet12) {
                    //---- case c: DIAGONAL line in right triangle ----
                    var percent1 = this.zFactor(k, pt0, pt1);
                    var percent2 = this.zFactor(k, pt1, pt2);

                    var x1 = this.lerp(percent1, pt0[xCol], pt1[xCol]);
                    var y1 = pt0[yCol];
                    var x2 = pt1[xCol];
                    var y2 = this.lerp(percent2, pt1[yCol], pt2[yCol]);

                    this.addLine(lineRecords, x1, y1, x2, y2);
                } else if (isBet02 && isBet12) {
                    //---- case b: VERTICAL line in right triangle ----
                    var percent1 = this.zFactor(k, pt0, pt2);
                    var percent2 = this.zFactor(k, pt1, pt2);

                    var x1 = this.lerp(percent1, pt0[xCol], pt2[xCol]);
                    var y1 = this.lerp(percent1, pt0[yCol], pt2[yCol]);
                    var x2 = pt1[xCol];
                    var y2 = this.lerp(percent2, pt1[yCol], pt2[yCol]);

                    this.addLine(lineRecords, x1, y1, x2, y2);
                } else if (isBet01 && isBet02) {
                    //---- case a: HORIZONTAL line in right triangle ---
                    var percent1 = this.zFactor(k, pt0, pt1);
                    var percent2 = this.zFactor(k, pt0, pt2);

                    var x1 = this.lerp(percent1, pt0[xCol], pt1[xCol]);
                    var y1 = pt0[yCol];
                    var x2 = this.lerp(percent2, pt0[xCol], pt2[xCol]);
                    var y2 = this.lerp(percent2, pt0[yCol], pt2[yCol]);

                    this.addLine(lineRecords, x1, y1, x2, y2);
                }
            };
            return statContourClass;
        })();
        stats.statContourClass = statContourClass;

        function createStatContour() {
            return new statContourClass();
        }
        stats.createStatContour = createStatContour;
    })(vp.stats || (vp.stats = {}));
    var stats = vp.stats;
})(vp || (vp = {}));
//# sourceMappingURL=statContour.js.map

///----------------------------------------------------------------
/// (from vvPlot\statDensity.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// statDensity.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - current method is to use a normalize bin of the data.
///-----------------------------------------------------------------------------------------------------------------
/// stat responsibilities (informal contract/API):
///     see statBin.js
///-----------------------------------------------------------------------------------------------------------------
vp.stats.statDensity = function ()
{
    //---- private state ----
    var binPercent = .3;

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.stats.statDensity";

    //---- property: binPercent ----
    closure.binPercent = function (value)
    {
        if (arguments.length == 0)
        {
            return binPercent;
        }

        binPercent = value;

        return closure;
    };

    closure.runStatOnData = function (xCol, yCols, data, layer)
    {
        if ((data) && (data.length > 0))
        {
            if (xCol)
            {
                var xdata = data.map(function (data, index) { return data[xCol]; });
                var isNumeric = vp.utils.isDataNumeric(xdata);

                if (isNumeric)
                {
                    //var max = xdata.max();
                    //var min = xdata.min();
                    //var binSize = (max - min) * binPercent;
                    var binCount = 1 / binPercent;

                    //---- numeric bin ----
                    data = vp.createBins(xdata, binCount);
                }
                else
                {
                    //---- category bin ----
                    data = vp.createCategoryBins(xdata);
                }
            }
        }

        return { xCol: ["name"], yCols: ["ndensity"], data: data };

    };

    return closure;
};


///----------------------------------------------------------------
/// (from vvPlot\statIdentity.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// statIdentity.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - plots a bar chart type layer for vvPlot.
///-----------------------------------------------------------------------------------------------------------------
/// stat responsibilities (informal contract/API):
///     see statBin.js
///-----------------------------------------------------------------------------------------------------------------
vp.stats.statIdentity = function ()
{
    //---- private state ----

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.stats.statIdentity";
    closure.statType = "identity";

    closure.runStatOnData = function (xCol, yCols, data, layer)
    {
        return {xCol: xCol, yCols: yCols, data: data };
    };

    return closure;
};


///----------------------------------------------------------------
/// (from vvPlot\statSpaceFill.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// statSpaceFill.js.  Copyright (c) 2012 Microsoft Corporation.
///    - part of the vuePlot library
///    - computes the rectangle positions of each item.
///-----------------------------------------------------------------------------------------------------------------
vp.stats.statSpaceFill = function ()
{
    //---- private state ----
    var startLoc = "left";      // side to start placing blocks  (left, top, right, bottom)
    var chunking = null;
    var phrasing = "strip";

    //---- closure ----
    var closure = function ()
    {
    };

    closure.ctr = "vp.stats.statSpaceFill";

    var computeRects = function (data, bounds, da, filteredData, layer)
    {
        var seriesIndex = 0;
        var items = [];
        var totalSize = 0;
        var phrase = { side: startLoc, forward: true };

        if (phrasing == "spikes")
        {
            phrase.forward = false;
        }

        //---- first pass - compute size of each item ----
        for (var i = 0; i < data.length; i++)
        {
            //---- update drawing attributes for this itemIndex ----
            layer.updateDrawingAttributes(da, seriesIndex, i, filteredData);

            var size = da.shapeSize;        // constant, mapped, "childCount", "allChildCount"
            var sz = size;

            if (size == "childCount")
            {
            }
            else if (size == "allChildCount")
            {
            }

            var item = filteredData[i];        // we will add on to original data
            item._size = sz;

            items.push(item);

            totalSize += sz;
        }

        var maxItems = (chunking) ? chunking : 1;
        var chunk = null;

        //---- second pass - compute rect of each item ----
        for (var i = 0; i < data.length; i++)
        {
            var item = items[i];

            var size = item._size;

            //---- start new chunk ----
            if ((!chunk) || (chunk.items.length >= maxItems))
            {
                if (chunk)
                {
                    layoutChunk(chunk, bounds, phrase, totalSize);

                    //---- update width/height of bounds after each chunk is layed out ----
                    bounds.width = bounds.right - bounds.left;
                    bounds.height = bounds.bottom - bounds.top;

                    //---- get new phrase value ----
                    if (phrasing == "zigzag")
                    {
                        phrase.forward = (!phrase.forward);
                    }
                    else if (phrasing == "spiral")
                    {
                        phrase.side = getNextSide(phrase.side);
                    }
                    else if (phrasing == "spikes")
                    {
                        phrase.side = getAdjacentSide(phrase.side);
                        phrase.forward = (!phrase.forward);
                    }

                    totalSize -= chunk.size;
                }

                var isVert = ((phrase.side == "left") || (phrase.side == "right"));

                chunk = { dir: "up", items: [], size: 0, isVert: isVert };
            }

            addToChunk(chunk, item);
        }

        //---- layout last chunk ----
        if (chunk)
        {
            layoutChunk(chunk, bounds, phrase, totalSize);
        }

        //---- do final adjustments based on total vertical/horizontal layouts ----

        return items;
    };

    var addToChunk = function (chunk, item)
    {
        chunk.size += item._size;
        chunk.items.push(item);
    };

    var getDirName = function (side, forward)
    {
        var name = "";

        if (side == "left")
        {
            name = (forward) ? "top" : "bottom";
        }
        else if (side == "right")
        {
            name = (forward) ? "bottom" : "top";
        }
        else if (side == "top")
        {
            name = (forward) ? "right" : "left";
        }
        else if (side == "bottom")
        {
            name = (forward) ? "left" : "right";
        }

        return name;
    }

    var getNextSide = function (side)
    {
        var name = "";

        if (side == "left")
        {
            name = "bottom";
        }
        else if (side == "bottom")
        {
            name = "right";
        }
        else if (side == "right")
        {
            name = "top";
        }
        else if (side == "top")
        {
            name = "left";
        }

        return name;
    }

    var getAdjacentSide = function (side)
    {
        var name = "";

        if (side == "left")
        {
            name = "bottom";
        }
        else if (side == "bottom")
        {
            name = "left";
        }
        else if (side == "right")
        {
            name = "top";
        }
        else if (side == "top")
        {
            name = "right";
        }

        return name;
    }

    var layoutChunk = function (chunk, bounds, phrase, totalSize)
    {
        var chunkPercent = chunk.size / totalSize;

        //---- first, layout the chunk rect within "bounds" ----
        var cb = layoutInBounds(chunk, bounds, phrase.side, chunkPercent);
        var dirName = getDirName(phrase.side, phrase.forward);

        //---- now layout each item of the chunk within "cb" (the chunk bounds) ----
        for (var i = 0; i < chunk.items.length; i++)
        {
            var item = chunk.items[i];

            var rect = layoutInBounds(item, cb, dirName, item._size / chunk.size);
            item._bounds = rect;
        }
    };

    var layoutInBounds = function (item, bounds, side, sizePercent)
    {
        var rect = null;

        if (side == "left")
        {
            var w = bounds.width * sizePercent;
            rect = vp.geom.rect(bounds.left, bounds.top, w, bounds.height);
            bounds.left += w;
        }
        else if (side == "right")
        {
            var w = bounds.width * sizePercent;
            rect = vp.geom.rect(bounds.right - w, bounds.top, w, bounds.height);
            bounds.right -= w;
        }
        else if (side == "top")
        {
            var h = bounds.height * sizePercent;
            rect = vp.geom.rect(bounds.left, bounds.top, bounds.width, h);
            bounds.top += h;
        }
        else if (side == "bottom")
        {
            var h = bounds.height * sizePercent;
            rect = vp.geom.rect(bounds.left, bounds.bottom - h, bounds.width, h);
            bounds.bottom -= h;
        }

        return rect;
    }

    closure.runStatOnData = function (xCol, yCols, data, layer)
    {
        if ((data) && (data.length))
        {
            var seriesIndex = 1;

            //---- get THEME drawing attributes for each of the parts we will draw ----
            var da = vp.session.currentTheme().getDrawingAttributes("layerSpaceFill", seriesIndex);

            //---- update the drawing attributes with CONSTANT attribute values from client code ----
            layer.addConstantDrawingAttributes(da, seriesIndex, data);

            var bounds = vp.geom.rect(0, 0, 1, 1);
            var items = null;

            if (xCol)
            {
                var xData = vp.data.dataSelect(data, xCol[0]);

                //---- since this stat is a 1-to-1 mapping to the data, we add a "._bounds" property to the original data ----
                //---- instead of creating a new data stream.  this allows the caller to do attribute mapping on the original ----
                //---- field names. ----
                items = computeRects(xData, bounds, da, data, layer);
            }
        }

        var newData = { xCol: xCol, yCols: yCols, data: items };

        return newData;
    };

    //---- property: startLoc ----
    closure.startLoc = function (value)
    {
        if (arguments.length == 0)
        {
            return startLoc;
        }

        startLoc = value;
        return closure;
    };

    //---- property: chunking ----
    closure.chunking = function (value)
    {
        if (arguments.length == 0)
        {
            return chunking;
        }

        chunking = value;
        return closure;
    };

    //---- property: phrasing ----
    closure.phrasing = function (value)
    {
        if (arguments.length == 0)
        {
            return phrasing;
        }

        phrasing = value;
        return closure;
    };

    return closure;
};


///----------------------------------------------------------------
/// (from vvPlot\uiStateMgr.js)
///----------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// uiStateMgr.ts.  Copyright (c) 2014 Microsoft Corporation.
///    - part of the vuePlot library
///    - manages interaction on a chart.
///    - maintains list of all hover shapes (typically 0 or 1)
///    - maintains list of all selected shapes (from different layers, different series)
///    - maintains list of all records being filtered OUT of current view (multiple data sources)
///-----------------------------------------------------------------------------------------------------------------
///<reference path="../scripts/allfiles.ts" />
var vp;
(function (vp) {
    (function (events) {
        var uiStateMgrClass = (function () {
            function uiStateMgrClass(viewName, appName, dragContainer, kidsContainer, updateVisualsCallback, filterChangedCallback, queryFromElementsInBounds) {
                this.ctr = "vp.uiStateMgr";
                //---- private state ----
                this._highlight = null;
                this._selection = null;
                this._filter = null;
                this._plotShapes = null;
                this._changeAgent = null;
                this._selectionCount = 0;
                this._shareName = "";
                this._isUiEnabled = true;
                this._isSelectionEnabled = true;
                this._rubberBand = null;
                this._zoomBoxHelper = null;
                this._dragMode = "select";
                this._isMouseDown = false;
                this._mouseX = 0;
                this._mouseY = 0;
                this._dragToKidsOffset = null;
                this._selectCallback = null;
                this._viewName = viewName;
                this._appName = appName;
                this._container = vp.dom.unwrap(dragContainer);
                this._shapeContainer = vp.dom.unwrap(kidsContainer);
                this._updateVisualsCallback = updateVisualsCallback;
                this._filterChangedCallback = filterChangedCallback;
                this._queryFromElementsInBounds = queryFromElementsInBounds;

                this.initBuild();
            }
            uiStateMgrClass.prototype.initBuild = function () {
                this._highlight = vp.session.query();
                this._selection = vp.session.query();
                this._filter = vp.session.query(); // when filter is empty, all elements are included

                if (this._container) {
                    this.initRubberBand();

                    this.initPanAndZoom();

                    this.dragMode(this._dragMode);
                }
            };

            /// private: onDragModeChanged().
            uiStateMgrClass.prototype.onDragModeChanged = function () {
                var isSelect = (this._dragMode == "select");

                this._rubberBand.isEnabled(isSelect);
            };

            uiStateMgrClass.prototype.adjustBoundsToKidsContainer = function (rcBand) {
                if (this._dragToKidsOffset) {
                    //---- we don't currently have correct support for finding doc offset for nested svg docs, so let caller specify ----
                    rcBand = vp.geom.offsetRect(rcBand, this._dragToKidsOffset.left, this._dragToKidsOffset.top);
                } else {
                    var off = vp.dom.docOffset(this._container);
                    var off2 = vp.dom.docOffset(this._shapeContainer);

                    var xdiff = off.left - off2.left;
                    var ydiff = off.top - off2.top;

                    rcBand = vp.geom.offsetRect(rcBand, xdiff, ydiff);
                }

                return rcBand;
            };

            /// call this as late as possible, so that sizes will be stable.
            uiStateMgrClass.prototype.initZoomIfNeeded = function () {
                if (!this._zoomBoxHelper) {
                    this._zoomBoxHelper = vp.utils.zoomBoxHelper(vp.select(this._shapeContainer));
                }
            };

            uiStateMgrClass.prototype.initPanAndZoom = function () {
                var _this = this;
                //---- capture mouse on left mouse down ----
                vp.events.attach(document, "mousedown", function (evt) {
                    if (_this._dragMode == "panAndZoom") {
                        _this.initZoomIfNeeded();

                        var button = ('which' in evt) ? evt.which : evt.button;
                        if (button == 1) {
                            if (evt.detail == 2) {
                                _this._zoomBoxHelper.reset();
                            } else {
                                _this._isMouseDown = true;

                                //document.body.style.cursor = "move";
                                if (document.body.setCapture) {
                                    document.body.setCapture();
                                }
                            }
                        }
                    }
                });

                vp.events.attach(document, "mouseup", function (evt) {
                    if (_this._dragMode == "panAndZoom") {
                        _this.initZoomIfNeeded();

                        _this._isMouseDown = false;

                        //document.body.style.cursor = "default";
                        if (document.body.releaseCapture) {
                            document.body.releaseCapture();
                        }
                    }
                });

                //---- hook mouse move at root ----
                vp.events.attach(document, "mousemove", function (evt) {
                    if (_this._dragMode == "panAndZoom") {
                        _this.initZoomIfNeeded();

                        var pos = vp.events.mousePosition(evt);

                        var newX = pos.x;
                        var newY = pos.y;

                        if (_this._isMouseDown) {
                            _this._zoomBoxHelper.pan(_this._mouseX - newX, _this._mouseY - newY);
                        }

                        _this._mouseX = newX;
                        _this._mouseY = newY;
                    }
                });

                //---- hook mouse wheel at root ----
                vp.events.attach(document, "mousewheel", function (evt) {
                    if (_this._dragMode == "panAndZoom") {
                        _this.initZoomIfNeeded();

                        var factor = (vp.events.wheelDelta(evt) > 0) ? 1.25 : 1 / 1.25;

                        var svgoff = vp.dom.docOffset(_this._container);
                        var svgX = _this._mouseX - svgoff.left;
                        var svgY = _this._mouseY - svgoff.top;

                        //vp.utils.debug("svgoff: x=" + svgoff.left + ", y=" + svgoff.top);
                        _this._zoomBoxHelper.zoom(factor, svgX, svgY);

                        return vp.events.cancelEvent(evt);
                    }
                });
            };

            uiStateMgrClass.prototype.initRubberBand = function () {
                var _this = this;
                this._rubberBand = vp.visuals.createRubberBandSelector(this._container, function (rcBand, toggle) {
                    toggle = (!toggle); // in stdChart, we add to selection by default

                    var elems = _this.getElementsFromBounds(rcBand);
                    vp.utils.debug("getElementsFromBounds found " + elems.length + " elements");

                    var query = null;

                    //---- see if host can build query from the elements in the bounds ----
                    if ((elems.length) && (_this._queryFromElementsInBounds)) {
                        query = _this._queryFromElementsInBounds(rcBand, toggle);
                    }

                    if (query) {
                        _this.setSelectionFromBoundsQuery(query);
                    } else {
                        _this.selectElementsFromBounds(elems, toggle);
                        vp.utils.debug("after selectElementsFromBounds: selectionCount=" + _this._selectionCount);
                    }
                });
            };

            /// public: selectByKeys(keys)
            uiStateMgrClass.prototype.selectByKeys = function (keys) {
                var query = "";

                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (query != "") {
                        query += " && ";
                    }

                    query += "(data.key=='" + key + "')";
                }

                this.setSelectionFromBoundsQuery(query);
            };

            ///------------------------------------------------------------------------------------------------------
            /// TODO: this should eventually use "documentRoot.getIntersectionList(rc, null)" to efficently and correctly
            /// get the elements in the specified rectangle on IE and Chrome.  As of 07/01/2014, "getIntersectionList"
            /// was not yet working on FireFox.
            ///------------------------------------------------------------------------------------------------------
            uiStateMgrClass.prototype.getElementsFromBounds = function (rcBand) {
                var elems = [];

                if ((rcBand.width) && (rcBand.height)) {
                    var rcAjusted = this.adjustBoundsToKidsContainer(rcBand);
                    elems = vp.utils.getElementsInBounds(this._shapeContainer, rcBand, rcAjusted);
                } else {
                    //---- band is too small; just get element at single point ----
                    var offset = vp.dom.docOffset(this._container);
                    var elem = vp.events.elementFromPoint(rcBand.left + offset.left, rcBand.top + offset.top);
                    if ((elem) && (elem.dataItem)) {
                        elems.push(elem);
                    }
                }

                return elems;
            };

            uiStateMgrClass.prototype.selectElementsFromBounds = function (elems, toggle) {
                if (!toggle) {
                    this.resetSelection(false, false);
                }

                if (elems.length == 0) {
                    //---- user clicked on non-shape; means "reset selection" ----
                    this.resetSelection();
                } else {
                    for (var e = 0; e < elems.length; e++) {
                        this.toggleSelectionOnShape(elems[e], false, false);
                    }

                    this.onSelectionChanged();
                }
            };

            uiStateMgrClass.prototype.shareName = function (value) {
                if (arguments.length == 0) {
                    return this._shareName;
                }

                //---- get new share name ----
                this._shareName = value;

                this.onShareInfoChanged();

                return this;
            };

            uiStateMgrClass.prototype.onShareInfoChanged = function () {
                var _this = this;
                //---- remove old share name
                if (this._changeAgent) {
                    this._changeAgent.unregister();
                    this._changeAgent = null;
                }

                if (this._isUiEnabled) {
                    if ((this._shareName.length) && (this._shareName.length > 0)) {
                        this._changeAgent = vp.session.changeAgent(this._viewName, this._shareName, this._appName, true, function (uiState, info) {
                            _this.onUiStateReceived(uiState, info);
                        });
                    }
                }
            };

            /// private: onUiStateReceived().
            uiStateMgrClass.prototype.onUiStateReceived = function (uiState, info) {
                if (this._isUiEnabled) {
                    //---- update our local query terms with new data received from CHANGE MGR web service ----
                    this._highlight.terms(uiState.highlight);
                    this._selection.terms(uiState.selection);

                    //---- update HIGHLIGHT property on shapes ----
                    this.applyQuery(this._highlight, "isHighlighted");

                    //---- update SELECTION property on shapes ----
                    this._selectionCount = this.applyQuery(this._selection, "isSelected").count;

                    this.updateShapeVisuals();

                    var myTerms = this._filter.terms();
                    var uiTerms = uiState.filter;

                    var filterHasChanged = this._filter.termsAreEqual(myTerms, uiTerms);
                    if (filterHasChanged) {
                        this._filter.terms(uiState.filter);

                        this.triggerFilterChangedCallback();
                    }
                }
            };

            /// private: applyQuery().
            uiStateMgrClass.prototype.applyQuery = function (query, matchAttribute) {
                var matches = [];
                var changed = false;

                if (this._plotShapes) {
                    for (var i = 0; i < this._plotShapes.length; i++) {
                        var elem = this._plotShapes[i];
                        var dataRecord = vp.dom.dataItem(elem);

                        var isIn = query.test(dataRecord);
                        if (isIn) {
                            matches.push(elem);
                        }

                        if (elem[matchAttribute] != isIn) {
                            elem[matchAttribute] = isIn;
                            changed = true;

                            //---- if selected changed while highlighted, turn on a special flag ----
                            if ((matchAttribute == "isSelected") && (elem.isHighlighted)) {
                                elem.selectChangedDuringHighlight = true;
                            } else {
                                elem.selectChangedDuringHighlight = false;
                            }
                        }
                    }

                    //---- get count of unique matches ----
                    matches = matches.distinct(function (elem) {
                        return vp.utils.getShapeId(elem);
                    });
                }

                return { count: matches.length, changed: changed };
            };

            /// public: resetFilter() - remove all items from the filter.
            uiStateMgrClass.prototype.resetFilter = function () {
                if (this._isUiEnabled) {
                    if (this._filter.terms().length > 0) {
                        this._filter.reset();
                        this.onFilterChanged();
                    }
                }

                return this;
            };

            /// public: invertFilter() - swap the filtered IN and filtered OUT records with each other.
            uiStateMgrClass.prototype.invertFilter = function () {
                if (this._isUiEnabled) {
                    //---- all terms in the filter query should be groups ----
                    this._filter.addGroup(null, true);

                    this.onFilterChanged();
                }

                return this;
            };

            ///public: hideFilter()  - hide the currently selected records (set filtered OUT records to selection)
            uiStateMgrClass.prototype.hideFilter = function () {
                if (this._isUiEnabled) {
                    this._filter.addGroup(this._selection, false);

                    //---- always clear selection when filter changes ----
                    this.resetSelection(true, false);

                    this.onFilterChanged();
                }

                return this;
            };

            /// public: isolateFilter() - hide the currently unselected records.
            uiStateMgrClass.prototype.isolateFilter = function () {
                if (this._isUiEnabled) {
                    this._filter.addGroup(this._selection, true);

                    //---- always clear selection when filter changes ----
                    this.resetSelection(true, false);

                    this.onFilterChanged();
                }

                return this;
            };

            ///  public: resetSelection() - clear the current selection.
            uiStateMgrClass.prototype.resetSelection = function (processSelection, tellOthers) {
                if (typeof processSelection === "undefined") { processSelection = true; }
                if (typeof tellOthers === "undefined") { tellOthers = true; }
                if ((this._isUiEnabled) && (this._isSelectionEnabled)) {
                    if (this._selection.terms().length > 0) {
                        this._selection.reset();

                        if (processSelection) {
                            this.onSelectionChanged(tellOthers);
                        }
                    }
                }

                return this;
            };

            /// public: toggleSelection().
            uiStateMgrClass.prototype.toggleSelection = function () {
                if ((this._isUiEnabled) && (this._isSelectionEnabled)) {
                    this._selection.invert();
                    this.onSelectionChanged();
                }

                return this;
            };

            /// private: getId(elem).
            uiStateMgrClass.prototype.getId = function (elem) {
                var str = null;

                // "data" looks like: { dataId: dd, shapeId: ss, key: kk, data: dataRecord }
                if ((elem) && (elem.dataItem) && (elem.dataItem.dataId)) {
                    var data = elem.dataItem;
                    var exp = "data.key == \"" + data.key + "\"";

                    str = "vp.queryShapeTest(data, " + exp + ", " + data.dataId + ", " + data.shapeId + ")";
                }

                return str;
            };

            uiStateMgrClass.prototype.plotShapes = function (value) {
                if (arguments.length == 0) {
                    return this._plotShapes;
                }

                this._plotShapes = value;
                return this;
            };

            uiStateMgrClass.prototype.isUiEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isUiEnabled;
                }

                this._isUiEnabled = value;
                this.onShareInfoChanged();

                return this;
            };

            uiStateMgrClass.prototype.isSelectionEnabled = function (value) {
                if (arguments.length == 0) {
                    return this._isSelectionEnabled;
                }

                this._isSelectionEnabled = value;
                this._rubberBand.isEnabled(value);

                this.onShareInfoChanged();

                return this;
            };

            uiStateMgrClass.prototype.dragMode = function (value) {
                if (arguments.length == 0) {
                    return this._dragMode;
                }

                this._dragMode = value;
                this.onDragModeChanged();

                return this;
            };

            uiStateMgrClass.prototype.dragToKidsOffset = function (value) {
                if (arguments.length == 0) {
                    return this._dragToKidsOffset;
                }

                this._dragToKidsOffset = value;

                return this;
            };

            /// public: highlightShape(elem).
            uiStateMgrClass.prototype.highlightShape = function (elem) {
                if (this._isUiEnabled) {
                    var id = this.getId(elem);
                    if (id) {
                        this._highlight.reset();
                        this._highlight.orWith(id);

                        this.onHighlightChanged();
                    }
                }

                return this;
            };

            /// public: toggleSelectionOnShape(elem).
            uiStateMgrClass.prototype.toggleSelectionOnShape = function (elem, processSelection, tellOthers) {
                //---- apply param defaults ----
                processSelection = (processSelection === undefined) ? true : processSelection;
                tellOthers = (tellOthers === undefined) ? true : tellOthers;

                if ((this._isUiEnabled) && (this._isSelectionEnabled)) {
                    var id = this.getId(elem);
                    if (id) {
                        this._selection.toggleTo(id);

                        if (processSelection) {
                            this.onSelectionChanged(tellOthers);
                        }
                    }
                }

                return this;
            };

            /// private: setSelectionFromBoundsQuery
            uiStateMgrClass.prototype.setSelectionFromBoundsQuery = function (query) {
                if ((this._isUiEnabled) && (this._isSelectionEnabled)) {
                    this._selection.boundsQuery(query);
                    this.onSelectionChanged(true);
                }

                return this;
            };

            /// public: selectShape(elem).
            uiStateMgrClass.prototype.selectShape = function (elem) {
                if ((this._isUiEnabled) && (this._isSelectionEnabled)) {
                    var id = this.getId(elem);
                    if (id) {
                        this._selection.reset();
                        this._selection.orWith(id);

                        this.onSelectionChanged();
                    }
                }

                return this;
            };

            /// private: updateShapeVisuals()
            uiStateMgrClass.prototype.updateShapeVisuals = function () {
                if (this._updateVisualsCallback) {
                    this._updateVisualsCallback(this._selectionCount);
                }
            };

            /// public: resetHighlight().
            uiStateMgrClass.prototype.resetHighlight = function () {
                if (this._isUiEnabled) {
                    if (this._highlight.terms().length > 0) {
                        this._highlight.reset();
                        this.onHighlightChanged();
                    }
                }
            };

            /// public readonly property: filter
            uiStateMgrClass.prototype.filter = function () {
                return this._filter;
            };

            uiStateMgrClass.prototype.selection = function () {
                return this._selection;
            };

            /// private: sendChangesToAgent()
            uiStateMgrClass.prototype.sendChangesToAgent = function () {
                var data = {
                    /// note: for "highlight", "selection", and "filter", we just send the terms
                    /// not the whole object.  So, when we receive a change, we need to beware its
                    /// not the full object we are getting!
                    dataSourceName: "tbd",
                    highlight: this._highlight.terms(),
                    selection: this._selection.terms(),
                    filter: this._filter.terms()
                };

                //---- tell changeAgent the data changed ----
                if (this._changeAgent != null) {
                    this._changeAgent.data(data);
                }
            };

            /// private: onHighlightChanged()
            uiStateMgrClass.prototype.onHighlightChanged = function () {
                if (this._isUiEnabled) {
                    this.applyQuery(this._highlight, "isHighlighted");
                    this.updateShapeVisuals();

                    this.sendChangesToAgent();
                }
            };

            /// private: onSelectionChanged(tellOthersAndUpdate)
            uiStateMgrClass.prototype.onSelectionChanged = function (tellOthersAndUpdate) {
                if (typeof tellOthersAndUpdate === "undefined") { tellOthersAndUpdate = true; }
                this._selectionCount = this.applyQuery(this._selection, "isSelected").count;

                if (tellOthersAndUpdate) {
                    this.updateShapeVisuals();
                    this.sendChangesToAgent();

                    this.triggerSelectCallback();
                }
            };

            uiStateMgrClass.prototype.selectionCount = function () {
                return this._selectionCount;
            };

            uiStateMgrClass.prototype.triggerSelectCallback = function () {
                if (this._selectCallback) {
                    //---- collect keys of all selected records ----
                    var keys = [];

                    if (this._plotShapes) {
                        for (var i = 0; i < this._plotShapes.length; i++) {
                            var elem = this._plotShapes[i];
                            if (elem.isSelected) {
                                keys.push(elem.dataItem.key);
                            }
                        }
                    }

                    this._selectCallback(keys);
                }
            };

            /// private: onFilterChanged()
            uiStateMgrClass.prototype.onFilterChanged = function () {
                this.applyQuery(this._filter, "isFilteredOut");

                this.sendChangesToAgent();

                this.triggerFilterChangedCallback();

                //---- ensure visual changes before filter still are in effect ----
                this.updateShapeVisuals();
            };

            /// private: triggerFilterChangedCallback()
            uiStateMgrClass.prototype.triggerFilterChangedCallback = function () {
                if (this._filterChangedCallback) {
                    this._filterChangedCallback();
                }
            };

            uiStateMgrClass.prototype.selectCallback = function (value) {
                if (arguments.length == 0) {
                    return this._selectCallback;
                }

                this._selectCallback = value;

                return this;
            };
            return uiStateMgrClass;
        })();
        events.uiStateMgrClass = uiStateMgrClass;

        function createUiStateMgr(viewName, appName, dragContainer, kidsContainer, updateVisualsCallback, filterChangedCallback, queryFromElementsInBounds) {
            return new uiStateMgrClass(viewName, appName, dragContainer, kidsContainer, updateVisualsCallback, filterChangedCallback, queryFromElementsInBounds);
        }
        events.createUiStateMgr = createUiStateMgr;
    })(vp.events || (vp.events = {}));
    var events = vp.events;
})(vp || (vp = {}));
//# sourceMappingURL=uiStateMgr.js.map
///-----------------------------------------------------------------------------------------------------------------
/// vpEnd.js.  Copyright (c) 2012 Microsoft Corporation.
///    - last file of VuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vuePlot = vp;       // "vuePlot" is an alias for "vp" in TypeScript declaration file, so we need to honor it here too.

